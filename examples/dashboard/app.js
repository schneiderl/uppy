(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg) && arg.length) {
				var inner = classNames.apply(null, arg);
				if (inner) {
					classes.push(inner);
				}
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());

},{}],2:[function(require,module,exports){
/**
 * cuid.js
 * Collision-resistant UID generator for browsers and node.
 * Sequential for fast db lookups and recency sorting.
 * Safe for element IDs and server-side lookups.
 *
 * Extracted from CLCTR
 *
 * Copyright (c) Eric Elliott 2012
 * MIT License
 */

var fingerprint = require('./lib/fingerprint.js');
var pad = require('./lib/pad.js');
var getRandomValue = require('./lib/getRandomValue.js');

var c = 0,
  blockSize = 4,
  base = 36,
  discreteValues = Math.pow(base, blockSize);

function randomBlock () {
  return pad((getRandomValue() *
    discreteValues << 0)
    .toString(base), blockSize);
}

function safeCounter () {
  c = c < discreteValues ? c : 0;
  c++; // this is not subliminal
  return c - 1;
}

function cuid () {
  // Starting with a lowercase letter makes
  // it HTML element ID friendly.
  var letter = 'c', // hard-coded allows for sequential access

    // timestamp
    // warning: this exposes the exact date and time
    // that the uid was created.
    timestamp = (new Date().getTime()).toString(base),

    // Prevent same-machine collisions.
    counter = pad(safeCounter().toString(base), blockSize),

    // A few chars to generate distinct ids for different
    // clients (so different computers are far less
    // likely to generate the same id)
    print = fingerprint(),

    // Grab some more chars from Math.random()
    random = randomBlock() + randomBlock();

  return letter + timestamp + counter + print + random;
}

cuid.slug = function slug () {
  var date = new Date().getTime().toString(36),
    counter = safeCounter().toString(36).slice(-4),
    print = fingerprint().slice(0, 1) +
      fingerprint().slice(-1),
    random = randomBlock().slice(-2);

  return date.slice(-2) +
    counter + print + random;
};

cuid.isCuid = function isCuid (stringToCheck) {
  if (typeof stringToCheck !== 'string') return false;
  if (stringToCheck.startsWith('c')) return true;
  return false;
};

cuid.isSlug = function isSlug (stringToCheck) {
  if (typeof stringToCheck !== 'string') return false;
  var stringLength = stringToCheck.length;
  if (stringLength >= 7 && stringLength <= 10) return true;
  return false;
};

cuid.fingerprint = fingerprint;

module.exports = cuid;

},{"./lib/fingerprint.js":3,"./lib/getRandomValue.js":4,"./lib/pad.js":5}],3:[function(require,module,exports){
var pad = require('./pad.js');

var env = typeof window === 'object' ? window : self;
var globalCount = Object.keys(env).length;
var mimeTypesLength = navigator.mimeTypes ? navigator.mimeTypes.length : 0;
var clientId = pad((mimeTypesLength +
  navigator.userAgent.length).toString(36) +
  globalCount.toString(36), 4);

module.exports = function fingerprint () {
  return clientId;
};

},{"./pad.js":5}],4:[function(require,module,exports){

var getRandomValue;

var crypto = window.crypto || window.msCrypto;

if (crypto) {
    var lim = Math.pow(2, 32) - 1;
    getRandomValue = function () {
        return Math.abs(crypto.getRandomValues(new Uint32Array(1))[0] / lim);
    };
} else {
    getRandomValue = Math.random;
}

module.exports = getRandomValue;

},{}],5:[function(require,module,exports){
module.exports = function pad (num, size) {
  var s = '000000000' + num;
  return s.substr(s.length - size);
};

},{}],6:[function(require,module,exports){
// This file can be required in Browserify and Node.js for automatic polyfill
// To use it:  require('es6-promise/auto');
'use strict';
module.exports = require('./').polyfill();

},{"./":7}],7:[function(require,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.5+7f2b526d
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var TRY_CATCH_ERROR = { error: null };

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    TRY_CATCH_ERROR.error = error;
    return TRY_CATCH_ERROR;
  }
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === TRY_CATCH_ERROR) {
      reject(promise, TRY_CATCH_ERROR.error);
      TRY_CATCH_ERROR.error = null;
    } else if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = void 0,
      failed = void 0;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value.error = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (failed) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = getThen(entry);

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        handleMaybeThenable(promise, entry, _then);
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    if (isFunction(callback)) {
      return promise.then(function (value) {
        return constructor.resolve(callback()).then(function () {
          return value;
        });
      }, function (reason) {
        return constructor.resolve(callback()).then(function () {
          throw reason;
        });
      });
    }

    return promise.then(callback, callback);
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));





}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":18}],8:[function(require,module,exports){
'use strict';

var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var setProperty = function setProperty(target, options) {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

// Return undefined instead of __proto__ if '__proto__' is not an own property
var getProperty = function getProperty(obj, name) {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

module.exports = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};

},{}],9:[function(require,module,exports){
module.exports = function isShallowEqual (a, b) {
  if (a === b) return true
  for (var i in a) if (!(i in b)) return false
  for (var i in b) if (a[i] !== b[i]) return false
  return true
}

},{}],10:[function(require,module,exports){
(function (global){
/*
 *  base64.js
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */
;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? module.exports = factory(global)
        : typeof define === 'function' && define.amd
        ? define(factory) : factory(global)
}((
    typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
: this
), function(global) {
    'use strict';
    // existing version for noConflict()
    global = global || {};
    var _Base64 = global.Base64;
    var version = "2.5.1";
    // if node.js and NOT React Native, we use Buffer
    var buffer;
    if (typeof module !== 'undefined' && module.exports) {
        try {
            buffer = eval("require('buffer').Buffer");
        } catch (err) {
            buffer = undefined;
        }
    }
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                                + fromCharCode(0x80 | (cc & 0x3f)))
                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                   + fromCharCode(0x80 | ( cc         & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16
            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
        chars = [
            b64chars.charAt( ord >>> 18),
            b64chars.charAt((ord >>> 12) & 63),
            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
        ];
        return chars.join('');
    };
    var btoa = global.btoa ? function(b) {
        return global.btoa(b);
    } : function(b) {
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = buffer ?
        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
        ? function (u) {
            return (u.constructor === buffer.constructor ? u : buffer.from(u))
                .toString('base64')
        }
        :  function (u) {
            return (u.constructor === buffer.constructor ? u : new  buffer(u))
                .toString('base64')
        }
        : function (u) { return btoa(utob(u)) }
    ;
    var encode = function(u, urisafe) {
        return !urisafe
            ? _encode(String(u))
            : _encode(String(u)).replace(/[+\/]/g, function(m0) {
                return m0 == '+' ? '-' : '_';
            }).replace(/=/g, '');
    };
    var encodeURI = function(u) { return encode(u, true) };
    // decoder stuff
    var re_btou = new RegExp([
        '[\xC0-\xDF][\x80-\xBF]',
        '[\xE0-\xEF][\x80-\xBF]{2}',
        '[\xF0-\xF7][\x80-\xBF]{3}'
    ].join('|'), 'g');
    var cb_btou = function(cccc) {
        switch(cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                |    ((0x3f & cccc.charCodeAt(1)) << 12)
                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
                |     (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
            return (fromCharCode((offset  >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
        case 3:
            return fromCharCode(
                ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    |  (0x3f & cccc.charCodeAt(2))
            );
        default:
            return  fromCharCode(
                ((0x1f & cccc.charCodeAt(0)) << 6)
                    |  (0x3f & cccc.charCodeAt(1))
            );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
        chars = [
            fromCharCode( n >>> 16),
            fromCharCode((n >>>  8) & 0xff),
            fromCharCode( n         & 0xff)
        ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var _atob = global.atob ? function(a) {
        return global.atob(a);
    } : function(a){
        return a.replace(/\S{1,4}/g, cb_decode);
    };
    var atob = function(a) {
        return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));
    };
    var _decode = buffer ?
        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
        ? function(a) {
            return (a.constructor === buffer.constructor
                    ? a : buffer.from(a, 'base64')).toString();
        }
        : function(a) {
            return (a.constructor === buffer.constructor
                    ? a : new buffer(a, 'base64')).toString();
        }
        : function(a) { return btou(_atob(a)) };
    var decode = function(a){
        return _decode(
            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })
                .replace(/[^A-Za-z0-9\+\/]/g, '')
        );
    };
    var noConflict = function() {
        var Base64 = global.Base64;
        global.Base64 = _Base64;
        return Base64;
    };
    // export Base64
    global.Base64 = {
        VERSION: version,
        atob: atob,
        btoa: btoa,
        fromBase64: decode,
        toBase64: encode,
        utob: utob,
        encode: encode,
        encodeURI: encodeURI,
        btou: btou,
        decode: decode,
        noConflict: noConflict,
        __buffer__: buffer
    };
    // if ES5 is available, make Base64.extendString() available
    if (typeof Object.defineProperty === 'function') {
        var noEnum = function(v){
            return {value:v,enumerable:false,writable:true,configurable:true};
        };
        global.Base64.extendString = function () {
            Object.defineProperty(
                String.prototype, 'fromBase64', noEnum(function () {
                    return decode(this)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64', noEnum(function (urisafe) {
                    return encode(this, urisafe)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64URI', noEnum(function () {
                    return encode(this, true)
                }));
        };
    }
    //
    // export Base64 to the namespace
    //
    if (global['Meteor']) { // Meteor.js
        Base64 = global.Base64;
    }
    // module.exports and AMD are mutually exclusive.
    // module.exports has precedence.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports.Base64 = global.Base64;
    }
    else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], function(){ return global.Base64 });
    }
    // that's it!
    return {Base64: global.Base64}
}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],11:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],12:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = throttle;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],13:[function(require,module,exports){
'use strict';

function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
        return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
        if (newInputs[i] !== lastInputs[i]) {
            return false;
        }
    }
    return true;
}

function memoizeOne(resultFn, isEqual) {
    if (isEqual === void 0) { isEqual = areInputsEqual; }
    var lastThis;
    var lastArgs = [];
    var lastResult;
    var calledOnce = false;
    function memoized() {
        var newArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
        }
        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {
            return lastResult;
        }
        lastResult = resultFn.apply(this, newArgs);
        calledOnce = true;
        lastThis = this;
        lastArgs = newArgs;
        return lastResult;
    }
    return memoized;
}

module.exports = memoizeOne;

},{}],14:[function(require,module,exports){
var wildcard = require('wildcard');
var reMimePartSplit = /[\/\+\.]/;

/**
  # mime-match

  A simple function to checker whether a target mime type matches a mime-type
  pattern (e.g. image/jpeg matches image/jpeg OR image/*).

  ## Example Usage

  <<< example.js

**/
module.exports = function(target, pattern) {
  function test(pattern) {
    var result = wildcard(pattern, target, reMimePartSplit);

    // ensure that we have a valid mime type (should have two parts)
    return result && result.length >= 2;
  }

  return pattern ? test(pattern.split(';')[0]) : test;
};

},{"wildcard":35}],15:[function(require,module,exports){
/**
* Create an event emitter with namespaces
* @name createNamespaceEmitter
* @example
* var emitter = require('./index')()
*
* emitter.on('*', function () {
*   console.log('all events emitted', this.event)
* })
*
* emitter.on('example', function () {
*   console.log('example event emitted')
* })
*/
module.exports = function createNamespaceEmitter () {
  var emitter = {}
  var _fns = emitter._fns = {}

  /**
  * Emit an event. Optionally namespace the event. Handlers are fired in the order in which they were added with exact matches taking precedence. Separate the namespace and event with a `:`
  * @name emit
  * @param {String} event – the name of the event, with optional namespace
  * @param {...*} data – up to 6 arguments that are passed to the event listener
  * @example
  * emitter.emit('example')
  * emitter.emit('demo:test')
  * emitter.emit('data', { example: true}, 'a string', 1)
  */
  emitter.emit = function emit (event, arg1, arg2, arg3, arg4, arg5, arg6) {
    var toEmit = getListeners(event)

    if (toEmit.length) {
      emitAll(event, toEmit, [arg1, arg2, arg3, arg4, arg5, arg6])
    }
  }

  /**
  * Create en event listener.
  * @name on
  * @param {String} event
  * @param {Function} fn
  * @example
  * emitter.on('example', function () {})
  * emitter.on('demo', function () {})
  */
  emitter.on = function on (event, fn) {
    if (!_fns[event]) {
      _fns[event] = []
    }

    _fns[event].push(fn)
  }

  /**
  * Create en event listener that fires once.
  * @name once
  * @param {String} event
  * @param {Function} fn
  * @example
  * emitter.once('example', function () {})
  * emitter.once('demo', function () {})
  */
  emitter.once = function once (event, fn) {
    function one () {
      fn.apply(this, arguments)
      emitter.off(event, one)
    }
    this.on(event, one)
  }

  /**
  * Stop listening to an event. Stop all listeners on an event by only passing the event name. Stop a single listener by passing that event handler as a callback.
  * You must be explicit about what will be unsubscribed: `emitter.off('demo')` will unsubscribe an `emitter.on('demo')` listener,
  * `emitter.off('demo:example')` will unsubscribe an `emitter.on('demo:example')` listener
  * @name off
  * @param {String} event
  * @param {Function} [fn] – the specific handler
  * @example
  * emitter.off('example')
  * emitter.off('demo', function () {})
  */
  emitter.off = function off (event, fn) {
    var keep = []

    if (event && fn) {
      var fns = this._fns[event]
      var i = 0
      var l = fns ? fns.length : 0

      for (i; i < l; i++) {
        if (fns[i] !== fn) {
          keep.push(fns[i])
        }
      }
    }

    keep.length ? this._fns[event] = keep : delete this._fns[event]
  }

  function getListeners (e) {
    var out = _fns[e] ? _fns[e] : []
    var idx = e.indexOf(':')
    var args = (idx === -1) ? [e] : [e.substring(0, idx), e.substring(idx + 1)]

    var keys = Object.keys(_fns)
    var i = 0
    var l = keys.length

    for (i; i < l; i++) {
      var key = keys[i]
      if (key === '*') {
        out = out.concat(_fns[key])
      }

      if (args.length === 2 && args[0] === key) {
        out = out.concat(_fns[key])
        break
      }
    }

    return out
  }

  function emitAll (e, fns, args) {
    var i = 0
    var l = fns.length

    for (i; i < l; i++) {
      if (!fns[i]) break
      fns[i].event = e
      fns[i].apply(fns[i], args)
    }
  }

  return emitter
}

},{}],16:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('preact')) :
  typeof define === 'function' && define.amd ? define(['preact'], factory) :
  (global.PreactCSSTransitionGroup = factory(global.preact));
}(this, (function (preact) { 'use strict';

function getKey(vnode) {
	return vnode.attributes && vnode.attributes.key;
}

function getComponentBase(component) {
	return component.base;
}

function onlyChild(children) {
	return children && children[0];
}

function filterNullChildren(children) {
	return children && children.filter(function (i) {
		return i !== null;
	});
}

function find(arr, iter) {
	for (var i = arr.length; i--;) {
		if (iter(arr[i])) return true;
	}
	return false;
}

function inChildrenByKey(children, key) {
	return find(children, function (c) {
		return getKey(c) === key;
	});
}

function inChildren(children, child) {
	return inChildrenByKey(children, getKey(child));
}

function isShownInChildrenByKey(children, key, showProp) {
	return find(children, function (c) {
		return getKey(c) === key && c.props[showProp];
	});
}

function isShownInChildren(children, child, showProp) {
	return isShownInChildrenByKey(children, getKey(child), showProp);
}

function mergeChildMappings(prev, next) {
	var ret = [];

	var nextChildrenPending = {},
	    pendingChildren = [];
	prev.forEach(function (c) {
		var key = getKey(c);
		if (inChildrenByKey(next, key)) {
			if (pendingChildren.length) {
				nextChildrenPending[key] = pendingChildren;
				pendingChildren = [];
			}
		} else {
			pendingChildren.push(c);
		}
	});

	next.forEach(function (c) {
		var key = getKey(c);
		if (nextChildrenPending.hasOwnProperty(key)) {
			ret = ret.concat(nextChildrenPending[key]);
		}
		ret.push(c);
	});

	return ret.concat(pendingChildren);
}

var SPACE = ' ';
var RE_CLASS = /[\n\t\r]+/g;

var norm = function (elemClass) {
	return (SPACE + elemClass + SPACE).replace(RE_CLASS, SPACE);
};

function addClass(elem, className) {
	if (elem.classList) {
		var _elem$classList;

		(_elem$classList = elem.classList).add.apply(_elem$classList, className.split(' '));
	} else {
		elem.className += ' ' + className;
	}
}

function removeClass(elem, needle) {
	needle = needle.trim();
	if (elem.classList) {
		var _elem$classList2;

		(_elem$classList2 = elem.classList).remove.apply(_elem$classList2, needle.split(' '));
	} else {
		var elemClass = elem.className.trim();
		var className = norm(elemClass);
		needle = SPACE + needle + SPACE;
		while (className.indexOf(needle) >= 0) {
			className = className.replace(needle, SPACE);
		}
		elem.className = className.trim();
	}
}

var EVENT_NAME_MAP = {
	transitionend: {
		transition: 'transitionend',
		WebkitTransition: 'webkitTransitionEnd',
		MozTransition: 'mozTransitionEnd',
		OTransition: 'oTransitionEnd',
		msTransition: 'MSTransitionEnd'
	},

	animationend: {
		animation: 'animationend',
		WebkitAnimation: 'webkitAnimationEnd',
		MozAnimation: 'mozAnimationEnd',
		OAnimation: 'oAnimationEnd',
		msAnimation: 'MSAnimationEnd'
	}
};

var endEvents = [];

function detectEvents() {
	var testEl = document.createElement('div'),
	    style = testEl.style;

	if (!('AnimationEvent' in window)) {
		delete EVENT_NAME_MAP.animationend.animation;
	}

	if (!('TransitionEvent' in window)) {
		delete EVENT_NAME_MAP.transitionend.transition;
	}

	for (var baseEventName in EVENT_NAME_MAP) {
		var baseEvents = EVENT_NAME_MAP[baseEventName];
		for (var styleName in baseEvents) {
			if (styleName in style) {
				endEvents.push(baseEvents[styleName]);
				break;
			}
		}
	}
}

if (typeof window !== 'undefined') {
	detectEvents();
}

function addEndEventListener(node, eventListener) {
	if (!endEvents.length) {
		return window.setTimeout(eventListener, 0);
	}
	endEvents.forEach(function (endEvent) {
		node.addEventListener(endEvent, eventListener, false);
	});
}

function removeEndEventListener(node, eventListener) {
	if (!endEvents.length) return;
	endEvents.forEach(function (endEvent) {
		node.removeEventListener(endEvent, eventListener, false);
	});
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var TICK = 17;

var CSSTransitionGroupChild = function (_Component) {
	inherits(CSSTransitionGroupChild, _Component);

	function CSSTransitionGroupChild() {
		var _temp, _this, _ret;

		classCallCheck(this, CSSTransitionGroupChild);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.flushClassNameQueue = function () {
			if (getComponentBase(_this)) {
				addClass(getComponentBase(_this), _this.classNameQueue.join(' '));
			}
			_this.classNameQueue.length = 0;
			_this.timeout = null;
		}, _temp), possibleConstructorReturn(_this, _ret);
	}

	CSSTransitionGroupChild.prototype.transition = function transition(animationType, finishCallback, timeout) {
		var _this2 = this;

		var node = getComponentBase(this);

		var className = this.props.name[animationType] || this.props.name + '-' + animationType;
		var activeClassName = this.props.name[animationType + 'Active'] || className + '-active';
		var timer = null;

		if (this.endListener) {
			this.endListener();
		}

		this.endListener = function (e) {
			if (e && e.target !== node) return;

			clearTimeout(timer);
			removeClass(node, className);
			removeClass(node, activeClassName);
			removeEndEventListener(node, _this2.endListener);
			_this2.endListener = null;

			if (finishCallback) {
				finishCallback();
			}
		};

		if (timeout) {
			timer = setTimeout(this.endListener, timeout);
			this.transitionTimeouts.push(timer);
		} else {
			addEndEventListener(node, this.endListener);
		}

		addClass(node, className);

		this.queueClass(activeClassName);
	};

	CSSTransitionGroupChild.prototype.queueClass = function queueClass(className) {
		this.classNameQueue.push(className);

		if (!this.timeout) {
			this.timeout = setTimeout(this.flushClassNameQueue, TICK);
		}
	};

	CSSTransitionGroupChild.prototype.stop = function stop() {
		if (this.timeout) {
			clearTimeout(this.timeout);
			this.classNameQueue.length = 0;
			this.timeout = null;
		}
		if (this.endListener) {
			this.endListener();
		}
	};

	CSSTransitionGroupChild.prototype.componentWillMount = function componentWillMount() {
		this.classNameQueue = [];
		this.transitionTimeouts = [];
	};

	CSSTransitionGroupChild.prototype.componentWillUnmount = function componentWillUnmount() {
		if (this.timeout) {
			clearTimeout(this.timeout);
		}
		this.transitionTimeouts.forEach(function (timeout) {
			clearTimeout(timeout);
		});
	};

	CSSTransitionGroupChild.prototype.componentWillEnter = function componentWillEnter(done) {
		if (this.props.enter) {
			this.transition('enter', done, this.props.enterTimeout);
		} else {
			done();
		}
	};

	CSSTransitionGroupChild.prototype.componentWillLeave = function componentWillLeave(done) {
		if (this.props.leave) {
			this.transition('leave', done, this.props.leaveTimeout);
		} else {
			done();
		}
	};

	CSSTransitionGroupChild.prototype.render = function render() {
		return onlyChild(this.props.children);
	};

	return CSSTransitionGroupChild;
}(preact.Component);

var CSSTransitionGroup = function (_Component) {
	inherits(CSSTransitionGroup, _Component);

	function CSSTransitionGroup(props) {
		classCallCheck(this, CSSTransitionGroup);

		var _this = possibleConstructorReturn(this, _Component.call(this));

		_this.renderChild = function (child) {
			var _this$props = _this.props;
			var transitionName = _this$props.transitionName;
			var transitionEnter = _this$props.transitionEnter;
			var transitionLeave = _this$props.transitionLeave;
			var transitionEnterTimeout = _this$props.transitionEnterTimeout;
			var transitionLeaveTimeout = _this$props.transitionLeaveTimeout;
			var key = getKey(child);
			return preact.h(
				CSSTransitionGroupChild,
				{
					key: key,
					ref: function (c) {
						if (!(_this.refs[key] = c)) child = null;
					},
					name: transitionName,
					enter: transitionEnter,
					leave: transitionLeave,
					enterTimeout: transitionEnterTimeout,
					leaveTimeout: transitionLeaveTimeout },
				child
			);
		};

		_this.refs = {};
		_this.state = {
			children: (props.children || []).slice()
		};
		return _this;
	}

	CSSTransitionGroup.prototype.shouldComponentUpdate = function shouldComponentUpdate(_, _ref) {
		var children = _ref.children;

		return children !== this.state.children;
	};

	CSSTransitionGroup.prototype.componentWillMount = function componentWillMount() {
		this.currentlyTransitioningKeys = {};
		this.keysToEnter = [];
		this.keysToLeave = [];
	};

	CSSTransitionGroup.prototype.componentWillReceiveProps = function componentWillReceiveProps(_ref2) {
		var _this2 = this;

		var children = _ref2.children;
		var exclusive = _ref2.exclusive;
		var showProp = _ref2.showProp;

		var nextChildMapping = filterNullChildren(children || []).slice();

		var prevChildMapping = filterNullChildren(exclusive ? this.props.children : this.state.children);

		var newChildren = mergeChildMappings(prevChildMapping, nextChildMapping);

		if (showProp) {
			newChildren = newChildren.map(function (c) {
				if (!c.props[showProp] && isShownInChildren(prevChildMapping, c, showProp)) {
					var _cloneElement;

					c = preact.cloneElement(c, (_cloneElement = {}, _cloneElement[showProp] = true, _cloneElement));
				}
				return c;
			});
		}

		if (exclusive) {
			newChildren.forEach(function (c) {
				return _this2.stop(getKey(c));
			});
		}

		this.setState({ children: newChildren });
		this.forceUpdate();

		nextChildMapping.forEach(function (c) {
			var key = c.key;
			var hasPrev = prevChildMapping && inChildren(prevChildMapping, c);
			if (showProp) {
				if (hasPrev) {
					var showInPrev = isShownInChildren(prevChildMapping, c, showProp),
					    showInNow = c.props[showProp];
					if (!showInPrev && showInNow && !_this2.currentlyTransitioningKeys[key]) {
						_this2.keysToEnter.push(key);
					}
				}
			} else if (!hasPrev && !_this2.currentlyTransitioningKeys[key]) {
				_this2.keysToEnter.push(key);
			}
		});

		prevChildMapping.forEach(function (c) {
			var key = c.key;
			var hasNext = nextChildMapping && inChildren(nextChildMapping, c);
			if (showProp) {
				if (hasNext) {
					var showInNext = isShownInChildren(nextChildMapping, c, showProp);
					var showInNow = c.props[showProp];
					if (!showInNext && showInNow && !_this2.currentlyTransitioningKeys[key]) {
						_this2.keysToLeave.push(key);
					}
				}
			} else if (!hasNext && !_this2.currentlyTransitioningKeys[key]) {
				_this2.keysToLeave.push(key);
			}
		});
	};

	CSSTransitionGroup.prototype.performEnter = function performEnter(key) {
		var _this3 = this;

		this.currentlyTransitioningKeys[key] = true;
		var component = this.refs[key];
		if (component.componentWillEnter) {
			component.componentWillEnter(function () {
				return _this3._handleDoneEntering(key);
			});
		} else {
			this._handleDoneEntering(key);
		}
	};

	CSSTransitionGroup.prototype._handleDoneEntering = function _handleDoneEntering(key) {
		delete this.currentlyTransitioningKeys[key];
		var currentChildMapping = filterNullChildren(this.props.children),
		    showProp = this.props.showProp;
		if (!currentChildMapping || !showProp && !inChildrenByKey(currentChildMapping, key) || showProp && !isShownInChildrenByKey(currentChildMapping, key, showProp)) {
			this.performLeave(key);
		} else {
			this.setState({ children: currentChildMapping });
		}
	};

	CSSTransitionGroup.prototype.stop = function stop(key) {
		delete this.currentlyTransitioningKeys[key];
		var component = this.refs[key];
		if (component) component.stop();
	};

	CSSTransitionGroup.prototype.performLeave = function performLeave(key) {
		var _this4 = this;

		this.currentlyTransitioningKeys[key] = true;
		var component = this.refs[key];
		if (component && component.componentWillLeave) {
			component.componentWillLeave(function () {
				return _this4._handleDoneLeaving(key);
			});
		} else {
			this._handleDoneLeaving(key);
		}
	};

	CSSTransitionGroup.prototype._handleDoneLeaving = function _handleDoneLeaving(key) {
		delete this.currentlyTransitioningKeys[key];
		var showProp = this.props.showProp,
		    currentChildMapping = filterNullChildren(this.props.children);
		if (showProp && currentChildMapping && isShownInChildrenByKey(currentChildMapping, key, showProp)) {
			this.performEnter(key);
		} else if (!showProp && currentChildMapping && inChildrenByKey(currentChildMapping, key)) {
			this.performEnter(key);
		} else {
			this.setState({ children: currentChildMapping });
		}
	};

	CSSTransitionGroup.prototype.componentDidUpdate = function componentDidUpdate() {
		var _this5 = this;

		var keysToEnter = this.keysToEnter;
		var keysToLeave = this.keysToLeave;

		this.keysToEnter = [];
		keysToEnter.forEach(function (k) {
			return _this5.performEnter(k);
		});
		this.keysToLeave = [];
		keysToLeave.forEach(function (k) {
			return _this5.performLeave(k);
		});
	};

	CSSTransitionGroup.prototype.render = function render(_ref3, _ref4) {
		var Component = _ref3.component;
		var transitionName = _ref3.transitionName;
		var transitionEnter = _ref3.transitionEnter;
		var transitionLeave = _ref3.transitionLeave;
		var transitionEnterTimeout = _ref3.transitionEnterTimeout;
		var transitionLeaveTimeout = _ref3.transitionLeaveTimeout;
		var c = _ref3.children;
		var props = objectWithoutProperties(_ref3, ['component', 'transitionName', 'transitionEnter', 'transitionLeave', 'transitionEnterTimeout', 'transitionLeaveTimeout', 'children']);
		var children = _ref4.children;

		return preact.h(
			Component,
			props,
			filterNullChildren(children).map(this.renderChild)
		);
	};

	return CSSTransitionGroup;
}(preact.Component);
CSSTransitionGroup.defaultProps = {
	component: 'span',
	transitionEnter: true,
	transitionLeave: true
};

return CSSTransitionGroup;

})));


},{"preact":17}],17:[function(require,module,exports){
!function() {
    'use strict';
    function VNode() {}
    function h(nodeName, attributes) {
        var lastSimple, child, simple, i, children = EMPTY_CHILDREN;
        for (i = arguments.length; i-- > 2; ) stack.push(arguments[i]);
        if (attributes && null != attributes.children) {
            if (!stack.length) stack.push(attributes.children);
            delete attributes.children;
        }
        while (stack.length) if ((child = stack.pop()) && void 0 !== child.pop) for (i = child.length; i--; ) stack.push(child[i]); else {
            if ('boolean' == typeof child) child = null;
            if (simple = 'function' != typeof nodeName) if (null == child) child = ''; else if ('number' == typeof child) child = String(child); else if ('string' != typeof child) simple = !1;
            if (simple && lastSimple) children[children.length - 1] += child; else if (children === EMPTY_CHILDREN) children = [ child ]; else children.push(child);
            lastSimple = simple;
        }
        var p = new VNode();
        p.nodeName = nodeName;
        p.children = children;
        p.attributes = null == attributes ? void 0 : attributes;
        p.key = null == attributes ? void 0 : attributes.key;
        if (void 0 !== options.vnode) options.vnode(p);
        return p;
    }
    function extend(obj, props) {
        for (var i in props) obj[i] = props[i];
        return obj;
    }
    function cloneElement(vnode, props) {
        return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);
    }
    function enqueueRender(component) {
        if (!component.__d && (component.__d = !0) && 1 == items.push(component)) (options.debounceRendering || defer)(rerender);
    }
    function rerender() {
        var p, list = items;
        items = [];
        while (p = list.pop()) if (p.__d) renderComponent(p);
    }
    function isSameNodeType(node, vnode, hydrating) {
        if ('string' == typeof vnode || 'number' == typeof vnode) return void 0 !== node.splitText;
        if ('string' == typeof vnode.nodeName) return !node._componentConstructor && isNamedNode(node, vnode.nodeName); else return hydrating || node._componentConstructor === vnode.nodeName;
    }
    function isNamedNode(node, nodeName) {
        return node.__n === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
    }
    function getNodeProps(vnode) {
        var props = extend({}, vnode.attributes);
        props.children = vnode.children;
        var defaultProps = vnode.nodeName.defaultProps;
        if (void 0 !== defaultProps) for (var i in defaultProps) if (void 0 === props[i]) props[i] = defaultProps[i];
        return props;
    }
    function createNode(nodeName, isSvg) {
        var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);
        node.__n = nodeName;
        return node;
    }
    function removeNode(node) {
        var parentNode = node.parentNode;
        if (parentNode) parentNode.removeChild(node);
    }
    function setAccessor(node, name, old, value, isSvg) {
        if ('className' === name) name = 'class';
        if ('key' === name) ; else if ('ref' === name) {
            if (old) old(null);
            if (value) value(node);
        } else if ('class' === name && !isSvg) node.className = value || ''; else if ('style' === name) {
            if (!value || 'string' == typeof value || 'string' == typeof old) node.style.cssText = value || '';
            if (value && 'object' == typeof value) {
                if ('string' != typeof old) for (var i in old) if (!(i in value)) node.style[i] = '';
                for (var i in value) node.style[i] = 'number' == typeof value[i] && !1 === IS_NON_DIMENSIONAL.test(i) ? value[i] + 'px' : value[i];
            }
        } else if ('dangerouslySetInnerHTML' === name) {
            if (value) node.innerHTML = value.__html || '';
        } else if ('o' == name[0] && 'n' == name[1]) {
            var useCapture = name !== (name = name.replace(/Capture$/, ''));
            name = name.toLowerCase().substring(2);
            if (value) {
                if (!old) node.addEventListener(name, eventProxy, useCapture);
            } else node.removeEventListener(name, eventProxy, useCapture);
            (node.__l || (node.__l = {}))[name] = value;
        } else if ('list' !== name && 'type' !== name && !isSvg && name in node) {
            setProperty(node, name, null == value ? '' : value);
            if (null == value || !1 === value) node.removeAttribute(name);
        } else {
            var ns = isSvg && name !== (name = name.replace(/^xlink:?/, ''));
            if (null == value || !1 === value) if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase()); else node.removeAttribute(name); else if ('function' != typeof value) if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value); else node.setAttribute(name, value);
        }
    }
    function setProperty(node, name, value) {
        try {
            node[name] = value;
        } catch (e) {}
    }
    function eventProxy(e) {
        return this.__l[e.type](options.event && options.event(e) || e);
    }
    function flushMounts() {
        var c;
        while (c = mounts.pop()) {
            if (options.afterMount) options.afterMount(c);
            if (c.componentDidMount) c.componentDidMount();
        }
    }
    function diff(dom, vnode, context, mountAll, parent, componentRoot) {
        if (!diffLevel++) {
            isSvgMode = null != parent && void 0 !== parent.ownerSVGElement;
            hydrating = null != dom && !('__preactattr_' in dom);
        }
        var ret = idiff(dom, vnode, context, mountAll, componentRoot);
        if (parent && ret.parentNode !== parent) parent.appendChild(ret);
        if (!--diffLevel) {
            hydrating = !1;
            if (!componentRoot) flushMounts();
        }
        return ret;
    }
    function idiff(dom, vnode, context, mountAll, componentRoot) {
        var out = dom, prevSvgMode = isSvgMode;
        if (null == vnode || 'boolean' == typeof vnode) vnode = '';
        if ('string' == typeof vnode || 'number' == typeof vnode) {
            if (dom && void 0 !== dom.splitText && dom.parentNode && (!dom._component || componentRoot)) {
                if (dom.nodeValue != vnode) dom.nodeValue = vnode;
            } else {
                out = document.createTextNode(vnode);
                if (dom) {
                    if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
                    recollectNodeTree(dom, !0);
                }
            }
            out.__preactattr_ = !0;
            return out;
        }
        var vnodeName = vnode.nodeName;
        if ('function' == typeof vnodeName) return buildComponentFromVNode(dom, vnode, context, mountAll);
        isSvgMode = 'svg' === vnodeName ? !0 : 'foreignObject' === vnodeName ? !1 : isSvgMode;
        vnodeName = String(vnodeName);
        if (!dom || !isNamedNode(dom, vnodeName)) {
            out = createNode(vnodeName, isSvgMode);
            if (dom) {
                while (dom.firstChild) out.appendChild(dom.firstChild);
                if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
                recollectNodeTree(dom, !0);
            }
        }
        var fc = out.firstChild, props = out.__preactattr_, vchildren = vnode.children;
        if (null == props) {
            props = out.__preactattr_ = {};
            for (var a = out.attributes, i = a.length; i--; ) props[a[i].name] = a[i].value;
        }
        if (!hydrating && vchildren && 1 === vchildren.length && 'string' == typeof vchildren[0] && null != fc && void 0 !== fc.splitText && null == fc.nextSibling) {
            if (fc.nodeValue != vchildren[0]) fc.nodeValue = vchildren[0];
        } else if (vchildren && vchildren.length || null != fc) innerDiffNode(out, vchildren, context, mountAll, hydrating || null != props.dangerouslySetInnerHTML);
        diffAttributes(out, vnode.attributes, props);
        isSvgMode = prevSvgMode;
        return out;
    }
    function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
        var j, c, f, vchild, child, originalChildren = dom.childNodes, children = [], keyed = {}, keyedLen = 0, min = 0, len = originalChildren.length, childrenLen = 0, vlen = vchildren ? vchildren.length : 0;
        if (0 !== len) for (var i = 0; i < len; i++) {
            var _child = originalChildren[i], props = _child.__preactattr_, key = vlen && props ? _child._component ? _child._component.__k : props.key : null;
            if (null != key) {
                keyedLen++;
                keyed[key] = _child;
            } else if (props || (void 0 !== _child.splitText ? isHydrating ? _child.nodeValue.trim() : !0 : isHydrating)) children[childrenLen++] = _child;
        }
        if (0 !== vlen) for (var i = 0; i < vlen; i++) {
            vchild = vchildren[i];
            child = null;
            var key = vchild.key;
            if (null != key) {
                if (keyedLen && void 0 !== keyed[key]) {
                    child = keyed[key];
                    keyed[key] = void 0;
                    keyedLen--;
                }
            } else if (!child && min < childrenLen) for (j = min; j < childrenLen; j++) if (void 0 !== children[j] && isSameNodeType(c = children[j], vchild, isHydrating)) {
                child = c;
                children[j] = void 0;
                if (j === childrenLen - 1) childrenLen--;
                if (j === min) min++;
                break;
            }
            child = idiff(child, vchild, context, mountAll);
            f = originalChildren[i];
            if (child && child !== dom && child !== f) if (null == f) dom.appendChild(child); else if (child === f.nextSibling) removeNode(f); else dom.insertBefore(child, f);
        }
        if (keyedLen) for (var i in keyed) if (void 0 !== keyed[i]) recollectNodeTree(keyed[i], !1);
        while (min <= childrenLen) if (void 0 !== (child = children[childrenLen--])) recollectNodeTree(child, !1);
    }
    function recollectNodeTree(node, unmountOnly) {
        var component = node._component;
        if (component) unmountComponent(component); else {
            if (null != node.__preactattr_ && node.__preactattr_.ref) node.__preactattr_.ref(null);
            if (!1 === unmountOnly || null == node.__preactattr_) removeNode(node);
            removeChildren(node);
        }
    }
    function removeChildren(node) {
        node = node.lastChild;
        while (node) {
            var next = node.previousSibling;
            recollectNodeTree(node, !0);
            node = next;
        }
    }
    function diffAttributes(dom, attrs, old) {
        var name;
        for (name in old) if ((!attrs || null == attrs[name]) && null != old[name]) setAccessor(dom, name, old[name], old[name] = void 0, isSvgMode);
        for (name in attrs) if (!('children' === name || 'innerHTML' === name || name in old && attrs[name] === ('value' === name || 'checked' === name ? dom[name] : old[name]))) setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
    }
    function collectComponent(component) {
        var name = component.constructor.name;
        (components[name] || (components[name] = [])).push(component);
    }
    function createComponent(Ctor, props, context) {
        var inst, list = components[Ctor.name];
        if (Ctor.prototype && Ctor.prototype.render) {
            inst = new Ctor(props, context);
            Component.call(inst, props, context);
        } else {
            inst = new Component(props, context);
            inst.constructor = Ctor;
            inst.render = doRender;
        }
        if (list) for (var i = list.length; i--; ) if (list[i].constructor === Ctor) {
            inst.__b = list[i].__b;
            list.splice(i, 1);
            break;
        }
        return inst;
    }
    function doRender(props, state, context) {
        return this.constructor(props, context);
    }
    function setComponentProps(component, props, opts, context, mountAll) {
        if (!component.__x) {
            component.__x = !0;
            if (component.__r = props.ref) delete props.ref;
            if (component.__k = props.key) delete props.key;
            if (!component.base || mountAll) {
                if (component.componentWillMount) component.componentWillMount();
            } else if (component.componentWillReceiveProps) component.componentWillReceiveProps(props, context);
            if (context && context !== component.context) {
                if (!component.__c) component.__c = component.context;
                component.context = context;
            }
            if (!component.__p) component.__p = component.props;
            component.props = props;
            component.__x = !1;
            if (0 !== opts) if (1 === opts || !1 !== options.syncComponentUpdates || !component.base) renderComponent(component, 1, mountAll); else enqueueRender(component);
            if (component.__r) component.__r(component);
        }
    }
    function renderComponent(component, opts, mountAll, isChild) {
        if (!component.__x) {
            var rendered, inst, cbase, props = component.props, state = component.state, context = component.context, previousProps = component.__p || props, previousState = component.__s || state, previousContext = component.__c || context, isUpdate = component.base, nextBase = component.__b, initialBase = isUpdate || nextBase, initialChildComponent = component._component, skip = !1;
            if (isUpdate) {
                component.props = previousProps;
                component.state = previousState;
                component.context = previousContext;
                if (2 !== opts && component.shouldComponentUpdate && !1 === component.shouldComponentUpdate(props, state, context)) skip = !0; else if (component.componentWillUpdate) component.componentWillUpdate(props, state, context);
                component.props = props;
                component.state = state;
                component.context = context;
            }
            component.__p = component.__s = component.__c = component.__b = null;
            component.__d = !1;
            if (!skip) {
                rendered = component.render(props, state, context);
                if (component.getChildContext) context = extend(extend({}, context), component.getChildContext());
                var toUnmount, base, childComponent = rendered && rendered.nodeName;
                if ('function' == typeof childComponent) {
                    var childProps = getNodeProps(rendered);
                    inst = initialChildComponent;
                    if (inst && inst.constructor === childComponent && childProps.key == inst.__k) setComponentProps(inst, childProps, 1, context, !1); else {
                        toUnmount = inst;
                        component._component = inst = createComponent(childComponent, childProps, context);
                        inst.__b = inst.__b || nextBase;
                        inst.__u = component;
                        setComponentProps(inst, childProps, 0, context, !1);
                        renderComponent(inst, 1, mountAll, !0);
                    }
                    base = inst.base;
                } else {
                    cbase = initialBase;
                    toUnmount = initialChildComponent;
                    if (toUnmount) cbase = component._component = null;
                    if (initialBase || 1 === opts) {
                        if (cbase) cbase._component = null;
                        base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, !0);
                    }
                }
                if (initialBase && base !== initialBase && inst !== initialChildComponent) {
                    var baseParent = initialBase.parentNode;
                    if (baseParent && base !== baseParent) {
                        baseParent.replaceChild(base, initialBase);
                        if (!toUnmount) {
                            initialBase._component = null;
                            recollectNodeTree(initialBase, !1);
                        }
                    }
                }
                if (toUnmount) unmountComponent(toUnmount);
                component.base = base;
                if (base && !isChild) {
                    var componentRef = component, t = component;
                    while (t = t.__u) (componentRef = t).base = base;
                    base._component = componentRef;
                    base._componentConstructor = componentRef.constructor;
                }
            }
            if (!isUpdate || mountAll) mounts.unshift(component); else if (!skip) {
                if (component.componentDidUpdate) component.componentDidUpdate(previousProps, previousState, previousContext);
                if (options.afterUpdate) options.afterUpdate(component);
            }
            if (null != component.__h) while (component.__h.length) component.__h.pop().call(component);
            if (!diffLevel && !isChild) flushMounts();
        }
    }
    function buildComponentFromVNode(dom, vnode, context, mountAll) {
        var c = dom && dom._component, originalComponent = c, oldDom = dom, isDirectOwner = c && dom._componentConstructor === vnode.nodeName, isOwner = isDirectOwner, props = getNodeProps(vnode);
        while (c && !isOwner && (c = c.__u)) isOwner = c.constructor === vnode.nodeName;
        if (c && isOwner && (!mountAll || c._component)) {
            setComponentProps(c, props, 3, context, mountAll);
            dom = c.base;
        } else {
            if (originalComponent && !isDirectOwner) {
                unmountComponent(originalComponent);
                dom = oldDom = null;
            }
            c = createComponent(vnode.nodeName, props, context);
            if (dom && !c.__b) {
                c.__b = dom;
                oldDom = null;
            }
            setComponentProps(c, props, 1, context, mountAll);
            dom = c.base;
            if (oldDom && dom !== oldDom) {
                oldDom._component = null;
                recollectNodeTree(oldDom, !1);
            }
        }
        return dom;
    }
    function unmountComponent(component) {
        if (options.beforeUnmount) options.beforeUnmount(component);
        var base = component.base;
        component.__x = !0;
        if (component.componentWillUnmount) component.componentWillUnmount();
        component.base = null;
        var inner = component._component;
        if (inner) unmountComponent(inner); else if (base) {
            if (base.__preactattr_ && base.__preactattr_.ref) base.__preactattr_.ref(null);
            component.__b = base;
            removeNode(base);
            collectComponent(component);
            removeChildren(base);
        }
        if (component.__r) component.__r(null);
    }
    function Component(props, context) {
        this.__d = !0;
        this.context = context;
        this.props = props;
        this.state = this.state || {};
    }
    function render(vnode, parent, merge) {
        return diff(merge, vnode, {}, !1, parent, !1);
    }
    var options = {};
    var stack = [];
    var EMPTY_CHILDREN = [];
    var defer = 'function' == typeof Promise ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;
    var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
    var items = [];
    var mounts = [];
    var diffLevel = 0;
    var isSvgMode = !1;
    var hydrating = !1;
    var components = {};
    extend(Component.prototype, {
        setState: function(state, callback) {
            var s = this.state;
            if (!this.__s) this.__s = extend({}, s);
            extend(s, 'function' == typeof state ? state(s, this.props) : state);
            if (callback) (this.__h = this.__h || []).push(callback);
            enqueueRender(this);
        },
        forceUpdate: function(callback) {
            if (callback) (this.__h = this.__h || []).push(callback);
            renderComponent(this, 2);
        },
        render: function() {}
    });
    var preact = {
        h: h,
        createElement: h,
        cloneElement: cloneElement,
        Component: Component,
        render: render,
        rerender: rerender,
        options: options
    };
    if ('undefined' != typeof module) module.exports = preact; else self.preact = preact;
}();

},{}],18:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],19:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encodeURIComponent(key);
      value = encodeURIComponent(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],20:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],21:[function(require,module,exports){
(function (global){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.ResizeObserver = factory());
}(this, (function () { 'use strict';

    /**
     * A collection of shims that provide minimal functionality of the ES6 collections.
     *
     * These implementations are not meant to be used outside of the ResizeObserver
     * modules as they cover only a limited range of use cases.
     */
    /* eslint-disable require-jsdoc, valid-jsdoc */
    var MapShim = (function () {
        if (typeof Map !== 'undefined') {
            return Map;
        }
        /**
         * Returns index in provided array that matches the specified key.
         *
         * @param {Array<Array>} arr
         * @param {*} key
         * @returns {number}
         */
        function getIndex(arr, key) {
            var result = -1;
            arr.some(function (entry, index) {
                if (entry[0] === key) {
                    result = index;
                    return true;
                }
                return false;
            });
            return result;
        }
        return /** @class */ (function () {
            function class_1() {
                this.__entries__ = [];
            }
            Object.defineProperty(class_1.prototype, "size", {
                /**
                 * @returns {boolean}
                 */
                get: function () {
                    return this.__entries__.length;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * @param {*} key
             * @returns {*}
             */
            class_1.prototype.get = function (key) {
                var index = getIndex(this.__entries__, key);
                var entry = this.__entries__[index];
                return entry && entry[1];
            };
            /**
             * @param {*} key
             * @param {*} value
             * @returns {void}
             */
            class_1.prototype.set = function (key, value) {
                var index = getIndex(this.__entries__, key);
                if (~index) {
                    this.__entries__[index][1] = value;
                }
                else {
                    this.__entries__.push([key, value]);
                }
            };
            /**
             * @param {*} key
             * @returns {void}
             */
            class_1.prototype.delete = function (key) {
                var entries = this.__entries__;
                var index = getIndex(entries, key);
                if (~index) {
                    entries.splice(index, 1);
                }
            };
            /**
             * @param {*} key
             * @returns {void}
             */
            class_1.prototype.has = function (key) {
                return !!~getIndex(this.__entries__, key);
            };
            /**
             * @returns {void}
             */
            class_1.prototype.clear = function () {
                this.__entries__.splice(0);
            };
            /**
             * @param {Function} callback
             * @param {*} [ctx=null]
             * @returns {void}
             */
            class_1.prototype.forEach = function (callback, ctx) {
                if (ctx === void 0) { ctx = null; }
                for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                    var entry = _a[_i];
                    callback.call(ctx, entry[1], entry[0]);
                }
            };
            return class_1;
        }());
    })();

    /**
     * Detects whether window and document objects are available in current environment.
     */
    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

    // Returns global object of a current environment.
    var global$1 = (function () {
        if (typeof global !== 'undefined' && global.Math === Math) {
            return global;
        }
        if (typeof self !== 'undefined' && self.Math === Math) {
            return self;
        }
        if (typeof window !== 'undefined' && window.Math === Math) {
            return window;
        }
        // eslint-disable-next-line no-new-func
        return Function('return this')();
    })();

    /**
     * A shim for the requestAnimationFrame which falls back to the setTimeout if
     * first one is not supported.
     *
     * @returns {number} Requests' identifier.
     */
    var requestAnimationFrame$1 = (function () {
        if (typeof requestAnimationFrame === 'function') {
            // It's required to use a bounded function because IE sometimes throws
            // an "Invalid calling object" error if rAF is invoked without the global
            // object on the left hand side.
            return requestAnimationFrame.bind(global$1);
        }
        return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
    })();

    // Defines minimum timeout before adding a trailing call.
    var trailingTimeout = 2;
    /**
     * Creates a wrapper function which ensures that provided callback will be
     * invoked only once during the specified delay period.
     *
     * @param {Function} callback - Function to be invoked after the delay period.
     * @param {number} delay - Delay after which to invoke callback.
     * @returns {Function}
     */
    function throttle (callback, delay) {
        var leadingCall = false, trailingCall = false, lastCallTime = 0;
        /**
         * Invokes the original callback function and schedules new invocation if
         * the "proxy" was called during current request.
         *
         * @returns {void}
         */
        function resolvePending() {
            if (leadingCall) {
                leadingCall = false;
                callback();
            }
            if (trailingCall) {
                proxy();
            }
        }
        /**
         * Callback invoked after the specified delay. It will further postpone
         * invocation of the original function delegating it to the
         * requestAnimationFrame.
         *
         * @returns {void}
         */
        function timeoutCallback() {
            requestAnimationFrame$1(resolvePending);
        }
        /**
         * Schedules invocation of the original function.
         *
         * @returns {void}
         */
        function proxy() {
            var timeStamp = Date.now();
            if (leadingCall) {
                // Reject immediately following calls.
                if (timeStamp - lastCallTime < trailingTimeout) {
                    return;
                }
                // Schedule new call to be in invoked when the pending one is resolved.
                // This is important for "transitions" which never actually start
                // immediately so there is a chance that we might miss one if change
                // happens amids the pending invocation.
                trailingCall = true;
            }
            else {
                leadingCall = true;
                trailingCall = false;
                setTimeout(timeoutCallback, delay);
            }
            lastCallTime = timeStamp;
        }
        return proxy;
    }

    // Minimum delay before invoking the update of observers.
    var REFRESH_DELAY = 20;
    // A list of substrings of CSS properties used to find transition events that
    // might affect dimensions of observed elements.
    var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
    // Check if MutationObserver is available.
    var mutationObserverSupported = typeof MutationObserver !== 'undefined';
    /**
     * Singleton controller class which handles updates of ResizeObserver instances.
     */
    var ResizeObserverController = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserverController.
         *
         * @private
         */
        function ResizeObserverController() {
            /**
             * Indicates whether DOM listeners have been added.
             *
             * @private {boolean}
             */
            this.connected_ = false;
            /**
             * Tells that controller has subscribed for Mutation Events.
             *
             * @private {boolean}
             */
            this.mutationEventsAdded_ = false;
            /**
             * Keeps reference to the instance of MutationObserver.
             *
             * @private {MutationObserver}
             */
            this.mutationsObserver_ = null;
            /**
             * A list of connected observers.
             *
             * @private {Array<ResizeObserverSPI>}
             */
            this.observers_ = [];
            this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
            this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
        }
        /**
         * Adds observer to observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be added.
         * @returns {void}
         */
        ResizeObserverController.prototype.addObserver = function (observer) {
            if (!~this.observers_.indexOf(observer)) {
                this.observers_.push(observer);
            }
            // Add listeners if they haven't been added yet.
            if (!this.connected_) {
                this.connect_();
            }
        };
        /**
         * Removes observer from observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be removed.
         * @returns {void}
         */
        ResizeObserverController.prototype.removeObserver = function (observer) {
            var observers = this.observers_;
            var index = observers.indexOf(observer);
            // Remove observer if it's present in registry.
            if (~index) {
                observers.splice(index, 1);
            }
            // Remove listeners if controller has no connected observers.
            if (!observers.length && this.connected_) {
                this.disconnect_();
            }
        };
        /**
         * Invokes the update of observers. It will continue running updates insofar
         * it detects changes.
         *
         * @returns {void}
         */
        ResizeObserverController.prototype.refresh = function () {
            var changesDetected = this.updateObservers_();
            // Continue running updates if changes have been detected as there might
            // be future ones caused by CSS transitions.
            if (changesDetected) {
                this.refresh();
            }
        };
        /**
         * Updates every observer from observers list and notifies them of queued
         * entries.
         *
         * @private
         * @returns {boolean} Returns "true" if any observer has detected changes in
         *      dimensions of it's elements.
         */
        ResizeObserverController.prototype.updateObservers_ = function () {
            // Collect observers that have active observations.
            var activeObservers = this.observers_.filter(function (observer) {
                return observer.gatherActive(), observer.hasActive();
            });
            // Deliver notifications in a separate cycle in order to avoid any
            // collisions between observers, e.g. when multiple instances of
            // ResizeObserver are tracking the same element and the callback of one
            // of them changes content dimensions of the observed target. Sometimes
            // this may result in notifications being blocked for the rest of observers.
            activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
            return activeObservers.length > 0;
        };
        /**
         * Initializes DOM listeners.
         *
         * @private
         * @returns {void}
         */
        ResizeObserverController.prototype.connect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already added.
            if (!isBrowser || this.connected_) {
                return;
            }
            // Subscription to the "Transitionend" event is used as a workaround for
            // delayed transitions. This way it's possible to capture at least the
            // final state of an element.
            document.addEventListener('transitionend', this.onTransitionEnd_);
            window.addEventListener('resize', this.refresh);
            if (mutationObserverSupported) {
                this.mutationsObserver_ = new MutationObserver(this.refresh);
                this.mutationsObserver_.observe(document, {
                    attributes: true,
                    childList: true,
                    characterData: true,
                    subtree: true
                });
            }
            else {
                document.addEventListener('DOMSubtreeModified', this.refresh);
                this.mutationEventsAdded_ = true;
            }
            this.connected_ = true;
        };
        /**
         * Removes DOM listeners.
         *
         * @private
         * @returns {void}
         */
        ResizeObserverController.prototype.disconnect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already removed.
            if (!isBrowser || !this.connected_) {
                return;
            }
            document.removeEventListener('transitionend', this.onTransitionEnd_);
            window.removeEventListener('resize', this.refresh);
            if (this.mutationsObserver_) {
                this.mutationsObserver_.disconnect();
            }
            if (this.mutationEventsAdded_) {
                document.removeEventListener('DOMSubtreeModified', this.refresh);
            }
            this.mutationsObserver_ = null;
            this.mutationEventsAdded_ = false;
            this.connected_ = false;
        };
        /**
         * "Transitionend" event handler.
         *
         * @private
         * @param {TransitionEvent} event
         * @returns {void}
         */
        ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
            var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
            // Detect whether transition may affect dimensions of an element.
            var isReflowProperty = transitionKeys.some(function (key) {
                return !!~propertyName.indexOf(key);
            });
            if (isReflowProperty) {
                this.refresh();
            }
        };
        /**
         * Returns instance of the ResizeObserverController.
         *
         * @returns {ResizeObserverController}
         */
        ResizeObserverController.getInstance = function () {
            if (!this.instance_) {
                this.instance_ = new ResizeObserverController();
            }
            return this.instance_;
        };
        /**
         * Holds reference to the controller's instance.
         *
         * @private {ResizeObserverController}
         */
        ResizeObserverController.instance_ = null;
        return ResizeObserverController;
    }());

    /**
     * Defines non-writable/enumerable properties of the provided target object.
     *
     * @param {Object} target - Object for which to define properties.
     * @param {Object} props - Properties to be defined.
     * @returns {Object} Target object.
     */
    var defineConfigurable = (function (target, props) {
        for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
            var key = _a[_i];
            Object.defineProperty(target, key, {
                value: props[key],
                enumerable: false,
                writable: false,
                configurable: true
            });
        }
        return target;
    });

    /**
     * Returns the global object associated with provided element.
     *
     * @param {Object} target
     * @returns {Object}
     */
    var getWindowOf = (function (target) {
        // Assume that the element is an instance of Node, which means that it
        // has the "ownerDocument" property from which we can retrieve a
        // corresponding global object.
        var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
        // Return the local global object if it's not possible extract one from
        // provided element.
        return ownerGlobal || global$1;
    });

    // Placeholder of an empty content rectangle.
    var emptyRect = createRectInit(0, 0, 0, 0);
    /**
     * Converts provided string to a number.
     *
     * @param {number|string} value
     * @returns {number}
     */
    function toFloat(value) {
        return parseFloat(value) || 0;
    }
    /**
     * Extracts borders size from provided styles.
     *
     * @param {CSSStyleDeclaration} styles
     * @param {...string} positions - Borders positions (top, right, ...)
     * @returns {number}
     */
    function getBordersSize(styles) {
        var positions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            positions[_i - 1] = arguments[_i];
        }
        return positions.reduce(function (size, position) {
            var value = styles['border-' + position + '-width'];
            return size + toFloat(value);
        }, 0);
    }
    /**
     * Extracts paddings sizes from provided styles.
     *
     * @param {CSSStyleDeclaration} styles
     * @returns {Object} Paddings box.
     */
    function getPaddings(styles) {
        var positions = ['top', 'right', 'bottom', 'left'];
        var paddings = {};
        for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
            var position = positions_1[_i];
            var value = styles['padding-' + position];
            paddings[position] = toFloat(value);
        }
        return paddings;
    }
    /**
     * Calculates content rectangle of provided SVG element.
     *
     * @param {SVGGraphicsElement} target - Element content rectangle of which needs
     *      to be calculated.
     * @returns {DOMRectInit}
     */
    function getSVGContentRect(target) {
        var bbox = target.getBBox();
        return createRectInit(0, 0, bbox.width, bbox.height);
    }
    /**
     * Calculates content rectangle of provided HTMLElement.
     *
     * @param {HTMLElement} target - Element for which to calculate the content rectangle.
     * @returns {DOMRectInit}
     */
    function getHTMLElementContentRect(target) {
        // Client width & height properties can't be
        // used exclusively as they provide rounded values.
        var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
        // By this condition we can catch all non-replaced inline, hidden and
        // detached elements. Though elements with width & height properties less
        // than 0.5 will be discarded as well.
        //
        // Without it we would need to implement separate methods for each of
        // those cases and it's not possible to perform a precise and performance
        // effective test for hidden elements. E.g. even jQuery's ':visible' filter
        // gives wrong results for elements with width & height less than 0.5.
        if (!clientWidth && !clientHeight) {
            return emptyRect;
        }
        var styles = getWindowOf(target).getComputedStyle(target);
        var paddings = getPaddings(styles);
        var horizPad = paddings.left + paddings.right;
        var vertPad = paddings.top + paddings.bottom;
        // Computed styles of width & height are being used because they are the
        // only dimensions available to JS that contain non-rounded values. It could
        // be possible to utilize the getBoundingClientRect if only it's data wasn't
        // affected by CSS transformations let alone paddings, borders and scroll bars.
        var width = toFloat(styles.width), height = toFloat(styles.height);
        // Width & height include paddings and borders when the 'border-box' box
        // model is applied (except for IE).
        if (styles.boxSizing === 'border-box') {
            // Following conditions are required to handle Internet Explorer which
            // doesn't include paddings and borders to computed CSS dimensions.
            //
            // We can say that if CSS dimensions + paddings are equal to the "client"
            // properties then it's either IE, and thus we don't need to subtract
            // anything, or an element merely doesn't have paddings/borders styles.
            if (Math.round(width + horizPad) !== clientWidth) {
                width -= getBordersSize(styles, 'left', 'right') + horizPad;
            }
            if (Math.round(height + vertPad) !== clientHeight) {
                height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
            }
        }
        // Following steps can't be applied to the document's root element as its
        // client[Width/Height] properties represent viewport area of the window.
        // Besides, it's as well not necessary as the <html> itself neither has
        // rendered scroll bars nor it can be clipped.
        if (!isDocumentElement(target)) {
            // In some browsers (only in Firefox, actually) CSS width & height
            // include scroll bars size which can be removed at this step as scroll
            // bars are the only difference between rounded dimensions + paddings
            // and "client" properties, though that is not always true in Chrome.
            var vertScrollbar = Math.round(width + horizPad) - clientWidth;
            var horizScrollbar = Math.round(height + vertPad) - clientHeight;
            // Chrome has a rather weird rounding of "client" properties.
            // E.g. for an element with content width of 314.2px it sometimes gives
            // the client width of 315px and for the width of 314.7px it may give
            // 314px. And it doesn't happen all the time. So just ignore this delta
            // as a non-relevant.
            if (Math.abs(vertScrollbar) !== 1) {
                width -= vertScrollbar;
            }
            if (Math.abs(horizScrollbar) !== 1) {
                height -= horizScrollbar;
            }
        }
        return createRectInit(paddings.left, paddings.top, width, height);
    }
    /**
     * Checks whether provided element is an instance of the SVGGraphicsElement.
     *
     * @param {Element} target - Element to be checked.
     * @returns {boolean}
     */
    var isSVGGraphicsElement = (function () {
        // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
        // interface.
        if (typeof SVGGraphicsElement !== 'undefined') {
            return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
        }
        // If it's so, then check that element is at least an instance of the
        // SVGElement and that it has the "getBBox" method.
        // eslint-disable-next-line no-extra-parens
        return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
            typeof target.getBBox === 'function'); };
    })();
    /**
     * Checks whether provided element is a document element (<html>).
     *
     * @param {Element} target - Element to be checked.
     * @returns {boolean}
     */
    function isDocumentElement(target) {
        return target === getWindowOf(target).document.documentElement;
    }
    /**
     * Calculates an appropriate content rectangle for provided html or svg element.
     *
     * @param {Element} target - Element content rectangle of which needs to be calculated.
     * @returns {DOMRectInit}
     */
    function getContentRect(target) {
        if (!isBrowser) {
            return emptyRect;
        }
        if (isSVGGraphicsElement(target)) {
            return getSVGContentRect(target);
        }
        return getHTMLElementContentRect(target);
    }
    /**
     * Creates rectangle with an interface of the DOMRectReadOnly.
     * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
     *
     * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
     * @returns {DOMRectReadOnly}
     */
    function createReadOnlyRect(_a) {
        var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
        // If DOMRectReadOnly is available use it as a prototype for the rectangle.
        var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
        var rect = Object.create(Constr.prototype);
        // Rectangle's properties are not writable and non-enumerable.
        defineConfigurable(rect, {
            x: x, y: y, width: width, height: height,
            top: y,
            right: x + width,
            bottom: height + y,
            left: x
        });
        return rect;
    }
    /**
     * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
     * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
     *
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} width - Rectangle's width.
     * @param {number} height - Rectangle's height.
     * @returns {DOMRectInit}
     */
    function createRectInit(x, y, width, height) {
        return { x: x, y: y, width: width, height: height };
    }

    /**
     * Class that is responsible for computations of the content rectangle of
     * provided DOM element and for keeping track of it's changes.
     */
    var ResizeObservation = /** @class */ (function () {
        /**
         * Creates an instance of ResizeObservation.
         *
         * @param {Element} target - Element to be observed.
         */
        function ResizeObservation(target) {
            /**
             * Broadcasted width of content rectangle.
             *
             * @type {number}
             */
            this.broadcastWidth = 0;
            /**
             * Broadcasted height of content rectangle.
             *
             * @type {number}
             */
            this.broadcastHeight = 0;
            /**
             * Reference to the last observed content rectangle.
             *
             * @private {DOMRectInit}
             */
            this.contentRect_ = createRectInit(0, 0, 0, 0);
            this.target = target;
        }
        /**
         * Updates content rectangle and tells whether it's width or height properties
         * have changed since the last broadcast.
         *
         * @returns {boolean}
         */
        ResizeObservation.prototype.isActive = function () {
            var rect = getContentRect(this.target);
            this.contentRect_ = rect;
            return (rect.width !== this.broadcastWidth ||
                rect.height !== this.broadcastHeight);
        };
        /**
         * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
         * from the corresponding properties of the last observed content rectangle.
         *
         * @returns {DOMRectInit} Last observed content rectangle.
         */
        ResizeObservation.prototype.broadcastRect = function () {
            var rect = this.contentRect_;
            this.broadcastWidth = rect.width;
            this.broadcastHeight = rect.height;
            return rect;
        };
        return ResizeObservation;
    }());

    var ResizeObserverEntry = /** @class */ (function () {
        /**
         * Creates an instance of ResizeObserverEntry.
         *
         * @param {Element} target - Element that is being observed.
         * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
         */
        function ResizeObserverEntry(target, rectInit) {
            var contentRect = createReadOnlyRect(rectInit);
            // According to the specification following properties are not writable
            // and are also not enumerable in the native implementation.
            //
            // Property accessors are not being used as they'd require to define a
            // private WeakMap storage which may cause memory leaks in browsers that
            // don't support this type of collections.
            defineConfigurable(this, { target: target, contentRect: contentRect });
        }
        return ResizeObserverEntry;
    }());

    var ResizeObserverSPI = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback function that is invoked
         *      when one of the observed elements changes it's content dimensions.
         * @param {ResizeObserverController} controller - Controller instance which
         *      is responsible for the updates of observer.
         * @param {ResizeObserver} callbackCtx - Reference to the public
         *      ResizeObserver instance which will be passed to callback function.
         */
        function ResizeObserverSPI(callback, controller, callbackCtx) {
            /**
             * Collection of resize observations that have detected changes in dimensions
             * of elements.
             *
             * @private {Array<ResizeObservation>}
             */
            this.activeObservations_ = [];
            /**
             * Registry of the ResizeObservation instances.
             *
             * @private {Map<Element, ResizeObservation>}
             */
            this.observations_ = new MapShim();
            if (typeof callback !== 'function') {
                throw new TypeError('The callback provided as parameter 1 is not a function.');
            }
            this.callback_ = callback;
            this.controller_ = controller;
            this.callbackCtx_ = callbackCtx;
        }
        /**
         * Starts observing provided element.
         *
         * @param {Element} target - Element to be observed.
         * @returns {void}
         */
        ResizeObserverSPI.prototype.observe = function (target) {
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
                return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
                throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            // Do nothing if element is already being observed.
            if (observations.has(target)) {
                return;
            }
            observations.set(target, new ResizeObservation(target));
            this.controller_.addObserver(this);
            // Force the update of observations.
            this.controller_.refresh();
        };
        /**
         * Stops observing provided element.
         *
         * @param {Element} target - Element to stop observing.
         * @returns {void}
         */
        ResizeObserverSPI.prototype.unobserve = function (target) {
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
                return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
                throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            // Do nothing if element is not being observed.
            if (!observations.has(target)) {
                return;
            }
            observations.delete(target);
            if (!observations.size) {
                this.controller_.removeObserver(this);
            }
        };
        /**
         * Stops observing all elements.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.disconnect = function () {
            this.clearActive();
            this.observations_.clear();
            this.controller_.removeObserver(this);
        };
        /**
         * Collects observation instances the associated element of which has changed
         * it's content rectangle.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.gatherActive = function () {
            var _this = this;
            this.clearActive();
            this.observations_.forEach(function (observation) {
                if (observation.isActive()) {
                    _this.activeObservations_.push(observation);
                }
            });
        };
        /**
         * Invokes initial callback function with a list of ResizeObserverEntry
         * instances collected from active resize observations.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.broadcastActive = function () {
            // Do nothing if observer doesn't have active observations.
            if (!this.hasActive()) {
                return;
            }
            var ctx = this.callbackCtx_;
            // Create ResizeObserverEntry instance for every active observation.
            var entries = this.activeObservations_.map(function (observation) {
                return new ResizeObserverEntry(observation.target, observation.broadcastRect());
            });
            this.callback_.call(ctx, entries, ctx);
            this.clearActive();
        };
        /**
         * Clears the collection of active observations.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.clearActive = function () {
            this.activeObservations_.splice(0);
        };
        /**
         * Tells whether observer has active observations.
         *
         * @returns {boolean}
         */
        ResizeObserverSPI.prototype.hasActive = function () {
            return this.activeObservations_.length > 0;
        };
        return ResizeObserverSPI;
    }());

    // Registry of internal observers. If WeakMap is not available use current shim
    // for the Map collection as it has all required methods and because WeakMap
    // can't be fully polyfilled anyway.
    var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
    /**
     * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
     * exposing only those methods and properties that are defined in the spec.
     */
    var ResizeObserver = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback that is invoked when
         *      dimensions of the observed elements change.
         */
        function ResizeObserver(callback) {
            if (!(this instanceof ResizeObserver)) {
                throw new TypeError('Cannot call a class as a function.');
            }
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            var controller = ResizeObserverController.getInstance();
            var observer = new ResizeObserverSPI(callback, controller, this);
            observers.set(this, observer);
        }
        return ResizeObserver;
    }());
    // Expose public methods of ResizeObserver.
    [
        'observe',
        'unobserve',
        'disconnect'
    ].forEach(function (method) {
        ResizeObserver.prototype[method] = function () {
            var _a;
            return (_a = observers.get(this))[method].apply(_a, arguments);
        };
    });

    var index = (function () {
        // Export existing implementation if available.
        if (typeof global$1.ResizeObserver !== 'undefined') {
            return global$1.ResizeObserver;
        }
        return ResizeObserver;
    })();

    return index;

})));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fingerprint;

var _isReactNative = require("./isReactNative");

var _isReactNative2 = _interopRequireDefault(_isReactNative);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Generate a fingerprint for a file which will be used the store the endpoint
 *
 * @param {File} file
 * @param {Object} options
 * @param {Function} callback
 */
function fingerprint(file, options, callback) {
  if ((0, _isReactNative2.default)()) {
    return callback(null, reactNativeFingerprint(file, options));
  }

  return callback(null, ["tus-br", file.name, file.type, file.size, file.lastModified, options.endpoint].join("-"));
}

function reactNativeFingerprint(file, options) {
  var exifHash = file.exif ? hashCode(JSON.stringify(file.exif)) : "noexif";
  return ["tus-rn", file.name || "noname", file.size || "nosize", exifHash, options.endpoint].join("/");
}

function hashCode(str) {
  // from https://stackoverflow.com/a/8831937/151666
  var hash = 0;
  if (str.length === 0) {
    return hash;
  }
  for (var i = 0; i < str.length; i++) {
    var char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return hash;
}
},{"./isReactNative":24}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var isCordova = function isCordova() {
  return typeof window != "undefined" && (typeof window.PhoneGap != "undefined" || typeof window.Cordova != "undefined" || typeof window.cordova != "undefined");
};

exports.default = isCordova;
},{}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var isReactNative = function isReactNative() {
  return typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
};

exports.default = isReactNative;
},{}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * readAsByteArray converts a File object to a Uint8Array.
 * This function is only used on the Apache Cordova platform.
 * See https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-file/index.html#read-a-file
 */
function readAsByteArray(chunk, callback) {
  var reader = new FileReader();
  reader.onload = function () {
    callback(null, new Uint8Array(reader.result));
  };
  reader.onerror = function (err) {
    callback(err);
  };
  reader.readAsArrayBuffer(chunk);
}

exports.default = readAsByteArray;
},{}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.newRequest = newRequest;
exports.resolveUrl = resolveUrl;

var _urlParse = require("url-parse");

var _urlParse2 = _interopRequireDefault(_urlParse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function newRequest() {
  return new window.XMLHttpRequest();
} /* global window */
function resolveUrl(origin, link) {
  return new _urlParse2.default(link, origin).toString();
}
},{"url-parse":33}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.getSource = getSource;

var _isReactNative = require("./isReactNative");

var _isReactNative2 = _interopRequireDefault(_isReactNative);

var _uriToBlob = require("./uriToBlob");

var _uriToBlob2 = _interopRequireDefault(_uriToBlob);

var _isCordova = require("./isCordova");

var _isCordova2 = _interopRequireDefault(_isCordova);

var _readAsByteArray = require("./readAsByteArray");

var _readAsByteArray2 = _interopRequireDefault(_readAsByteArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FileSource = function () {
  function FileSource(file) {
    _classCallCheck(this, FileSource);

    this._file = file;
    this.size = file.size;
  }

  _createClass(FileSource, [{
    key: "slice",
    value: function slice(start, end, callback) {
      // In Apache Cordova applications, a File must be resolved using
      // FileReader instances, see
      // https://cordova.apache.org/docs/en/8.x/reference/cordova-plugin-file/index.html#read-a-file
      if ((0, _isCordova2.default)()) {
        (0, _readAsByteArray2.default)(this._file.slice(start, end), function (err, chunk) {
          if (err) return callback(err);

          callback(null, chunk);
        });
        return;
      }

      callback(null, this._file.slice(start, end));
    }
  }, {
    key: "close",
    value: function close() {}
  }]);

  return FileSource;
}();

var StreamSource = function () {
  function StreamSource(reader, chunkSize) {
    _classCallCheck(this, StreamSource);

    this._chunkSize = chunkSize;
    this._buffer = undefined;
    this._bufferOffset = 0;
    this._reader = reader;
    this._done = false;
  }

  _createClass(StreamSource, [{
    key: "slice",
    value: function slice(start, end, callback) {
      if (start < this._bufferOffset) {
        callback(new Error("Requested data is before the reader's current offset"));
        return;
      }

      return this._readUntilEnoughDataOrDone(start, end, callback);
    }
  }, {
    key: "_readUntilEnoughDataOrDone",
    value: function _readUntilEnoughDataOrDone(start, end, callback) {
      var _this = this;

      var hasEnoughData = end <= this._bufferOffset + len(this._buffer);
      if (this._done || hasEnoughData) {
        var value = this._getDataFromBuffer(start, end);
        callback(null, value, value == null ? this._done : false);
        return;
      }
      this._reader.read().then(function (_ref) {
        var value = _ref.value,
            done = _ref.done;

        if (done) {
          _this._done = true;
        } else if (_this._buffer === undefined) {
          _this._buffer = value;
        } else {
          _this._buffer = concat(_this._buffer, value);
        }

        _this._readUntilEnoughDataOrDone(start, end, callback);
      }).catch(function (err) {
        callback(new Error("Error during read: " + err));
      });
    }
  }, {
    key: "_getDataFromBuffer",
    value: function _getDataFromBuffer(start, end) {
      // Remove data from buffer before `start`.
      // Data might be reread from the buffer if an upload fails, so we can only
      // safely delete data when it comes *before* what is currently being read.
      if (start > this._bufferOffset) {
        this._buffer = this._buffer.slice(start - this._bufferOffset);
        this._bufferOffset = start;
      }
      // If the buffer is empty after removing old data, all data has been read.
      var hasAllDataBeenRead = len(this._buffer) === 0;
      if (this._done && hasAllDataBeenRead) {
        return null;
      }
      // We already removed data before `start`, so we just return the first
      // chunk from the buffer.
      return this._buffer.slice(0, end - start);
    }
  }, {
    key: "close",
    value: function close() {
      if (this._reader.cancel) {
        this._reader.cancel();
      }
    }
  }]);

  return StreamSource;
}();

function len(blobOrArray) {
  if (blobOrArray === undefined) return 0;
  if (blobOrArray.size !== undefined) return blobOrArray.size;
  return blobOrArray.length;
}

/*
  Typed arrays and blobs don't have a concat method.
  This function helps StreamSource accumulate data to reach chunkSize.
*/
function concat(a, b) {
  if (a.concat) {
    // Is `a` an Array?
    return a.concat(b);
  }
  if (a instanceof Blob) {
    return new Blob([a, b], { type: a.type });
  }
  if (a.set) {
    // Is `a` a typed array?
    var c = new a.constructor(a.length + b.length);
    c.set(a);
    c.set(b, a.length);
    return c;
  }
  throw new Error("Unknown data type");
}

function getSource(input, chunkSize, callback) {
  // In React Native, when user selects a file, instead of a File or Blob,
  // you usually get a file object {} with a uri property that contains
  // a local path to the file. We use XMLHttpRequest to fetch
  // the file blob, before uploading with tus.
  if ((0, _isReactNative2.default)() && input && typeof input.uri !== "undefined") {
    (0, _uriToBlob2.default)(input.uri, function (err, blob) {
      if (err) {
        return callback(new Error("tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. " + err));
      }
      callback(null, new FileSource(blob));
    });
    return;
  }

  // Since we emulate the Blob type in our tests (not all target browsers
  // support it), we cannot use `instanceof` for testing whether the input value
  // can be handled. Instead, we simply check is the slice() function and the
  // size property are available.
  if (typeof input.slice === "function" && typeof input.size !== "undefined") {
    callback(null, new FileSource(input));
    return;
  }

  if (typeof input.read === "function") {
    chunkSize = +chunkSize;
    if (!isFinite(chunkSize)) {
      callback(new Error("cannot create source for stream without a finite value for the `chunkSize` option"));
      return;
    }
    callback(null, new StreamSource(input, chunkSize));
    return;
  }

  callback(new Error("source object may only be an instance of File, Blob, or Reader in this environment"));
}
},{"./isCordova":23,"./isReactNative":24,"./readAsByteArray":25,"./uriToBlob":29}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.getStorage = getStorage;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* global window, localStorage */

var hasStorage = false;
try {
  hasStorage = "localStorage" in window;

  // Attempt to store and read entries from the local storage to detect Private
  // Mode on Safari on iOS (see #49)
  var key = "tusSupport";
  localStorage.setItem(key, localStorage.getItem(key));
} catch (e) {
  // If we try to access localStorage inside a sandboxed iframe, a SecurityError
  // is thrown. When in private mode on iOS Safari, a QuotaExceededError is
  // thrown (see #49)
  if (e.code === e.SECURITY_ERR || e.code === e.QUOTA_EXCEEDED_ERR) {
    hasStorage = false;
  } else {
    throw e;
  }
}

var canStoreURLs = exports.canStoreURLs = hasStorage;

var LocalStorage = function () {
  function LocalStorage() {
    _classCallCheck(this, LocalStorage);
  }

  _createClass(LocalStorage, [{
    key: "setItem",
    value: function setItem(key, value, cb) {
      cb(null, localStorage.setItem(key, value));
    }
  }, {
    key: "getItem",
    value: function getItem(key, cb) {
      cb(null, localStorage.getItem(key));
    }
  }, {
    key: "removeItem",
    value: function removeItem(key, cb) {
      cb(null, localStorage.removeItem(key));
    }
  }]);

  return LocalStorage;
}();

function getStorage() {
  return hasStorage ? new LocalStorage() : null;
}
},{}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * uriToBlob resolves a URI to a Blob object. This is used for
 * React Native to retrieve a file (identified by a file://
 * URI) as a blob.
 */
function uriToBlob(uri, done) {
  var xhr = new XMLHttpRequest();
  xhr.responseType = "blob";
  xhr.onload = function () {
    var blob = xhr.response;
    done(null, blob);
  };
  xhr.onerror = function (err) {
    done(err);
  };
  xhr.open("GET", uri);
  xhr.send();
}

exports.default = uriToBlob;
},{}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DetailedError = function (_Error) {
  _inherits(DetailedError, _Error);

  function DetailedError(error) {
    var causingErr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var xhr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, DetailedError);

    var _this = _possibleConstructorReturn(this, (DetailedError.__proto__ || Object.getPrototypeOf(DetailedError)).call(this, error.message));

    _this.originalRequest = xhr;
    _this.causingError = causingErr;

    var message = error.message;
    if (causingErr != null) {
      message += ", caused by " + causingErr.toString();
    }
    if (xhr != null) {
      message += ", originated from request (response code: " + xhr.status + ", response text: " + xhr.responseText + ")";
    }
    _this.message = message;
    return _this;
  }

  return DetailedError;
}(Error);

exports.default = DetailedError;
},{}],31:[function(require,module,exports){
"use strict";

var _upload = require("./upload");

var _upload2 = _interopRequireDefault(_upload);

var _storage = require("./node/storage");

var storage = _interopRequireWildcard(_storage);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* global window */
var defaultOptions = _upload2.default.defaultOptions;


var moduleExport = {
  Upload: _upload2.default,
  canStoreURLs: storage.canStoreURLs,
  defaultOptions: defaultOptions
};

if (typeof window !== "undefined") {
  // Browser environment using XMLHttpRequest
  var _window = window,
      XMLHttpRequest = _window.XMLHttpRequest,
      Blob = _window.Blob;


  moduleExport.isSupported = XMLHttpRequest && Blob && typeof Blob.prototype.slice === "function";
} else {
  // Node.js environment using http module
  moduleExport.isSupported = true;
  // make FileStorage module available as it will not be set by default.
  moduleExport.FileStorage = storage.FileStorage;
}

// The usage of the commonjs exporting syntax instead of the new ECMAScript
// one is actually inteded and prevents weird behaviour if we are trying to
// import this module in another module using Babel.
module.exports = moduleExport;
},{"./node/storage":28,"./upload":32}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global window */


// We import the files used inside the Node environment which are rewritten
// for browsers using the rules defined in the package.json


var _error = require("./error");

var _error2 = _interopRequireDefault(_error);

var _extend = require("extend");

var _extend2 = _interopRequireDefault(_extend);

var _jsBase = require("js-base64");

var _request = require("./node/request");

var _source = require("./node/source");

var _storage = require("./node/storage");

var _fingerprint = require("./node/fingerprint");

var _fingerprint2 = _interopRequireDefault(_fingerprint);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultOptions = {
  endpoint: null,
  fingerprint: _fingerprint2.default,
  resume: true,
  onProgress: null,
  onChunkComplete: null,
  onSuccess: null,
  onError: null,
  headers: {},
  chunkSize: Infinity,
  withCredentials: false,
  uploadUrl: null,
  uploadSize: null,
  overridePatchMethod: false,
  retryDelays: null,
  removeFingerprintOnSuccess: false,
  uploadLengthDeferred: false,
  urlStorage: null,
  fileReader: null,
  uploadDataDuringCreation: false
};

var Upload = function () {
  function Upload(file, options) {
    _classCallCheck(this, Upload);

    this.options = (0, _extend2.default)(true, {}, defaultOptions, options);

    // The storage module used to store URLs
    this._storage = this.options.urlStorage;

    // The underlying File/Blob object
    this.file = file;

    // The URL against which the file will be uploaded
    this.url = null;

    // The underlying XHR object for the current PATCH request
    this._xhr = null;

    // The fingerpinrt for the current file (set after start())
    this._fingerprint = null;

    // The offset used in the current PATCH request
    this._offset = null;

    // True if the current PATCH request has been aborted
    this._aborted = false;

    // The file's size in bytes
    this._size = null;

    // The Source object which will wrap around the given file and provides us
    // with a unified interface for getting its size and slice chunks from its
    // content allowing us to easily handle Files, Blobs, Buffers and Streams.
    this._source = null;

    // The current count of attempts which have been made. Null indicates none.
    this._retryAttempt = 0;

    // The timeout's ID which is used to delay the next retry
    this._retryTimeout = null;

    // The offset of the remote upload before the latest attempt was started.
    this._offsetBeforeRetry = 0;
  }

  _createClass(Upload, [{
    key: "start",
    value: function start() {
      var _this = this;

      var file = this.file;

      if (!file) {
        this._emitError(new Error("tus: no file or stream to upload provided"));
        return;
      }

      if (!this.options.endpoint && !this.options.uploadUrl) {
        this._emitError(new Error("tus: neither an endpoint or an upload URL is provided"));
        return;
      }

      if (this.options.resume && this._storage == null) {
        this._storage = (0, _storage.getStorage)();
      }

      if (this._source) {
        this._start(this._source);
      } else {
        var fileReader = this.options.fileReader || _source.getSource;
        fileReader(file, this.options.chunkSize, function (err, source) {
          if (err) {
            _this._emitError(err);
            return;
          }

          _this._source = source;
          _this._start(source);
        });
      }
    }
  }, {
    key: "_start",
    value: function _start(source) {
      var _this2 = this;

      var file = this.file;

      // First, we look at the uploadLengthDeferred option.
      // Next, we check if the caller has supplied a manual upload size.
      // Finally, we try to use the calculated size from the source object.
      if (this.options.uploadLengthDeferred) {
        this._size = null;
      } else if (this.options.uploadSize != null) {
        this._size = +this.options.uploadSize;
        if (isNaN(this._size)) {
          this._emitError(new Error("tus: cannot convert `uploadSize` option into a number"));
          return;
        }
      } else {
        this._size = source.size;
        if (this._size == null) {
          this._emitError(new Error("tus: cannot automatically derive upload's size from input and must be specified manually using the `uploadSize` option"));
          return;
        }
      }

      var retryDelays = this.options.retryDelays;
      if (retryDelays != null) {
        if (Object.prototype.toString.call(retryDelays) !== "[object Array]") {
          this._emitError(new Error("tus: the `retryDelays` option must either be an array or null"));
          return;
        } else {
          var errorCallback = this.options.onError;
          this.options.onError = function (err) {
            // Restore the original error callback which may have been set.
            _this2.options.onError = errorCallback;

            // We will reset the attempt counter if
            // - we were already able to connect to the server (offset != null) and
            // - we were able to upload a small chunk of data to the server
            var shouldResetDelays = _this2._offset != null && _this2._offset > _this2._offsetBeforeRetry;
            if (shouldResetDelays) {
              _this2._retryAttempt = 0;
            }

            var isOnline = true;
            if (typeof window !== "undefined" && "navigator" in window && window.navigator.onLine === false) {
              isOnline = false;
            }

            // We only attempt a retry if
            // - we didn't exceed the maxium number of retries, yet, and
            // - this error was caused by a request or it's response and
            // - the error is server error (i.e. no a status 4xx or a 409 or 423) and
            // - the browser does not indicate that we are offline
            var status = err.originalRequest ? err.originalRequest.status : 0;
            var isServerError = !inStatusCategory(status, 400) || status === 409 || status === 423;
            var shouldRetry = _this2._retryAttempt < retryDelays.length && err.originalRequest != null && isServerError && isOnline;

            if (!shouldRetry) {
              _this2._emitError(err);
              return;
            }

            var delay = retryDelays[_this2._retryAttempt++];

            _this2._offsetBeforeRetry = _this2._offset;
            _this2.options.uploadUrl = _this2.url;

            _this2._retryTimeout = setTimeout(function () {
              _this2.start();
            }, delay);
          };
        }
      }

      // Reset the aborted flag when the upload is started or else the
      // _startUpload will stop before sending a request if the upload has been
      // aborted previously.
      this._aborted = false;

      // The upload had been started previously and we should reuse this URL.
      if (this.url != null) {
        this._resumeUpload();
        return;
      }

      // A URL has manually been specified, so we try to resume
      if (this.options.uploadUrl != null) {
        this.url = this.options.uploadUrl;
        this._resumeUpload();
        return;
      }

      // Try to find the endpoint for the file in the storage
      if (this._hasStorage()) {
        this.options.fingerprint(file, this.options, function (err, fingerprintValue) {
          if (err) {
            _this2._emitError(err);
            return;
          }

          _this2._fingerprint = fingerprintValue;
          _this2._storage.getItem(_this2._fingerprint, function (err, resumedUrl) {
            if (err) {
              _this2._emitError(err);
              return;
            }

            if (resumedUrl != null) {
              _this2.url = resumedUrl;
              _this2._resumeUpload();
            } else {
              _this2._createUpload();
            }
          });
        });
      } else {
        // An upload has not started for the file yet, so we start a new one
        this._createUpload();
      }
    }
  }, {
    key: "abort",
    value: function abort(shouldTerminate, cb) {
      var _this3 = this;

      if (this._xhr !== null) {
        this._xhr.abort();
        this._source.close();
      }
      this._aborted = true;

      if (this._retryTimeout != null) {
        clearTimeout(this._retryTimeout);
        this._retryTimeout = null;
      }

      cb = cb || function () {};
      if (shouldTerminate) {
        Upload.terminate(this.url, this.options, function (err, xhr) {
          if (err) {
            return cb(err, xhr);
          }

          _this3._hasStorage() ? _this3._storage.removeItem(_this3._fingerprint, cb) : cb();
        });
      } else {
        cb();
      }
    }
  }, {
    key: "_hasStorage",
    value: function _hasStorage() {
      return this.options.resume && this._storage;
    }
  }, {
    key: "_emitXhrError",
    value: function _emitXhrError(xhr, err, causingErr) {
      this._emitError(new _error2.default(err, causingErr, xhr));
    }
  }, {
    key: "_emitError",
    value: function _emitError(err) {
      if (typeof this.options.onError === "function") {
        this.options.onError(err);
      } else {
        throw err;
      }
    }
  }, {
    key: "_emitSuccess",
    value: function _emitSuccess() {
      if (typeof this.options.onSuccess === "function") {
        this.options.onSuccess();
      }
    }

    /**
     * Publishes notification when data has been sent to the server. This
     * data may not have been accepted by the server yet.
     * @param  {number} bytesSent  Number of bytes sent to the server.
     * @param  {number} bytesTotal Total number of bytes to be sent to the server.
     */

  }, {
    key: "_emitProgress",
    value: function _emitProgress(bytesSent, bytesTotal) {
      if (typeof this.options.onProgress === "function") {
        this.options.onProgress(bytesSent, bytesTotal);
      }
    }

    /**
     * Publishes notification when a chunk of data has been sent to the server
     * and accepted by the server.
     * @param  {number} chunkSize  Size of the chunk that was accepted by the
     *                             server.
     * @param  {number} bytesAccepted Total number of bytes that have been
     *                                accepted by the server.
     * @param  {number} bytesTotal Total number of bytes to be sent to the server.
     */

  }, {
    key: "_emitChunkComplete",
    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {
      if (typeof this.options.onChunkComplete === "function") {
        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);
      }
    }

    /**
     * Set the headers used in the request and the withCredentials property
     * as defined in the options
     *
     * @param {XMLHttpRequest} xhr
     */

  }, {
    key: "_setupXHR",
    value: function _setupXHR(xhr) {
      this._xhr = xhr;
      setupXHR(xhr, this.options);
    }

    /**
     * Create a new upload using the creation extension by sending a POST
     * request to the endpoint. After successful creation the file will be
     * uploaded
     *
     * @api private
     */

  }, {
    key: "_createUpload",
    value: function _createUpload() {
      var _this4 = this;

      if (!this.options.endpoint) {
        this._emitError(new Error("tus: unable to create upload because no endpoint is provided"));
        return;
      }

      var xhr = (0, _request.newRequest)();
      xhr.open("POST", this.options.endpoint, true);

      xhr.onload = function () {
        if (!inStatusCategory(xhr.status, 200)) {
          _this4._emitXhrError(xhr, new Error("tus: unexpected response while creating upload"));
          return;
        }

        var location = xhr.getResponseHeader("Location");
        if (location == null) {
          _this4._emitXhrError(xhr, new Error("tus: invalid or missing Location header"));
          return;
        }

        _this4.url = (0, _request.resolveUrl)(_this4.options.endpoint, location);

        if (_this4._size === 0) {
          // Nothing to upload and file was successfully created
          _this4._emitSuccess();
          _this4._source.close();
          return;
        }

        if (_this4._hasStorage()) {
          _this4._storage.setItem(_this4._fingerprint, _this4.url, function (err) {
            if (err) {
              _this4._emitError(err);
            }
          });
        }

        if (_this4.options.uploadDataDuringCreation) {
          _this4._handleUploadResponse(xhr);
        } else {
          _this4._offset = 0;
          _this4._startUpload();
        }
      };

      xhr.onerror = function (err) {
        _this4._emitXhrError(xhr, new Error("tus: failed to create upload"), err);
      };

      this._setupXHR(xhr);
      if (this.options.uploadLengthDeferred) {
        xhr.setRequestHeader("Upload-Defer-Length", 1);
      } else {
        xhr.setRequestHeader("Upload-Length", this._size);
      }

      // Add metadata if values have been added
      var metadata = encodeMetadata(this.options.metadata);
      if (metadata !== "") {
        xhr.setRequestHeader("Upload-Metadata", metadata);
      }

      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {
        this._offset = 0;
        this._addChunkToRequest(xhr);
      } else {
        xhr.send(null);
      }
    }

    /*
     * Try to resume an existing upload. First a HEAD request will be sent
     * to retrieve the offset. If the request fails a new upload will be
     * created. In the case of a successful response the file will be uploaded.
     *
     * @api private
     */

  }, {
    key: "_resumeUpload",
    value: function _resumeUpload() {
      var _this5 = this;

      var xhr = (0, _request.newRequest)();
      xhr.open("HEAD", this.url, true);

      xhr.onload = function () {
        if (!inStatusCategory(xhr.status, 200)) {
          if (_this5._hasStorage() && inStatusCategory(xhr.status, 400)) {
            // Remove stored fingerprint and corresponding endpoint,
            // on client errors since the file can not be found
            _this5._storage.removeItem(_this5._fingerprint, function (err) {
              if (err) {
                _this5._emitError(err);
              }
            });
          }

          // If the upload is locked (indicated by the 423 Locked status code), we
          // emit an error instead of directly starting a new upload. This way the
          // retry logic can catch the error and will retry the upload. An upload
          // is usually locked for a short period of time and will be available
          // afterwards.
          if (xhr.status === 423) {
            _this5._emitXhrError(xhr, new Error("tus: upload is currently locked; retry later"));
            return;
          }

          if (!_this5.options.endpoint) {
            // Don't attempt to create a new upload if no endpoint is provided.
            _this5._emitXhrError(xhr, new Error("tus: unable to resume upload (new upload cannot be created without an endpoint)"));
            return;
          }

          // Try to create a new upload
          _this5.url = null;
          _this5._createUpload();
          return;
        }

        var offset = parseInt(xhr.getResponseHeader("Upload-Offset"), 10);
        if (isNaN(offset)) {
          _this5._emitXhrError(xhr, new Error("tus: invalid or missing offset value"));
          return;
        }

        var length = parseInt(xhr.getResponseHeader("Upload-Length"), 10);
        if (isNaN(length) && !_this5.options.uploadLengthDeferred) {
          _this5._emitXhrError(xhr, new Error("tus: invalid or missing length value"));
          return;
        }

        // Upload has already been completed and we do not need to send additional
        // data to the server
        if (offset === length) {
          _this5._emitProgress(length, length);
          _this5._emitSuccess();
          return;
        }

        _this5._offset = offset;
        _this5._startUpload();
      };

      xhr.onerror = function (err) {
        _this5._emitXhrError(xhr, new Error("tus: failed to resume upload"), err);
      };

      this._setupXHR(xhr);
      xhr.send(null);
    }

    /**
     * Start uploading the file using PATCH requests. The file will be divided
     * into chunks as specified in the chunkSize option. During the upload
     * the onProgress event handler may be invoked multiple times.
     *
     * @api private
     */

  }, {
    key: "_startUpload",
    value: function _startUpload() {
      var _this6 = this;

      // If the upload has been aborted, we will not send the next PATCH request.
      // This is important if the abort method was called during a callback, such
      // as onChunkComplete or onProgress.
      if (this._aborted) {
        return;
      }

      var xhr = (0, _request.newRequest)();

      // Some browser and servers may not support the PATCH method. For those
      // cases, you can tell tus-js-client to use a POST request with the
      // X-HTTP-Method-Override header for simulating a PATCH request.
      if (this.options.overridePatchMethod) {
        xhr.open("POST", this.url, true);
        xhr.setRequestHeader("X-HTTP-Method-Override", "PATCH");
      } else {
        xhr.open("PATCH", this.url, true);
      }

      xhr.onload = function () {
        if (!inStatusCategory(xhr.status, 200)) {
          _this6._emitXhrError(xhr, new Error("tus: unexpected response while uploading chunk"));
          return;
        }

        _this6._handleUploadResponse(xhr);
      };

      xhr.onerror = function (err) {
        // Don't emit an error if the upload was aborted manually
        if (_this6._aborted) {
          return;
        }

        _this6._emitXhrError(xhr, new Error("tus: failed to upload chunk at offset " + _this6._offset), err);
      };

      this._setupXHR(xhr);

      xhr.setRequestHeader("Upload-Offset", this._offset);
      this._addChunkToRequest(xhr);
    }

    /**
     * _addChunktoRequest reads a chunk from the source and sends it using the
     * supplied XHR object. It will not handle the response.
     */

  }, {
    key: "_addChunkToRequest",
    value: function _addChunkToRequest(xhr) {
      var _this7 = this;

      // Test support for progress events before attaching an event listener
      if ("upload" in xhr) {
        xhr.upload.onprogress = function (e) {
          if (!e.lengthComputable) {
            return;
          }

          _this7._emitProgress(start + e.loaded, _this7._size);
        };
      }

      xhr.setRequestHeader("Content-Type", "application/offset+octet-stream");

      var start = this._offset;
      var end = this._offset + this.options.chunkSize;

      // The specified chunkSize may be Infinity or the calcluated end position
      // may exceed the file's size. In both cases, we limit the end position to
      // the input's total size for simpler calculations and correctness.
      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {
        end = this._size;
      }

      this._source.slice(start, end, function (err, value, complete) {
        if (err) {
          _this7._emitError(err);
          return;
        }

        if (_this7.options.uploadLengthDeferred) {
          if (complete) {
            _this7._size = _this7._offset + (value && value.size ? value.size : 0);
            xhr.setRequestHeader("Upload-Length", _this7._size);
          }
        }

        if (value === null) {
          xhr.send();
        } else {
          xhr.send(value);
          _this7._emitProgress(_this7._offset, _this7._size);
        }
      });
    }

    /**
     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest
     * and already have received a response.
     */

  }, {
    key: "_handleUploadResponse",
    value: function _handleUploadResponse(xhr) {
      var _this8 = this;

      var offset = parseInt(xhr.getResponseHeader("Upload-Offset"), 10);
      if (isNaN(offset)) {
        this._emitXhrError(xhr, new Error("tus: invalid or missing offset value"));
        return;
      }

      this._emitProgress(offset, this._size);
      this._emitChunkComplete(offset - this._offset, offset, this._size);

      this._offset = offset;

      if (offset == this._size) {
        if (this.options.removeFingerprintOnSuccess && this.options.resume) {
          // Remove stored fingerprint and corresponding endpoint. This causes
          // new upload of the same file must be treated as a different file.
          this._storage.removeItem(this._fingerprint, function (err) {
            if (err) {
              _this8._emitError(err);
            }
          });
        }

        // Yay, finally done :)
        this._emitSuccess();
        this._source.close();
        return;
      }

      this._startUpload();
    }
  }], [{
    key: "terminate",
    value: function terminate(url, options, cb) {
      if (typeof options !== "function" && typeof cb !== "function") {
        throw new Error("tus: a callback function must be specified");
      }

      if (typeof options === "function") {
        cb = options;
        options = {};
      }

      var xhr = (0, _request.newRequest)();
      xhr.open("DELETE", url, true);

      xhr.onload = function () {
        if (xhr.status !== 204) {
          cb(new _error2.default(new Error("tus: unexpected response while terminating upload"), null, xhr));
          return;
        }

        cb();
      };

      xhr.onerror = function (err) {
        cb(new _error2.default(err, new Error("tus: failed to terminate upload"), xhr));
      };

      setupXHR(xhr, options);
      xhr.send(null);
    }
  }]);

  return Upload;
}();

function encodeMetadata(metadata) {
  var encoded = [];

  for (var key in metadata) {
    encoded.push(key + " " + _jsBase.Base64.encode(metadata[key]));
  }

  return encoded.join(",");
}

/**
 * Checks whether a given status is in the range of the expected category.
 * For example, only a status between 200 and 299 will satisfy the category 200.
 *
 * @api private
 */
function inStatusCategory(status, category) {
  return status >= category && status < category + 100;
}

function setupXHR(xhr, options) {
  xhr.setRequestHeader("Tus-Resumable", "1.0.0");
  var headers = options.headers || {};

  for (var name in headers) {
    xhr.setRequestHeader(name, headers[name]);
  }

  xhr.withCredentials = options.withCredentials;
}

Upload.defaultOptions = defaultOptions;

exports.default = Upload;
},{"./error":30,"./node/fingerprint":22,"./node/request":26,"./node/source":27,"./node/storage":28,"extend":8,"js-base64":10}],33:[function(require,module,exports){
(function (global){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
  , left = new RegExp('^'+ whitespace +'+');

/**
 * Trim a given string.
 *
 * @param {String} str String to trim.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(left, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof global !== 'undefined') globalVar = global;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  address = trimLeft(address);
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":19,"requires-port":20}],34:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.WHATWGFetch = {})));
}(this, (function (exports) { 'use strict';

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],35:[function(require,module,exports){
/* jshint node: true */
'use strict';

/**
  # wildcard

  Very simple wildcard matching, which is designed to provide the same
  functionality that is found in the
  [eve](https://github.com/adobe-webplatform/eve) eventing library.

  ## Usage

  It works with strings:

  <<< examples/strings.js

  Arrays:

  <<< examples/arrays.js

  Objects (matching against keys):

  <<< examples/objects.js

  While the library works in Node, if you are are looking for file-based
  wildcard matching then you should have a look at:

  <https://github.com/isaacs/node-glob>
**/

function WildcardMatcher(text, separator) {
  this.text = text = text || '';
  this.hasWild = ~text.indexOf('*');
  this.separator = separator;
  this.parts = text.split(separator);
}

WildcardMatcher.prototype.match = function(input) {
  var matches = true;
  var parts = this.parts;
  var ii;
  var partsCount = parts.length;
  var testParts;

  if (typeof input == 'string' || input instanceof String) {
    if (!this.hasWild && this.text != input) {
      matches = false;
    } else {
      testParts = (input || '').split(this.separator);
      for (ii = 0; matches && ii < partsCount; ii++) {
        if (parts[ii] === '*')  {
          continue;
        } else if (ii < testParts.length) {
          matches = parts[ii] === testParts[ii];
        } else {
          matches = false;
        }
      }

      // If matches, then return the component parts
      matches = matches && testParts;
    }
  }
  else if (typeof input.splice == 'function') {
    matches = [];

    for (ii = input.length; ii--; ) {
      if (this.match(input[ii])) {
        matches[matches.length] = input[ii];
      }
    }
  }
  else if (typeof input == 'object') {
    matches = {};

    for (var key in input) {
      if (this.match(key)) {
        matches[key] = input[key];
      }
    }
  }

  return matches;
};

module.exports = function(text, test, separator) {
  var matcher = new WildcardMatcher(text, separator || /[\/\.]/);
  if (typeof test != 'undefined') {
    return matcher.match(test);
  }

  return matcher;
};

},{}],36:[function(require,module,exports){
module.exports={
  "name": "@uppy/companion-client",
  "description": "Client library for communication with Companion. Intended for use in Uppy plugins.",
  "version": "1.4.1",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "companion",
    "provider"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "namespace-emitter": "^2.0.1"
  }
}

},{}],37:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var AuthError =
/*#__PURE__*/
function (_Error) {
  _inheritsLoose(AuthError, _Error);

  function AuthError() {
    var _this;

    _this = _Error.call(this, 'Authorization required') || this;
    _this.name = 'AuthError';
    _this.isAuthError = true;
    return _this;
  }

  return AuthError;
}(_wrapNativeSuper(Error));

module.exports = AuthError;

},{}],38:[function(require,module,exports){
'use strict';

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var RequestClient = require('./RequestClient');

var tokenStorage = require('./tokenStorage');

var _getName = function _getName(id) {
  return id.split('-').map(function (s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }).join(' ');
};

module.exports =
/*#__PURE__*/
function (_RequestClient) {
  _inheritsLoose(Provider, _RequestClient);

  function Provider(uppy, opts) {
    var _this;

    _this = _RequestClient.call(this, uppy, opts) || this;
    _this.provider = opts.provider;
    _this.id = _this.provider;
    _this.authProvider = opts.authProvider || _this.provider;
    _this.name = _this.opts.name || _getName(_this.id);
    _this.pluginId = _this.opts.pluginId;
    _this.tokenKey = "companion-" + _this.pluginId + "-auth-token";
    return _this;
  }

  var _proto = Provider.prototype;

  _proto.headers = function headers() {
    var _this2 = this;

    return new Promise(function (resolve, reject) {
      _RequestClient.prototype.headers.call(_this2).then(function (headers) {
        _this2.getAuthToken().then(function (token) {
          resolve(_extends({}, headers, {
            'uppy-auth-token': token
          }));
        });
      }).catch(reject);
    });
  };

  _proto.onReceiveResponse = function onReceiveResponse(response) {
    response = _RequestClient.prototype.onReceiveResponse.call(this, response);
    var plugin = this.uppy.getPlugin(this.pluginId);
    var oldAuthenticated = plugin.getPluginState().authenticated;
    var authenticated = oldAuthenticated ? response.status !== 401 : response.status < 400;
    plugin.setPluginState({
      authenticated: authenticated
    });
    return response;
  } // @todo(i.olarewaju) consider whether or not this method should be exposed
  ;

  _proto.setAuthToken = function setAuthToken(token) {
    return this.uppy.getPlugin(this.pluginId).storage.setItem(this.tokenKey, token);
  };

  _proto.getAuthToken = function getAuthToken() {
    return this.uppy.getPlugin(this.pluginId).storage.getItem(this.tokenKey);
  };

  _proto.authUrl = function authUrl() {
    return this.hostname + "/" + this.id + "/connect";
  };

  _proto.fileUrl = function fileUrl(id) {
    return this.hostname + "/" + this.id + "/get/" + id;
  };

  _proto.list = function list(directory) {
    return this.get(this.id + "/list/" + (directory || ''));
  };

  _proto.logout = function logout() {
    var _this3 = this;

    return new Promise(function (resolve, reject) {
      _this3.get(_this3.id + "/logout").then(function (res) {
        _this3.uppy.getPlugin(_this3.pluginId).storage.removeItem(_this3.tokenKey).then(function () {
          return resolve(res);
        }).catch(reject);
      }).catch(reject);
    });
  };

  Provider.initPlugin = function initPlugin(plugin, opts, defaultOpts) {
    plugin.type = 'acquirer';
    plugin.files = [];

    if (defaultOpts) {
      plugin.opts = _extends({}, defaultOpts, opts);
    }

    if (opts.serverUrl || opts.serverPattern) {
      throw new Error('`serverUrl` and `serverPattern` have been renamed to `companionUrl` and `companionAllowedHosts` respectively in the 0.30.5 release. Please consult the docs (for example, https://uppy.io/docs/instagram/ for the Instagram plugin) and use the updated options.`');
    }

    if (opts.companionAllowedHosts) {
      var pattern = opts.companionAllowedHosts; // validate companionAllowedHosts param

      if (typeof pattern !== 'string' && !Array.isArray(pattern) && !(pattern instanceof RegExp)) {
        throw new TypeError(plugin.id + ": the option \"companionAllowedHosts\" must be one of string, Array, RegExp");
      }

      plugin.opts.companionAllowedHosts = pattern;
    } else {
      // does not start with https://
      if (/^(?!https?:\/\/).*$/i.test(opts.companionUrl)) {
        plugin.opts.companionAllowedHosts = "https://" + opts.companionUrl.replace(/^\/\//, '');
      } else {
        plugin.opts.companionAllowedHosts = opts.companionUrl;
      }
    }

    plugin.storage = plugin.opts.storage || tokenStorage;
  };

  return Provider;
}(RequestClient);

},{"./RequestClient":39,"./tokenStorage":42}],39:[function(require,module,exports){
'use strict';

var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var AuthError = require('./AuthError'); // Remove the trailing slash so we can always safely append /xyz.


function stripSlash(url) {
  return url.replace(/\/$/, '');
}

module.exports = (_temp = _class =
/*#__PURE__*/
function () {
  function RequestClient(uppy, opts) {
    this.uppy = uppy;
    this.opts = opts;
    this.onReceiveResponse = this.onReceiveResponse.bind(this);
    this.allowedHeaders = ['accept', 'content-type', 'uppy-auth-token'];
    this.preflightDone = false;
  }

  var _proto = RequestClient.prototype;

  _proto.headers = function headers() {
    var userHeaders = this.opts.companionHeaders || this.opts.serverHeaders || {};
    return Promise.resolve(_extends({}, this.defaultHeaders, {}, userHeaders));
  };

  _proto._getPostResponseFunc = function _getPostResponseFunc(skip) {
    var _this = this;

    return function (response) {
      if (!skip) {
        return _this.onReceiveResponse(response);
      }

      return response;
    };
  };

  _proto.onReceiveResponse = function onReceiveResponse(response) {
    var state = this.uppy.getState();
    var companion = state.companion || {};
    var host = this.opts.companionUrl;
    var headers = response.headers; // Store the self-identified domain name for the Companion instance we just hit.

    if (headers.has('i-am') && headers.get('i-am') !== companion[host]) {
      var _extends2;

      this.uppy.setState({
        companion: _extends({}, companion, (_extends2 = {}, _extends2[host] = headers.get('i-am'), _extends2))
      });
    }

    return response;
  };

  _proto._getUrl = function _getUrl(url) {
    if (/^(https?:|)\/\//.test(url)) {
      return url;
    }

    return this.hostname + "/" + url;
  };

  _proto._json = function _json(res) {
    if (res.status === 401) {
      throw new AuthError();
    }

    if (res.status < 200 || res.status > 300) {
      var errMsg = "Failed request with status: " + res.status + ". " + res.statusText;
      return res.json().then(function (errData) {
        errMsg = errData.message ? errMsg + " message: " + errData.message : errMsg;
        errMsg = errData.requestId ? errMsg + " request-Id: " + errData.requestId : errMsg;
        throw new Error(errMsg);
      }).catch(function () {
        throw new Error(errMsg);
      });
    }

    return res.json();
  };

  _proto.preflight = function preflight(path) {
    var _this2 = this;

    return new Promise(function (resolve, reject) {
      if (_this2.preflightDone) {
        return resolve(_this2.allowedHeaders.slice());
      }

      fetch(_this2._getUrl(path), {
        method: 'OPTIONS'
      }).then(function (response) {
        if (response.headers.has('access-control-allow-headers')) {
          _this2.allowedHeaders = response.headers.get('access-control-allow-headers').split(',').map(function (headerName) {
            return headerName.trim().toLowerCase();
          });
        }

        _this2.preflightDone = true;
        resolve(_this2.allowedHeaders.slice());
      }).catch(function (err) {
        _this2.uppy.log("[CompanionClient] unable to make preflight request " + err, 'warning');

        _this2.preflightDone = true;
        resolve(_this2.allowedHeaders.slice());
      });
    });
  };

  _proto.preflightAndHeaders = function preflightAndHeaders(path) {
    var _this3 = this;

    return Promise.all([this.preflight(path), this.headers()]).then(function (_ref) {
      var allowedHeaders = _ref[0],
          headers = _ref[1];
      // filter to keep only allowed Headers
      Object.keys(headers).forEach(function (header) {
        if (allowedHeaders.indexOf(header.toLowerCase()) === -1) {
          _this3.uppy.log("[CompanionClient] excluding unallowed header " + header);

          delete headers[header];
        }
      });
      return headers;
    });
  };

  _proto.get = function get(path, skipPostResponse) {
    var _this4 = this;

    return new Promise(function (resolve, reject) {
      _this4.preflightAndHeaders(path).then(function (headers) {
        fetch(_this4._getUrl(path), {
          method: 'get',
          headers: headers,
          credentials: 'same-origin'
        }).then(_this4._getPostResponseFunc(skipPostResponse)).then(function (res) {
          return _this4._json(res).then(resolve);
        }).catch(function (err) {
          err = err.isAuthError ? err : new Error("Could not get " + _this4._getUrl(path) + ". " + err);
          reject(err);
        });
      }).catch(reject);
    });
  };

  _proto.post = function post(path, data, skipPostResponse) {
    var _this5 = this;

    return new Promise(function (resolve, reject) {
      _this5.preflightAndHeaders(path).then(function (headers) {
        fetch(_this5._getUrl(path), {
          method: 'post',
          headers: headers,
          credentials: 'same-origin',
          body: JSON.stringify(data)
        }).then(_this5._getPostResponseFunc(skipPostResponse)).then(function (res) {
          return _this5._json(res).then(resolve);
        }).catch(function (err) {
          err = err.isAuthError ? err : new Error("Could not post " + _this5._getUrl(path) + ". " + err);
          reject(err);
        });
      }).catch(reject);
    });
  };

  _proto.delete = function _delete(path, data, skipPostResponse) {
    var _this6 = this;

    return new Promise(function (resolve, reject) {
      _this6.preflightAndHeaders(path).then(function (headers) {
        fetch(_this6.hostname + "/" + path, {
          method: 'delete',
          headers: headers,
          credentials: 'same-origin',
          body: data ? JSON.stringify(data) : null
        }).then(_this6._getPostResponseFunc(skipPostResponse)).then(function (res) {
          return _this6._json(res).then(resolve);
        }).catch(function (err) {
          err = err.isAuthError ? err : new Error("Could not delete " + _this6._getUrl(path) + ". " + err);
          reject(err);
        });
      }).catch(reject);
    });
  };

  _createClass(RequestClient, [{
    key: "hostname",
    get: function get() {
      var _this$uppy$getState = this.uppy.getState(),
          companion = _this$uppy$getState.companion;

      var host = this.opts.companionUrl;
      return stripSlash(companion && companion[host] ? companion[host] : host);
    }
  }, {
    key: "defaultHeaders",
    get: function get() {
      return {
        Accept: 'application/json',
        'Content-Type': 'application/json',
        'Uppy-Versions': "@uppy/companion-client=" + RequestClient.VERSION
      };
    }
  }]);

  return RequestClient;
}(), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":36,"./AuthError":37}],40:[function(require,module,exports){
var ee = require('namespace-emitter');

module.exports =
/*#__PURE__*/
function () {
  function UppySocket(opts) {
    this.opts = opts;
    this._queued = [];
    this.isOpen = false;
    this.emitter = ee();
    this._handleMessage = this._handleMessage.bind(this);
    this.close = this.close.bind(this);
    this.emit = this.emit.bind(this);
    this.on = this.on.bind(this);
    this.once = this.once.bind(this);
    this.send = this.send.bind(this);

    if (!opts || opts.autoOpen !== false) {
      this.open();
    }
  }

  var _proto = UppySocket.prototype;

  _proto.open = function open() {
    var _this = this;

    this.socket = new WebSocket(this.opts.target);

    this.socket.onopen = function (e) {
      _this.isOpen = true;

      while (_this._queued.length > 0 && _this.isOpen) {
        var first = _this._queued[0];

        _this.send(first.action, first.payload);

        _this._queued = _this._queued.slice(1);
      }
    };

    this.socket.onclose = function (e) {
      _this.isOpen = false;
    };

    this.socket.onmessage = this._handleMessage;
  };

  _proto.close = function close() {
    if (this.socket) {
      this.socket.close();
    }
  };

  _proto.send = function send(action, payload) {
    // attach uuid
    if (!this.isOpen) {
      this._queued.push({
        action: action,
        payload: payload
      });

      return;
    }

    this.socket.send(JSON.stringify({
      action: action,
      payload: payload
    }));
  };

  _proto.on = function on(action, handler) {
    this.emitter.on(action, handler);
  };

  _proto.emit = function emit(action, payload) {
    this.emitter.emit(action, payload);
  };

  _proto.once = function once(action, handler) {
    this.emitter.once(action, handler);
  };

  _proto._handleMessage = function _handleMessage(e) {
    try {
      var message = JSON.parse(e.data);
      this.emit(message.action, message.payload);
    } catch (err) {
      console.log(err);
    }
  };

  return UppySocket;
}();

},{"namespace-emitter":15}],41:[function(require,module,exports){
'use strict';
/**
 * Manages communications with Companion
 */

var RequestClient = require('./RequestClient');

var Provider = require('./Provider');

var Socket = require('./Socket');

module.exports = {
  RequestClient: RequestClient,
  Provider: Provider,
  Socket: Socket
};

},{"./Provider":38,"./RequestClient":39,"./Socket":40}],42:[function(require,module,exports){
'use strict';
/**
 * This module serves as an Async wrapper for LocalStorage
 */

module.exports.setItem = function (key, value) {
  return new Promise(function (resolve) {
    localStorage.setItem(key, value);
    resolve();
  });
};

module.exports.getItem = function (key) {
  return Promise.resolve(localStorage.getItem(key));
};

module.exports.removeItem = function (key) {
  return new Promise(function (resolve) {
    localStorage.removeItem(key);
    resolve();
  });
};

},{}],43:[function(require,module,exports){
module.exports={
  "name": "@uppy/core",
  "description": "Core module for the extensible JavaScript file upload widget with support for drag&drop, resumable uploads, previews, restrictions, file processing/encoding, remote providers like Instagram, Dropbox, Google Drive, S3 and more :dog:",
  "version": "1.7.1",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/store-default": "file:../store-default",
    "@uppy/utils": "file:../utils",
    "cuid": "^2.1.1",
    "lodash.throttle": "^4.1.1",
    "mime-match": "^1.0.2",
    "namespace-emitter": "^2.0.1",
    "preact": "8.2.9"
  }
}

},{}],44:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var preact = require('preact');

var findDOMElement = require('./../../utils/lib/findDOMElement');
/**
 * Defer a frequent call to the microtask queue.
 */


function debounce(fn) {
  var calling = null;
  var latestArgs = null;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    latestArgs = args;

    if (!calling) {
      calling = Promise.resolve().then(function () {
        calling = null; // At this point `args` may be different from the most
        // recent state, if multiple calls happened since this task
        // was queued. So we use the `latestArgs`, which definitely
        // is the most recent call.

        return fn.apply(void 0, latestArgs);
      });
    }

    return calling;
  };
}
/**
 * Boilerplate that all Plugins share - and should not be used
 * directly. It also shows which methods final plugins should implement/override,
 * this deciding on structure.
 *
 * @param {object} main Uppy core object
 * @param {object} object with plugin options
 * @returns {Array|string} files or success/fail message
 */


module.exports =
/*#__PURE__*/
function () {
  function Plugin(uppy, opts) {
    this.uppy = uppy;
    this.opts = opts || {};
    this.update = this.update.bind(this);
    this.mount = this.mount.bind(this);
    this.install = this.install.bind(this);
    this.uninstall = this.uninstall.bind(this);
  }

  var _proto = Plugin.prototype;

  _proto.getPluginState = function getPluginState() {
    var _this$uppy$getState = this.uppy.getState(),
        plugins = _this$uppy$getState.plugins;

    return plugins[this.id] || {};
  };

  _proto.setPluginState = function setPluginState(update) {
    var _extends2;

    var _this$uppy$getState2 = this.uppy.getState(),
        plugins = _this$uppy$getState2.plugins;

    this.uppy.setState({
      plugins: _extends({}, plugins, (_extends2 = {}, _extends2[this.id] = _extends({}, plugins[this.id], {}, update), _extends2))
    });
  };

  _proto.setOptions = function setOptions(newOpts) {
    this.opts = _extends({}, this.opts, {}, newOpts);
    this.setPluginState(); // so that UI re-renders with new options
  };

  _proto.update = function update(state) {
    if (typeof this.el === 'undefined') {
      return;
    }

    if (this._updateUI) {
      this._updateUI(state);
    }
  } // Called after every state update, after everything's mounted. Debounced.
  ;

  _proto.afterUpdate = function afterUpdate() {}
  /**
   * Called when plugin is mounted, whether in DOM or into another plugin.
   * Needed because sometimes plugins are mounted separately/after `install`,
   * so this.el and this.parent might not be available in `install`.
   * This is the case with @uppy/react plugins, for example.
   */
  ;

  _proto.onMount = function onMount() {}
  /**
   * Check if supplied `target` is a DOM element or an `object`.
   * If it’s an object — target is a plugin, and we search `plugins`
   * for a plugin with same name and return its target.
   *
   * @param {string|object} target
   *
   */
  ;

  _proto.mount = function mount(target, plugin) {
    var _this = this;

    var callerPluginName = plugin.id;
    var targetElement = findDOMElement(target);

    if (targetElement) {
      this.isTargetDOMEl = true; // API for plugins that require a synchronous rerender.

      this.rerender = function (state) {
        // plugin could be removed, but this.rerender is debounced below,
        // so it could still be called even after uppy.removePlugin or uppy.close
        // hence the check
        if (!_this.uppy.getPlugin(_this.id)) return;
        _this.el = preact.render(_this.render(state), targetElement, _this.el);

        _this.afterUpdate();
      };

      this._updateUI = debounce(this.rerender);
      this.uppy.log("Installing " + callerPluginName + " to a DOM element '" + target + "'"); // clear everything inside the target container

      if (this.opts.replaceTargetContent) {
        targetElement.innerHTML = '';
      }

      this.el = preact.render(this.render(this.uppy.getState()), targetElement);
      this.onMount();
      return this.el;
    }

    var targetPlugin;

    if (typeof target === 'object' && target instanceof Plugin) {
      // Targeting a plugin *instance*
      targetPlugin = target;
    } else if (typeof target === 'function') {
      // Targeting a plugin type
      var Target = target; // Find the target plugin instance.

      this.uppy.iteratePlugins(function (plugin) {
        if (plugin instanceof Target) {
          targetPlugin = plugin;
          return false;
        }
      });
    }

    if (targetPlugin) {
      this.uppy.log("Installing " + callerPluginName + " to " + targetPlugin.id);
      this.parent = targetPlugin;
      this.el = targetPlugin.addTarget(plugin);
      this.onMount();
      return this.el;
    }

    this.uppy.log("Not installing " + callerPluginName);
    throw new Error("Invalid target option given to " + callerPluginName + ". Please make sure that the element\n      exists on the page, or that the plugin you are targeting has been installed. Check that the <script> tag initializing Uppy\n      comes at the bottom of the page, before the closing </body> tag (see https://github.com/transloadit/uppy/issues/1042).");
  };

  _proto.render = function render(state) {
    throw new Error('Extend the render method to add your plugin to a DOM element');
  };

  _proto.addTarget = function addTarget(plugin) {
    throw new Error('Extend the addTarget method to add your plugin to another plugin\'s target');
  };

  _proto.unmount = function unmount() {
    if (this.isTargetDOMEl && this.el && this.el.parentNode) {
      this.el.parentNode.removeChild(this.el);
    }
  };

  _proto.install = function install() {};

  _proto.uninstall = function uninstall() {
    this.unmount();
  };

  return Plugin;
}();

},{"./../../utils/lib/findDOMElement":123,"preact":17}],45:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var Translator = require('./../../utils/lib/Translator');

var ee = require('namespace-emitter');

var cuid = require('cuid');

var throttle = require('lodash.throttle');

var prettyBytes = require('./../../utils/lib/prettyBytes');

var match = require('mime-match');

var DefaultStore = require('./../../store-default');

var getFileType = require('./../../utils/lib/getFileType');

var getFileNameAndExtension = require('./../../utils/lib/getFileNameAndExtension');

var generateFileID = require('./../../utils/lib/generateFileID');

var supportsUploadProgress = require('./supportsUploadProgress');

var _require = require('./loggers'),
    nullLogger = _require.nullLogger,
    debugLogger = _require.debugLogger;

var Plugin = require('./Plugin'); // Exported from here.


var RestrictionError =
/*#__PURE__*/
function (_Error) {
  _inheritsLoose(RestrictionError, _Error);

  function RestrictionError() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Error.call.apply(_Error, [this].concat(args)) || this;
    _this.isRestriction = true;
    return _this;
  }

  return RestrictionError;
}(_wrapNativeSuper(Error));
/**
 * Uppy Core module.
 * Manages plugins, state updates, acts as an event bus,
 * adds/removes files and metadata.
 */


var Uppy =
/*#__PURE__*/
function () {
  /**
   * Instantiate Uppy
   *
   * @param {object} opts — Uppy options
   */
  function Uppy(opts) {
    var _this2 = this;

    this.defaultLocale = {
      strings: {
        addBulkFilesFailed: {
          0: 'Failed to add %{smart_count} file due to an internal error',
          1: 'Failed to add %{smart_count} files due to internal errors'
        },
        youCanOnlyUploadX: {
          0: 'You can only upload %{smart_count} file',
          1: 'You can only upload %{smart_count} files',
          2: 'You can only upload %{smart_count} files'
        },
        youHaveToAtLeastSelectX: {
          0: 'You have to select at least %{smart_count} file',
          1: 'You have to select at least %{smart_count} files',
          2: 'You have to select at least %{smart_count} files'
        },
        exceedsSize: 'This file exceeds maximum allowed size of',
        youCanOnlyUploadFileTypes: 'You can only upload: %{types}',
        companionError: 'Connection with Companion failed',
        companionAuthError: 'Authorization required',
        companionUnauthorizeHint: 'To unauthorize to your %{provider} account, please go to %{url}',
        failedToUpload: 'Failed to upload %{file}',
        noInternetConnection: 'No Internet connection',
        connectedToInternet: 'Connected to the Internet',
        // Strings for remote providers
        noFilesFound: 'You have no files or folders here',
        selectX: {
          0: 'Select %{smart_count}',
          1: 'Select %{smart_count}',
          2: 'Select %{smart_count}'
        },
        selectAllFilesFromFolderNamed: 'Select all files from folder %{name}',
        unselectAllFilesFromFolderNamed: 'Unselect all files from folder %{name}',
        selectFileNamed: 'Select file %{name}',
        unselectFileNamed: 'Unselect file %{name}',
        openFolderNamed: 'Open folder %{name}',
        cancel: 'Cancel',
        logOut: 'Log out',
        filter: 'Filter',
        resetFilter: 'Reset filter',
        loading: 'Loading...',
        authenticateWithTitle: 'Please authenticate with %{pluginName} to select files',
        authenticateWith: 'Connect to %{pluginName}',
        emptyFolderAdded: 'No files were added from empty folder',
        folderAdded: {
          0: 'Added %{smart_count} file from %{folder}',
          1: 'Added %{smart_count} files from %{folder}',
          2: 'Added %{smart_count} files from %{folder}'
        }
      }
    };
    var defaultOptions = {
      id: 'uppy',
      autoProceed: false,
      allowMultipleUploads: true,
      debug: false,
      restrictions: {
        maxFileSize: null,
        maxNumberOfFiles: null,
        minNumberOfFiles: null,
        allowedFileTypes: null
      },
      meta: {},
      onBeforeFileAdded: function onBeforeFileAdded(currentFile, files) {
        return currentFile;
      },
      onBeforeUpload: function onBeforeUpload(files) {
        return files;
      },
      store: DefaultStore(),
      logger: nullLogger
    }; // Merge default options with the ones set by user,
    // making sure to merge restrictions too

    this.opts = _extends({}, defaultOptions, {}, opts, {
      restrictions: _extends({}, defaultOptions.restrictions, {}, opts && opts.restrictions)
    }); // Support debug: true for backwards-compatability, unless logger is set in opts
    // opts instead of this.opts to avoid comparing objects — we set logger: nullLogger in defaultOptions

    if (opts && opts.logger && opts.debug) {
      this.log('You are using a custom `logger`, but also set `debug: true`, which uses built-in logger to output logs to console. Ignoring `debug: true` and using your custom `logger`.', 'warning');
    } else if (opts && opts.debug) {
      this.opts.logger = debugLogger;
    }

    this.log("Using Core v" + this.constructor.VERSION);

    if (this.opts.restrictions.allowedFileTypes && this.opts.restrictions.allowedFileTypes !== null && !Array.isArray(this.opts.restrictions.allowedFileTypes)) {
      throw new TypeError('`restrictions.allowedFileTypes` must be an array');
    }

    this.i18nInit(); // Container for different types of plugins

    this.plugins = {};
    this.getState = this.getState.bind(this);
    this.getPlugin = this.getPlugin.bind(this);
    this.setFileMeta = this.setFileMeta.bind(this);
    this.setFileState = this.setFileState.bind(this);
    this.log = this.log.bind(this);
    this.info = this.info.bind(this);
    this.hideInfo = this.hideInfo.bind(this);
    this.addFile = this.addFile.bind(this);
    this.removeFile = this.removeFile.bind(this);
    this.pauseResume = this.pauseResume.bind(this); // ___Why throttle at 500ms?
    //    - We must throttle at >250ms for superfocus in Dashboard to work well (because animation takes 0.25s, and we want to wait for all animations to be over before refocusing).
    //    [Practical Check]: if thottle is at 100ms, then if you are uploading a file, and click 'ADD MORE FILES', - focus won't activate in Firefox.
    //    - We must throttle at around >500ms to avoid performance lags.
    //    [Practical Check] Firefox, try to upload a big file for a prolonged period of time. Laptop will start to heat up.

    this._calculateProgress = throttle(this._calculateProgress.bind(this), 500, {
      leading: true,
      trailing: true
    });
    this.updateOnlineStatus = this.updateOnlineStatus.bind(this);
    this.resetProgress = this.resetProgress.bind(this);
    this.pauseAll = this.pauseAll.bind(this);
    this.resumeAll = this.resumeAll.bind(this);
    this.retryAll = this.retryAll.bind(this);
    this.cancelAll = this.cancelAll.bind(this);
    this.retryUpload = this.retryUpload.bind(this);
    this.upload = this.upload.bind(this);
    this.emitter = ee();
    this.on = this.on.bind(this);
    this.off = this.off.bind(this);
    this.once = this.emitter.once.bind(this.emitter);
    this.emit = this.emitter.emit.bind(this.emitter);
    this.preProcessors = [];
    this.uploaders = [];
    this.postProcessors = [];
    this.store = this.opts.store;
    this.setState({
      plugins: {},
      files: {},
      currentUploads: {},
      allowNewUpload: true,
      capabilities: {
        uploadProgress: supportsUploadProgress(),
        individualCancellation: true,
        resumableUploads: false
      },
      totalProgress: 0,
      meta: _extends({}, this.opts.meta),
      info: {
        isHidden: true,
        type: 'info',
        message: ''
      }
    });
    this._storeUnsubscribe = this.store.subscribe(function (prevState, nextState, patch) {
      _this2.emit('state-update', prevState, nextState, patch);

      _this2.updateAll(nextState);
    }); // Exposing uppy object on window for debugging and testing

    if (this.opts.debug && typeof window !== 'undefined') {
      window[this.opts.id] = this;
    }

    this._addListeners();
  }

  var _proto = Uppy.prototype;

  _proto.on = function on(event, callback) {
    this.emitter.on(event, callback);
    return this;
  };

  _proto.off = function off(event, callback) {
    this.emitter.off(event, callback);
    return this;
  }
  /**
   * Iterate on all plugins and run `update` on them.
   * Called each time state changes.
   *
   */
  ;

  _proto.updateAll = function updateAll(state) {
    this.iteratePlugins(function (plugin) {
      plugin.update(state);
    });
  }
  /**
   * Updates state with a patch
   *
   * @param {object} patch {foo: 'bar'}
   */
  ;

  _proto.setState = function setState(patch) {
    this.store.setState(patch);
  }
  /**
   * Returns current state.
   *
   * @returns {object}
   */
  ;

  _proto.getState = function getState() {
    return this.store.getState();
  }
  /**
   * Back compat for when uppy.state is used instead of uppy.getState().
   */
  ;

  /**
   * Shorthand to set state for a specific file.
   */
  _proto.setFileState = function setFileState(fileID, state) {
    var _extends2;

    if (!this.getState().files[fileID]) {
      throw new Error("Can\u2019t set state for " + fileID + " (the file could have been removed)");
    }

    this.setState({
      files: _extends({}, this.getState().files, (_extends2 = {}, _extends2[fileID] = _extends({}, this.getState().files[fileID], state), _extends2))
    });
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.opts.locale]);
    this.locale = this.translator.locale;
    this.i18n = this.translator.translate.bind(this.translator);
    this.i18nArray = this.translator.translateArray.bind(this.translator);
  };

  _proto.setOptions = function setOptions(newOpts) {
    this.opts = _extends({}, this.opts, {}, newOpts, {
      restrictions: _extends({}, this.opts.restrictions, {}, newOpts && newOpts.restrictions)
    });

    if (newOpts.meta) {
      this.setMeta(newOpts.meta);
    }

    this.i18nInit();

    if (newOpts.locale) {
      this.iteratePlugins(function (plugin) {
        plugin.setOptions();
      });
    }

    this.setState(); // so that UI re-renders with new options
  };

  _proto.resetProgress = function resetProgress() {
    var defaultProgress = {
      percentage: 0,
      bytesUploaded: 0,
      uploadComplete: false,
      uploadStarted: null
    };

    var files = _extends({}, this.getState().files);

    var updatedFiles = {};
    Object.keys(files).forEach(function (fileID) {
      var updatedFile = _extends({}, files[fileID]);

      updatedFile.progress = _extends({}, updatedFile.progress, defaultProgress);
      updatedFiles[fileID] = updatedFile;
    });
    this.setState({
      files: updatedFiles,
      totalProgress: 0
    });
    this.emit('reset-progress');
  };

  _proto.addPreProcessor = function addPreProcessor(fn) {
    this.preProcessors.push(fn);
  };

  _proto.removePreProcessor = function removePreProcessor(fn) {
    var i = this.preProcessors.indexOf(fn);

    if (i !== -1) {
      this.preProcessors.splice(i, 1);
    }
  };

  _proto.addPostProcessor = function addPostProcessor(fn) {
    this.postProcessors.push(fn);
  };

  _proto.removePostProcessor = function removePostProcessor(fn) {
    var i = this.postProcessors.indexOf(fn);

    if (i !== -1) {
      this.postProcessors.splice(i, 1);
    }
  };

  _proto.addUploader = function addUploader(fn) {
    this.uploaders.push(fn);
  };

  _proto.removeUploader = function removeUploader(fn) {
    var i = this.uploaders.indexOf(fn);

    if (i !== -1) {
      this.uploaders.splice(i, 1);
    }
  };

  _proto.setMeta = function setMeta(data) {
    var updatedMeta = _extends({}, this.getState().meta, data);

    var updatedFiles = _extends({}, this.getState().files);

    Object.keys(updatedFiles).forEach(function (fileID) {
      updatedFiles[fileID] = _extends({}, updatedFiles[fileID], {
        meta: _extends({}, updatedFiles[fileID].meta, data)
      });
    });
    this.log('Adding metadata:');
    this.log(data);
    this.setState({
      meta: updatedMeta,
      files: updatedFiles
    });
  };

  _proto.setFileMeta = function setFileMeta(fileID, data) {
    var updatedFiles = _extends({}, this.getState().files);

    if (!updatedFiles[fileID]) {
      this.log('Was trying to set metadata for a file that has been removed: ', fileID);
      return;
    }

    var newMeta = _extends({}, updatedFiles[fileID].meta, data);

    updatedFiles[fileID] = _extends({}, updatedFiles[fileID], {
      meta: newMeta
    });
    this.setState({
      files: updatedFiles
    });
  }
  /**
   * Get a file object.
   *
   * @param {string} fileID The ID of the file object to return.
   */
  ;

  _proto.getFile = function getFile(fileID) {
    return this.getState().files[fileID];
  }
  /**
   * Get all files in an array.
   */
  ;

  _proto.getFiles = function getFiles() {
    var _this$getState = this.getState(),
        files = _this$getState.files;

    return Object.keys(files).map(function (fileID) {
      return files[fileID];
    });
  }
  /**
   * Check if minNumberOfFiles restriction is reached before uploading.
   *
   * @private
   */
  ;

  _proto._checkMinNumberOfFiles = function _checkMinNumberOfFiles(files) {
    var minNumberOfFiles = this.opts.restrictions.minNumberOfFiles;

    if (Object.keys(files).length < minNumberOfFiles) {
      throw new RestrictionError("" + this.i18n('youHaveToAtLeastSelectX', {
        smart_count: minNumberOfFiles
      }));
    }
  }
  /**
   * Check if file passes a set of restrictions set in options: maxFileSize,
   * maxNumberOfFiles and allowedFileTypes.
   *
   * @param {object} files Object of IDs → files already added
   * @param {object} file object to check
   * @private
   */
  ;

  _proto._checkRestrictions = function _checkRestrictions(files, file) {
    var _this$opts$restrictio = this.opts.restrictions,
        maxFileSize = _this$opts$restrictio.maxFileSize,
        maxNumberOfFiles = _this$opts$restrictio.maxNumberOfFiles,
        allowedFileTypes = _this$opts$restrictio.allowedFileTypes;

    if (maxNumberOfFiles) {
      if (Object.keys(files).length + 1 > maxNumberOfFiles) {
        throw new RestrictionError("" + this.i18n('youCanOnlyUploadX', {
          smart_count: maxNumberOfFiles
        }));
      }
    }

    if (allowedFileTypes) {
      var isCorrectFileType = allowedFileTypes.some(function (type) {
        // is this is a mime-type
        if (type.indexOf('/') > -1) {
          if (!file.type) return false;
          return match(file.type, type);
        } // otherwise this is likely an extension


        if (type[0] === '.') {
          return file.extension.toLowerCase() === type.substr(1).toLowerCase();
        }

        return false;
      });

      if (!isCorrectFileType) {
        var allowedFileTypesString = allowedFileTypes.join(', ');
        throw new RestrictionError(this.i18n('youCanOnlyUploadFileTypes', {
          types: allowedFileTypesString
        }));
      }
    } // We can't check maxFileSize if the size is unknown.


    if (maxFileSize && file.data.size != null) {
      if (file.data.size > maxFileSize) {
        throw new RestrictionError(this.i18n('exceedsSize') + " " + prettyBytes(maxFileSize));
      }
    }
  };

  _proto._showOrLogErrorAndThrow = function _showOrLogErrorAndThrow(err, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$showInformer = _ref.showInformer,
        showInformer = _ref$showInformer === void 0 ? true : _ref$showInformer,
        _ref$file = _ref.file,
        file = _ref$file === void 0 ? null : _ref$file;

    var message = typeof err === 'object' ? err.message : err;
    var details = typeof err === 'object' && err.details ? err.details : ''; // Restriction errors should be logged, but not as errors,
    // as they are expected and shown in the UI.

    if (err.isRestriction) {
      this.log(message + " " + details);
      this.emit('restriction-failed', file, err);
    } else {
      this.log(message + " " + details, 'error');
    } // Sometimes informer has to be shown manually by the developer,
    // for example, in `onBeforeFileAdded`.


    if (showInformer) {
      this.info({
        message: message,
        details: details
      }, 'error', 5000);
    }

    throw typeof err === 'object' ? err : new Error(err);
  };

  _proto._assertNewUploadAllowed = function _assertNewUploadAllowed(file) {
    var _this$getState2 = this.getState(),
        allowNewUpload = _this$getState2.allowNewUpload;

    if (allowNewUpload === false) {
      this._showOrLogErrorAndThrow(new RestrictionError('Cannot add new files: already uploading.'), {
        file: file
      });
    }
  }
  /**
   * Create a file state object based on user-provided `addFile()` options.
   *
   * Note this is extremely side-effectful and should only be done when a file state object will be added to state immediately afterward!
   *
   * The `files` value is passed in because it may be updated by the caller without updating the store.
   */
  ;

  _proto._checkAndCreateFileStateObject = function _checkAndCreateFileStateObject(files, file) {
    var fileType = getFileType(file);
    file.type = fileType;
    var onBeforeFileAddedResult = this.opts.onBeforeFileAdded(file, files);

    if (onBeforeFileAddedResult === false) {
      // Don’t show UI info for this error, as it should be done by the developer
      this._showOrLogErrorAndThrow(new RestrictionError('Cannot add the file because onBeforeFileAdded returned false.'), {
        showInformer: false,
        file: file
      });
    }

    if (typeof onBeforeFileAddedResult === 'object' && onBeforeFileAddedResult) {
      file = onBeforeFileAddedResult;
    }

    var fileName;

    if (file.name) {
      fileName = file.name;
    } else if (fileType.split('/')[0] === 'image') {
      fileName = fileType.split('/')[0] + '.' + fileType.split('/')[1];
    } else {
      fileName = 'noname';
    }

    var fileExtension = getFileNameAndExtension(fileName).extension;
    var isRemote = file.isRemote || false;
    var fileID = generateFileID(file);

    if (files[fileID]) {
      this._showOrLogErrorAndThrow(new RestrictionError("Cannot add the duplicate file '" + fileName + "', it already exists."), {
        file: file
      });
    }

    var meta = file.meta || {};
    meta.name = fileName;
    meta.type = fileType; // `null` means the size is unknown.

    var size = isFinite(file.data.size) ? file.data.size : null;
    var newFile = {
      source: file.source || '',
      id: fileID,
      name: fileName,
      extension: fileExtension || '',
      meta: _extends({}, this.getState().meta, {}, meta),
      type: fileType,
      data: file.data,
      progress: {
        percentage: 0,
        bytesUploaded: 0,
        bytesTotal: size,
        uploadComplete: false,
        uploadStarted: null
      },
      size: size,
      isRemote: isRemote,
      remote: file.remote || '',
      preview: file.preview
    };

    try {
      this._checkRestrictions(files, newFile);
    } catch (err) {
      this._showOrLogErrorAndThrow(err, {
        file: newFile
      });
    }

    return newFile;
  } // Schedule an upload if `autoProceed` is enabled.
  ;

  _proto._startIfAutoProceed = function _startIfAutoProceed() {
    var _this3 = this;

    if (this.opts.autoProceed && !this.scheduledAutoProceed) {
      this.scheduledAutoProceed = setTimeout(function () {
        _this3.scheduledAutoProceed = null;

        _this3.upload().catch(function (err) {
          if (!err.isRestriction) {
            _this3.log(err.stack || err.message || err);
          }
        });
      }, 4);
    }
  }
  /**
   * Add a new file to `state.files`. This will run `onBeforeFileAdded`,
   * try to guess file type in a clever way, check file against restrictions,
   * and start an upload if `autoProceed === true`.
   *
   * @param {object} file object to add
   * @returns {string} id for the added file
   */
  ;

  _proto.addFile = function addFile(file) {
    var _extends3;

    this._assertNewUploadAllowed(file);

    var _this$getState3 = this.getState(),
        files = _this$getState3.files;

    var newFile = this._checkAndCreateFileStateObject(files, file);

    this.setState({
      files: _extends({}, files, (_extends3 = {}, _extends3[newFile.id] = newFile, _extends3))
    });
    this.emit('file-added', newFile);
    this.log("Added file: " + newFile.name + ", " + newFile.id + ", mime type: " + newFile.type);

    this._startIfAutoProceed();

    return newFile.id;
  }
  /**
   * Add multiple files to `state.files`. See the `addFile()` documentation.
   *
   * This cuts some corners for performance, so should typically only be used in cases where there may be a lot of files.
   *
   * If an error occurs while adding a file, it is logged and the user is notified. This is good for UI plugins, but not for programmatic use. Programmatic users should usually still use `addFile()` on individual files.
   */
  ;

  _proto.addFiles = function addFiles(fileDescriptors) {
    var _this4 = this;

    this._assertNewUploadAllowed(); // create a copy of the files object only once


    var files = _extends({}, this.getState().files);

    var newFiles = [];
    var errors = [];

    for (var i = 0; i < fileDescriptors.length; i++) {
      try {
        var newFile = this._checkAndCreateFileStateObject(files, fileDescriptors[i]);

        newFiles.push(newFile);
        files[newFile.id] = newFile;
      } catch (err) {
        if (!err.isRestriction) {
          errors.push(err);
        }
      }
    }

    this.setState({
      files: files
    });
    newFiles.forEach(function (newFile) {
      _this4.emit('file-added', newFile);
    });
    this.log("Added batch of " + newFiles.length + " files");

    this._startIfAutoProceed();

    if (errors.length > 0) {
      var message = 'Multiple errors occurred while adding files:\n';
      errors.forEach(function (subError) {
        message += "\n * " + subError.message;
      });
      this.info({
        message: this.i18n('addBulkFilesFailed', {
          smart_count: errors.length
        }),
        details: message
      }, 'error', 5000);
      var err = new Error(message);
      err.errors = errors;
      throw err;
    }
  };

  _proto.removeFiles = function removeFiles(fileIDs) {
    var _this5 = this;

    var _this$getState4 = this.getState(),
        files = _this$getState4.files,
        currentUploads = _this$getState4.currentUploads;

    var updatedFiles = _extends({}, files);

    var updatedUploads = _extends({}, currentUploads);

    var removedFiles = Object.create(null);
    fileIDs.forEach(function (fileID) {
      if (files[fileID]) {
        removedFiles[fileID] = files[fileID];
        delete updatedFiles[fileID];
      }
    }); // Remove files from the `fileIDs` list in each upload.

    function fileIsNotRemoved(uploadFileID) {
      return removedFiles[uploadFileID] === undefined;
    }

    var uploadsToRemove = [];
    Object.keys(updatedUploads).forEach(function (uploadID) {
      var newFileIDs = currentUploads[uploadID].fileIDs.filter(fileIsNotRemoved); // Remove the upload if no files are associated with it anymore.

      if (newFileIDs.length === 0) {
        uploadsToRemove.push(uploadID);
        return;
      }

      updatedUploads[uploadID] = _extends({}, currentUploads[uploadID], {
        fileIDs: newFileIDs
      });
    });
    uploadsToRemove.forEach(function (uploadID) {
      delete updatedUploads[uploadID];
    });
    var stateUpdate = {
      currentUploads: updatedUploads,
      files: updatedFiles
    }; // If all files were removed - allow new uploads!

    if (Object.keys(updatedFiles).length === 0) {
      stateUpdate.allowNewUpload = true;
    }

    this.setState(stateUpdate);

    this._calculateTotalProgress();

    var removedFileIDs = Object.keys(removedFiles);
    removedFileIDs.forEach(function (fileID) {
      _this5.emit('file-removed', removedFiles[fileID]);
    });

    if (removedFileIDs.length > 5) {
      this.log("Removed " + removedFileIDs.length + " files");
    } else {
      this.log("Removed files: " + removedFileIDs.join(', '));
    }
  };

  _proto.removeFile = function removeFile(fileID) {
    this.removeFiles([fileID]);
  };

  _proto.pauseResume = function pauseResume(fileID) {
    if (!this.getState().capabilities.resumableUploads || this.getFile(fileID).uploadComplete) {
      return;
    }

    var wasPaused = this.getFile(fileID).isPaused || false;
    var isPaused = !wasPaused;
    this.setFileState(fileID, {
      isPaused: isPaused
    });
    this.emit('upload-pause', fileID, isPaused);
    return isPaused;
  };

  _proto.pauseAll = function pauseAll() {
    var updatedFiles = _extends({}, this.getState().files);

    var inProgressUpdatedFiles = Object.keys(updatedFiles).filter(function (file) {
      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;
    });
    inProgressUpdatedFiles.forEach(function (file) {
      var updatedFile = _extends({}, updatedFiles[file], {
        isPaused: true
      });

      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles
    });
    this.emit('pause-all');
  };

  _proto.resumeAll = function resumeAll() {
    var updatedFiles = _extends({}, this.getState().files);

    var inProgressUpdatedFiles = Object.keys(updatedFiles).filter(function (file) {
      return !updatedFiles[file].progress.uploadComplete && updatedFiles[file].progress.uploadStarted;
    });
    inProgressUpdatedFiles.forEach(function (file) {
      var updatedFile = _extends({}, updatedFiles[file], {
        isPaused: false,
        error: null
      });

      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles
    });
    this.emit('resume-all');
  };

  _proto.retryAll = function retryAll() {
    var updatedFiles = _extends({}, this.getState().files);

    var filesToRetry = Object.keys(updatedFiles).filter(function (file) {
      return updatedFiles[file].error;
    });
    filesToRetry.forEach(function (file) {
      var updatedFile = _extends({}, updatedFiles[file], {
        isPaused: false,
        error: null
      });

      updatedFiles[file] = updatedFile;
    });
    this.setState({
      files: updatedFiles,
      error: null
    });
    this.emit('retry-all', filesToRetry);

    var uploadID = this._createUpload(filesToRetry);

    return this._runUpload(uploadID);
  };

  _proto.cancelAll = function cancelAll() {
    this.emit('cancel-all');

    var _this$getState5 = this.getState(),
        files = _this$getState5.files;

    var fileIDs = Object.keys(files);

    if (fileIDs.length) {
      this.removeFiles(fileIDs);
    }

    this.setState({
      totalProgress: 0,
      error: null
    });
  };

  _proto.retryUpload = function retryUpload(fileID) {
    this.setFileState(fileID, {
      error: null,
      isPaused: false
    });
    this.emit('upload-retry', fileID);

    var uploadID = this._createUpload([fileID]);

    return this._runUpload(uploadID);
  };

  _proto.reset = function reset() {
    this.cancelAll();
  };

  _proto._calculateProgress = function _calculateProgress(file, data) {
    if (!this.getFile(file.id)) {
      this.log("Not setting progress for a file that has been removed: " + file.id);
      return;
    } // bytesTotal may be null or zero; in that case we can't divide by it


    var canHavePercentage = isFinite(data.bytesTotal) && data.bytesTotal > 0;
    this.setFileState(file.id, {
      progress: _extends({}, this.getFile(file.id).progress, {
        bytesUploaded: data.bytesUploaded,
        bytesTotal: data.bytesTotal,
        percentage: canHavePercentage // TODO(goto-bus-stop) flooring this should probably be the choice of the UI?
        // we get more accurate calculations if we don't round this at all.
        ? Math.round(data.bytesUploaded / data.bytesTotal * 100) : 0
      })
    });

    this._calculateTotalProgress();
  };

  _proto._calculateTotalProgress = function _calculateTotalProgress() {
    // calculate total progress, using the number of files currently uploading,
    // multiplied by 100 and the summ of individual progress of each file
    var files = this.getFiles();
    var inProgress = files.filter(function (file) {
      return file.progress.uploadStarted;
    });

    if (inProgress.length === 0) {
      this.emit('progress', 0);
      this.setState({
        totalProgress: 0
      });
      return;
    }

    var sizedFiles = inProgress.filter(function (file) {
      return file.progress.bytesTotal != null;
    });
    var unsizedFiles = inProgress.filter(function (file) {
      return file.progress.bytesTotal == null;
    });

    if (sizedFiles.length === 0) {
      var progressMax = inProgress.length * 100;
      var currentProgress = unsizedFiles.reduce(function (acc, file) {
        return acc + file.progress.percentage;
      }, 0);

      var _totalProgress = Math.round(currentProgress / progressMax * 100);

      this.setState({
        totalProgress: _totalProgress
      });
      return;
    }

    var totalSize = sizedFiles.reduce(function (acc, file) {
      return acc + file.progress.bytesTotal;
    }, 0);
    var averageSize = totalSize / sizedFiles.length;
    totalSize += averageSize * unsizedFiles.length;
    var uploadedSize = 0;
    sizedFiles.forEach(function (file) {
      uploadedSize += file.progress.bytesUploaded;
    });
    unsizedFiles.forEach(function (file) {
      uploadedSize += averageSize * (file.progress.percentage || 0) / 100;
    });
    var totalProgress = totalSize === 0 ? 0 : Math.round(uploadedSize / totalSize * 100); // hot fix, because:
    // uploadedSize ended up larger than totalSize, resulting in 1325% total

    if (totalProgress > 100) {
      totalProgress = 100;
    }

    this.setState({
      totalProgress: totalProgress
    });
    this.emit('progress', totalProgress);
  }
  /**
   * Registers listeners for all global actions, like:
   * `error`, `file-removed`, `upload-progress`
   */
  ;

  _proto._addListeners = function _addListeners() {
    var _this6 = this;

    this.on('error', function (error) {
      _this6.setState({
        error: error.message || 'Unknown error'
      });
    });
    this.on('upload-error', function (file, error, response) {
      _this6.setFileState(file.id, {
        error: error.message || 'Unknown error',
        response: response
      });

      _this6.setState({
        error: error.message
      });

      var message = _this6.i18n('failedToUpload', {
        file: file.name
      });

      if (typeof error === 'object' && error.message) {
        message = {
          message: message,
          details: error.message
        };
      }

      _this6.info(message, 'error', 5000);
    });
    this.on('upload', function () {
      _this6.setState({
        error: null
      });
    });
    this.on('upload-started', function (file, upload) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      _this6.setFileState(file.id, {
        progress: {
          uploadStarted: Date.now(),
          uploadComplete: false,
          percentage: 0,
          bytesUploaded: 0,
          bytesTotal: file.size
        }
      });
    });
    this.on('upload-progress', this._calculateProgress);
    this.on('upload-success', function (file, uploadResp) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      var currentProgress = _this6.getFile(file.id).progress;

      _this6.setFileState(file.id, {
        progress: _extends({}, currentProgress, {
          uploadComplete: true,
          percentage: 100,
          bytesUploaded: currentProgress.bytesTotal
        }),
        response: uploadResp,
        uploadURL: uploadResp.uploadURL,
        isPaused: false
      });

      _this6._calculateTotalProgress();
    });
    this.on('preprocess-progress', function (file, progress) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      _this6.setFileState(file.id, {
        progress: _extends({}, _this6.getFile(file.id).progress, {
          preprocess: progress
        })
      });
    });
    this.on('preprocess-complete', function (file) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      var files = _extends({}, _this6.getState().files);

      files[file.id] = _extends({}, files[file.id], {
        progress: _extends({}, files[file.id].progress)
      });
      delete files[file.id].progress.preprocess;

      _this6.setState({
        files: files
      });
    });
    this.on('postprocess-progress', function (file, progress) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      _this6.setFileState(file.id, {
        progress: _extends({}, _this6.getState().files[file.id].progress, {
          postprocess: progress
        })
      });
    });
    this.on('postprocess-complete', function (file) {
      if (!_this6.getFile(file.id)) {
        _this6.log("Not setting progress for a file that has been removed: " + file.id);

        return;
      }

      var files = _extends({}, _this6.getState().files);

      files[file.id] = _extends({}, files[file.id], {
        progress: _extends({}, files[file.id].progress)
      });
      delete files[file.id].progress.postprocess; // TODO should we set some kind of `fullyComplete` property on the file object
      // so it's easier to see that the file is upload…fully complete…rather than
      // what we have to do now (`uploadComplete && !postprocess`)

      _this6.setState({
        files: files
      });
    });
    this.on('restored', function () {
      // Files may have changed--ensure progress is still accurate.
      _this6._calculateTotalProgress();
    }); // show informer if offline

    if (typeof window !== 'undefined' && window.addEventListener) {
      window.addEventListener('online', function () {
        return _this6.updateOnlineStatus();
      });
      window.addEventListener('offline', function () {
        return _this6.updateOnlineStatus();
      });
      setTimeout(function () {
        return _this6.updateOnlineStatus();
      }, 3000);
    }
  };

  _proto.updateOnlineStatus = function updateOnlineStatus() {
    var online = typeof window.navigator.onLine !== 'undefined' ? window.navigator.onLine : true;

    if (!online) {
      this.emit('is-offline');
      this.info(this.i18n('noInternetConnection'), 'error', 0);
      this.wasOffline = true;
    } else {
      this.emit('is-online');

      if (this.wasOffline) {
        this.emit('back-online');
        this.info(this.i18n('connectedToInternet'), 'success', 3000);
        this.wasOffline = false;
      }
    }
  };

  _proto.getID = function getID() {
    return this.opts.id;
  }
  /**
   * Registers a plugin with Core.
   *
   * @param {object} Plugin object
   * @param {object} [opts] object with options to be passed to Plugin
   * @returns {object} self for chaining
   */
  ;

  _proto.use = function use(Plugin, opts) {
    if (typeof Plugin !== 'function') {
      var msg = "Expected a plugin class, but got " + (Plugin === null ? 'null' : typeof Plugin) + "." + ' Please verify that the plugin was imported and spelled correctly.';
      throw new TypeError(msg);
    } // Instantiate


    var plugin = new Plugin(this, opts);
    var pluginId = plugin.id;
    this.plugins[plugin.type] = this.plugins[plugin.type] || [];

    if (!pluginId) {
      throw new Error('Your plugin must have an id');
    }

    if (!plugin.type) {
      throw new Error('Your plugin must have a type');
    }

    var existsPluginAlready = this.getPlugin(pluginId);

    if (existsPluginAlready) {
      var _msg = "Already found a plugin named '" + existsPluginAlready.id + "'. " + ("Tried to use: '" + pluginId + "'.\n") + 'Uppy plugins must have unique `id` options. See https://uppy.io/docs/plugins/#id.';

      throw new Error(_msg);
    }

    if (Plugin.VERSION) {
      this.log("Using " + pluginId + " v" + Plugin.VERSION);
    }

    this.plugins[plugin.type].push(plugin);
    plugin.install();
    return this;
  }
  /**
   * Find one Plugin by name.
   *
   * @param {string} id plugin id
   * @returns {object|boolean}
   */
  ;

  _proto.getPlugin = function getPlugin(id) {
    var foundPlugin = null;
    this.iteratePlugins(function (plugin) {
      if (plugin.id === id) {
        foundPlugin = plugin;
        return false;
      }
    });
    return foundPlugin;
  }
  /**
   * Iterate through all `use`d plugins.
   *
   * @param {Function} method that will be run on each plugin
   */
  ;

  _proto.iteratePlugins = function iteratePlugins(method) {
    var _this7 = this;

    Object.keys(this.plugins).forEach(function (pluginType) {
      _this7.plugins[pluginType].forEach(method);
    });
  }
  /**
   * Uninstall and remove a plugin.
   *
   * @param {object} instance The plugin instance to remove.
   */
  ;

  _proto.removePlugin = function removePlugin(instance) {
    this.log("Removing plugin " + instance.id);
    this.emit('plugin-remove', instance);

    if (instance.uninstall) {
      instance.uninstall();
    }

    var list = this.plugins[instance.type].slice();
    var index = list.indexOf(instance);

    if (index !== -1) {
      list.splice(index, 1);
      this.plugins[instance.type] = list;
    }

    var updatedState = this.getState();
    delete updatedState.plugins[instance.id];
    this.setState(updatedState);
  }
  /**
   * Uninstall all plugins and close down this Uppy instance.
   */
  ;

  _proto.close = function close() {
    var _this8 = this;

    this.log("Closing Uppy instance " + this.opts.id + ": removing all files and uninstalling plugins");
    this.reset();

    this._storeUnsubscribe();

    this.iteratePlugins(function (plugin) {
      _this8.removePlugin(plugin);
    });
  }
  /**
   * Set info message in `state.info`, so that UI plugins like `Informer`
   * can display the message.
   *
   * @param {string | object} message Message to be displayed by the informer
   * @param {string} [type]
   * @param {number} [duration]
   */
  ;

  _proto.info = function info(message, type, duration) {
    if (type === void 0) {
      type = 'info';
    }

    if (duration === void 0) {
      duration = 3000;
    }

    var isComplexMessage = typeof message === 'object';
    this.setState({
      info: {
        isHidden: false,
        type: type,
        message: isComplexMessage ? message.message : message,
        details: isComplexMessage ? message.details : null
      }
    });
    this.emit('info-visible');
    clearTimeout(this.infoTimeoutID);

    if (duration === 0) {
      this.infoTimeoutID = undefined;
      return;
    } // hide the informer after `duration` milliseconds


    this.infoTimeoutID = setTimeout(this.hideInfo, duration);
  };

  _proto.hideInfo = function hideInfo() {
    var newInfo = _extends({}, this.getState().info, {
      isHidden: true
    });

    this.setState({
      info: newInfo
    });
    this.emit('info-hidden');
  }
  /**
   * Passes messages to a function, provided in `opts.logger`.
   * If `opts.logger: Uppy.debugLogger` or `opts.debug: true`, logs to the browser console.
   *
   * @param {string|object} message to log
   * @param {string} [type] optional `error` or `warning`
   */
  ;

  _proto.log = function log(message, type) {
    var logger = this.opts.logger;

    switch (type) {
      case 'error':
        logger.error(message);
        break;

      case 'warning':
        logger.warn(message);
        break;

      default:
        logger.debug(message);
        break;
    }
  }
  /**
   * Obsolete, event listeners are now added in the constructor.
   */
  ;

  _proto.run = function run() {
    this.log('Calling run() is no longer necessary.', 'warning');
    return this;
  }
  /**
   * Restore an upload by its ID.
   */
  ;

  _proto.restore = function restore(uploadID) {
    this.log("Core: attempting to restore upload \"" + uploadID + "\"");

    if (!this.getState().currentUploads[uploadID]) {
      this._removeUpload(uploadID);

      return Promise.reject(new Error('Nonexistent upload'));
    }

    return this._runUpload(uploadID);
  }
  /**
   * Create an upload for a bunch of files.
   *
   * @param {Array<string>} fileIDs File IDs to include in this upload.
   * @returns {string} ID of this upload.
   */
  ;

  _proto._createUpload = function _createUpload(fileIDs) {
    var _extends4;

    var _this$getState6 = this.getState(),
        allowNewUpload = _this$getState6.allowNewUpload,
        currentUploads = _this$getState6.currentUploads;

    if (!allowNewUpload) {
      throw new Error('Cannot create a new upload: already uploading.');
    }

    var uploadID = cuid();
    this.emit('upload', {
      id: uploadID,
      fileIDs: fileIDs
    });
    this.setState({
      allowNewUpload: this.opts.allowMultipleUploads !== false,
      currentUploads: _extends({}, currentUploads, (_extends4 = {}, _extends4[uploadID] = {
        fileIDs: fileIDs,
        step: 0,
        result: {}
      }, _extends4))
    });
    return uploadID;
  };

  _proto._getUpload = function _getUpload(uploadID) {
    var _this$getState7 = this.getState(),
        currentUploads = _this$getState7.currentUploads;

    return currentUploads[uploadID];
  }
  /**
   * Add data to an upload's result object.
   *
   * @param {string} uploadID The ID of the upload.
   * @param {object} data Data properties to add to the result object.
   */
  ;

  _proto.addResultData = function addResultData(uploadID, data) {
    var _extends5;

    if (!this._getUpload(uploadID)) {
      this.log("Not setting result for an upload that has been removed: " + uploadID);
      return;
    }

    var currentUploads = this.getState().currentUploads;

    var currentUpload = _extends({}, currentUploads[uploadID], {
      result: _extends({}, currentUploads[uploadID].result, data)
    });

    this.setState({
      currentUploads: _extends({}, currentUploads, (_extends5 = {}, _extends5[uploadID] = currentUpload, _extends5))
    });
  }
  /**
   * Remove an upload, eg. if it has been canceled or completed.
   *
   * @param {string} uploadID The ID of the upload.
   */
  ;

  _proto._removeUpload = function _removeUpload(uploadID) {
    var currentUploads = _extends({}, this.getState().currentUploads);

    delete currentUploads[uploadID];
    this.setState({
      currentUploads: currentUploads
    });
  }
  /**
   * Run an upload. This picks up where it left off in case the upload is being restored.
   *
   * @private
   */
  ;

  _proto._runUpload = function _runUpload(uploadID) {
    var _this9 = this;

    var uploadData = this.getState().currentUploads[uploadID];
    var restoreStep = uploadData.step;
    var steps = [].concat(this.preProcessors, this.uploaders, this.postProcessors);
    var lastStep = Promise.resolve();
    steps.forEach(function (fn, step) {
      // Skip this step if we are restoring and have already completed this step before.
      if (step < restoreStep) {
        return;
      }

      lastStep = lastStep.then(function () {
        var _extends6;

        var _this9$getState = _this9.getState(),
            currentUploads = _this9$getState.currentUploads;

        var currentUpload = currentUploads[uploadID];

        if (!currentUpload) {
          return;
        }

        var updatedUpload = _extends({}, currentUpload, {
          step: step
        });

        _this9.setState({
          currentUploads: _extends({}, currentUploads, (_extends6 = {}, _extends6[uploadID] = updatedUpload, _extends6))
        }); // TODO give this the `updatedUpload` object as its only parameter maybe?
        // Otherwise when more metadata may be added to the upload this would keep getting more parameters


        return fn(updatedUpload.fileIDs, uploadID);
      }).then(function (result) {
        return null;
      });
    }); // Not returning the `catch`ed promise, because we still want to return a rejected
    // promise from this method if the upload failed.

    lastStep.catch(function (err) {
      _this9.emit('error', err, uploadID);

      _this9._removeUpload(uploadID);
    });
    return lastStep.then(function () {
      // Set result data.
      var _this9$getState2 = _this9.getState(),
          currentUploads = _this9$getState2.currentUploads;

      var currentUpload = currentUploads[uploadID];

      if (!currentUpload) {
        return;
      }

      var files = currentUpload.fileIDs.map(function (fileID) {
        return _this9.getFile(fileID);
      });
      var successful = files.filter(function (file) {
        return !file.error;
      });
      var failed = files.filter(function (file) {
        return file.error;
      });

      _this9.addResultData(uploadID, {
        successful: successful,
        failed: failed,
        uploadID: uploadID
      });
    }).then(function () {
      // Emit completion events.
      // This is in a separate function so that the `currentUploads` variable
      // always refers to the latest state. In the handler right above it refers
      // to an outdated object without the `.result` property.
      var _this9$getState3 = _this9.getState(),
          currentUploads = _this9$getState3.currentUploads;

      if (!currentUploads[uploadID]) {
        return;
      }

      var currentUpload = currentUploads[uploadID];
      var result = currentUpload.result;

      _this9.emit('complete', result);

      _this9._removeUpload(uploadID);

      return result;
    }).then(function (result) {
      if (result == null) {
        _this9.log("Not setting result for an upload that has been removed: " + uploadID);
      }

      return result;
    });
  }
  /**
   * Start an upload for all the files that are not currently being uploaded.
   *
   * @returns {Promise}
   */
  ;

  _proto.upload = function upload() {
    var _this10 = this;

    if (!this.plugins.uploader) {
      this.log('No uploader type plugins are used', 'warning');
    }

    var files = this.getState().files;
    var onBeforeUploadResult = this.opts.onBeforeUpload(files);

    if (onBeforeUploadResult === false) {
      return Promise.reject(new Error('Not starting the upload because onBeforeUpload returned false'));
    }

    if (onBeforeUploadResult && typeof onBeforeUploadResult === 'object') {
      files = onBeforeUploadResult;
    }

    return Promise.resolve().then(function () {
      return _this10._checkMinNumberOfFiles(files);
    }).then(function () {
      var _this10$getState = _this10.getState(),
          currentUploads = _this10$getState.currentUploads; // get a list of files that are currently assigned to uploads


      var currentlyUploadingFiles = Object.keys(currentUploads).reduce(function (prev, curr) {
        return prev.concat(currentUploads[curr].fileIDs);
      }, []);
      var waitingFileIDs = [];
      Object.keys(files).forEach(function (fileID) {
        var file = _this10.getFile(fileID); // if the file hasn't started uploading and hasn't already been assigned to an upload..


        if (!file.progress.uploadStarted && currentlyUploadingFiles.indexOf(fileID) === -1) {
          waitingFileIDs.push(file.id);
        }
      });

      var uploadID = _this10._createUpload(waitingFileIDs);

      return _this10._runUpload(uploadID);
    }).catch(function (err) {
      _this10._showOrLogErrorAndThrow(err);
    });
  };

  _createClass(Uppy, [{
    key: "state",
    get: function get() {
      return this.getState();
    }
  }]);

  return Uppy;
}();

Uppy.VERSION = require('../package.json').version;

module.exports = function (opts) {
  return new Uppy(opts);
}; // Expose class constructor.


module.exports.Uppy = Uppy;
module.exports.Plugin = Plugin;
module.exports.debugLogger = debugLogger;

},{"../package.json":43,"./../../store-default":103,"./../../utils/lib/Translator":118,"./../../utils/lib/generateFileID":124,"./../../utils/lib/getFileNameAndExtension":131,"./../../utils/lib/getFileType":132,"./../../utils/lib/prettyBytes":143,"./Plugin":44,"./loggers":46,"./supportsUploadProgress":47,"cuid":2,"lodash.throttle":12,"mime-match":14,"namespace-emitter":15}],46:[function(require,module,exports){
var getTimeStamp = require('./../../utils/lib/getTimeStamp'); // Swallow logs, default if logger is not set or debug: false


var nullLogger = {
  debug: function debug() {},
  warn: function warn() {},
  error: function error() {}
}; // Print logs to console with namespace + timestamp,
// set by logger: Uppy.debugLogger or debug: true

var debugLogger = {
  debug: function debug() {
    // IE 10 doesn’t support console.debug
    var debug = console.debug || console.log;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    debug.call.apply(debug, [console, "[Uppy] [" + getTimeStamp() + "]"].concat(args));
  },
  warn: function warn() {
    var _console;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return (_console = console).warn.apply(_console, ["[Uppy] [" + getTimeStamp() + "]"].concat(args));
  },
  error: function error() {
    var _console2;

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return (_console2 = console).error.apply(_console2, ["[Uppy] [" + getTimeStamp() + "]"].concat(args));
  }
};
module.exports = {
  nullLogger: nullLogger,
  debugLogger: debugLogger
};

},{"./../../utils/lib/getTimeStamp":136}],47:[function(require,module,exports){
// Edge 15.x does not fire 'progress' events on uploads.
// See https://github.com/transloadit/uppy/issues/945
// And https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12224510/
module.exports = function supportsUploadProgress(userAgent) {
  // Allow passing in userAgent for tests
  if (userAgent == null) {
    userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : null;
  } // Assume it works because basically everything supports progress events.


  if (!userAgent) return true;
  var m = /Edge\/(\d+\.\d+)/.exec(userAgent);
  if (!m) return true;
  var edgeVersion = m[1];

  var _edgeVersion$split = edgeVersion.split('.'),
      major = _edgeVersion$split[0],
      minor = _edgeVersion$split[1];

  major = parseInt(major, 10);
  minor = parseInt(minor, 10); // Worked before:
  // Edge 40.15063.0.0
  // Microsoft EdgeHTML 15.15063

  if (major < 15 || major === 15 && minor < 15063) {
    return true;
  } // Fixed in:
  // Microsoft EdgeHTML 18.18218


  if (major > 18 || major === 18 && minor >= 18218) {
    return true;
  } // other versions don't work.


  return false;
};

},{}],48:[function(require,module,exports){
module.exports={
  "name": "@uppy/dashboard",
  "description": "Universal UI plugin for Uppy.",
  "version": "1.5.2",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "dashboard",
    "ui"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/informer": "file:../informer",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/status-bar": "file:../status-bar",
    "@uppy/thumbnail-generator": "file:../thumbnail-generator",
    "@uppy/utils": "file:../utils",
    "classnames": "^2.2.6",
    "cuid": "^2.1.1",
    "is-shallow-equal": "^1.0.1",
    "lodash.debounce": "^4.0.8",
    "lodash.throttle": "^4.1.1",
    "memoize-one": "^5.0.4",
    "preact": "8.2.9",
    "preact-css-transition-group": "^1.3.0",
    "resize-observer-polyfill": "^1.5.0"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],49:[function(require,module,exports){
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('./icons'),
    localIcon = _require.localIcon;

var _require2 = require('preact'),
    h = _require2.h,
    Component = _require2.Component;

var AddFiles =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(AddFiles, _Component);

  function AddFiles(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.triggerFileInputClick = _this.triggerFileInputClick.bind(_assertThisInitialized(_this));
    _this.onFileInputChange = _this.onFileInputChange.bind(_assertThisInitialized(_this));
    _this.renderPoweredByUppy = _this.renderPoweredByUppy.bind(_assertThisInitialized(_this));
    _this.renderHiddenFileInput = _this.renderHiddenFileInput.bind(_assertThisInitialized(_this));
    _this.renderDropPasteBrowseTagline = _this.renderDropPasteBrowseTagline.bind(_assertThisInitialized(_this));
    _this.renderMyDeviceAcquirer = _this.renderMyDeviceAcquirer.bind(_assertThisInitialized(_this));
    _this.renderAcquirer = _this.renderAcquirer.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = AddFiles.prototype;

  _proto.triggerFileInputClick = function triggerFileInputClick() {
    this.fileInput.click();
  };

  _proto.onFileInputChange = function onFileInputChange(event) {
    this.props.handleInputChange(event); // We clear the input after a file is selected, because otherwise
    // change event is not fired in Chrome and Safari when a file
    // with the same name is selected.
    // ___Why not use value="" on <input/> instead?
    //    Because if we use that method of clearing the input,
    //    Chrome will not trigger change if we drop the same file twice (Issue #768).

    event.target.value = null;
  };

  _proto.renderPoweredByUppy = function renderPoweredByUppy() {
    return h("a", {
      tabindex: "-1",
      href: "https://uppy.io",
      rel: "noreferrer noopener",
      target: "_blank",
      class: "uppy-Dashboard-poweredBy"
    }, this.props.i18n('poweredBy') + ' ', h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      class: "UppyIcon uppy-Dashboard-poweredByIcon",
      width: "11",
      height: "11",
      viewBox: "0 0 11 11"
    }, h("path", {
      d: "M7.365 10.5l-.01-4.045h2.612L5.5.806l-4.467 5.65h2.604l.01 4.044h3.718z",
      "fill-rule": "evenodd"
    })), h("span", {
      class: "uppy-Dashboard-poweredByUppy"
    }, "Uppy"));
  };

  _proto.renderHiddenFileInput = function renderHiddenFileInput() {
    var _this2 = this;

    return h("input", {
      class: "uppy-Dashboard-input",
      hidden: true,
      "aria-hidden": "true",
      tabindex: -1,
      type: "file",
      name: "files[]",
      multiple: this.props.maxNumberOfFiles !== 1,
      onchange: this.onFileInputChange,
      accept: this.props.allowedFileTypes,
      ref: function ref(_ref) {
        _this2.fileInput = _ref;
      }
    });
  };

  _proto.renderDropPasteBrowseTagline = function renderDropPasteBrowseTagline() {
    var browse = h("button", {
      type: "button",
      class: "uppy-u-reset uppy-Dashboard-browse",
      onclick: this.triggerFileInputClick
    }, this.props.i18n('browse'));
    return h("div", {
      class: "uppy-Dashboard-dropFilesTitle"
    }, h("span", null, this.props.acquirers.length === 0 ? this.props.i18nArray('dropPaste', {
      browse: browse
    }) : this.props.i18nArray('dropPasteImport', {
      browse: browse
    })));
  };

  _proto.renderMyDeviceAcquirer = function renderMyDeviceAcquirer() {
    return h("div", {
      class: "uppy-DashboardTab",
      role: "presentation"
    }, h("button", {
      type: "button",
      class: "uppy-DashboardTab-btn",
      role: "tab",
      tabindex: 0,
      "data-uppy-super-focusable": true,
      onclick: this.triggerFileInputClick
    }, localIcon(), h("div", {
      class: "uppy-DashboardTab-name"
    }, this.props.i18n('myDevice'))));
  };

  _proto.renderAcquirer = function renderAcquirer(acquirer) {
    var _this3 = this;

    return h("div", {
      class: "uppy-DashboardTab",
      role: "presentation"
    }, h("button", {
      type: "button",
      class: "uppy-DashboardTab-btn",
      role: "tab",
      tabindex: 0,
      "aria-controls": "uppy-DashboardContent-panel--" + acquirer.id,
      "aria-selected": this.props.activePickerPanel.id === acquirer.id,
      "data-uppy-super-focusable": true,
      onclick: function onclick() {
        return _this3.props.showPanel(acquirer.id);
      }
    }, acquirer.icon(), h("div", {
      class: "uppy-DashboardTab-name"
    }, acquirer.name)));
  };

  _proto.render = function render() {
    var _this4 = this;

    return h("div", {
      class: "uppy-DashboardAddFiles"
    }, this.renderHiddenFileInput(), h("div", {
      class: "uppy-DashboardTabs"
    }, this.renderDropPasteBrowseTagline(), this.props.acquirers.length > 0 && h("div", {
      class: "uppy-DashboardTabs-list",
      role: "tablist"
    }, this.renderMyDeviceAcquirer(), this.props.acquirers.map(function (acquirer) {
      return _this4.renderAcquirer(acquirer);
    })), h("div", {
      class: "uppy-DashboardAddFiles-info"
    }, this.props.note && h("div", {
      class: "uppy-Dashboard-note"
    }, this.props.note), this.props.proudlyDisplayPoweredByUppy && this.renderPoweredByUppy(this.props))));
  };

  return AddFiles;
}(Component);

module.exports = AddFiles;

},{"./icons":63,"preact":17}],50:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var AddFiles = require('./AddFiles');

var AddFilesPanel = function AddFilesPanel(props) {
  return h("div", {
    class: "uppy-Dashboard-AddFilesPanel",
    "data-uppy-panelType": "AddFiles",
    "aria-hidden": props.showAddFilesPanel
  }, h("div", {
    class: "uppy-DashboardContent-bar"
  }, h("div", {
    class: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "h1"
  }, props.i18n('addingMoreFiles')), h("button", {
    class: "uppy-DashboardContent-back",
    type: "button",
    onclick: function onclick(ev) {
      return props.toggleAddFilesPanel(false);
    }
  }, props.i18n('back'))), h(AddFiles, props));
};

module.exports = AddFilesPanel;

},{"./AddFiles":49,"preact":17}],51:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var FileList = require('./FileList');

var AddFiles = require('./AddFiles');

var AddFilesPanel = require('./AddFilesPanel');

var PickerPanelContent = require('./PickerPanelContent');

var PanelTopBar = require('./PickerPanelTopBar');

var FileCard = require('./FileCard');

var classNames = require('classnames');

var isTouchDevice = require('./../../../utils/lib/isTouchDevice');

var _require = require('preact'),
    h = _require.h;

var PreactCSSTransitionGroup = require('preact-css-transition-group'); // http://dev.edenspiekermann.com/2016/02/11/introducing-accessible-modal-dialog
// https://github.com/ghosh/micromodal


function TransitionWrapper(props) {
  return h(PreactCSSTransitionGroup, {
    transitionName: "uppy-transition-slideDownUp",
    transitionEnterTimeout: 250,
    transitionLeaveTimeout: 250
  }, props.children);
}

var WIDTH_XL = 900;
var WIDTH_LG = 700;
var WIDTH_MD = 576;
var HEIGHT_MD = 576;

module.exports = function Dashboard(props) {
  var noFiles = props.totalFileCount === 0;
  var dashboardClassName = classNames({
    'uppy-Root': props.isTargetDOMEl,
    'uppy-Dashboard': true,
    'Uppy--isTouchDevice': isTouchDevice(),
    'uppy-Dashboard--animateOpenClose': props.animateOpenClose,
    'uppy-Dashboard--isClosing': props.isClosing,
    'uppy-Dashboard--isDraggingOver': props.isDraggingOver,
    'uppy-Dashboard--modal': !props.inline,
    'uppy-size--md': props.containerWidth > WIDTH_MD,
    'uppy-size--lg': props.containerWidth > WIDTH_LG,
    'uppy-size--xl': props.containerWidth > WIDTH_XL,
    'uppy-size--height-md': props.containerHeight > HEIGHT_MD,
    'uppy-Dashboard--isAddFilesPanelVisible': props.showAddFilesPanel,
    'uppy-Dashboard--isInnerWrapVisible': props.areInsidesReadyToBeVisible
  });
  var showFileList = props.showSelectedFiles && !noFiles;
  return h("div", {
    class: dashboardClassName,
    "aria-hidden": props.inline ? 'false' : props.isHidden,
    "aria-label": !props.inline ? props.i18n('dashboardWindowTitle') : props.i18n('dashboardTitle'),
    onpaste: props.handlePaste,
    onDragOver: props.handleDragOver,
    onDragLeave: props.handleDragLeave,
    onDrop: props.handleDrop
  }, h("div", {
    class: "uppy-Dashboard-overlay",
    tabindex: -1,
    onclick: props.handleClickOutside
  }), h("div", {
    class: "uppy-Dashboard-inner",
    "aria-modal": !props.inline && 'true',
    role: !props.inline && 'dialog',
    style: {
      width: props.inline && props.width ? props.width : '',
      height: props.inline && props.height ? props.height : ''
    }
  }, !props.inline ? h("button", {
    class: "uppy-u-reset uppy-Dashboard-close",
    type: "button",
    "aria-label": props.i18n('closeModal'),
    title: props.i18n('closeModal'),
    onclick: props.closeModal
  }, h("span", {
    "aria-hidden": "true"
  }, "\xD7")) : null, h("div", {
    class: "uppy-Dashboard-innerWrap"
  }, h("div", {
    class: "uppy-Dashboard-dropFilesHereHint"
  }, props.i18n('dropHint')), showFileList && h(PanelTopBar, props), showFileList ? h(FileList, props) : h(AddFiles, props), h(TransitionWrapper, null, props.showAddFilesPanel ? h(AddFilesPanel, _extends({
    key: "AddFilesPanel"
  }, props)) : null), h(TransitionWrapper, null, props.fileCardFor ? h(FileCard, _extends({
    key: "FileCard"
  }, props)) : null), h(TransitionWrapper, null, props.activePickerPanel ? h(PickerPanelContent, _extends({
    key: "PickerPanelContent"
  }, props)) : null), h("div", {
    class: "uppy-Dashboard-progressindicators"
  }, props.progressindicators.map(function (target) {
    return props.getPlugin(target.id).render(props.state);
  })))));
};

},{"./../../../utils/lib/isTouchDevice":141,"./AddFiles":49,"./AddFilesPanel":50,"./FileCard":52,"./FileList":59,"./PickerPanelContent":61,"./PickerPanelTopBar":62,"classnames":1,"preact":17,"preact-css-transition-group":16}],52:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var getFileTypeIcon = require('../../utils/getFileTypeIcon');

var ignoreEvent = require('../../utils/ignoreEvent.js');

var FilePreview = require('../FilePreview');

var FileCard =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(FileCard, _Component);

  function FileCard(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _this.saveOnEnter = function (ev) {
      if (ev.keyCode === 13) {
        ev.stopPropagation();
        ev.preventDefault();
        var file = _this.props.files[_this.props.fileCardFor];

        _this.props.saveFileCard(_this.state.formState, file.id);
      }
    };

    _this.tempStoreMeta = function (ev, name) {
      var _extends2;

      _this.setState({
        formState: _extends({}, _this.state.formState, (_extends2 = {}, _extends2[name] = ev.target.value, _extends2))
      });
    };

    _this.handleSave = function () {
      var fileID = _this.props.fileCardFor;

      _this.props.saveFileCard(_this.state.formState, fileID);
    };

    _this.handleCancel = function () {
      _this.props.toggleFileCard();
    };

    _this.renderMetaFields = function () {
      var metaFields = _this.props.metaFields || [];
      return metaFields.map(function (field) {
        var id = "uppy-Dashboard-FileCard-input-" + field.id;
        return h("fieldset", {
          key: field.id,
          class: "uppy-Dashboard-FileCard-fieldset"
        }, h("label", {
          class: "uppy-Dashboard-FileCard-label",
          for: id
        }, field.name), h("input", {
          class: "uppy-u-reset uppy-c-textInput uppy-Dashboard-FileCard-input",
          id: id,
          type: "text",
          value: _this.state.formState[field.id],
          placeholder: field.placeholder,
          onkeyup: _this.saveOnEnter,
          onkeydown: _this.saveOnEnter,
          onkeypress: _this.saveOnEnter,
          oninput: function oninput(ev) {
            return _this.tempStoreMeta(ev, field.id);
          },
          "data-uppy-super-focusable": true
        }));
      });
    };

    var _file = _this.props.files[_this.props.fileCardFor];

    var _metaFields = _this.props.metaFields || [];

    var storedMetaData = {};

    _metaFields.forEach(function (field) {
      storedMetaData[field.id] = _file.meta[field.id] || '';
    });

    _this.state = {
      formState: storedMetaData
    };
    return _this;
  }

  var _proto = FileCard.prototype;

  _proto.render = function render() {
    var file = this.props.files[this.props.fileCardFor];
    return h("div", {
      class: "uppy-Dashboard-FileCard",
      "data-uppy-panelType": "FileCard",
      onDragOver: ignoreEvent,
      onDragLeave: ignoreEvent,
      onDrop: ignoreEvent,
      onPaste: ignoreEvent
    }, h("div", {
      class: "uppy-DashboardContent-bar"
    }, h("div", {
      class: "uppy-DashboardContent-title",
      role: "heading",
      "aria-level": "h1"
    }, this.props.i18nArray('editing', {
      file: h("span", {
        class: "uppy-DashboardContent-titleFile"
      }, file.meta ? file.meta.name : file.name)
    })), h("button", {
      class: "uppy-DashboardContent-back",
      type: "button",
      title: this.props.i18n('finishEditingFile'),
      onclick: this.handleSave
    }, this.props.i18n('done'))), h("div", {
      class: "uppy-Dashboard-FileCard-inner"
    }, h("div", {
      class: "uppy-Dashboard-FileCard-preview",
      style: {
        backgroundColor: getFileTypeIcon(file.type).color
      }
    }, h(FilePreview, {
      file: file
    })), h("div", {
      class: "uppy-Dashboard-FileCard-info"
    }, this.renderMetaFields()), h("div", {
      class: "uppy-Dashboard-FileCard-actions"
    }, h("button", {
      class: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Dashboard-FileCard-actionsBtn",
      type: "button",
      onclick: this.handleSave
    }, this.props.i18n('saveChanges')), h("button", {
      class: "uppy-u-reset uppy-c-btn uppy-c-btn-link uppy-Dashboard-FileCard-actionsBtn",
      type: "button",
      onclick: this.handleCancel
    }, this.props.i18n('cancel')))));
  };

  return FileCard;
}(Component);

module.exports = FileCard;

},{"../../utils/getFileTypeIcon":68,"../../utils/ignoreEvent.js":69,"../FilePreview":60,"preact":17}],53:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var copyToClipboard = require('../../../utils/copyToClipboard');

var _require2 = require('../../icons'),
    iconPencil = _require2.iconPencil,
    iconCross = _require2.iconCross,
    iconCopyLink = _require2.iconCopyLink;

var renderEditButton = function renderEditButton(props) {
  return !props.uploadInProgressOrComplete && props.metaFields && props.metaFields.length > 0 && h("button", {
    class: "uppy-u-reset uppy-DashboardItem-action uppy-DashboardItem-action--edit",
    type: "button",
    "aria-label": props.i18n('editFile') + ' ' + props.file.meta.name,
    title: props.i18n('editFile'),
    onclick: function onclick(e) {
      return props.toggleFileCard(props.file.id);
    }
  }, iconPencil());
};

var renderRemoveButton = function renderRemoveButton(props) {
  return props.showRemoveButton && h("button", {
    class: "uppy-u-reset uppy-DashboardItem-action uppy-DashboardItem-action--remove",
    type: "button",
    "aria-label": props.i18n('removeFile'),
    title: props.i18n('removeFile'),
    onclick: function onclick() {
      return props.removeFile(props.file.id);
    }
  }, iconCross());
};

var copyLinkToClipboard = function copyLinkToClipboard(event, props) {
  return copyToClipboard(props.file.uploadURL, props.i18n('copyLinkToClipboardFallback')).then(function () {
    props.log('Link copied to clipboard.');
    props.info(props.i18n('copyLinkToClipboardSuccess'), 'info', 3000);
  }).catch(props.log) // avoid losing focus
  .then(function () {
    return event.target.focus({
      preventScroll: true
    });
  });
};

var renderCopyLinkButton = function renderCopyLinkButton(props) {
  return props.showLinkToFileUploadResult && props.file.uploadURL && h("button", {
    class: "uppy-u-reset uppy-DashboardItem-action uppy-DashboardItem-action--copyLink",
    type: "button",
    "aria-label": props.i18n('copyLink'),
    title: props.i18n('copyLink'),
    onclick: function onclick(event) {
      return copyLinkToClipboard(event, props);
    }
  }, iconCopyLink());
};

module.exports = function Buttons(props) {
  return h("div", {
    className: "uppy-DashboardItem-actionWrapper"
  }, renderEditButton(props), renderCopyLinkButton(props), renderRemoveButton(props));
};

},{"../../../utils/copyToClipboard":65,"../../icons":63,"preact":17}],54:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var prettyBytes = require('./../../../../../utils/lib/prettyBytes');

var truncateString = require('../../../utils/truncateString');

var renderAcquirerIcon = function renderAcquirerIcon(acquirer, props) {
  return h("span", {
    title: props.i18n('fileSource', {
      name: acquirer.name
    })
  }, acquirer.icon());
};

var renderFileSource = function renderFileSource(props) {
  return props.file.source && props.file.source !== props.id && h("div", {
    class: "uppy-DashboardItem-sourceIcon"
  }, props.acquirers.map(function (acquirer) {
    if (acquirer.id === props.file.source) {
      return renderAcquirerIcon(acquirer, props);
    }
  }));
};

var renderFileName = function renderFileName(props) {
  // Take up at most 2 lines on any screen
  var maxNameLength; // For very small mobile screens

  if (props.containerWidth <= 352) {
    maxNameLength = 35; // For regular mobile screens
  } else if (props.containerWidth <= 576) {
    maxNameLength = 60; // For desktops
  } else {
    maxNameLength = 30;
  }

  return h("div", {
    class: "uppy-DashboardItem-name",
    title: props.file.meta.name
  }, truncateString(props.file.meta.name, maxNameLength));
};

var renderFileSize = function renderFileSize(props) {
  return props.file.data.size && h("div", {
    class: "uppy-DashboardItem-statusSize"
  }, prettyBytes(props.file.data.size));
};

module.exports = function FileInfo(props) {
  return h("div", {
    class: "uppy-DashboardItem-fileInfo",
    "data-uppy-file-source": props.file.source
  }, renderFileName(props), h("div", {
    class: "uppy-DashboardItem-status"
  }, renderFileSize(props), renderFileSource(props)));
};

},{"../../../utils/truncateString":71,"./../../../../../utils/lib/prettyBytes":143,"preact":17}],55:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var FilePreview = require('../../FilePreview');

var getFileTypeIcon = require('../../../utils/getFileTypeIcon');

module.exports = function FilePreviewAndLink(props) {
  return h("div", {
    class: "uppy-DashboardItem-previewInnerWrap",
    style: {
      backgroundColor: getFileTypeIcon(props.file.type).color
    }
  }, props.showLinkToFileUploadResult && props.file.uploadURL && h("a", {
    class: "uppy-DashboardItem-previewLink",
    href: props.file.uploadURL,
    rel: "noreferrer noopener",
    target: "_blank",
    "aria-label": props.file.meta.name
  }), h(FilePreview, {
    file: props.file
  }));
};

},{"../../../utils/getFileTypeIcon":68,"../../FilePreview":60,"preact":17}],56:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h; // http://codepen.io/Harkko/pen/rVxvNM
// https://css-tricks.com/svg-line-animation-works/
// https://gist.github.com/eswak/ad4ea57bcd5ff7aa5d42
// circle length equals 2 * PI * R


var circleLength = 2 * Math.PI * 15; // stroke-dashoffset is a percentage of the progress from circleLength,
// substracted from circleLength, because its an offset

module.exports = function PauseResumeCancelIcon(props) {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "70",
    height: "70",
    viewBox: "0 0 36 36",
    class: "UppyIcon UppyIcon-progressCircle"
  }, h("g", {
    class: "progress-group"
  }, h("circle", {
    class: "bg",
    r: "15",
    cx: "18",
    cy: "18",
    "stroke-width": "2",
    fill: "none"
  }), h("circle", {
    class: "progress",
    r: "15",
    cx: "18",
    cy: "18",
    transform: "rotate(-90, 18, 18)",
    "stroke-width": "2",
    fill: "none",
    "stroke-dasharray": circleLength,
    "stroke-dashoffset": circleLength - circleLength / 100 * props.progress
  })), !props.hidePauseResumeCancelButtons && h("g", null, h("polygon", {
    class: "play",
    transform: "translate(3, 3)",
    points: "12 20 12 10 20 15"
  }), h("g", {
    class: "pause",
    transform: "translate(14.5, 13)"
  }, h("rect", {
    x: "0",
    y: "0",
    width: "2",
    height: "10",
    rx: "0"
  }), h("rect", {
    x: "5",
    y: "0",
    width: "2",
    height: "10",
    rx: "0"
  })), h("polygon", {
    class: "cancel",
    transform: "translate(2, 2)",
    points: "19.8856516 11.0625 16 14.9481516 12.1019737 11.0625 11.0625 12.1143484 14.9481516 16 11.0625 19.8980263 12.1019737 20.9375 16 17.0518484 19.8856516 20.9375 20.9375 19.8980263 17.0518484 16 20.9375 12"
  })), h("polygon", {
    class: "check",
    transform: "translate(2, 3)",
    points: "14 22.5 7 15.2457065 8.99985857 13.1732815 14 18.3547104 22.9729883 9 25 11.1005634"
  }));
};

},{"preact":17}],57:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var _require2 = require('../../icons'),
    iconRetry = _require2.iconRetry;

var PauseResumeCancelIcon = require('./PauseResumeCancelIcon');

function onPauseResumeCancelRetry(props) {
  if (props.isUploaded) return;

  if (props.error && !props.hideRetryButton) {
    props.retryUpload(props.file.id);
    return;
  }

  if (props.hidePauseResumeCancelButtons) {
    return;
  }

  if (props.resumableUploads) {
    props.pauseUpload(props.file.id);
  } else if (props.individualCancellation) {
    props.cancelUpload(props.file.id);
  }
}

function progressIndicatorTitle(props) {
  if (props.isUploaded) {
    return props.i18n('uploadComplete');
  }

  if (props.error) {
    return props.i18n('retryUpload');
  }

  if (props.resumableUploads) {
    if (props.file.isPaused) {
      return props.i18n('resumeUpload');
    }

    return props.i18n('pauseUpload');
  } else if (props.individualCancellation) {
    return props.i18n('cancelUpload');
  }

  return '';
}

module.exports = function FileProgress(props) {
  if (props.hideRetryButton && props.error) {
    return h("div", {
      class: "uppy-DashboardItem-progress"
    });
  } else if (props.isUploaded || props.hidePauseResumeCancelButtons && !props.error) {
    return h("div", {
      class: "uppy-DashboardItem-progress"
    }, h("div", {
      class: "uppy-DashboardItem-progressIndicator"
    }, h(PauseResumeCancelIcon, {
      progress: props.file.progress.percentage,
      hidePauseResumeCancelButtons: props.hidePauseResumeCancelButtons
    })));
  } else {
    return h("div", {
      class: "uppy-DashboardItem-progress"
    }, h("button", {
      class: "uppy-u-reset uppy-DashboardItem-progressIndicator",
      type: "button",
      "aria-label": progressIndicatorTitle(props),
      title: progressIndicatorTitle(props),
      onclick: function onclick() {
        return onPauseResumeCancelRetry(props);
      }
    }, props.error ? props.hideRetryButton ? null : iconRetry() : h(PauseResumeCancelIcon, {
      progress: props.file.progress.percentage,
      hidePauseResumeCancelButtons: props.hidePauseResumeCancelButtons
    })));
  }
};

},{"../../icons":63,"./PauseResumeCancelIcon":56,"preact":17}],58:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var classNames = require('classnames');

var shallowEqual = require('is-shallow-equal');

var FilePreviewAndLink = require('./FilePreviewAndLink');

var FileProgress = require('./FileProgress');

var FileInfo = require('./FileInfo');

var Buttons = require('./Buttons');

module.exports =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(FileItem, _Component);

  function FileItem() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = FileItem.prototype;

  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    return !shallowEqual(this.props, nextProps);
  };

  _proto.render = function render() {
    var file = this.props.file;
    var isProcessing = file.progress.preprocess || file.progress.postprocess;
    var isUploaded = file.progress.uploadComplete && !isProcessing && !file.error;
    var uploadInProgressOrComplete = file.progress.uploadStarted || isProcessing;
    var uploadInProgress = file.progress.uploadStarted && !file.progress.uploadComplete || isProcessing;
    var isPaused = file.isPaused || false;
    var error = file.error || false;
    var showRemoveButton = this.props.individualCancellation ? !isUploaded : !uploadInProgress && !isUploaded;
    var dashboardItemClass = classNames({
      'uppy-u-reset': true,
      'uppy-DashboardItem': true,
      'is-inprogress': uploadInProgress,
      'is-processing': isProcessing,
      'is-complete': isUploaded,
      'is-paused': isPaused,
      'is-error': !!error,
      'is-resumable': this.props.resumableUploads,
      'is-noIndividualCancellation': !this.props.individualCancellation
    });
    return h("li", {
      class: dashboardItemClass,
      id: "uppy_" + file.id
    }, h("div", {
      class: "uppy-DashboardItem-preview"
    }, h(FilePreviewAndLink, {
      file: file,
      showLinkToFileUploadResult: this.props.showLinkToFileUploadResult
    }), h(FileProgress, _extends({}, this.props, {
      file: file,
      error: error,
      isUploaded: isUploaded
    }))), h("div", {
      class: "uppy-DashboardItem-fileInfoAndButtons"
    }, h(FileInfo, {
      file: file,
      id: this.props.id,
      acquirers: this.props.acquirers,
      containerWidth: this.props.containerWidth,
      i18n: this.props.i18n
    }), h(Buttons, {
      file: file,
      metaFields: this.props.metaFields,
      showLinkToFileUploadResult: this.props.showLinkToFileUploadResult,
      showRemoveButton: showRemoveButton,
      uploadInProgressOrComplete: uploadInProgressOrComplete,
      removeFile: this.props.removeFile,
      toggleFileCard: this.props.toggleFileCard,
      i18n: this.props.i18n,
      log: this.props.log,
      info: this.props.info
    })));
  };

  return FileItem;
}(Component);

},{"./Buttons":53,"./FileInfo":54,"./FilePreviewAndLink":55,"./FileProgress":57,"classnames":1,"is-shallow-equal":9,"preact":17}],59:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var FileItem = require('./FileItem/index.js');

var classNames = require('classnames');

var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  var dashboardFilesClass = classNames({
    'uppy-Dashboard-files': true,
    'uppy-Dashboard-files--noFiles': props.totalFileCount === 0
  });
  var fileProps = {
    // FIXME This is confusing, it's actually the Dashboard's plugin ID
    id: props.id,
    error: props.error,
    // TODO move this to context
    i18n: props.i18n,
    log: props.log,
    info: props.info,
    // features
    acquirers: props.acquirers,
    resumableUploads: props.resumableUploads,
    individualCancellation: props.individualCancellation,
    // visual options
    hideRetryButton: props.hideRetryButton,
    hidePauseResumeCancelButtons: props.hidePauseResumeCancelButtons,
    showLinkToFileUploadResult: props.showLinkToFileUploadResult,
    isWide: props.isWide,
    metaFields: props.metaFields,
    // callbacks
    retryUpload: props.retryUpload,
    pauseUpload: props.pauseUpload,
    cancelUpload: props.cancelUpload,
    toggleFileCard: props.toggleFileCard,
    removeFile: props.removeFile,
    handleRequestThumbnail: props.handleRequestThumbnail
  };

  function renderItem(fileID) {
    return h(FileItem, _extends({
      key: fileID
    }, fileProps, {
      file: props.files[fileID]
    }));
  }

  return h("ul", {
    class: dashboardFilesClass
  }, Object.keys(props.files).map(renderItem));
};

},{"./FileItem/index.js":58,"classnames":1,"preact":17}],60:[function(require,module,exports){
var getFileTypeIcon = require('../utils/getFileTypeIcon');

var _require = require('preact'),
    h = _require.h;

module.exports = function FilePreview(props) {
  var file = props.file;

  if (file.preview) {
    return h("img", {
      class: "uppy-DashboardItem-previewImg",
      alt: file.name,
      src: file.preview
    });
  }

  var _getFileTypeIcon = getFileTypeIcon(file.type),
      color = _getFileTypeIcon.color,
      icon = _getFileTypeIcon.icon;

  return h("div", {
    class: "uppy-DashboardItem-previewIconWrap"
  }, h("span", {
    class: "uppy-DashboardItem-previewIcon",
    style: {
      color: color
    }
  }, icon), h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "uppy-DashboardItem-previewIconBg",
    width: "58",
    height: "76",
    viewBox: "0 0 58 76"
  }, h("rect", {
    fill: "#FFF",
    width: "58",
    height: "76",
    rx: "3",
    "fill-rule": "evenodd"
  })));
};

},{"../utils/getFileTypeIcon":68,"preact":17}],61:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var ignoreEvent = require('../utils/ignoreEvent.js');

function PickerPanelContent(props) {
  return h("div", {
    class: "uppy-DashboardContent-panel",
    role: "tabpanel",
    "data-uppy-panelType": "PickerPanel",
    id: "uppy-DashboardContent-panel--" + props.activePickerPanel.id,
    onDragOver: ignoreEvent,
    onDragLeave: ignoreEvent,
    onDrop: ignoreEvent,
    onPaste: ignoreEvent
  }, h("div", {
    class: "uppy-DashboardContent-bar"
  }, h("div", {
    class: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "h1"
  }, props.i18n('importFrom', {
    name: props.activePickerPanel.name
  })), h("button", {
    class: "uppy-DashboardContent-back",
    type: "button",
    onclick: props.hideAllPanels
  }, props.i18n('done'))), h("div", {
    class: "uppy-DashboardContent-panelBody"
  }, props.getPlugin(props.activePickerPanel.id).render(props.state)));
}

module.exports = PickerPanelContent;

},{"../utils/ignoreEvent.js":69,"preact":17}],62:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var _require2 = require('./icons'),
    iconPlus = _require2.iconPlus;

var uploadStates = {
  STATE_ERROR: 'error',
  STATE_WAITING: 'waiting',
  STATE_PREPROCESSING: 'preprocessing',
  STATE_UPLOADING: 'uploading',
  STATE_POSTPROCESSING: 'postprocessing',
  STATE_COMPLETE: 'complete',
  STATE_PAUSED: 'paused'
};

function getUploadingState(isAllErrored, isAllComplete, isAllPaused, files) {
  if (files === void 0) {
    files = {};
  }

  if (isAllErrored) {
    return uploadStates.STATE_ERROR;
  }

  if (isAllComplete) {
    return uploadStates.STATE_COMPLETE;
  }

  if (isAllPaused) {
    return uploadStates.STATE_PAUSED;
  }

  var state = uploadStates.STATE_WAITING;
  var fileIDs = Object.keys(files);

  for (var i = 0; i < fileIDs.length; i++) {
    var progress = files[fileIDs[i]].progress; // If ANY files are being uploaded right now, show the uploading state.

    if (progress.uploadStarted && !progress.uploadComplete) {
      return uploadStates.STATE_UPLOADING;
    } // If files are being preprocessed AND postprocessed at this time, we show the
    // preprocess state. If any files are being uploaded we show uploading.


    if (progress.preprocess && state !== uploadStates.STATE_UPLOADING) {
      state = uploadStates.STATE_PREPROCESSING;
    } // If NO files are being preprocessed or uploaded right now, but some files are
    // being postprocessed, show the postprocess state.


    if (progress.postprocess && state !== uploadStates.STATE_UPLOADING && state !== uploadStates.STATE_PREPROCESSING) {
      state = uploadStates.STATE_POSTPROCESSING;
    }
  }

  return state;
}

function UploadStatus(props) {
  var uploadingState = getUploadingState(props.isAllErrored, props.isAllComplete, props.isAllPaused, props.files);

  switch (uploadingState) {
    case 'uploading':
      return props.i18n('uploadingXFiles', {
        smart_count: props.inProgressNotPausedFiles.length
      });

    case 'preprocessing':
    case 'postprocessing':
      return props.i18n('processingXFiles', {
        smart_count: props.processingFiles.length
      });

    case 'paused':
      return props.i18n('uploadPaused');

    case 'waiting':
      return props.i18n('xFilesSelected', {
        smart_count: props.newFiles.length
      });

    case 'complete':
      return props.i18n('uploadComplete');
  }
}

function PanelTopBar(props) {
  var allowNewUpload = props.allowNewUpload; // TODO maybe this should be done in ../index.js, then just pass that down as `allowNewUpload`

  if (allowNewUpload && props.maxNumberOfFiles) {
    allowNewUpload = props.totalFileCount < props.maxNumberOfFiles;
  }

  return h("div", {
    class: "uppy-DashboardContent-bar"
  }, !props.isAllComplete && !props.hideCancelButton ? h("button", {
    class: "uppy-DashboardContent-back",
    type: "button",
    onclick: props.cancelAll
  }, props.i18n('cancel')) : h("div", null), h("div", {
    class: "uppy-DashboardContent-title",
    role: "heading",
    "aria-level": "h1"
  }, h(UploadStatus, props)), allowNewUpload ? h("button", {
    class: "uppy-DashboardContent-addMore",
    type: "button",
    "aria-label": props.i18n('addMoreFiles'),
    title: props.i18n('addMoreFiles'),
    onclick: function onclick() {
      return props.toggleAddFilesPanel(true);
    }
  }, iconPlus(), h("span", {
    class: "uppy-DashboardContent-addMoreCaption"
  }, props.i18n('addMore'))) : h("div", null));
}

module.exports = PanelTopBar;

},{"./icons":63,"preact":17}],63:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h; // https://css-tricks.com/creating-svg-icon-system-react/


function defaultPickerIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "30",
    height: "30",
    viewBox: "0 0 30 30"
  }, h("path", {
    d: "M15 30c8.284 0 15-6.716 15-15 0-8.284-6.716-15-15-15C6.716 0 0 6.716 0 15c0 8.284 6.716 15 15 15zm4.258-12.676v6.846h-8.426v-6.846H5.204l9.82-12.364 9.82 12.364H19.26z"
  }));
}

function iconCopy() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    width: "51",
    height: "51",
    viewBox: "0 0 51 51"
  }, h("path", {
    d: "M17.21 45.765a5.394 5.394 0 0 1-7.62 0l-4.12-4.122a5.393 5.393 0 0 1 0-7.618l6.774-6.775-2.404-2.404-6.775 6.776c-3.424 3.427-3.424 9 0 12.426l4.12 4.123a8.766 8.766 0 0 0 6.216 2.57c2.25 0 4.5-.858 6.214-2.57l13.55-13.552a8.72 8.72 0 0 0 2.575-6.213 8.73 8.73 0 0 0-2.575-6.213l-4.123-4.12-2.404 2.404 4.123 4.12a5.352 5.352 0 0 1 1.58 3.81c0 1.438-.562 2.79-1.58 3.808l-13.55 13.55z"
  }), h("path", {
    d: "M44.256 2.858A8.728 8.728 0 0 0 38.043.283h-.002a8.73 8.73 0 0 0-6.212 2.574l-13.55 13.55a8.725 8.725 0 0 0-2.575 6.214 8.73 8.73 0 0 0 2.574 6.216l4.12 4.12 2.405-2.403-4.12-4.12a5.357 5.357 0 0 1-1.58-3.812c0-1.437.562-2.79 1.58-3.808l13.55-13.55a5.348 5.348 0 0 1 3.81-1.58c1.44 0 2.792.562 3.81 1.58l4.12 4.12c2.1 2.1 2.1 5.518 0 7.617L39.2 23.775l2.404 2.404 6.775-6.777c3.426-3.427 3.426-9 0-12.426l-4.12-4.12z"
  }));
}

function iconResume() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    width: "25",
    height: "25",
    viewBox: "0 0 44 44"
  }, h("polygon", {
    class: "play",
    transform: "translate(6, 5.5)",
    points: "13 21.6666667 13 11 21 16.3333333"
  }));
}

function iconPause() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    width: "25px",
    height: "25px",
    viewBox: "0 0 44 44"
  }, h("g", {
    transform: "translate(18, 17)",
    class: "pause"
  }, h("rect", {
    x: "0",
    y: "0",
    width: "2",
    height: "10",
    rx: "0"
  }), h("rect", {
    x: "6",
    y: "0",
    width: "2",
    height: "10",
    rx: "0"
  })));
}

function localIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    fill: "#607d8b",
    width: "27",
    height: "25",
    viewBox: "0 0 27 25"
  }, h("path", {
    d: "M5.586 9.288a.313.313 0 0 0 .282.176h4.84v3.922c0 1.514 1.25 2.24 2.792 2.24 1.54 0 2.79-.726 2.79-2.24V9.464h4.84c.122 0 .23-.068.284-.176a.304.304 0 0 0-.046-.324L13.735.106a.316.316 0 0 0-.472 0l-7.63 8.857a.302.302 0 0 0-.047.325z"
  }), h("path", {
    d: "M24.3 5.093c-.218-.76-.54-1.187-1.208-1.187h-4.856l1.018 1.18h3.948l2.043 11.038h-7.193v2.728H9.114v-2.725h-7.36l2.66-11.04h3.33l1.018-1.18H3.907c-.668 0-1.06.46-1.21 1.186L0 16.456v7.062C0 24.338.676 25 1.51 25h23.98c.833 0 1.51-.663 1.51-1.482v-7.062L24.3 5.093z"
  }));
}

function iconRetry() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon retry",
    width: "28",
    height: "31",
    viewBox: "0 0 16 19"
  }, h("path", {
    d: "M16 11a8 8 0 1 1-8-8v2a6 6 0 1 0 6 6h2z"
  }), h("path", {
    d: "M7.9 3H10v2H7.9z"
  }), h("path", {
    d: "M8.536.5l3.535 3.536-1.414 1.414L7.12 1.914z"
  }), h("path", {
    d: "M10.657 2.621l1.414 1.415L8.536 7.57 7.12 6.157z"
  }));
}

function checkIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon UppyIcon-check",
    width: "13",
    height: "9",
    viewBox: "0 0 13 9"
  }, h("polygon", {
    points: "5 7.293 1.354 3.647 0.646 4.354 5 8.707 12.354 1.354 11.646 0.647"
  }));
}

function iconAudio() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M9.5 18.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V7.25a.5.5 0 0 1 .379-.485l9-2.25A.5.5 0 0 1 18.5 5v11.64c0 1.14-1.145 2-2.5 2s-2.5-.86-2.5-2c0-1.14 1.145-2 2.5-2 .557 0 1.079.145 1.5.396V8.67l-8 2v7.97zm8-11v-2l-8 2v2l8-2zM7 19.64c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1zm9-2c.855 0 1.5-.484 1.5-1s-.645-1-1.5-1-1.5.484-1.5 1 .645 1 1.5 1z",
    fill: "#049BCF",
    "fill-rule": "nonzero"
  }));
}

function iconVideo() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M16 11.834l4.486-2.691A1 1 0 0 1 22 10v6a1 1 0 0 1-1.514.857L16 14.167V17a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V9a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v2.834zM15 9H5v8h10V9zm1 4l5 3v-6l-5 3z",
    fill: "#19AF67",
    "fill-rule": "nonzero"
  }));
}

function iconPDF() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M9.766 8.295c-.691-1.843-.539-3.401.747-3.726 1.643-.414 2.505.938 2.39 3.299-.039.79-.194 1.662-.537 3.148.324.49.66.967 1.055 1.51.17.231.382.488.629.757 1.866-.128 3.653.114 4.918.655 1.487.635 2.192 1.685 1.614 2.84-.566 1.133-1.839 1.084-3.416.249-1.141-.604-2.457-1.634-3.51-2.707a13.467 13.467 0 0 0-2.238.426c-1.392 4.051-4.534 6.453-5.707 4.572-.986-1.58 1.38-4.206 4.914-5.375.097-.322.185-.656.264-1.001.08-.353.306-1.31.407-1.737-.678-1.059-1.2-2.031-1.53-2.91zm2.098 4.87c-.033.144-.068.287-.104.427l.033-.01-.012.038a14.065 14.065 0 0 1 1.02-.197l-.032-.033.052-.004a7.902 7.902 0 0 1-.208-.271c-.197-.27-.38-.526-.555-.775l-.006.028-.002-.003c-.076.323-.148.632-.186.8zm5.77 2.978c1.143.605 1.832.632 2.054.187.26-.519-.087-1.034-1.113-1.473-.911-.39-2.175-.608-3.55-.608.845.766 1.787 1.459 2.609 1.894zM6.559 18.789c.14.223.693.16 1.425-.413.827-.648 1.61-1.747 2.208-3.206-2.563 1.064-4.102 2.867-3.633 3.62zm5.345-10.97c.088-1.793-.351-2.48-1.146-2.28-.473.119-.564 1.05-.056 2.405.213.566.52 1.188.908 1.859.18-.858.268-1.453.294-1.984z",
    fill: "#E2514A",
    "fill-rule": "nonzero"
  }));
}

function iconFile() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("g", {
    fill: "#A7AFB7",
    "fill-rule": "nonzero"
  }, h("path", {
    d: "M5.5 22a.5.5 0 0 1-.5-.5v-18a.5.5 0 0 1 .5-.5h10.719a.5.5 0 0 1 .367.16l3.281 3.556a.5.5 0 0 1 .133.339V21.5a.5.5 0 0 1-.5.5h-14zm.5-1h13V7.25L16 4H6v17z"
  }), h("path", {
    d: "M15 4v3a1 1 0 0 0 1 1h3V7h-3V4h-1z"
  })));
}

function iconText() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    width: "25",
    height: "25",
    viewBox: "0 0 25 25"
  }, h("path", {
    d: "M4.5 7h13a.5.5 0 1 1 0 1h-13a.5.5 0 0 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h15a.5.5 0 1 1 0 1h-15a.5.5 0 1 1 0-1zm0 3h10a.5.5 0 1 1 0 1h-10a.5.5 0 1 1 0-1z",
    fill: "#5A5E69",
    "fill-rule": "nonzero"
  }));
}

function iconCopyLink() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    width: "14",
    height: "14",
    viewBox: "0 0 14 12"
  }, h("path", {
    d: "M7.94 7.703a2.613 2.613 0 0 1-.626 2.681l-.852.851a2.597 2.597 0 0 1-1.849.766A2.616 2.616 0 0 1 2.764 7.54l.852-.852a2.596 2.596 0 0 1 2.69-.625L5.267 7.099a1.44 1.44 0 0 0-.833.407l-.852.851a1.458 1.458 0 0 0 1.03 2.486c.39 0 .755-.152 1.03-.426l.852-.852c.231-.231.363-.522.406-.824l1.04-1.038zm4.295-5.937A2.596 2.596 0 0 0 10.387 1c-.698 0-1.355.272-1.849.766l-.852.851a2.614 2.614 0 0 0-.624 2.688l1.036-1.036c.041-.304.173-.6.407-.833l.852-.852c.275-.275.64-.426 1.03-.426a1.458 1.458 0 0 1 1.03 2.486l-.852.851a1.442 1.442 0 0 1-.824.406l-1.04 1.04a2.596 2.596 0 0 0 2.683-.628l.851-.85a2.616 2.616 0 0 0 0-3.697zm-6.88 6.883a.577.577 0 0 0 .82 0l3.474-3.474a.579.579 0 1 0-.819-.82L5.355 7.83a.579.579 0 0 0 0 .819z"
  }));
}

function iconPencil() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    width: "14",
    height: "14",
    viewBox: "0 0 14 14"
  }, h("g", {
    "fill-rule": "evenodd"
  }, h("path", {
    d: "M1.5 10.793h2.793A1 1 0 0 0 5 10.5L11.5 4a1 1 0 0 0 0-1.414L9.707.793a1 1 0 0 0-1.414 0l-6.5 6.5A1 1 0 0 0 1.5 8v2.793zm1-1V8L9 1.5l1.793 1.793-6.5 6.5H2.5z",
    "fill-rule": "nonzero"
  }), h("rect", {
    x: "1",
    y: "12.293",
    width: "11",
    height: "1",
    rx: ".5"
  }), h("path", {
    "fill-rule": "nonzero",
    d: "M6.793 2.5L9.5 5.207l.707-.707L7.5 1.793z"
  })));
}

function iconCross() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    width: "18",
    height: "18",
    viewBox: "0 0 18 18"
  }, h("path", {
    d: "M9 0C4.034 0 0 4.034 0 9s4.034 9 9 9 9-4.034 9-9-4.034-9-9-9z"
  }), h("path", {
    fill: "#FFF",
    d: "M13 12.222l-.778.778L9 9.778 5.778 13 5 12.222 8.222 9 5 5.778 5.778 5 9 8.222 12.222 5l.778.778L9.778 9z"
  }));
}

function iconPlus() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    width: "15",
    height: "15",
    viewBox: "0 0 15 15"
  }, h("path", {
    d: "M8 6.5h6a.5.5 0 0 1 .5.5v.5a.5.5 0 0 1-.5.5H8v6a.5.5 0 0 1-.5.5H7a.5.5 0 0 1-.5-.5V8h-6a.5.5 0 0 1-.5-.5V7a.5.5 0 0 1 .5-.5h6v-6A.5.5 0 0 1 7 0h.5a.5.5 0 0 1 .5.5v6z"
  }));
}

module.exports = {
  defaultPickerIcon: defaultPickerIcon,
  iconCopy: iconCopy,
  iconResume: iconResume,
  iconPause: iconPause,
  iconRetry: iconRetry,
  localIcon: localIcon,
  checkIcon: checkIcon,
  iconAudio: iconAudio,
  iconVideo: iconVideo,
  iconPDF: iconPDF,
  iconFile: iconFile,
  iconText: iconText,
  iconCopyLink: iconCopyLink,
  iconPencil: iconPencil,
  iconCross: iconCross,
  iconPlus: iconPlus
};

},{"preact":17}],64:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var Translator = require('./../../utils/lib/Translator');

var DashboardUI = require('./components/Dashboard');

var StatusBar = require('./../../status-bar');

var Informer = require('./../../informer');

var ThumbnailGenerator = require('./../../thumbnail-generator');

var findAllDOMElements = require('./../../utils/lib/findAllDOMElements');

var toArray = require('./../../utils/lib/toArray');

var getDroppedFiles = require('./../../utils/lib/getDroppedFiles');

var trapFocus = require('./utils/trapFocus');

var cuid = require('cuid');

var ResizeObserver = require('resize-observer-polyfill').default || require('resize-observer-polyfill');

var _require2 = require('./components/icons'),
    defaultPickerIcon = _require2.defaultPickerIcon;

var createSuperFocus = require('./utils/createSuperFocus');

var memoize = require('memoize-one').default || require('memoize-one');

var TAB_KEY = 9;
var ESC_KEY = 27;

function createPromise() {
  var o = {};
  o.promise = new Promise(function (resolve, reject) {
    o.resolve = resolve;
    o.reject = reject;
  });
  return o;
}
/**
 * Dashboard UI with previews, metadata editing, tabs for various services and more
 */


module.exports = (_temp = _class =
/*#__PURE__*/
function (_Plugin) {
  _inheritsLoose(Dashboard, _Plugin);

  function Dashboard(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;

    _this.cancelUpload = function (fileID) {
      _this.uppy.removeFile(fileID);
    };

    _this.saveFileCard = function (meta, fileID) {
      _this.uppy.setFileMeta(fileID, meta);

      _this.toggleFileCard();
    };

    _this._attachRenderFunctionToTarget = function (target) {
      var plugin = _this.uppy.getPlugin(target.id);

      return _extends({}, target, {
        icon: plugin.icon || _this.opts.defaultPickerIcon,
        render: plugin.render
      });
    };

    _this._isTargetSupported = function (target) {
      var plugin = _this.uppy.getPlugin(target.id); // If the plugin does not provide a `supported` check, assume the plugin works everywhere.


      if (typeof plugin.isSupported !== 'function') {
        return true;
      }

      return plugin.isSupported();
    };

    _this._getAcquirers = memoize(function (targets) {
      return targets.filter(function (target) {
        return target.type === 'acquirer' && _this._isTargetSupported(target);
      }).map(_this._attachRenderFunctionToTarget);
    });
    _this._getProgressIndicators = memoize(function (targets) {
      return targets.filter(function (target) {
        return target.type === 'progressindicator';
      }).map(_this._attachRenderFunctionToTarget);
    });
    _this.id = _this.opts.id || 'Dashboard';
    _this.title = 'Dashboard';
    _this.type = 'orchestrator';
    _this.modalName = "uppy-Dashboard-" + cuid();
    _this.defaultLocale = {
      strings: {
        closeModal: 'Close Modal',
        importFrom: 'Import from %{name}',
        addingMoreFiles: 'Adding more files',
        addMoreFiles: 'Add more files',
        dashboardWindowTitle: 'File Uploader Window (Press escape to close)',
        dashboardTitle: 'File Uploader',
        copyLinkToClipboardSuccess: 'Link copied to clipboard',
        copyLinkToClipboardFallback: 'Copy the URL below',
        copyLink: 'Copy link',
        link: 'Link',
        fileSource: 'File source: %{name}',
        done: 'Done',
        back: 'Back',
        addMore: 'Add more',
        removeFile: 'Remove file',
        editFile: 'Edit file',
        editing: 'Editing %{file}',
        edit: 'Edit',
        finishEditingFile: 'Finish editing file',
        saveChanges: 'Save changes',
        cancel: 'Cancel',
        myDevice: 'My Device',
        dropPasteImport: 'Drop files here, paste, %{browse} or import from',
        dropPaste: 'Drop files here, paste or %{browse}',
        dropHint: 'Drop your files here',
        browse: 'browse',
        uploadComplete: 'Upload complete',
        uploadPaused: 'Upload paused',
        resumeUpload: 'Resume upload',
        pauseUpload: 'Pause upload',
        retryUpload: 'Retry upload',
        cancelUpload: 'Cancel upload',
        xFilesSelected: {
          0: '%{smart_count} file selected',
          1: '%{smart_count} files selected',
          2: '%{smart_count} files selected'
        },
        uploadingXFiles: {
          0: 'Uploading %{smart_count} file',
          1: 'Uploading %{smart_count} files',
          2: 'Uploading %{smart_count} files'
        },
        processingXFiles: {
          0: 'Processing %{smart_count} file',
          1: 'Processing %{smart_count} files',
          2: 'Processing %{smart_count} files'
        },
        poweredBy: 'Powered by'
      }
    }; // set default options

    var defaultOptions = {
      target: 'body',
      metaFields: [],
      trigger: '#uppy-select-files',
      inline: false,
      width: 750,
      height: 550,
      thumbnailWidth: 280,
      waitForThumbnailsBeforeUpload: false,
      defaultPickerIcon: defaultPickerIcon,
      showLinkToFileUploadResult: true,
      showProgressDetails: false,
      hideUploadButton: false,
      hideRetryButton: false,
      hidePauseResumeCancelButtons: false,
      hideProgressAfterFinish: false,
      note: null,
      closeModalOnClickOutside: false,
      closeAfterFinish: false,
      disableStatusBar: false,
      disableInformer: false,
      disableThumbnailGenerator: false,
      disablePageScrollWhenModalOpen: true,
      animateOpenClose: true,
      proudlyDisplayPoweredByUppy: true,
      onRequestCloseModal: function onRequestCloseModal() {
        return _this.closeModal();
      },
      showSelectedFiles: true,
      browserBackButtonClose: false
    }; // merge default options with the ones set by user

    _this.opts = _extends({}, defaultOptions, {}, opts);

    _this.i18nInit();

    _this.openModal = _this.openModal.bind(_assertThisInitialized(_this));
    _this.closeModal = _this.closeModal.bind(_assertThisInitialized(_this));
    _this.requestCloseModal = _this.requestCloseModal.bind(_assertThisInitialized(_this));
    _this.isModalOpen = _this.isModalOpen.bind(_assertThisInitialized(_this));
    _this.addTarget = _this.addTarget.bind(_assertThisInitialized(_this));
    _this.removeTarget = _this.removeTarget.bind(_assertThisInitialized(_this));
    _this.hideAllPanels = _this.hideAllPanels.bind(_assertThisInitialized(_this));
    _this.showPanel = _this.showPanel.bind(_assertThisInitialized(_this));
    _this.toggleFileCard = _this.toggleFileCard.bind(_assertThisInitialized(_this));
    _this.toggleAddFilesPanel = _this.toggleAddFilesPanel.bind(_assertThisInitialized(_this));
    _this.initEvents = _this.initEvents.bind(_assertThisInitialized(_this));
    _this.handlePopState = _this.handlePopState.bind(_assertThisInitialized(_this));
    _this.handleKeyDownInModal = _this.handleKeyDownInModal.bind(_assertThisInitialized(_this));
    _this.handleKeyDownInInline = _this.handleKeyDownInInline.bind(_assertThisInitialized(_this));
    _this.handleComplete = _this.handleComplete.bind(_assertThisInitialized(_this));
    _this.handleClickOutside = _this.handleClickOutside.bind(_assertThisInitialized(_this));
    _this.handlePaste = _this.handlePaste.bind(_assertThisInitialized(_this));
    _this.handlePasteOnBody = _this.handlePasteOnBody.bind(_assertThisInitialized(_this));
    _this.handleInputChange = _this.handleInputChange.bind(_assertThisInitialized(_this));
    _this.handleDragOver = _this.handleDragOver.bind(_assertThisInitialized(_this));
    _this.handleDragLeave = _this.handleDragLeave.bind(_assertThisInitialized(_this));
    _this.handleDrop = _this.handleDrop.bind(_assertThisInitialized(_this));
    _this.superFocusOnEachUpdate = _this.superFocusOnEachUpdate.bind(_assertThisInitialized(_this));
    _this.recordIfFocusedOnUppyRecently = _this.recordIfFocusedOnUppyRecently.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    _this.install = _this.install.bind(_assertThisInitialized(_this));
    _this.superFocus = createSuperFocus();
    _this.ifFocusedOnUppyRecently = false; // Timeouts

    _this.makeDashboardInsidesVisibleAnywayTimeout = null;
    _this.removeDragOverClassTimeout = null;
    return _this;
  }

  var _proto = Dashboard.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, newOpts);

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.i18nArray = this.translator.translateArray.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  };

  _proto.removeTarget = function removeTarget(plugin) {
    var pluginState = this.getPluginState(); // filter out the one we want to remove

    var newTargets = pluginState.targets.filter(function (target) {
      return target.id !== plugin.id;
    });
    this.setPluginState({
      targets: newTargets
    });
  };

  _proto.addTarget = function addTarget(plugin) {
    var callerPluginId = plugin.id || plugin.constructor.name;
    var callerPluginName = plugin.title || callerPluginId;
    var callerPluginType = plugin.type;

    if (callerPluginType !== 'acquirer' && callerPluginType !== 'progressindicator' && callerPluginType !== 'presenter') {
      var msg = 'Dashboard: Modal can only be used by plugins of types: acquirer, progressindicator, presenter';
      this.uppy.log(msg, 'error');
      return;
    }

    var target = {
      id: callerPluginId,
      name: callerPluginName,
      type: callerPluginType
    };
    var state = this.getPluginState();
    var newTargets = state.targets.slice();
    newTargets.push(target);
    this.setPluginState({
      targets: newTargets
    });
    return this.el;
  };

  _proto.hideAllPanels = function hideAllPanels() {
    var update = {
      activePickerPanel: false,
      showAddFilesPanel: false,
      activeOverlayType: null
    };
    var current = this.getPluginState();

    if (current.activePickerPanel === update.activePickerPanel && current.showAddFilesPanel === update.showAddFilesPanel && current.activeOverlayType === update.activeOverlayType) {
      // avoid doing a state update if nothing changed
      return;
    }

    this.setPluginState(update);
  };

  _proto.showPanel = function showPanel(id) {
    var _this$getPluginState = this.getPluginState(),
        targets = _this$getPluginState.targets;

    var activePickerPanel = targets.filter(function (target) {
      return target.type === 'acquirer' && target.id === id;
    })[0];
    this.setPluginState({
      activePickerPanel: activePickerPanel,
      activeOverlayType: 'PickerPanel'
    });
  };

  _proto.openModal = function openModal() {
    var _this2 = this;

    var _createPromise = createPromise(),
        promise = _createPromise.promise,
        resolve = _createPromise.resolve; // save scroll position


    this.savedScrollPosition = window.pageYOffset; // save active element, so we can restore focus when modal is closed

    this.savedActiveElement = document.activeElement;

    if (this.opts.disablePageScrollWhenModalOpen) {
      document.body.classList.add('uppy-Dashboard-isFixed');
    }

    if (this.opts.animateOpenClose && this.getPluginState().isClosing) {
      var handler = function handler() {
        _this2.setPluginState({
          isHidden: false
        });

        _this2.el.removeEventListener('animationend', handler, false);

        resolve();
      };

      this.el.addEventListener('animationend', handler, false);
    } else {
      this.setPluginState({
        isHidden: false
      });
      resolve();
    }

    if (this.opts.browserBackButtonClose) {
      this.updateBrowserHistory();
    } // handle ESC and TAB keys in modal dialog


    document.addEventListener('keydown', this.handleKeyDownInModal);
    this.uppy.emit('dashboard:modal-open');
    return promise;
  };

  _proto.closeModal = function closeModal(opts) {
    var _this3 = this;

    if (opts === void 0) {
      opts = {};
    }

    var _opts = opts,
        _opts$manualClose = _opts.manualClose,
        manualClose = _opts$manualClose === void 0 ? true : _opts$manualClose;

    var _this$getPluginState2 = this.getPluginState(),
        isHidden = _this$getPluginState2.isHidden,
        isClosing = _this$getPluginState2.isClosing;

    if (isHidden || isClosing) {
      // short-circuit if animation is ongoing
      return;
    }

    var _createPromise2 = createPromise(),
        promise = _createPromise2.promise,
        resolve = _createPromise2.resolve;

    if (this.opts.disablePageScrollWhenModalOpen) {
      document.body.classList.remove('uppy-Dashboard-isFixed');
    }

    if (this.opts.animateOpenClose) {
      this.setPluginState({
        isClosing: true
      });

      var handler = function handler() {
        _this3.setPluginState({
          isHidden: true,
          isClosing: false
        });

        _this3.superFocus.cancel();

        _this3.savedActiveElement.focus();

        _this3.el.removeEventListener('animationend', handler, false);

        resolve();
      };

      this.el.addEventListener('animationend', handler, false);
    } else {
      this.setPluginState({
        isHidden: true
      });
      this.superFocus.cancel();
      this.savedActiveElement.focus();
      resolve();
    } // handle ESC and TAB keys in modal dialog


    document.removeEventListener('keydown', this.handleKeyDownInModal);

    if (manualClose) {
      if (this.opts.browserBackButtonClose) {
        // Make sure that the latest entry in the history state is our modal name
        if (history.state && history.state[this.modalName]) {
          // Go back in history to clear out the entry we created (ultimately closing the modal)
          history.go(-1);
        }
      }
    }

    this.uppy.emit('dashboard:modal-closed');
    return promise;
  };

  _proto.isModalOpen = function isModalOpen() {
    return !this.getPluginState().isHidden || false;
  };

  _proto.requestCloseModal = function requestCloseModal() {
    if (this.opts.onRequestCloseModal) {
      return this.opts.onRequestCloseModal();
    }

    return this.closeModal();
  };

  _proto.toggleFileCard = function toggleFileCard(fileId) {
    if (fileId) {
      this.uppy.emit('dashboard:file-edit-start');
    } else {
      this.uppy.emit('dashboard:file-edit-complete');
    }

    this.setPluginState({
      fileCardFor: fileId || null,
      activeOverlayType: fileId ? 'FileCard' : null
    });
  };

  _proto.toggleAddFilesPanel = function toggleAddFilesPanel(show) {
    this.setPluginState({
      showAddFilesPanel: show,
      activeOverlayType: show ? 'AddFiles' : null
    });
  };

  _proto.addFiles = function addFiles(files) {
    var _this4 = this;

    var descriptors = files.map(function (file) {
      return {
        source: _this4.id,
        name: file.name,
        type: file.type,
        data: file,
        meta: {
          // path of the file relative to the ancestor directory the user selected.
          // e.g. 'docs/Old Prague/airbnb.pdf'
          relativePath: file.relativePath || null
        }
      };
    });

    try {
      this.uppy.addFiles(descriptors);
    } catch (err) {
      this.uppy.log(err);
    }
  } // ___Why make insides of Dashboard invisible until first ResizeObserver event is emitted?
  //    ResizeOberserver doesn't emit the first resize event fast enough, users can see the jump from one .uppy-size-- to another (e.g. in Safari)
  // ___Why not apply visibility property to .uppy-Dashboard-inner?
  //    Because ideally, acc to specs, ResizeObserver should see invisible elements as of width 0. So even though applying invisibility to .uppy-Dashboard-inner works now, it may not work in the future.
  ;

  _proto.startListeningToResize = function startListeningToResize() {
    var _this5 = this;

    // Watch for Dashboard container (`.uppy-Dashboard-inner`) resize
    // and update containerWidth/containerHeight in plugin state accordingly.
    // Emits first event on initialization.
    this.resizeObserver = new ResizeObserver(function (entries, observer) {
      var uppyDashboardInnerEl = entries[0];
      var _uppyDashboardInnerEl = uppyDashboardInnerEl.contentRect,
          width = _uppyDashboardInnerEl.width,
          height = _uppyDashboardInnerEl.height;

      _this5.uppy.log("[Dashboard] resized: " + width + " / " + height, 'debug');

      _this5.setPluginState({
        containerWidth: width,
        containerHeight: height,
        areInsidesReadyToBeVisible: true
      });
    });
    this.resizeObserver.observe(this.el.querySelector('.uppy-Dashboard-inner')); // If ResizeObserver fails to emit an event telling us what size to use - default to the mobile view

    this.makeDashboardInsidesVisibleAnywayTimeout = setTimeout(function () {
      var pluginState = _this5.getPluginState();

      var isModalAndClosed = !_this5.opts.inline && pluginState.isHidden;

      if ( // if ResizeObserver hasn't yet fired,
      !pluginState.areInsidesReadyToBeVisible && // and it's not due to the modal being closed
      !isModalAndClosed) {
        _this5.uppy.log("[Dashboard] resize event didn't fire on time: defaulted to mobile layout", 'debug');

        _this5.setPluginState({
          areInsidesReadyToBeVisible: true
        });
      }
    }, 1000);
  };

  _proto.stopListeningToResize = function stopListeningToResize() {
    this.resizeObserver.disconnect();
    clearTimeout(this.makeDashboardInsidesVisibleAnywayTimeout);
  } // Records whether we have been interacting with uppy right now, which is then used to determine whether state updates should trigger a refocusing.
  ;

  _proto.recordIfFocusedOnUppyRecently = function recordIfFocusedOnUppyRecently(event) {
    if (this.el.contains(event.target)) {
      this.ifFocusedOnUppyRecently = true;
    } else {
      this.ifFocusedOnUppyRecently = false; // ___Why run this.superFocus.cancel here when it already runs in superFocusOnEachUpdate?
      //    Because superFocus is debounced, when we move from Uppy to some other element on the page,
      //    previously run superFocus sometimes hits and moves focus back to Uppy.

      this.superFocus.cancel();
    }
  };

  _proto.updateBrowserHistory = function updateBrowserHistory() {
    // Ensure history state does not already contain our modal name to avoid double-pushing
    if (!history.state || !history.state[this.modalName]) {
      var _extends2;

      // Push to history so that the page is not lost on browser back button press
      history.pushState(_extends({}, history.state, (_extends2 = {}, _extends2[this.modalName] = true, _extends2)), '');
    } // Listen for back button presses


    window.addEventListener('popstate', this.handlePopState, false);
  };

  _proto.handlePopState = function handlePopState(event) {
    // Close the modal if the history state no longer contains our modal name
    if (this.isModalOpen() && (!event.state || !event.state[this.modalName])) {
      this.closeModal({
        manualClose: false
      });
    } // When the browser back button is pressed and uppy is now the latest entry in the history but the modal is closed, fix the history by removing the uppy history entry
    // This occurs when another entry is added into the history state while the modal is open, and then the modal gets manually closed
    // Solves PR #575 (https://github.com/transloadit/uppy/pull/575)


    if (!this.isModalOpen() && event.state && event.state[this.modalName]) {
      history.go(-1);
    }
  };

  _proto.handleKeyDownInModal = function handleKeyDownInModal(event) {
    // close modal on esc key press
    if (event.keyCode === ESC_KEY) this.requestCloseModal(event); // trap focus on tab key press

    if (event.keyCode === TAB_KEY) trapFocus.forModal(event, this.getPluginState().activeOverlayType, this.el);
  };

  _proto.handleClickOutside = function handleClickOutside() {
    if (this.opts.closeModalOnClickOutside) this.requestCloseModal();
  };

  _proto.handlePaste = function handlePaste(event) {
    // 1. Let any acquirer plugin (Url/Webcam/etc.) handle pastes to the root
    this.uppy.iteratePlugins(function (plugin) {
      if (plugin.type === 'acquirer') {
        // Every Plugin with .type acquirer can define handleRootPaste(event)
        plugin.handleRootPaste && plugin.handleRootPaste(event);
      }
    }); // 2. Add all dropped files

    var files = toArray(event.clipboardData.files);
    this.addFiles(files);
  };

  _proto.handleInputChange = function handleInputChange(event) {
    event.preventDefault();
    var files = toArray(event.target.files);
    this.addFiles(files);
  };

  _proto.handleDragOver = function handleDragOver(event) {
    event.preventDefault();
    event.stopPropagation(); // 1. Add a small (+) icon on drop
    // (and prevent browsers from interpreting this as files being _moved_ into the browser, https://github.com/transloadit/uppy/issues/1978)

    event.dataTransfer.dropEffect = 'copy';
    clearTimeout(this.removeDragOverClassTimeout);
    this.setPluginState({
      isDraggingOver: true
    });
  };

  _proto.handleDragLeave = function handleDragLeave(event) {
    var _this6 = this;

    event.preventDefault();
    event.stopPropagation();
    clearTimeout(this.removeDragOverClassTimeout); // Timeout against flickering, this solution is taken from drag-drop library. Solution with 'pointer-events: none' didn't work across browsers.

    this.removeDragOverClassTimeout = setTimeout(function () {
      _this6.setPluginState({
        isDraggingOver: false
      });
    }, 50);
  };

  _proto.handleDrop = function handleDrop(event, dropCategory) {
    var _this7 = this;

    event.preventDefault();
    event.stopPropagation();
    clearTimeout(this.removeDragOverClassTimeout); // 2. Remove dragover class

    this.setPluginState({
      isDraggingOver: false
    }); // 3. Let any acquirer plugin (Url/Webcam/etc.) handle drops to the root

    this.uppy.iteratePlugins(function (plugin) {
      if (plugin.type === 'acquirer') {
        // Every Plugin with .type acquirer can define handleRootDrop(event)
        plugin.handleRootDrop && plugin.handleRootDrop(event);
      }
    }); // 4. Add all dropped files

    var executedDropErrorOnce = false;

    var logDropError = function logDropError(error) {
      _this7.uppy.log(error, 'error'); // In practice all drop errors are most likely the same, so let's just show one to avoid overwhelming the user


      if (!executedDropErrorOnce) {
        _this7.uppy.info(error.message, 'error');

        executedDropErrorOnce = true;
      }
    };

    getDroppedFiles(event.dataTransfer, {
      logDropError: logDropError
    }).then(function (files) {
      if (files.length > 0) {
        _this7.uppy.log('[Dashboard] Files were dropped');

        _this7.addFiles(files);
      }
    });
  };

  _proto.handleKeyDownInInline = function handleKeyDownInInline(event) {
    // Trap focus on tab key press.
    if (event.keyCode === TAB_KEY) trapFocus.forInline(event, this.getPluginState().activeOverlayType, this.el);
  } // ___Why do we listen to the 'paste' event on a document instead of onPaste={props.handlePaste} prop, or this.el.addEventListener('paste')?
  //    Because (at least) Chrome doesn't handle paste if focus is on some button, e.g. 'My Device'.
  //    => Therefore, the best option is to listen to all 'paste' events, and only react to them when we are focused on our particular Uppy instance.
  // ___Why do we still need onPaste={props.handlePaste} for the DashboardUi?
  //    Because if we click on the 'Drop files here' caption e.g., `document.activeElement` will be 'body'. Which means our standard determination of whether we're pasting into our Uppy instance won't work.
  //    => Therefore, we need a traditional onPaste={props.handlePaste} handler too.
  ;

  _proto.handlePasteOnBody = function handlePasteOnBody(event) {
    var isFocusInOverlay = this.el.contains(document.activeElement);

    if (isFocusInOverlay) {
      this.handlePaste(event);
    }
  };

  _proto.handleComplete = function handleComplete(_ref) {
    var failed = _ref.failed,
        uploadID = _ref.uploadID;

    if (this.opts.closeAfterFinish && failed.length === 0) {
      // All uploads are done
      this.requestCloseModal();
    }
  };

  _proto.initEvents = function initEvents() {
    var _this8 = this;

    // Modal open button
    var showModalTrigger = findAllDOMElements(this.opts.trigger);

    if (!this.opts.inline && showModalTrigger) {
      showModalTrigger.forEach(function (trigger) {
        return trigger.addEventListener('click', _this8.openModal);
      });
    }

    if (!this.opts.inline && !showModalTrigger) {
      this.uppy.log('Dashboard modal trigger not found. Make sure `trigger` is set in Dashboard options unless you are planning to call openModal() method yourself', 'error');
    }

    this.startListeningToResize();
    document.addEventListener('paste', this.handlePasteOnBody);
    this.uppy.on('plugin-remove', this.removeTarget);
    this.uppy.on('file-added', this.hideAllPanels);
    this.uppy.on('dashboard:modal-closed', this.hideAllPanels);
    this.uppy.on('complete', this.handleComplete); // ___Why fire on capture?
    //    Because this.ifFocusedOnUppyRecently needs to change before onUpdate() fires.

    document.addEventListener('focus', this.recordIfFocusedOnUppyRecently, true);
    document.addEventListener('click', this.recordIfFocusedOnUppyRecently, true);

    if (this.opts.inline) {
      this.el.addEventListener('keydown', this.handleKeyDownInInline);
    }
  };

  _proto.removeEvents = function removeEvents() {
    var _this9 = this;

    var showModalTrigger = findAllDOMElements(this.opts.trigger);

    if (!this.opts.inline && showModalTrigger) {
      showModalTrigger.forEach(function (trigger) {
        return trigger.removeEventListener('click', _this9.openModal);
      });
    }

    this.stopListeningToResize();
    document.removeEventListener('paste', this.handlePasteOnBody);
    window.removeEventListener('popstate', this.handlePopState, false);
    this.uppy.off('plugin-remove', this.removeTarget);
    this.uppy.off('file-added', this.hideAllPanels);
    this.uppy.off('dashboard:modal-closed', this.hideAllPanels);
    this.uppy.off('complete', this.handleComplete);
    document.removeEventListener('focus', this.recordIfFocusedOnUppyRecently);
    document.removeEventListener('click', this.recordIfFocusedOnUppyRecently);

    if (this.opts.inline) {
      this.el.removeEventListener('keydown', this.handleKeyDownInInline);
    }
  };

  _proto.superFocusOnEachUpdate = function superFocusOnEachUpdate() {
    var isFocusInUppy = this.el.contains(document.activeElement); // When focus is lost on the page (== focus is on body for most browsers, or focus is null for IE11)

    var isFocusNowhere = document.activeElement === document.querySelector('body') || document.activeElement === null;
    var isInformerHidden = this.uppy.getState().info.isHidden;
    var isModal = !this.opts.inline;

    if ( // If update is connected to showing the Informer - let the screen reader calmly read it.
    isInformerHidden && ( // If we are in a modal - always superfocus without concern for other elements on the page (user is unlikely to want to interact with the rest of the page)
    isModal || // If we are already inside of Uppy, or
    isFocusInUppy || // If we are not focused on anything BUT we have already, at least once, focused on uppy
    //   1. We focus when isFocusNowhere, because when the element we were focused on disappears (e.g. an overlay), - focus gets lost. If user is typing something somewhere else on the page, - focus won't be 'nowhere'.
    //   2. We only focus when focus is nowhere AND this.ifFocusedOnUppyRecently, to avoid focus jumps if we do something else on the page.
    //   [Practical check] Without '&& this.ifFocusedOnUppyRecently', in Safari, in inline mode, when file is uploading, - navigate via tab to the checkbox, try to press space multiple times. Focus will jump to Uppy.
    isFocusNowhere && this.ifFocusedOnUppyRecently)) {
      this.superFocus(this.el, this.getPluginState().activeOverlayType);
    } else {
      this.superFocus.cancel();
    }
  };

  _proto.afterUpdate = function afterUpdate() {
    this.superFocusOnEachUpdate();
  };

  _proto.render = function render(state) {
    var pluginState = this.getPluginState();
    var files = state.files,
        capabilities = state.capabilities,
        allowNewUpload = state.allowNewUpload; // TODO: move this to Core, to share between Status Bar and Dashboard
    // (and any other plugin that might need it, too)

    var newFiles = Object.keys(files).filter(function (file) {
      return !files[file].progress.uploadStarted;
    });
    var uploadStartedFiles = Object.keys(files).filter(function (file) {
      return files[file].progress.uploadStarted;
    });
    var pausedFiles = Object.keys(files).filter(function (file) {
      return files[file].isPaused;
    });
    var completeFiles = Object.keys(files).filter(function (file) {
      return files[file].progress.uploadComplete;
    });
    var erroredFiles = Object.keys(files).filter(function (file) {
      return files[file].error;
    });
    var inProgressFiles = Object.keys(files).filter(function (file) {
      return !files[file].progress.uploadComplete && files[file].progress.uploadStarted;
    });
    var inProgressNotPausedFiles = inProgressFiles.filter(function (file) {
      return !files[file].isPaused;
    });
    var processingFiles = Object.keys(files).filter(function (file) {
      return files[file].progress.preprocess || files[file].progress.postprocess;
    });
    var isUploadStarted = uploadStartedFiles.length > 0;
    var isAllComplete = state.totalProgress === 100 && completeFiles.length === Object.keys(files).length && processingFiles.length === 0;
    var isAllErrored = isUploadStarted && erroredFiles.length === uploadStartedFiles.length;
    var isAllPaused = inProgressFiles.length !== 0 && pausedFiles.length === inProgressFiles.length;

    var acquirers = this._getAcquirers(pluginState.targets);

    var progressindicators = this._getProgressIndicators(pluginState.targets);

    return DashboardUI({
      state: state,
      isHidden: pluginState.isHidden,
      files: files,
      newFiles: newFiles,
      uploadStartedFiles: uploadStartedFiles,
      completeFiles: completeFiles,
      erroredFiles: erroredFiles,
      inProgressFiles: inProgressFiles,
      inProgressNotPausedFiles: inProgressNotPausedFiles,
      processingFiles: processingFiles,
      isUploadStarted: isUploadStarted,
      isAllComplete: isAllComplete,
      isAllErrored: isAllErrored,
      isAllPaused: isAllPaused,
      totalFileCount: Object.keys(files).length,
      totalProgress: state.totalProgress,
      allowNewUpload: allowNewUpload,
      acquirers: acquirers,
      activePickerPanel: pluginState.activePickerPanel,
      animateOpenClose: this.opts.animateOpenClose,
      isClosing: pluginState.isClosing,
      getPlugin: this.uppy.getPlugin,
      progressindicators: progressindicators,
      autoProceed: this.uppy.opts.autoProceed,
      id: this.id,
      closeModal: this.requestCloseModal,
      handleClickOutside: this.handleClickOutside,
      handleInputChange: this.handleInputChange,
      handlePaste: this.handlePaste,
      inline: this.opts.inline,
      showPanel: this.showPanel,
      hideAllPanels: this.hideAllPanels,
      log: this.uppy.log,
      i18n: this.i18n,
      i18nArray: this.i18nArray,
      removeFile: this.uppy.removeFile,
      info: this.uppy.info,
      note: this.opts.note,
      metaFields: pluginState.metaFields,
      resumableUploads: capabilities.resumableUploads || false,
      individualCancellation: capabilities.individualCancellation,
      pauseUpload: this.uppy.pauseResume,
      retryUpload: this.uppy.retryUpload,
      cancelUpload: this.cancelUpload,
      cancelAll: this.uppy.cancelAll,
      fileCardFor: pluginState.fileCardFor,
      toggleFileCard: this.toggleFileCard,
      toggleAddFilesPanel: this.toggleAddFilesPanel,
      showAddFilesPanel: pluginState.showAddFilesPanel,
      saveFileCard: this.saveFileCard,
      width: this.opts.width,
      height: this.opts.height,
      showLinkToFileUploadResult: this.opts.showLinkToFileUploadResult,
      proudlyDisplayPoweredByUppy: this.opts.proudlyDisplayPoweredByUppy,
      hideCancelButton: this.opts.hideCancelButton,
      containerWidth: pluginState.containerWidth,
      containerHeight: pluginState.containerHeight,
      areInsidesReadyToBeVisible: pluginState.areInsidesReadyToBeVisible,
      isTargetDOMEl: this.isTargetDOMEl,
      parentElement: this.el,
      allowedFileTypes: this.uppy.opts.restrictions.allowedFileTypes,
      maxNumberOfFiles: this.uppy.opts.restrictions.maxNumberOfFiles,
      showSelectedFiles: this.opts.showSelectedFiles,
      // drag props
      isDraggingOver: pluginState.isDraggingOver,
      handleDragOver: this.handleDragOver,
      handleDragLeave: this.handleDragLeave,
      handleDrop: this.handleDrop
    });
  };

  _proto.discoverProviderPlugins = function discoverProviderPlugins() {
    var _this10 = this;

    this.uppy.iteratePlugins(function (plugin) {
      if (plugin && !plugin.target && plugin.opts && plugin.opts.target === _this10.constructor) {
        _this10.addTarget(plugin);
      }
    });
  };

  _proto.install = function install() {
    var _this11 = this;

    // Set default state for Dashboard
    this.setPluginState({
      isHidden: true,
      fileCardFor: null,
      activeOverlayType: null,
      showAddFilesPanel: false,
      activePickerPanel: false,
      metaFields: this.opts.metaFields,
      targets: [],
      // We'll make them visible once .containerWidth is determined
      areInsidesReadyToBeVisible: false,
      isDraggingOver: false
    });
    var _this$opts = this.opts,
        inline = _this$opts.inline,
        closeAfterFinish = _this$opts.closeAfterFinish;

    if (inline && closeAfterFinish) {
      throw new Error('[Dashboard] `closeAfterFinish: true` cannot be used on an inline Dashboard, because an inline Dashboard cannot be closed at all. Either set `inline: false`, or disable the `closeAfterFinish` option.');
    }

    var allowMultipleUploads = this.uppy.opts.allowMultipleUploads;

    if (allowMultipleUploads && closeAfterFinish) {
      this.uppy.log('[Dashboard] When using `closeAfterFinish`, we recommended setting the `allowMultipleUploads` option to `false` in the Uppy constructor. See https://uppy.io/docs/uppy/#allowMultipleUploads-true', 'warning');
    }

    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }

    var plugins = this.opts.plugins || [];
    plugins.forEach(function (pluginID) {
      var plugin = _this11.uppy.getPlugin(pluginID);

      if (plugin) {
        plugin.mount(_this11, plugin);
      }
    });

    if (!this.opts.disableStatusBar) {
      this.uppy.use(StatusBar, {
        id: this.id + ":StatusBar",
        target: this,
        hideUploadButton: this.opts.hideUploadButton,
        hideRetryButton: this.opts.hideRetryButton,
        hidePauseResumeButton: this.opts.hidePauseResumeButton,
        hideCancelButton: this.opts.hideCancelButton,
        showProgressDetails: this.opts.showProgressDetails,
        hideAfterFinish: this.opts.hideProgressAfterFinish,
        locale: this.opts.locale
      });
    }

    if (!this.opts.disableInformer) {
      this.uppy.use(Informer, {
        id: this.id + ":Informer",
        target: this
      });
    }

    if (!this.opts.disableThumbnailGenerator) {
      this.uppy.use(ThumbnailGenerator, {
        id: this.id + ":ThumbnailGenerator",
        thumbnailWidth: this.opts.thumbnailWidth,
        waitForThumbnailsBeforeUpload: this.opts.waitForThumbnailsBeforeUpload
      });
    }

    this.discoverProviderPlugins();
    this.initEvents();
  };

  _proto.uninstall = function uninstall() {
    var _this12 = this;

    if (!this.opts.disableInformer) {
      var informer = this.uppy.getPlugin(this.id + ":Informer"); // Checking if this plugin exists, in case it was removed by uppy-core
      // before the Dashboard was.

      if (informer) this.uppy.removePlugin(informer);
    }

    if (!this.opts.disableStatusBar) {
      var statusBar = this.uppy.getPlugin(this.id + ":StatusBar");
      if (statusBar) this.uppy.removePlugin(statusBar);
    }

    if (!this.opts.disableThumbnailGenerator) {
      var thumbnail = this.uppy.getPlugin(this.id + ":ThumbnailGenerator");
      if (thumbnail) this.uppy.removePlugin(thumbnail);
    }

    var plugins = this.opts.plugins || [];
    plugins.forEach(function (pluginID) {
      var plugin = _this12.uppy.getPlugin(pluginID);

      if (plugin) plugin.unmount();
    });
    this.unmount();
    this.removeEvents();
  };

  return Dashboard;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":48,"./../../core":45,"./../../informer":80,"./../../status-bar":101,"./../../thumbnail-generator":107,"./../../utils/lib/Translator":118,"./../../utils/lib/findAllDOMElements":122,"./../../utils/lib/getDroppedFiles":126,"./../../utils/lib/toArray":147,"./components/Dashboard":51,"./components/icons":63,"./utils/createSuperFocus":66,"./utils/trapFocus":70,"cuid":2,"memoize-one":13,"resize-observer-polyfill":21}],65:[function(require,module,exports){
/**
 * Copies text to clipboard by creating an almost invisible textarea,
 * adding text there, then running execCommand('copy').
 * Falls back to prompt() when the easy way fails (hello, Safari!)
 * From http://stackoverflow.com/a/30810322
 *
 * @param {string} textToCopy
 * @param {string} fallbackString
 * @returns {Promise}
 */
module.exports = function copyToClipboard(textToCopy, fallbackString) {
  fallbackString = fallbackString || 'Copy the URL below';
  return new Promise(function (resolve) {
    var textArea = document.createElement('textarea');
    textArea.setAttribute('style', {
      position: 'fixed',
      top: 0,
      left: 0,
      width: '2em',
      height: '2em',
      padding: 0,
      border: 'none',
      outline: 'none',
      boxShadow: 'none',
      background: 'transparent'
    });
    textArea.value = textToCopy;
    document.body.appendChild(textArea);
    textArea.select();

    var magicCopyFailed = function magicCopyFailed() {
      document.body.removeChild(textArea);
      window.prompt(fallbackString, textToCopy);
      resolve();
    };

    try {
      var successful = document.execCommand('copy');

      if (!successful) {
        return magicCopyFailed('copy command unavailable');
      }

      document.body.removeChild(textArea);
      return resolve();
    } catch (err) {
      document.body.removeChild(textArea);
      return magicCopyFailed(err);
    }
  });
};

},{}],66:[function(require,module,exports){
var debounce = require('lodash.debounce');

var FOCUSABLE_ELEMENTS = require('./../../../utils/lib/FOCUSABLE_ELEMENTS');

var getActiveOverlayEl = require('./getActiveOverlayEl');
/*
  Focuses on some element in the currently topmost overlay.

  1. If there are some [data-uppy-super-focusable] elements rendered already - focuses on the first superfocusable element, and leaves focus up to the control of a user (until currently focused element disappears from the screen [which can happen when overlay changes, or, e.g., when we click on a folder in googledrive]).
  2. If there are no [data-uppy-super-focusable] elements yet (or ever) - focuses on the first focusable element, but switches focus if superfocusable elements appear on next render.
*/


module.exports = function createSuperFocus() {
  var lastFocusWasOnSuperFocusableEl = false;

  var superFocus = function superFocus(dashboardEl, activeOverlayType) {
    var overlayEl = getActiveOverlayEl(dashboardEl, activeOverlayType);
    var isFocusInOverlay = overlayEl.contains(document.activeElement); // If focus is already in the topmost overlay, AND on last update we focused on the superfocusable element - then leave focus up to the user.
    // [Practical check] without this line, typing in the search input in googledrive overlay won't work.

    if (isFocusInOverlay && lastFocusWasOnSuperFocusableEl) return;
    var superFocusableEl = overlayEl.querySelector('[data-uppy-super-focusable]'); // If we are already in the topmost overlay, AND there are no super focusable elements yet, - leave focus up to the user.
    // [Practical check] without this line, if you are in an empty folder in google drive, and something's uploading in the bg, - focus will be jumping to Done all the time.

    if (isFocusInOverlay && !superFocusableEl) return;

    if (superFocusableEl) {
      superFocusableEl.focus({
        preventScroll: true
      });
      lastFocusWasOnSuperFocusableEl = true;
    } else {
      var firstEl = overlayEl.querySelector(FOCUSABLE_ELEMENTS);
      firstEl && firstEl.focus({
        preventScroll: true
      });
      lastFocusWasOnSuperFocusableEl = false;
    }
  }; // ___Why do we need to debounce?
  //    1. To deal with animations: overlay changes via animations, which results in the DOM updating AFTER plugin.update() already executed.
  //    [Practical check] without debounce, if we open the Url overlay, and click 'Done', Dashboard won't get focused again.
  //    [Practical check] if we delay 250ms instead of 260ms - IE11 won't get focused in same situation.
  //    2. Performance: there can be many state update()s in a second, and this function is called every time.


  return debounce(superFocus, 260);
};

},{"./../../../utils/lib/FOCUSABLE_ELEMENTS":116,"./getActiveOverlayEl":67,"lodash.debounce":11}],67:[function(require,module,exports){
/**
 * @returns {HTMLElement} - either dashboard element, or the overlay that's most on top
 */
module.exports = function getActiveOverlayEl(dashboardEl, activeOverlayType) {
  if (activeOverlayType) {
    var overlayEl = dashboardEl.querySelector("[data-uppy-paneltype=\"" + activeOverlayType + "\"]"); // if an overlay is already mounted

    if (overlayEl) return overlayEl;
  }

  return dashboardEl;
};

},{}],68:[function(require,module,exports){
var _require = require('../components/icons'),
    iconFile = _require.iconFile,
    iconText = _require.iconText,
    iconAudio = _require.iconAudio,
    iconVideo = _require.iconVideo,
    iconPDF = _require.iconPDF;

module.exports = function getIconByMime(fileType) {
  var defaultChoice = {
    color: '#838999',
    icon: iconFile()
  };
  if (!fileType) return defaultChoice;
  var fileTypeGeneral = fileType.split('/')[0];
  var fileTypeSpecific = fileType.split('/')[1];

  if (fileTypeGeneral === 'text') {
    return {
      color: '#5a5e69',
      icon: iconText()
    };
  }

  if (fileTypeGeneral === 'audio') {
    return {
      color: '#068dbb',
      icon: iconAudio()
    };
  }

  if (fileTypeGeneral === 'video') {
    return {
      color: '#19af67',
      icon: iconVideo()
    };
  }

  if (fileTypeGeneral === 'application' && fileTypeSpecific === 'pdf') {
    return {
      color: '#e25149',
      icon: iconPDF()
    };
  }

  if (fileTypeGeneral === 'image') {
    return {
      color: '#f2f2f2',
      icon: ''
    };
  }

  return defaultChoice;
};

},{"../components/icons":63}],69:[function(require,module,exports){
// ignore drop/paste events if they are not in input or textarea —
// otherwise when Url plugin adds drop/paste listeners to this.el,
// draging UI elements or pasting anything into any field triggers those events —
// Url treats them as URLs that need to be imported
function ignoreEvent(ev) {
  var tagName = ev.target.tagName;

  if (tagName === 'INPUT' || tagName === 'TEXTAREA') {
    ev.stopPropagation();
    return;
  }

  ev.preventDefault();
  ev.stopPropagation();
}

module.exports = ignoreEvent;

},{}],70:[function(require,module,exports){
var toArray = require('./../../../utils/lib/toArray');

var getActiveOverlayEl = require('./getActiveOverlayEl');

var FOCUSABLE_ELEMENTS = require('./../../../utils/lib/FOCUSABLE_ELEMENTS');

function focusOnFirstNode(event, nodes) {
  var node = nodes[0];

  if (node) {
    node.focus();
    event.preventDefault();
  }
}

function focusOnLastNode(event, nodes) {
  var node = nodes[nodes.length - 1];

  if (node) {
    node.focus();
    event.preventDefault();
  }
} // ___Why not just use (focusedItemIndex === -1)?
//    Firefox thinks <ul> is focusable, but we don't have <ul>s in our FOCUSABLE_ELEMENTS. Which means that if we tab into the <ul>, code will think that we are not in the active overlay, and we should focusOnFirstNode() of the currently active overlay!
//    [Practical check] if we use (focusedItemIndex === -1), instagram provider in firefox will never get focus on its pics in the <ul>.


function isFocusInOverlay(activeOverlayEl) {
  return activeOverlayEl.contains(document.activeElement);
}

function trapFocus(event, activeOverlayType, dashboardEl) {
  var activeOverlayEl = getActiveOverlayEl(dashboardEl, activeOverlayType);
  var focusableNodes = toArray(activeOverlayEl.querySelectorAll(FOCUSABLE_ELEMENTS));
  var focusedItemIndex = focusableNodes.indexOf(document.activeElement); // If we pressed tab, and focus is not yet within the current overlay - focus on the first element within the current overlay.
  // This is a safety measure (for when user returns from another tab e.g.), most plugins will try to focus on some important element as it loads.

  if (!isFocusInOverlay(activeOverlayEl)) {
    focusOnFirstNode(event, focusableNodes); // If we pressed shift + tab, and we're on the first element of a modal
  } else if (event.shiftKey && focusedItemIndex === 0) {
    focusOnLastNode(event, focusableNodes); // If we pressed tab, and we're on the last element of the modal
  } else if (!event.shiftKey && focusedItemIndex === focusableNodes.length - 1) {
    focusOnFirstNode(event, focusableNodes);
  }
}

module.exports = {
  // Traps focus inside of the currently open overlay (e.g. Dashboard, or e.g. Instagram), never lets focus disappear from the modal.
  forModal: function forModal(event, activeOverlayType, dashboardEl) {
    trapFocus(event, activeOverlayType, dashboardEl);
  },
  // Traps focus inside of the currently open overlay, unless overlay is null - then let the user tab away.
  forInline: function forInline(event, activeOverlayType, dashboardEl) {
    // ___When we're in the bare 'Drop files here, paste, browse or import from' screen
    if (activeOverlayType === null) {// Do nothing and let the browser handle it, user can tab away from Uppy to other elements on the page
      // ___When there is some overlay with 'Done' button
    } else {
      // Trap the focus inside this overlay!
      // User can close the overlay (click 'Done') if they want to travel away from Uppy.
      trapFocus(event, activeOverlayType, dashboardEl);
    }
  }
};

},{"./../../../utils/lib/FOCUSABLE_ELEMENTS":116,"./../../../utils/lib/toArray":147,"./getActiveOverlayEl":67}],71:[function(require,module,exports){
/**
 * Truncates a string to the given number of chars (maxLength) by inserting '...' in the middle of that string.
 * Partially taken from https://stackoverflow.com/a/5723274/3192470.
 *
 * @param {string} string - string to be truncated
 * @param {number} maxLength - maximum size of the resulting string
 * @returns {string}
 */
module.exports = function truncateString(string, maxLength) {
  var separator = '...'; // Return original string if it's already shorter than maxLength

  if (string.length <= maxLength) {
    return string; // Return truncated substring without '...' if string can't be meaningfully truncated
  } else if (maxLength <= separator.length) {
    return string.substr(0, maxLength); // Return truncated string divided in half by '...'
  } else {
    var charsToShow = maxLength - separator.length;
    var frontChars = Math.ceil(charsToShow / 2);
    var backChars = Math.floor(charsToShow / 2);
    return string.substr(0, frontChars) + separator + string.substr(string.length - backChars);
  }
};

},{}],72:[function(require,module,exports){
module.exports={
  "name": "@uppy/dropbox",
  "description": "Import files from Dropbox, into Uppy.",
  "version": "1.3.5",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "dropbox"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],73:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var ProviderViews = require('./../../provider-views');

var _require3 = require('preact'),
    h = _require3.h;

module.exports = (_temp = _class =
/*#__PURE__*/
function (_Plugin) {
  _inheritsLoose(Dropbox, _Plugin);

  function Dropbox(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'Dropbox';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'Dropbox';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "128",
        height: "128",
        viewBox: "0 0 128 128"
      }, h("path", {
        d: "M31.997 11L64 31.825 31.997 52.651 0 31.825 31.997 11zM96 11l32 20.825-32 20.826-32-20.826L96 11zM0 73.476l31.997-20.825L64 73.476 31.997 94.302 0 73.476zm96-20.825l32 20.825-32 20.826-32-20.826 32-20.825zm-64.508 48.254l32.003-20.826 31.997 20.826-31.997 20.825-32.003-20.825z",
        fill: "#0260FF",
        "fill-rule": "nonzero"
      }));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      storage: _this.opts.storage,
      provider: 'dropbox',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Dropbox.prototype;

  _proto.install = function install() {
    this.view = new ProviderViews(this, {
      provider: this.provider
    }); // Set default state for Dropbox

    this.setPluginState({
      authenticated: false,
      files: [],
      folders: [],
      directories: [],
      activeRow: -1,
      filterInput: '',
      isSearchVisible: false
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return this.view.getFolder();
  };

  _proto.render = function render(state) {
    return this.view.render(state);
  };

  return Dropbox;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":72,"./../../companion-client":41,"./../../core":45,"./../../provider-views":97,"preact":17}],74:[function(require,module,exports){
module.exports={
  "name": "@uppy/facebook",
  "description": "Import files from Facebook, into Uppy.",
  "version": "0.2.2",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "facebook"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],75:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var ProviderViews = require('./../../provider-views');

var _require3 = require('preact'),
    h = _require3.h;

module.exports = (_temp = _class =
/*#__PURE__*/
function (_Plugin) {
  _inheritsLoose(Facebook, _Plugin);

  function Facebook(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'Facebook';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'Facebook';

    _this.icon = function () {
      return h("svg", {
        version: "1.1",
        id: "Layer_1",
        xmlns: "http://www.w3.org/2000/svg",
        x: "0px",
        y: "0px",
        width: "266.893px",
        height: "266.895px",
        viewBox: "0 0 266.893 266.895",
        "enable-background": "new 0 0 266.893 266.895"
      }, h("path", {
        id: "Blue_1_",
        fill: "#3C5A99",
        d: "M248.082,262.307c7.854,0,14.223-6.369,14.223-14.225V18.812 c0-7.857-6.368-14.224-14.223-14.224H18.812c-7.857,0-14.224,6.367-14.224,14.224v229.27c0,7.855,6.366,14.225,14.224,14.225 H248.082z"
      }), h("path", {
        id: "f",
        fill: "#FFFFFF",
        d: "M182.409,262.307v-99.803h33.499l5.016-38.895h-38.515V98.777c0-11.261,3.127-18.935,19.275-18.935 l20.596-0.009V45.045c-3.562-0.474-15.788-1.533-30.012-1.533c-29.695,0-50.025,18.126-50.025,51.413v28.684h-33.585v38.895h33.585 v99.803H182.409z"
      }));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      storage: _this.opts.storage,
      provider: 'facebook',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Facebook.prototype;

  _proto.install = function install() {
    this.view = new ProviderViews(this, {
      provider: this.provider
    }); // Set default state for Dropbox

    this.setPluginState({
      authenticated: false,
      files: [],
      folders: [],
      directories: [],
      activeRow: -1,
      filterInput: '',
      isSearchVisible: false
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return this.view.getFolder();
  };

  _proto.render = function render(state) {
    var viewOptions = {};

    if (this.getPluginState().files.length && !this.getPluginState().folders.length) {
      viewOptions.viewType = 'grid';
      viewOptions.showFilter = false;
      viewOptions.showTitles = false;
    }

    return this.view.render(state, viewOptions);
  };

  return Facebook;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":74,"./../../companion-client":41,"./../../core":45,"./../../provider-views":97,"preact":17}],76:[function(require,module,exports){
module.exports={
  "name": "@uppy/google-drive",
  "description": "The Google Drive plugin for Uppy lets users import files from their Google Drive account",
  "version": "1.3.5",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "google drive",
    "cloud storage",
    "uppy",
    "uppy-plugin"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],77:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var ProviderViews = require('./../../provider-views');

module.exports =
/*#__PURE__*/
function (_ProviderViews) {
  _inheritsLoose(DriveProviderViews, _ProviderViews);

  function DriveProviderViews() {
    return _ProviderViews.apply(this, arguments) || this;
  }

  var _proto = DriveProviderViews.prototype;

  _proto.toggleCheckbox = function toggleCheckbox(e, file) {
    e.stopPropagation();
    e.preventDefault(); // Shared Drives aren't selectable; for all else, defer to the base ProviderView.
    // @todo isTeamDrive is left for backward compatibility. We should remove it in the next
    // major release.

    if (!file.custom.isTeamDrive && !file.custom.isSharedDrive) {
      _ProviderViews.prototype.toggleCheckbox.call(this, e, file);
    }
  };

  return DriveProviderViews;
}(ProviderViews);

},{"./../../provider-views":97}],78:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var DriveProviderViews = require('./DriveProviderViews');

var _require3 = require('preact'),
    h = _require3.h;

module.exports = (_temp = _class =
/*#__PURE__*/
function (_Plugin) {
  _inheritsLoose(GoogleDrive, _Plugin);

  function GoogleDrive(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'GoogleDrive';
    _this.title = _this.opts.title || 'Google Drive';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'Google Drive';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        width: "18px",
        height: "16px",
        viewBox: "0 0 18 16",
        version: "1.1"
      }, h("g", {
        "fill-rule": "evenodd"
      }, h("polygon", {
        fill: "#3089FC",
        points: "6.32475 10.2 18 10.2 14.999625 15.3 3.324375 15.3"
      }), h("polygon", {
        fill: "#00A85D",
        points: "3.000375 15.3 0 10.2 5.83875 0.275974026 8.838 5.37597403 5.999625 10.2"
      }), h("polygon", {
        fill: "#FFD024",
        points: "11.838375 9.92402597 5.999625 0 12.000375 0 17.839125 9.92402597"
      })));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      storage: _this.opts.storage,
      provider: 'drive',
      authProvider: 'google',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = GoogleDrive.prototype;

  _proto.install = function install() {
    this.view = new DriveProviderViews(this, {
      provider: this.provider
    }); // Set default state for Google Drive

    this.setPluginState({
      authenticated: false,
      files: [],
      folders: [],
      directories: [],
      activeRow: -1,
      filterInput: '',
      isSearchVisible: false,
      hasTeamDrives: false,
      teamDrives: [],
      teamDriveId: ''
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return this.view.getFolder('root', '/');
  };

  _proto.render = function render(state) {
    return this.view.render(state);
  };

  return GoogleDrive;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":76,"./../../companion-client":41,"./../../core":45,"./DriveProviderViews":77,"preact":17}],79:[function(require,module,exports){
module.exports={
  "name": "@uppy/informer",
  "description": "A notification and error pop-up bar for Uppy.",
  "version": "1.3.4",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "notification",
    "bar",
    "ui"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],80:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('preact'),
    h = _require2.h;
/**
 * Informer
 * Shows rad message bubbles
 * used like this: `uppy.info('hello world', 'info', 5000)`
 * or for errors: `uppy.info('Error uploading img.jpg', 'error', 5000)`
 *
 */


module.exports = (_temp = _class =
/*#__PURE__*/
function (_Plugin) {
  _inheritsLoose(Informer, _Plugin);

  function Informer(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.type = 'progressindicator';
    _this.id = _this.opts.id || 'Informer';
    _this.title = 'Informer'; // set default options

    var defaultOptions = {}; // merge default options with the ones set by user

    _this.opts = _extends({}, defaultOptions, opts);
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Informer.prototype;

  _proto.render = function render(state) {
    var _state$info = state.info,
        isHidden = _state$info.isHidden,
        message = _state$info.message,
        details = _state$info.details;
    return h("div", {
      class: "uppy uppy-Informer",
      "aria-hidden": isHidden
    }, h("p", {
      role: "alert"
    }, message, ' ', details && h("span", {
      "aria-label": details,
      "data-microtip-position": "top-left",
      "data-microtip-size": "medium",
      role: "tooltip"
    }, "?")));
  };

  _proto.install = function install() {
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  return Informer;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":79,"./../../core":45,"preact":17}],81:[function(require,module,exports){
module.exports={
  "name": "@uppy/instagram",
  "description": "Import photos and videos from Instagram, into Uppy.",
  "version": "1.3.5",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "instagram",
    "provider",
    "photos",
    "videos"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],82:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var ProviderViews = require('./../../provider-views');

var _require3 = require('preact'),
    h = _require3.h;

module.exports = (_temp = _class =
/*#__PURE__*/
function (_Plugin) {
  _inheritsLoose(Instagram, _Plugin);

  function Instagram(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'Instagram';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'Instagram';

    _this.icon = function () {
      return h("svg", {
        "aria-hidden": "true",
        focusable: "false",
        fill: "#DE3573",
        width: "28",
        height: "28",
        viewBox: "0 0 512 512"
      }, h("path", {
        d: "M256,49.471c67.266,0,75.233.257,101.8,1.469,24.562,1.121,37.9,5.224,46.778,8.674a78.052,78.052,0,0,1,28.966,18.845,78.052,78.052,0,0,1,18.845,28.966c3.45,8.877,7.554,22.216,8.674,46.778,1.212,26.565,1.469,34.532,1.469,101.8s-0.257,75.233-1.469,101.8c-1.121,24.562-5.225,37.9-8.674,46.778a83.427,83.427,0,0,1-47.811,47.811c-8.877,3.45-22.216,7.554-46.778,8.674-26.56,1.212-34.527,1.469-101.8,1.469s-75.237-.257-101.8-1.469c-24.562-1.121-37.9-5.225-46.778-8.674a78.051,78.051,0,0,1-28.966-18.845,78.053,78.053,0,0,1-18.845-28.966c-3.45-8.877-7.554-22.216-8.674-46.778-1.212-26.564-1.469-34.532-1.469-101.8s0.257-75.233,1.469-101.8c1.121-24.562,5.224-37.9,8.674-46.778A78.052,78.052,0,0,1,78.458,78.458a78.053,78.053,0,0,1,28.966-18.845c8.877-3.45,22.216-7.554,46.778-8.674,26.565-1.212,34.532-1.469,101.8-1.469m0-45.391c-68.418,0-77,.29-103.866,1.516-26.815,1.224-45.127,5.482-61.151,11.71a123.488,123.488,0,0,0-44.62,29.057A123.488,123.488,0,0,0,17.3,90.982C11.077,107.007,6.819,125.319,5.6,152.134,4.369,179,4.079,187.582,4.079,256S4.369,333,5.6,359.866c1.224,26.815,5.482,45.127,11.71,61.151a123.489,123.489,0,0,0,29.057,44.62,123.486,123.486,0,0,0,44.62,29.057c16.025,6.228,34.337,10.486,61.151,11.71,26.87,1.226,35.449,1.516,103.866,1.516s77-.29,103.866-1.516c26.815-1.224,45.127-5.482,61.151-11.71a128.817,128.817,0,0,0,73.677-73.677c6.228-16.025,10.486-34.337,11.71-61.151,1.226-26.87,1.516-35.449,1.516-103.866s-0.29-77-1.516-103.866c-1.224-26.815-5.482-45.127-11.71-61.151a123.486,123.486,0,0,0-29.057-44.62A123.487,123.487,0,0,0,421.018,17.3C404.993,11.077,386.681,6.819,359.866,5.6,333,4.369,324.418,4.079,256,4.079h0Z"
      }), h("path", {
        d: "M256,126.635A129.365,129.365,0,1,0,385.365,256,129.365,129.365,0,0,0,256,126.635Zm0,213.338A83.973,83.973,0,1,1,339.974,256,83.974,83.974,0,0,1,256,339.973Z"
      }), h("circle", {
        cx: "390.476",
        cy: "121.524",
        r: "30.23"
      }));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      storage: _this.opts.storage,
      provider: 'instagram',
      authProvider: 'instagram',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Instagram.prototype;

  _proto.install = function install() {
    this.view = new ProviderViews(this, {
      provider: this.provider,
      viewType: 'grid',
      showTitles: false,
      showFilter: false,
      showBreadcrumbs: false
    }); // Set default state for Instagram

    this.setPluginState({
      authenticated: false,
      files: [],
      folders: [],
      directories: [],
      activeRow: -1,
      filterInput: '',
      isSearchVisible: false
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    this.view.getFolder('recent');
  };

  _proto.render = function render(state) {
    return this.view.render(state);
  };

  return Instagram;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":81,"./../../companion-client":41,"./../../core":45,"./../../provider-views":97,"preact":17}],83:[function(require,module,exports){
module.exports={
  "name": "@uppy/onedrive",
  "description": "Import files from OneDrive, into Uppy.",
  "version": "0.1.4",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "onedrive"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/provider-views": "file:../provider-views",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],84:[function(require,module,exports){
var _class, _temp;

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider;

var ProviderViews = require('./../../provider-views');

var _require3 = require('preact'),
    h = _require3.h;

module.exports = (_temp = _class =
/*#__PURE__*/
function (_Plugin) {
  _inheritsLoose(OneDrive, _Plugin);

  function OneDrive(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'OneDrive';
    Provider.initPlugin(_assertThisInitialized(_this), opts);
    _this.title = _this.opts.title || 'OneDrive';

    _this.icon = function () {
      return h("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 48 48",
        width: "48",
        height: "48"
      }, h("path", {
        fill: "#1565c0",
        d: "M40.429,35.999c0,0,2.89-0.393,3.47-3.185C43.964,32.502,44,32.161,44,31.787 c0-0.233-0.015-0.454-0.044-0.665c-0.428-3.158-3.852-3.868-3.852-3.868s0.595-3.401-2.543-5.183c-3.138-1.78-6.005,0-6.005,0 s-1.678-3.401-6.222-3.401c-5.843,0-6.817,6.64-6.817,6.64S13,25.636,13,30.493C13,35.352,18.031,36,18.031,36L40.429,35.999 L40.429,35.999z"
      }), h("path", {
        fill: "#1565c0",
        d: "M11,30.493c0-4.395,3.286-6.319,5.875-6.945c0.898-2.954,3.384-6.878,8.46-6.878 c0.006,0,0.011,0.001,0.017,0.001c0.007,0,0.013-0.001,0.02-0.001c3.522,0,5.71,1.646,6.892,2.953 c0.65-0.191,1.448-0.343,2.347-0.343c0.004,0,0.007,0.001,0.011,0.001c0.003,0,0.006,0,0.01,0c0.02,0,0.039,0.004,0.059,0.004 C34.729,19,34.063,12,26.013,12c-5.503,0-7.446,4.691-7.446,4.691s-3.992-2.965-8.092,1.133c-2.105,2.104-1.619,5.338-1.619,5.338 S4,23.648,4,28.825C4.001,33.515,9.018,34,9.018,34h2.807C11.32,33.041,11,31.886,11,30.493z"
      }));
    };

    _this.provider = new Provider(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders,
      storage: _this.opts.storage,
      provider: 'onedrive',
      pluginId: _this.id
    });
    _this.onFirstRender = _this.onFirstRender.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = OneDrive.prototype;

  _proto.install = function install() {
    this.view = new ProviderViews(this, {
      provider: this.provider
    }); // Set default state for Dropbox

    this.setPluginState({
      authenticated: false,
      files: [],
      folders: [],
      directories: [],
      activeRow: -1,
      filterInput: '',
      isSearchVisible: false
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.view.tearDown();
    this.unmount();
  };

  _proto.onFirstRender = function onFirstRender() {
    return this.view.getFolder();
  };

  _proto.render = function render(state) {
    return this.view.render(state);
  };

  return OneDrive;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":83,"./../../companion-client":41,"./../../core":45,"./../../provider-views":97,"preact":17}],85:[function(require,module,exports){
module.exports={
  "name": "@uppy/provider-views",
  "description": "View library for Uppy remote provider plugins.",
  "version": "1.5.2",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "classnames": "^2.2.6",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],86:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var AuthView =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(AuthView, _Component);

  function AuthView() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = AuthView.prototype;

  _proto.render = function render() {
    var pluginNameComponent = h("span", {
      class: "uppy-Provider-authTitleName"
    }, this.props.pluginName, h("br", null));
    return h("div", {
      class: "uppy-Provider-auth"
    }, h("div", {
      class: "uppy-Provider-authIcon"
    }, this.props.pluginIcon()), h("div", {
      class: "uppy-Provider-authTitle"
    }, this.props.i18nArray('authenticateWithTitle', {
      pluginName: pluginNameComponent
    })), h("button", {
      type: "button",
      class: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Provider-authBtn",
      onclick: this.props.handleAuth,
      "data-uppy-super-focusable": true
    }, this.props.i18nArray('authenticateWith', {
      pluginName: this.props.pluginName
    })));
  };

  return AuthView;
}(Component);

module.exports = AuthView;

},{"preact":17}],87:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h; // TODO use Fragment when upgrading to preact X


var Breadcrumb = function Breadcrumb(props) {
  return h("span", null, h("button", {
    type: "button",
    class: "uppy-u-reset",
    onclick: props.getFolder
  }, props.title), !props.isLast ? ' / ' : '');
};

module.exports = function (props) {
  return h("div", {
    class: "uppy-Provider-breadcrumbs"
  }, h("div", {
    class: "uppy-Provider-breadcrumbsIcon"
  }, props.breadcrumbsIcon), props.directories.map(function (directory, i) {
    return h(Breadcrumb, {
      key: directory.id,
      getFolder: function getFolder() {
        return props.getFolder(directory.id);
      },
      title: i === 0 ? props.title : directory.title,
      isLast: i + 1 === props.directories.length
    });
  }));
};

},{"preact":17}],88:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var classNames = require('classnames');

var Breadcrumbs = require('./Breadcrumbs');

var Filter = require('./Filter');

var ItemList = require('./ItemList');

var FooterActions = require('./FooterActions');

var _require = require('preact'),
    h = _require.h;

var Browser = function Browser(props) {
  var filteredFolders = props.folders;
  var filteredFiles = props.files;

  if (props.filterInput !== '') {
    filteredFolders = props.filterItems(props.folders);
    filteredFiles = props.filterItems(props.files);
  }

  var selected = props.currentSelection.length;
  return h("div", {
    class: classNames('uppy-ProviderBrowser', "uppy-ProviderBrowser-viewType--" + props.viewType)
  }, h("div", {
    class: "uppy-ProviderBrowser-header"
  }, h("div", {
    class: classNames('uppy-ProviderBrowser-headerBar', !props.showBreadcrumbs && 'uppy-ProviderBrowser-headerBar--simple')
  }, props.showBreadcrumbs && Breadcrumbs({
    getFolder: props.getFolder,
    directories: props.directories,
    breadcrumbsIcon: props.pluginIcon && props.pluginIcon(),
    title: props.title
  }), h("span", {
    class: "uppy-ProviderBrowser-user"
  }, props.username), h("button", {
    type: "button",
    onclick: props.logout,
    class: "uppy-u-reset uppy-ProviderBrowser-userLogout"
  }, props.i18n('logOut')))), props.showFilter && h(Filter, props), h(ItemList, {
    columns: [{
      name: 'Name',
      key: 'title'
    }],
    folders: filteredFolders,
    files: filteredFiles,
    activeRow: props.isActiveRow,
    sortByTitle: props.sortByTitle,
    sortByDate: props.sortByDate,
    isChecked: props.isChecked,
    handleFolderClick: props.getNextFolder,
    toggleCheckbox: props.toggleCheckbox,
    handleScroll: props.handleScroll,
    title: props.title,
    showTitles: props.showTitles,
    i18n: props.i18n,
    viewType: props.viewType
  }), selected > 0 && h(FooterActions, _extends({
    selected: selected
  }, props)));
};

module.exports = Browser;

},{"./Breadcrumbs":87,"./Filter":89,"./FooterActions":90,"./ItemList":95,"classnames":1,"preact":17}],89:[function(require,module,exports){
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

module.exports =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(Filter, _Component);

  function Filter(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.preventEnterPress = _this.preventEnterPress.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Filter.prototype;

  _proto.preventEnterPress = function preventEnterPress(ev) {
    if (ev.keyCode === 13) {
      ev.stopPropagation();
      ev.preventDefault();
    }
  };

  _proto.render = function render() {
    var _this2 = this;

    return h("div", {
      class: "uppy-ProviderBrowser-search"
    }, h("input", {
      class: "uppy-u-reset uppy-ProviderBrowser-searchInput",
      type: "text",
      placeholder: this.props.i18n('filter'),
      "aria-label": this.props.i18n('filter'),
      onkeyup: this.preventEnterPress,
      onkeydown: this.preventEnterPress,
      onkeypress: this.preventEnterPress,
      oninput: function oninput(e) {
        return _this2.props.filterQuery(e);
      },
      value: this.props.filterInput
    }), h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      class: "UppyIcon uppy-ProviderBrowser-searchIcon",
      width: "12",
      height: "12",
      viewBox: "0 0 12 12"
    }, h("path", {
      d: "M8.638 7.99l3.172 3.172a.492.492 0 1 1-.697.697L7.91 8.656a4.977 4.977 0 0 1-2.983.983C2.206 9.639 0 7.481 0 4.819 0 2.158 2.206 0 4.927 0c2.721 0 4.927 2.158 4.927 4.82a4.74 4.74 0 0 1-1.216 3.17zm-3.71.685c2.176 0 3.94-1.726 3.94-3.856 0-2.129-1.764-3.855-3.94-3.855C2.75.964.984 2.69.984 4.819c0 2.13 1.765 3.856 3.942 3.856z"
    })), this.props.filterInput && h("button", {
      class: "uppy-u-reset uppy-ProviderBrowser-searchClose",
      type: "button",
      "aria-label": this.props.i18n('resetFilter'),
      title: this.props.i18n('resetFilter'),
      onclick: this.props.filterQuery
    }, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      class: "UppyIcon",
      viewBox: "0 0 19 19"
    }, h("path", {
      d: "M17.318 17.232L9.94 9.854 9.586 9.5l-.354.354-7.378 7.378h.707l-.62-.62v.706L9.318 9.94l.354-.354-.354-.354L1.94 1.854v.707l.62-.62h-.706l7.378 7.378.354.354.354-.354 7.378-7.378h-.707l.622.62v-.706L9.854 9.232l-.354.354.354.354 7.378 7.378.708-.707-7.38-7.378v.708l7.38-7.38.353-.353-.353-.353-.622-.622-.353-.353-.354.352-7.378 7.38h.708L2.56 1.23 2.208.88l-.353.353-.622.62-.353.355.352.353 7.38 7.38v-.708l-7.38 7.38-.353.353.352.353.622.622.353.353.354-.353 7.38-7.38h-.708l7.38 7.38z"
    }))));
  };

  return Filter;
}(Component);

},{"preact":17}],90:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("div", {
    class: "uppy-ProviderBrowser-footer"
  }, h("button", {
    class: "uppy-u-reset uppy-c-btn uppy-c-btn-primary",
    onclick: props.done
  }, props.i18n('selectX', {
    smart_count: props.selected
  })), h("button", {
    class: "uppy-u-reset uppy-c-btn uppy-c-btn-link",
    onclick: props.cancel
  }, props.i18n('cancel')));
};

},{"preact":17}],91:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h; // it could be a <li><button class="fake-checkbox"/> <button/></li>


module.exports = function (props) {
  return h("li", {
    class: props.className
  }, h("div", {
    "aria-hidden": true,
    class: "uppy-ProviderBrowserItem-fakeCheckbox " + (props.isChecked ? 'uppy-ProviderBrowserItem-fakeCheckbox--is-checked' : '')
  }), h("button", {
    type: "button",
    class: "uppy-u-reset uppy-ProviderBrowserItem-inner",
    onclick: props.toggleCheckbox,
    role: "option",
    "aria-label": props.isChecked ? props.i18n('unselectFileNamed', {
      name: props.title
    }) : props.i18n('selectFileNamed', {
      name: props.title
    }),
    "aria-selected": props.isChecked,
    "aria-disabled": props.isDisabled,
    "data-uppy-super-focusable": true
  }, props.itemIconEl, props.showTitles && props.title));
};

},{"preact":17}],92:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

function FileIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    width: 11,
    height: 14.5,
    viewBox: "0 0 44 58"
  }, h("path", {
    d: "M27.437.517a1 1 0 0 0-.094.03H4.25C2.037.548.217 2.368.217 4.58v48.405c0 2.212 1.82 4.03 4.03 4.03H39.03c2.21 0 4.03-1.818 4.03-4.03V15.61a1 1 0 0 0-.03-.28 1 1 0 0 0 0-.093 1 1 0 0 0-.03-.032 1 1 0 0 0 0-.03 1 1 0 0 0-.032-.063 1 1 0 0 0-.03-.063 1 1 0 0 0-.032 0 1 1 0 0 0-.03-.063 1 1 0 0 0-.032-.03 1 1 0 0 0-.03-.063 1 1 0 0 0-.063-.062l-14.593-14a1 1 0 0 0-.062-.062A1 1 0 0 0 28 .708a1 1 0 0 0-.374-.157 1 1 0 0 0-.156 0 1 1 0 0 0-.03-.03l-.003-.003zM4.25 2.547h22.218v9.97c0 2.21 1.82 4.03 4.03 4.03h10.564v36.438a2.02 2.02 0 0 1-2.032 2.032H4.25c-1.13 0-2.032-.9-2.032-2.032V4.58c0-1.13.902-2.032 2.03-2.032zm24.218 1.345l10.375 9.937.75.718H30.5c-1.13 0-2.032-.9-2.032-2.03V3.89z"
  }));
}

function FolderIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    style: {
      width: 16,
      marginRight: 3
    },
    viewBox: "0 0 276.157 276.157"
  }, h("path", {
    d: "M273.08 101.378c-3.3-4.65-8.86-7.32-15.254-7.32h-24.34V67.59c0-10.2-8.3-18.5-18.5-18.5h-85.322c-3.63 0-9.295-2.875-11.436-5.805l-6.386-8.735c-4.982-6.814-15.104-11.954-23.546-11.954H58.73c-9.292 0-18.638 6.608-21.737 15.372l-2.033 5.752c-.958 2.71-4.72 5.37-7.596 5.37H18.5C8.3 49.09 0 57.39 0 67.59v167.07c0 .886.16 1.73.443 2.52.152 3.306 1.18 6.424 3.053 9.064 3.3 4.652 8.86 7.32 15.255 7.32h188.487c11.395 0 23.27-8.425 27.035-19.18l40.677-116.188c2.11-6.035 1.43-12.164-1.87-16.816zM18.5 64.088h8.864c9.295 0 18.64-6.607 21.738-15.37l2.032-5.75c.96-2.712 4.722-5.373 7.597-5.373h29.565c3.63 0 9.295 2.876 11.437 5.806l6.386 8.735c4.982 6.815 15.104 11.954 23.546 11.954h85.322c1.898 0 3.5 1.602 3.5 3.5v26.47H69.34c-11.395 0-23.27 8.423-27.035 19.178L15 191.23V67.59c0-1.898 1.603-3.5 3.5-3.5zm242.29 49.15l-40.676 116.188c-1.674 4.78-7.812 9.135-12.877 9.135H18.75c-1.447 0-2.576-.372-3.02-.997-.442-.625-.422-1.814.057-3.18l40.677-116.19c1.674-4.78 7.812-9.134 12.877-9.134h188.487c1.448 0 2.577.372 3.02.997.443.625.423 1.814-.056 3.18z"
  }));
}

function VideoIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    viewBox: "0 0 58 58"
  }, h("path", {
    d: "M36.537 28.156l-11-7a1.005 1.005 0 0 0-1.02-.033C24.2 21.3 24 21.635 24 22v14a1 1 0 0 0 1.537.844l11-7a1.002 1.002 0 0 0 0-1.688zM26 34.18V23.82L34.137 29 26 34.18z"
  }), h("path", {
    d: "M57 6H1a1 1 0 0 0-1 1v44a1 1 0 0 0 1 1h56a1 1 0 0 0 1-1V7a1 1 0 0 0-1-1zM10 28H2v-9h8v9zm-8 2h8v9H2v-9zm10 10V8h34v42H12V40zm44-12h-8v-9h8v9zm-8 2h8v9h-8v-9zm8-22v9h-8V8h8zM2 8h8v9H2V8zm0 42v-9h8v9H2zm54 0h-8v-9h8v9z"
  }));
}

module.exports = function (props) {
  if (props.itemIconString === null) return;

  switch (props.itemIconString) {
    case 'file':
      return h(FileIcon, null);

    case 'folder':
      return h(FolderIcon, null);

    case 'video':
      return h(VideoIcon, null);

    default:
      return h("img", {
        src: props.itemIconString
      });
  }
};

},{"preact":17}],93:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var getAriaLabelOfCheckbox = function getAriaLabelOfCheckbox(props) {
  if (props.type === 'folder') {
    if (props.isChecked) {
      return props.i18n('unselectAllFilesFromFolderNamed', {
        name: props.title
      });
    } else {
      return props.i18n('selectAllFilesFromFolderNamed', {
        name: props.title
      });
    }
  } else {
    if (props.isChecked) {
      return props.i18n('unselectFileNamed', {
        name: props.title
      });
    } else {
      return props.i18n('selectFileNamed', {
        name: props.title
      });
    }
  }
}; // if folder:
//   + checkbox (selects all files from folder)
//   + folder name (opens folder)
// if file:
//   + checkbox (selects file)
//   + file name (selects file)


module.exports = function (props) {
  return h("li", {
    class: props.className
  }, h("button", {
    type: "button",
    class: "uppy-u-reset uppy-ProviderBrowserItem-fakeCheckbox " + (props.isChecked ? 'uppy-ProviderBrowserItem-fakeCheckbox--is-checked' : ''),
    onClick: props.toggleCheckbox // for the <label/>
    ,
    id: props.id,
    role: "option",
    "aria-label": getAriaLabelOfCheckbox(props),
    "aria-selected": props.isChecked,
    "aria-disabled": props.isDisabled,
    "data-uppy-super-focusable": true
  }), props.type === 'file' ? // label for a checkbox
  h("label", {
    for: props.id,
    className: "uppy-u-reset uppy-ProviderBrowserItem-inner"
  }, props.itemIconEl, props.showTitles && props.title) : // button to open a folder
  h("button", {
    type: "button",
    class: "uppy-u-reset uppy-ProviderBrowserItem-inner",
    onclick: props.handleFolderClick,
    "aria-label": props.i18n('openFolderNamed', {
      name: props.title
    })
  }, props.itemIconEl, props.showTitles && props.title));
};

},{"preact":17}],94:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _require = require('preact'),
    h = _require.h;

var classNames = require('classnames');

var ItemIcon = require('./components/ItemIcon');

var GridLi = require('./components/GridLi');

var ListLi = require('./components/ListLi');

module.exports = function (props) {
  var itemIconString = props.getItemIcon();
  var className = classNames('uppy-ProviderBrowserItem', {
    'uppy-ProviderBrowserItem--selected': props.isChecked
  }, {
    'uppy-ProviderBrowserItem--noPreview': itemIconString === 'video'
  });
  var itemIconEl = h(ItemIcon, {
    itemIconString: itemIconString
  });

  switch (props.viewType) {
    case 'grid':
      return h(GridLi, _extends({}, props, {
        className: className,
        itemIconEl: itemIconEl
      }));

    case 'list':
      return h(ListLi, _extends({}, props, {
        className: className,
        itemIconEl: itemIconEl
      }));

    default:
      throw new Error("There is no such type " + props.viewType);
  }
};

},{"./components/GridLi":91,"./components/ItemIcon":92,"./components/ListLi":93,"classnames":1,"preact":17}],95:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var _require = require('preact'),
    h = _require.h;

var Item = require('./Item/index');

var getSharedProps = function getSharedProps(fileOrFolder, props) {
  return {
    id: fileOrFolder.id,
    title: fileOrFolder.name,
    getItemIcon: function getItemIcon() {
      return fileOrFolder.icon;
    },
    isChecked: props.isChecked(fileOrFolder),
    toggleCheckbox: function toggleCheckbox(e) {
      return props.toggleCheckbox(e, fileOrFolder);
    },
    columns: props.columns,
    showTitles: props.showTitles,
    viewType: props.viewType,
    i18n: props.i18n
  };
};

module.exports = function (props) {
  if (!props.folders.length && !props.files.length) {
    return h("div", {
      class: "uppy-Provider-empty"
    }, props.i18n('noFilesFound'));
  }

  return h("div", {
    class: "uppy-ProviderBrowser-body"
  }, h("ul", {
    class: "uppy-ProviderBrowser-list",
    onscroll: props.handleScroll,
    role: "listbox" // making <ul> not focusable for firefox
    ,
    tabindex: "-1"
  }, props.folders.map(function (folder) {
    return Item(_extends({}, getSharedProps(folder, props), {
      type: 'folder',
      isDisabled: props.isChecked(folder) ? props.isChecked(folder).loading : false,
      handleFolderClick: function handleFolderClick() {
        return props.handleFolderClick(folder);
      }
    }));
  }), props.files.map(function (file) {
    return Item(_extends({}, getSharedProps(file, props), {
      type: 'file',
      isDisabled: false
    }));
  })));
};

},{"./Item/index":94,"preact":17}],96:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("div", {
    class: "uppy-Provider-loading"
  }, h("span", null, props.i18n('loading')));
};

},{"preact":17}],97:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var AuthView = require('./AuthView');

var Browser = require('./Browser');

var LoaderView = require('./Loader');

var generateFileID = require('./../../utils/lib/generateFileID');

var getFileType = require('./../../utils/lib/getFileType');

var isPreviewSupported = require('./../../utils/lib/isPreviewSupported');
/**
 * Array.prototype.findIndex ponyfill for old browsers.
 */


function findIndex(array, predicate) {
  for (var i = 0; i < array.length; i++) {
    if (predicate(array[i])) return i;
  }

  return -1;
} // location.origin does not exist in IE


function getOrigin() {
  if ('origin' in location) {
    return location.origin; // eslint-disable-line compat/compat
  }

  return location.protocol + "//" + location.hostname + (location.port ? ":" + location.port : '');
}

var CloseWrapper =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(CloseWrapper, _Component);

  function CloseWrapper() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = CloseWrapper.prototype;

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.onUnmount();
  };

  _proto.render = function render() {
    return this.props.children[0];
  };

  return CloseWrapper;
}(Component);
/**
 * Class to easily generate generic views for Provider plugins
 */


module.exports = (_temp = _class =
/*#__PURE__*/
function () {
  /**
   * @param {object} plugin instance of the plugin
   * @param {object} opts
   */
  function ProviderView(plugin, opts) {
    this.plugin = plugin;
    this.provider = opts.provider; // set default options

    var defaultOptions = {
      viewType: 'list',
      showTitles: true,
      showFilter: true,
      showBreadcrumbs: true
    }; // merge default options with the ones set by user

    this.opts = _extends({}, defaultOptions, {}, opts); // Logic

    this.addFile = this.addFile.bind(this);
    this.filterItems = this.filterItems.bind(this);
    this.filterQuery = this.filterQuery.bind(this);
    this.toggleSearch = this.toggleSearch.bind(this);
    this.getFolder = this.getFolder.bind(this);
    this.getNextFolder = this.getNextFolder.bind(this);
    this.logout = this.logout.bind(this);
    this.preFirstRender = this.preFirstRender.bind(this);
    this.handleAuth = this.handleAuth.bind(this);
    this.sortByTitle = this.sortByTitle.bind(this);
    this.sortByDate = this.sortByDate.bind(this);
    this.isActiveRow = this.isActiveRow.bind(this);
    this.isChecked = this.isChecked.bind(this);
    this.toggleCheckbox = this.toggleCheckbox.bind(this);
    this.handleError = this.handleError.bind(this);
    this.handleScroll = this.handleScroll.bind(this);
    this.listAllFiles = this.listAllFiles.bind(this);
    this.donePicking = this.donePicking.bind(this);
    this.cancelPicking = this.cancelPicking.bind(this);
    this.clearSelection = this.clearSelection.bind(this); // Visual

    this.render = this.render.bind(this);
    this.clearSelection();
  }

  var _proto2 = ProviderView.prototype;

  _proto2.tearDown = function tearDown() {// Nothing.
  };

  _proto2._updateFilesAndFolders = function _updateFilesAndFolders(res, files, folders) {
    this.nextPagePath = res.nextPagePath;
    res.items.forEach(function (item) {
      if (item.isFolder) {
        folders.push(item);
      } else {
        files.push(item);
      }
    });
    this.plugin.setPluginState({
      folders: folders,
      files: files
    });
  }
  /**
   * Called only the first time the provider view is rendered.
   * Kind of like an init function.
   */
  ;

  _proto2.preFirstRender = function preFirstRender() {
    this.plugin.setPluginState({
      didFirstRender: true
    });
    this.plugin.onFirstRender();
  }
  /**
   * Based on folder ID, fetch a new folder and update it to state
   *
   * @param  {string} id Folder id
   * @returns {Promise}   Folders/files in folder
   */
  ;

  _proto2.getFolder = function getFolder(id, name) {
    var _this = this;

    return this._loaderWrapper(this.provider.list(id), function (res) {
      var folders = [];
      var files = [];
      var updatedDirectories;

      var state = _this.plugin.getPluginState();

      var index = findIndex(state.directories, function (dir) {
        return id === dir.id;
      });

      if (index !== -1) {
        updatedDirectories = state.directories.slice(0, index + 1);
      } else {
        updatedDirectories = state.directories.concat([{
          id: id,
          title: name
        }]);
      }

      _this.username = _this.username ? _this.username : res.username;

      _this._updateFilesAndFolders(res, files, folders);

      _this.plugin.setPluginState({
        directories: updatedDirectories
      });
    }, this.handleError);
  }
  /**
   * Fetches new folder
   *
   * @param  {object} Folder
   * @param  {string} title Folder title
   */
  ;

  _proto2.getNextFolder = function getNextFolder(folder) {
    this.getFolder(folder.requestPath, folder.name);
    this.lastCheckbox = undefined;
  };

  _proto2.addFile = function addFile(file) {
    var tagFile = {
      id: this.providerFileToId(file),
      source: this.plugin.id,
      data: file,
      name: file.name || file.id,
      type: file.mimeType,
      isRemote: true,
      body: {
        fileId: file.id
      },
      remote: {
        companionUrl: this.plugin.opts.companionUrl,
        url: "" + this.provider.fileUrl(file.requestPath),
        body: {
          fileId: file.id
        },
        providerOptions: this.provider.opts
      }
    };
    var fileType = getFileType(tagFile); // TODO Should we just always use the thumbnail URL if it exists?

    if (fileType && isPreviewSupported(fileType)) {
      tagFile.preview = file.thumbnail;
    }

    this.plugin.uppy.log('Adding remote file');

    try {
      this.plugin.uppy.addFile(tagFile);
    } catch (err) {
      if (!err.isRestriction) {
        this.plugin.uppy.log(err);
      }
    }
  };

  _proto2.removeFile = function removeFile(id) {
    var _this$plugin$getPlugi = this.plugin.getPluginState(),
        currentSelection = _this$plugin$getPlugi.currentSelection;

    this.plugin.setPluginState({
      currentSelection: currentSelection.filter(function (file) {
        return file.id !== id;
      })
    });
  }
  /**
   * Removes session token on client side.
   */
  ;

  _proto2.logout = function logout() {
    var _this2 = this;

    this.provider.logout().then(function (res) {
      if (res.ok) {
        if (!res.revoked) {
          var message = _this2.plugin.uppy.i18n('companionUnauthorizeHint', {
            provider: _this2.plugin.title,
            url: res.manual_revoke_url
          });

          _this2.plugin.uppy.info(message, 'info', 7000);
        }

        var newState = {
          authenticated: false,
          files: [],
          folders: [],
          directories: []
        };

        _this2.plugin.setPluginState(newState);
      }
    }).catch(this.handleError);
  };

  _proto2.filterQuery = function filterQuery(e) {
    var state = this.plugin.getPluginState();
    this.plugin.setPluginState(_extends({}, state, {
      filterInput: e ? e.target.value : ''
    }));
  };

  _proto2.toggleSearch = function toggleSearch(inputEl) {
    var state = this.plugin.getPluginState();
    this.plugin.setPluginState({
      isSearchVisible: !state.isSearchVisible,
      filterInput: ''
    });
  };

  _proto2.filterItems = function filterItems(items) {
    var state = this.plugin.getPluginState();

    if (!state.filterInput || state.filterInput === '') {
      return items;
    }

    return items.filter(function (folder) {
      return folder.name.toLowerCase().indexOf(state.filterInput.toLowerCase()) !== -1;
    });
  };

  _proto2.sortByTitle = function sortByTitle() {
    var state = _extends({}, this.plugin.getPluginState());

    var files = state.files,
        folders = state.folders,
        sorting = state.sorting;
    var sortedFiles = files.sort(function (fileA, fileB) {
      if (sorting === 'titleDescending') {
        return fileB.name.localeCompare(fileA.name);
      }

      return fileA.name.localeCompare(fileB.name);
    });
    var sortedFolders = folders.sort(function (folderA, folderB) {
      if (sorting === 'titleDescending') {
        return folderB.name.localeCompare(folderA.name);
      }

      return folderA.name.localeCompare(folderB.name);
    });
    this.plugin.setPluginState(_extends({}, state, {
      files: sortedFiles,
      folders: sortedFolders,
      sorting: sorting === 'titleDescending' ? 'titleAscending' : 'titleDescending'
    }));
  };

  _proto2.sortByDate = function sortByDate() {
    var state = _extends({}, this.plugin.getPluginState());

    var files = state.files,
        folders = state.folders,
        sorting = state.sorting;
    var sortedFiles = files.sort(function (fileA, fileB) {
      var a = new Date(fileA.modifiedDate);
      var b = new Date(fileB.modifiedDate);

      if (sorting === 'dateDescending') {
        return a > b ? -1 : a < b ? 1 : 0;
      }

      return a > b ? 1 : a < b ? -1 : 0;
    });
    var sortedFolders = folders.sort(function (folderA, folderB) {
      var a = new Date(folderA.modifiedDate);
      var b = new Date(folderB.modifiedDate);

      if (sorting === 'dateDescending') {
        return a > b ? -1 : a < b ? 1 : 0;
      }

      return a > b ? 1 : a < b ? -1 : 0;
    });
    this.plugin.setPluginState(_extends({}, state, {
      files: sortedFiles,
      folders: sortedFolders,
      sorting: sorting === 'dateDescending' ? 'dateAscending' : 'dateDescending'
    }));
  };

  _proto2.sortBySize = function sortBySize() {
    var state = _extends({}, this.plugin.getPluginState());

    var files = state.files,
        sorting = state.sorting; // check that plugin supports file sizes

    if (!files.length || !this.plugin.getItemData(files[0]).size) {
      return;
    }

    var sortedFiles = files.sort(function (fileA, fileB) {
      var a = fileA.size;
      var b = fileB.size;

      if (sorting === 'sizeDescending') {
        return a > b ? -1 : a < b ? 1 : 0;
      }

      return a > b ? 1 : a < b ? -1 : 0;
    });
    this.plugin.setPluginState(_extends({}, state, {
      files: sortedFiles,
      sorting: sorting === 'sizeDescending' ? 'sizeAscending' : 'sizeDescending'
    }));
  };

  _proto2.isActiveRow = function isActiveRow(file) {
    return this.plugin.getPluginState().activeRow === this.plugin.getItemId(file);
  };

  _proto2.isChecked = function isChecked(file) {
    var _this$plugin$getPlugi2 = this.plugin.getPluginState(),
        currentSelection = _this$plugin$getPlugi2.currentSelection; // comparing id instead of the file object, because the reference to the object
    // changes when we switch folders, and the file list is updated


    return currentSelection.some(function (item) {
      return item.id === file.id;
    });
  }
  /**
   * Adds all files found inside of specified folder.
   *
   * Uses separated state while folder contents are being fetched and
   * mantains list of selected folders, which are separated from files.
   */
  ;

  _proto2.addFolder = function addFolder(folder) {
    var _this3 = this;

    var folderId = this.providerFileToId(folder);
    var state = this.plugin.getPluginState();
    var folders = state.selectedFolders || {};

    if (folderId in folders && folders[folderId].loading) {
      return;
    }

    folders[folderId] = {
      loading: true,
      files: []
    };
    this.plugin.setPluginState({
      selectedFolders: folders
    });
    return this.listAllFiles(folder.requestPath).then(function (files) {
      files.forEach(function (file) {
        _this3.addFile(file);
      });
      var ids = files.map(_this3.providerFileToId);
      state = _this3.plugin.getPluginState();
      state.selectedFolders[folderId] = {
        loading: false,
        files: ids
      };

      _this3.plugin.setPluginState({
        selectedFolders: folders
      });

      var message;

      if (files.length) {
        message = _this3.plugin.uppy.i18n('folderAdded', {
          smart_count: files.length,
          folder: folder.name
        });
      } else {
        message = _this3.plugin.uppy.i18n('emptyFolderAdded');
      }

      _this3.plugin.uppy.info(message);
    }).catch(function (e) {
      state = _this3.plugin.getPluginState();
      delete state.selectedFolders[folderId];

      _this3.plugin.setPluginState({
        selectedFolders: state.selectedFolders
      });

      _this3.handleError(e);
    });
  }
  /**
   * Toggles file/folder checkbox to on/off state while updating files list.
   *
   * Note that some extra complexity comes from supporting shift+click to
   * toggle multiple checkboxes at once, which is done by getting all files
   * in between last checked file and current one.
   */
  ;

  _proto2.toggleCheckbox = function toggleCheckbox(e, file) {
    e.stopPropagation();
    e.preventDefault();
    e.currentTarget.focus();

    var _this$plugin$getPlugi3 = this.plugin.getPluginState(),
        folders = _this$plugin$getPlugi3.folders,
        files = _this$plugin$getPlugi3.files;

    var items = this.filterItems(folders.concat(files)); // Shift-clicking selects a single consecutive list of items
    // starting at the previous click and deselects everything else.

    if (this.lastCheckbox && e.shiftKey) {
      var _currentSelection;

      var prevIndex = items.indexOf(this.lastCheckbox);
      var currentIndex = items.indexOf(file);

      if (prevIndex < currentIndex) {
        _currentSelection = items.slice(prevIndex, currentIndex + 1);
      } else {
        _currentSelection = items.slice(currentIndex, prevIndex + 1);
      }

      this.plugin.setPluginState({
        currentSelection: _currentSelection
      });
      return;
    }

    this.lastCheckbox = file;

    var _this$plugin$getPlugi4 = this.plugin.getPluginState(),
        currentSelection = _this$plugin$getPlugi4.currentSelection;

    if (this.isChecked(file)) {
      this.plugin.setPluginState({
        currentSelection: currentSelection.filter(function (item) {
          return item.id !== file.id;
        })
      });
    } else {
      this.plugin.setPluginState({
        currentSelection: currentSelection.concat([file])
      });
    }
  };

  _proto2.providerFileToId = function providerFileToId(file) {
    return generateFileID({
      data: file,
      name: file.name || file.id,
      type: file.mimeType
    });
  };

  _proto2.handleAuth = function handleAuth() {
    var _this4 = this;

    var authState = btoa(JSON.stringify({
      origin: getOrigin()
    }));
    var clientVersion = encodeURIComponent("@uppy/provider-views=" + ProviderView.VERSION);
    var link = this.provider.authUrl() + "?state=" + authState + "&uppyVersions=" + clientVersion;
    var authWindow = window.open(link, '_blank');

    var handleToken = function handleToken(e) {
      if (!_this4._isOriginAllowed(e.origin, _this4.plugin.opts.companionAllowedHosts) || e.source !== authWindow) {
        _this4.plugin.uppy.log("rejecting event from " + e.origin + " vs allowed pattern " + _this4.plugin.opts.companionAllowedHosts);

        return;
      } // Check if it's a string before doing the JSON.parse to maintain support
      // for older Companion versions that used object references


      var data = typeof e.data === 'string' ? JSON.parse(e.data) : e.data;

      if (!data.token) {
        _this4.plugin.uppy.log('did not receive token from auth window');

        return;
      }

      authWindow.close();
      window.removeEventListener('message', handleToken);

      _this4.provider.setAuthToken(data.token);

      _this4.preFirstRender();
    };

    window.addEventListener('message', handleToken);
  };

  _proto2._isOriginAllowed = function _isOriginAllowed(origin, allowedOrigin) {
    var getRegex = function getRegex(value) {
      if (typeof value === 'string') {
        return new RegExp("^" + value + "$");
      } else if (value instanceof RegExp) {
        return value;
      }
    };

    var patterns = Array.isArray(allowedOrigin) ? allowedOrigin.map(getRegex) : [getRegex(allowedOrigin)];
    return patterns.filter(function (pattern) {
      return pattern != null;
    }) // loose comparison to catch undefined
    .some(function (pattern) {
      return pattern.test(origin) || pattern.test(origin + "/");
    }); // allowing for trailing '/'
  };

  _proto2.handleError = function handleError(error) {
    var uppy = this.plugin.uppy;
    uppy.log(error.toString());

    if (error.isAuthError) {
      return;
    }

    var message = uppy.i18n('companionError');
    uppy.info({
      message: message,
      details: error.toString()
    }, 'error', 5000);
  };

  _proto2.handleScroll = function handleScroll(e) {
    var _this5 = this;

    var scrollPos = e.target.scrollHeight - (e.target.scrollTop + e.target.offsetHeight);
    var path = this.nextPagePath || null;

    if (scrollPos < 50 && path && !this._isHandlingScroll) {
      this.provider.list(path).then(function (res) {
        var _this5$plugin$getPlug = _this5.plugin.getPluginState(),
            files = _this5$plugin$getPlug.files,
            folders = _this5$plugin$getPlug.folders;

        _this5._updateFilesAndFolders(res, files, folders);
      }).catch(this.handleError).then(function () {
        _this5._isHandlingScroll = false;
      }); // always called

      this._isHandlingScroll = true;
    }
  };

  _proto2.listAllFiles = function listAllFiles(path, files) {
    var _this6 = this;

    if (files === void 0) {
      files = null;
    }

    files = files || [];
    return new Promise(function (resolve, reject) {
      _this6.provider.list(path).then(function (res) {
        res.items.forEach(function (item) {
          if (!item.isFolder) {
            files.push(item);
          }
        });
        var moreFiles = res.nextPagePath || null;

        if (moreFiles) {
          return _this6.listAllFiles(moreFiles, files).then(function (files) {
            return resolve(files);
          }).catch(function (e) {
            return reject(e);
          });
        } else {
          return resolve(files);
        }
      }).catch(function (e) {
        return reject(e);
      });
    });
  };

  _proto2.donePicking = function donePicking() {
    var _this7 = this;

    var _this$plugin$getPlugi5 = this.plugin.getPluginState(),
        currentSelection = _this$plugin$getPlugi5.currentSelection;

    var promises = currentSelection.map(function (file) {
      if (file.isFolder) {
        return _this7.addFolder(file);
      } else {
        return _this7.addFile(file);
      }
    });

    this._loaderWrapper(Promise.all(promises), function () {
      _this7.clearSelection();
    }, function () {});
  };

  _proto2.cancelPicking = function cancelPicking() {
    this.clearSelection();
    var dashboard = this.plugin.uppy.getPlugin('Dashboard');
    if (dashboard) dashboard.hideAllPanels();
  };

  _proto2.clearSelection = function clearSelection() {
    this.plugin.setPluginState({
      currentSelection: []
    });
  } // displays loader view while asynchronous request is being made.
  ;

  _proto2._loaderWrapper = function _loaderWrapper(promise, then, catch_) {
    var _this8 = this;

    promise.then(function (result) {
      _this8.plugin.setPluginState({
        loading: false
      });

      then(result);
    }).catch(function (err) {
      _this8.plugin.setPluginState({
        loading: false
      });

      catch_(err);
    });
    this.plugin.setPluginState({
      loading: true
    });
  };

  _proto2.render = function render(state, viewOptions) {
    if (viewOptions === void 0) {
      viewOptions = {};
    }

    var _this$plugin$getPlugi6 = this.plugin.getPluginState(),
        authenticated = _this$plugin$getPlugi6.authenticated,
        didFirstRender = _this$plugin$getPlugi6.didFirstRender;

    if (!didFirstRender) {
      this.preFirstRender();
    } // reload pluginState for "loading" attribute because it might
    // have changed above.


    if (this.plugin.getPluginState().loading) {
      return h(CloseWrapper, {
        onUnmount: this.clearSelection
      }, h(LoaderView, {
        i18n: this.plugin.uppy.i18n
      }));
    }

    if (!authenticated) {
      return h(CloseWrapper, {
        onUnmount: this.clearSelection
      }, h(AuthView, {
        pluginName: this.plugin.title,
        pluginIcon: this.plugin.icon,
        handleAuth: this.handleAuth,
        i18n: this.plugin.uppy.i18n,
        i18nArray: this.plugin.uppy.i18nArray
      }));
    }

    var targetViewOptions = _extends({}, this.opts, {}, viewOptions);

    var browserProps = _extends({}, this.plugin.getPluginState(), {
      username: this.username,
      getNextFolder: this.getNextFolder,
      getFolder: this.getFolder,
      filterItems: this.filterItems,
      filterQuery: this.filterQuery,
      toggleSearch: this.toggleSearch,
      sortByTitle: this.sortByTitle,
      sortByDate: this.sortByDate,
      logout: this.logout,
      isActiveRow: this.isActiveRow,
      isChecked: this.isChecked,
      toggleCheckbox: this.toggleCheckbox,
      handleScroll: this.handleScroll,
      listAllFiles: this.listAllFiles,
      done: this.donePicking,
      cancel: this.cancelPicking,
      title: this.plugin.title,
      viewType: targetViewOptions.viewType,
      showTitles: targetViewOptions.showTitles,
      showFilter: targetViewOptions.showFilter,
      showBreadcrumbs: targetViewOptions.showBreadcrumbs,
      pluginIcon: this.plugin.icon,
      i18n: this.plugin.uppy.i18n
    });

    return h(CloseWrapper, {
      onUnmount: this.clearSelection
    }, h(Browser, browserProps));
  };

  return ProviderView;
}(), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":85,"./../../utils/lib/generateFileID":124,"./../../utils/lib/getFileType":132,"./../../utils/lib/isPreviewSupported":140,"./AuthView":86,"./Browser":88,"./Loader":96,"preact":17}],98:[function(require,module,exports){
module.exports={
  "name": "@uppy/status-bar",
  "description": "A progress bar for Uppy, with many bells and whistles.",
  "version": "1.4.2",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "progress bar",
    "status bar",
    "progress",
    "upload",
    "eta",
    "speed"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "classnames": "^2.2.6",
    "lodash.throttle": "^4.1.1",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],99:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var throttle = require('lodash.throttle');

var classNames = require('classnames');

var statusBarStates = require('./StatusBarStates');

var prettyBytes = require('./../../utils/lib/prettyBytes');

var prettyETA = require('./../../utils/lib/prettyETA');

var _require = require('preact'),
    h = _require.h;

function calculateProcessingProgress(files) {
  // Collect pre or postprocessing progress states.
  var progresses = [];
  Object.keys(files).forEach(function (fileID) {
    var progress = files[fileID].progress;

    if (progress.preprocess) {
      progresses.push(progress.preprocess);
    }

    if (progress.postprocess) {
      progresses.push(progress.postprocess);
    }
  }); // In the future we should probably do this differently. For now we'll take the
  // mode and message from the first file…

  var _progresses$ = progresses[0],
      mode = _progresses$.mode,
      message = _progresses$.message;
  var value = progresses.filter(isDeterminate).reduce(function (total, progress, index, all) {
    return total + progress.value / all.length;
  }, 0);

  function isDeterminate(progress) {
    return progress.mode === 'determinate';
  }

  return {
    mode: mode,
    message: message,
    value: value
  };
}

function togglePauseResume(props) {
  if (props.isAllComplete) return;

  if (!props.resumableUploads) {
    return props.cancelAll();
  }

  if (props.isAllPaused) {
    return props.resumeAll();
  }

  return props.pauseAll();
}

module.exports = function (props) {
  props = props || {};
  var _props = props,
      newFiles = _props.newFiles,
      allowNewUpload = _props.allowNewUpload,
      isUploadInProgress = _props.isUploadInProgress,
      isAllPaused = _props.isAllPaused,
      resumableUploads = _props.resumableUploads,
      error = _props.error,
      hideUploadButton = _props.hideUploadButton,
      hidePauseResumeButton = _props.hidePauseResumeButton,
      hideCancelButton = _props.hideCancelButton,
      hideRetryButton = _props.hideRetryButton;
  var uploadState = props.uploadState;
  var progressValue = props.totalProgress;
  var progressMode;
  var progressBarContent;

  if (uploadState === statusBarStates.STATE_PREPROCESSING || uploadState === statusBarStates.STATE_POSTPROCESSING) {
    var progress = calculateProcessingProgress(props.files);
    progressMode = progress.mode;

    if (progressMode === 'determinate') {
      progressValue = progress.value * 100;
    }

    progressBarContent = ProgressBarProcessing(progress);
  } else if (uploadState === statusBarStates.STATE_COMPLETE) {
    progressBarContent = ProgressBarComplete(props);
  } else if (uploadState === statusBarStates.STATE_UPLOADING) {
    if (!props.supportsUploadProgress) {
      progressMode = 'indeterminate';
      progressValue = null;
    }

    progressBarContent = ProgressBarUploading(props);
  } else if (uploadState === statusBarStates.STATE_ERROR) {
    progressValue = undefined;
    progressBarContent = ProgressBarError(props);
  }

  var width = typeof progressValue === 'number' ? progressValue : 100;
  var isHidden = uploadState === statusBarStates.STATE_WAITING && props.hideUploadButton || uploadState === statusBarStates.STATE_WAITING && !props.newFiles > 0 || uploadState === statusBarStates.STATE_COMPLETE && props.hideAfterFinish;
  var showUploadBtn = !error && newFiles && !isUploadInProgress && !isAllPaused && allowNewUpload && !hideUploadButton;
  var showCancelBtn = !hideCancelButton && uploadState !== statusBarStates.STATE_WAITING && uploadState !== statusBarStates.STATE_COMPLETE;
  var showPauseResumeBtn = resumableUploads && !hidePauseResumeButton && uploadState !== statusBarStates.STATE_WAITING && uploadState !== statusBarStates.STATE_PREPROCESSING && uploadState !== statusBarStates.STATE_POSTPROCESSING && uploadState !== statusBarStates.STATE_COMPLETE;
  var showRetryBtn = error && !hideRetryButton;
  var progressClassNames = "uppy-StatusBar-progress\n                           " + (progressMode ? 'is-' + progressMode : '');
  var statusBarClassNames = classNames({
    'uppy-Root': props.isTargetDOMEl
  }, 'uppy-StatusBar', "is-" + uploadState);
  return h("div", {
    class: statusBarClassNames,
    "aria-hidden": isHidden
  }, h("div", {
    class: progressClassNames,
    style: {
      width: width + '%'
    },
    role: "progressbar",
    "aria-valuemin": "0",
    "aria-valuemax": "100",
    "aria-valuenow": progressValue
  }), progressBarContent, h("div", {
    class: "uppy-StatusBar-actions"
  }, showUploadBtn ? h(UploadBtn, _extends({}, props, {
    uploadState: uploadState
  })) : null, showRetryBtn ? h(RetryBtn, props) : null, showPauseResumeBtn ? h(PauseResumeButton, props) : null, showCancelBtn ? h(CancelBtn, props) : null));
};

var UploadBtn = function UploadBtn(props) {
  var uploadBtnClassNames = classNames('uppy-u-reset', 'uppy-c-btn', 'uppy-StatusBar-actionBtn', 'uppy-StatusBar-actionBtn--upload', {
    'uppy-c-btn-primary': props.uploadState === statusBarStates.STATE_WAITING
  });
  return h("button", {
    type: "button",
    class: uploadBtnClassNames,
    "aria-label": props.i18n('uploadXFiles', {
      smart_count: props.newFiles
    }),
    onclick: props.startUpload,
    "data-uppy-super-focusable": true
  }, props.newFiles && props.isUploadStarted ? props.i18n('uploadXNewFiles', {
    smart_count: props.newFiles
  }) : props.i18n('uploadXFiles', {
    smart_count: props.newFiles
  }));
};

var RetryBtn = function RetryBtn(props) {
  return h("button", {
    type: "button",
    class: "uppy-u-reset uppy-c-btn uppy-StatusBar-actionBtn uppy-StatusBar-actionBtn--retry",
    "aria-label": props.i18n('retryUpload'),
    onclick: props.retryAll,
    "data-uppy-super-focusable": true
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    width: "8",
    height: "10",
    viewBox: "0 0 8 10"
  }, h("path", {
    d: "M4 2.408a2.75 2.75 0 1 0 2.75 2.75.626.626 0 0 1 1.25.018v.023a4 4 0 1 1-4-4.041V.25a.25.25 0 0 1 .389-.208l2.299 1.533a.25.25 0 0 1 0 .416l-2.3 1.533A.25.25 0 0 1 4 3.316v-.908z"
  })), props.i18n('retry'));
};

var CancelBtn = function CancelBtn(props) {
  return h("button", {
    type: "button",
    class: "uppy-u-reset uppy-StatusBar-actionCircleBtn",
    title: props.i18n('cancel'),
    "aria-label": props.i18n('cancel'),
    onclick: props.cancelAll,
    "data-uppy-super-focusable": true
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16"
  }, h("g", {
    fill: "none",
    "fill-rule": "evenodd"
  }, h("circle", {
    fill: "#888",
    cx: "8",
    cy: "8",
    r: "8"
  }), h("path", {
    fill: "#FFF",
    d: "M9.283 8l2.567 2.567-1.283 1.283L8 9.283 5.433 11.85 4.15 10.567 6.717 8 4.15 5.433 5.433 4.15 8 6.717l2.567-2.567 1.283 1.283z"
  }))));
};

var PauseResumeButton = function PauseResumeButton(props) {
  var isAllPaused = props.isAllPaused,
      i18n = props.i18n;
  var title = isAllPaused ? i18n('resume') : i18n('pause');
  return h("button", {
    title: title,
    "aria-label": title,
    class: "uppy-u-reset uppy-StatusBar-actionCircleBtn",
    type: "button",
    onclick: function onclick() {
      return togglePauseResume(props);
    },
    "data-uppy-super-focusable": true
  }, isAllPaused ? h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16"
  }, h("g", {
    fill: "none",
    "fill-rule": "evenodd"
  }, h("circle", {
    fill: "#888",
    cx: "8",
    cy: "8",
    r: "8"
  }), h("path", {
    fill: "#FFF",
    d: "M6 4.25L11.5 8 6 11.75z"
  }))) : h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    width: "16",
    height: "16",
    viewBox: "0 0 16 16"
  }, h("g", {
    fill: "none",
    "fill-rule": "evenodd"
  }, h("circle", {
    fill: "#888",
    cx: "8",
    cy: "8",
    r: "8"
  }), h("path", {
    d: "M5 4.5h2v7H5v-7zm4 0h2v7H9v-7z",
    fill: "#FFF"
  }))));
};

var LoadingSpinner = function LoadingSpinner() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "uppy-StatusBar-spinner",
    width: "14",
    height: "14"
  }, h("path", {
    d: "M13.983 6.547c-.12-2.509-1.64-4.893-3.939-5.936-2.48-1.127-5.488-.656-7.556 1.094C.524 3.367-.398 6.048.162 8.562c.556 2.495 2.46 4.52 4.94 5.183 2.932.784 5.61-.602 7.256-3.015-1.493 1.993-3.745 3.309-6.298 2.868-2.514-.434-4.578-2.349-5.153-4.84a6.226 6.226 0 0 1 2.98-6.778C6.34.586 9.74 1.1 11.373 3.493c.407.596.693 1.282.842 1.988.127.598.073 1.197.161 1.794.078.525.543 1.257 1.15.864.525-.341.49-1.05.456-1.592-.007-.15.02.3 0 0",
    "fill-rule": "evenodd"
  }));
};

var ProgressBarProcessing = function ProgressBarProcessing(props) {
  var value = Math.round(props.value * 100);
  return h("div", {
    class: "uppy-StatusBar-content"
  }, h(LoadingSpinner, null), props.mode === 'determinate' ? value + "% \xB7 " : '', props.message);
};

var renderDot = function renderDot() {
  return " \xB7 ";
};

var ProgressDetails = function ProgressDetails(props) {
  var ifShowFilesUploadedOfTotal = props.numUploads > 1;
  return h("div", {
    class: "uppy-StatusBar-statusSecondary"
  }, ifShowFilesUploadedOfTotal && props.i18n('filesUploadedOfTotal', {
    complete: props.complete,
    smart_count: props.numUploads
  }), h("span", {
    class: "uppy-StatusBar-additionalInfo"
  }, ifShowFilesUploadedOfTotal && renderDot(), props.i18n('dataUploadedOfTotal', {
    complete: prettyBytes(props.totalUploadedSize),
    total: prettyBytes(props.totalSize)
  }), renderDot(), props.i18n('xTimeLeft', {
    time: prettyETA(props.totalETA)
  })));
};

var UnknownProgressDetails = function UnknownProgressDetails(props) {
  return h("div", {
    class: "uppy-StatusBar-statusSecondary"
  }, props.i18n('filesUploadedOfTotal', {
    complete: props.complete,
    smart_count: props.numUploads
  }));
};

var UploadNewlyAddedFiles = function UploadNewlyAddedFiles(props) {
  var uploadBtnClassNames = classNames('uppy-u-reset', 'uppy-c-btn', 'uppy-StatusBar-actionBtn', 'uppy-StatusBar-actionBtn--uploadNewlyAdded');
  return h("div", {
    class: "uppy-StatusBar-statusSecondary"
  }, h("div", {
    class: "uppy-StatusBar-statusSecondaryHint"
  }, props.i18n('xMoreFilesAdded', {
    smart_count: props.newFiles
  })), h("button", {
    type: "button",
    class: uploadBtnClassNames,
    "aria-label": props.i18n('uploadXFiles', {
      smart_count: props.newFiles
    }),
    onclick: props.startUpload
  }, props.i18n('upload')));
};

var ThrottledProgressDetails = throttle(ProgressDetails, 500, {
  leading: true,
  trailing: true
});

var ProgressBarUploading = function ProgressBarUploading(props) {
  if (!props.isUploadStarted || props.isAllComplete) {
    return null;
  }

  var title = props.isAllPaused ? props.i18n('paused') : props.i18n('uploading');
  var showUploadNewlyAddedFiles = props.newFiles && props.isUploadStarted;
  return h("div", {
    class: "uppy-StatusBar-content",
    "aria-label": title,
    title: title
  }, !props.isAllPaused ? h(LoadingSpinner, null) : null, h("div", {
    class: "uppy-StatusBar-status"
  }, h("div", {
    class: "uppy-StatusBar-statusPrimary"
  }, props.supportsUploadProgress ? title + ": " + props.totalProgress + "%" : title), !props.isAllPaused && !showUploadNewlyAddedFiles && props.showProgressDetails ? props.supportsUploadProgress ? h(ThrottledProgressDetails, props) : h(UnknownProgressDetails, props) : null, showUploadNewlyAddedFiles ? h(UploadNewlyAddedFiles, props) : null));
};

var ProgressBarComplete = function ProgressBarComplete(_ref) {
  var totalProgress = _ref.totalProgress,
      i18n = _ref.i18n;
  return h("div", {
    class: "uppy-StatusBar-content",
    role: "status",
    title: i18n('complete')
  }, h("div", {
    class: "uppy-StatusBar-status"
  }, h("div", {
    class: "uppy-StatusBar-statusPrimary"
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "uppy-StatusBar-statusIndicator UppyIcon",
    width: "15",
    height: "11",
    viewBox: "0 0 15 11"
  }, h("path", {
    d: "M.414 5.843L1.627 4.63l3.472 3.472L13.202 0l1.212 1.213L5.1 10.528z"
  })), i18n('complete'))));
};

var ProgressBarError = function ProgressBarError(_ref2) {
  var error = _ref2.error,
      retryAll = _ref2.retryAll,
      hideRetryButton = _ref2.hideRetryButton,
      i18n = _ref2.i18n;
  return h("div", {
    class: "uppy-StatusBar-content",
    role: "alert",
    title: i18n('uploadFailed')
  }, h("div", {
    class: "uppy-StatusBar-status"
  }, h("div", {
    class: "uppy-StatusBar-statusPrimary"
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "uppy-StatusBar-statusIndicator UppyIcon",
    width: "11",
    height: "11",
    viewBox: "0 0 11 11"
  }, h("path", {
    d: "M4.278 5.5L0 1.222 1.222 0 5.5 4.278 9.778 0 11 1.222 6.722 5.5 11 9.778 9.778 11 5.5 6.722 1.222 11 0 9.778z"
  })), i18n('uploadFailed'))), h("span", {
    class: "uppy-StatusBar-details",
    "aria-label": error,
    "data-microtip-position": "top-right",
    "data-microtip-size": "medium",
    role: "tooltip"
  }, "?"));
};

},{"./../../utils/lib/prettyBytes":143,"./../../utils/lib/prettyETA":144,"./StatusBarStates":100,"classnames":1,"lodash.throttle":12,"preact":17}],100:[function(require,module,exports){
module.exports = {
  STATE_ERROR: 'error',
  STATE_WAITING: 'waiting',
  STATE_PREPROCESSING: 'preprocessing',
  STATE_UPLOADING: 'uploading',
  STATE_POSTPROCESSING: 'postprocessing',
  STATE_COMPLETE: 'complete'
};

},{}],101:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var Translator = require('./../../utils/lib/Translator');

var StatusBarUI = require('./StatusBar');

var statusBarStates = require('./StatusBarStates');

var getSpeed = require('./../../utils/lib/getSpeed');

var getBytesRemaining = require('./../../utils/lib/getBytesRemaining');
/**
 * StatusBar: renders a status bar with upload/pause/resume/cancel/retry buttons,
 * progress percentage and time remaining.
 */


module.exports = (_temp = _class =
/*#__PURE__*/
function (_Plugin) {
  _inheritsLoose(StatusBar, _Plugin);

  function StatusBar(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;

    _this.startUpload = function () {
      return _this.uppy.upload().catch(function (err) {
        if (!err.isRestriction) {
          _this.uppy.log(err.stack || err.message || err);
        }
      });
    };

    _this.id = _this.opts.id || 'StatusBar';
    _this.title = 'StatusBar';
    _this.type = 'progressindicator';
    _this.defaultLocale = {
      strings: {
        uploading: 'Uploading',
        upload: 'Upload',
        complete: 'Complete',
        uploadFailed: 'Upload failed',
        paused: 'Paused',
        retry: 'Retry',
        cancel: 'Cancel',
        pause: 'Pause',
        resume: 'Resume',
        filesUploadedOfTotal: {
          0: '%{complete} of %{smart_count} file uploaded',
          1: '%{complete} of %{smart_count} files uploaded',
          2: '%{complete} of %{smart_count} files uploaded'
        },
        dataUploadedOfTotal: '%{complete} of %{total}',
        xTimeLeft: '%{time} left',
        uploadXFiles: {
          0: 'Upload %{smart_count} file',
          1: 'Upload %{smart_count} files',
          2: 'Upload %{smart_count} files'
        },
        uploadXNewFiles: {
          0: 'Upload +%{smart_count} file',
          1: 'Upload +%{smart_count} files',
          2: 'Upload +%{smart_count} files'
        },
        xMoreFilesAdded: {
          0: '%{smart_count} more file added',
          1: '%{smart_count} more files added',
          2: '%{smart_count} more files added'
        }
      }
    }; // set default options

    var defaultOptions = {
      target: 'body',
      hideUploadButton: false,
      hideRetryButton: false,
      hidePauseResumeButton: false,
      hideCancelButton: false,
      showProgressDetails: false,
      hideAfterFinish: true
    };
    _this.opts = _extends({}, defaultOptions, {}, opts);

    _this.i18nInit();

    _this.render = _this.render.bind(_assertThisInitialized(_this));
    _this.install = _this.install.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = StatusBar.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, newOpts);

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  };

  _proto.getTotalSpeed = function getTotalSpeed(files) {
    var totalSpeed = 0;
    files.forEach(function (file) {
      totalSpeed = totalSpeed + getSpeed(file.progress);
    });
    return totalSpeed;
  };

  _proto.getTotalETA = function getTotalETA(files) {
    var totalSpeed = this.getTotalSpeed(files);

    if (totalSpeed === 0) {
      return 0;
    }

    var totalBytesRemaining = files.reduce(function (total, file) {
      return total + getBytesRemaining(file.progress);
    }, 0);
    return Math.round(totalBytesRemaining / totalSpeed * 10) / 10;
  };

  _proto.getUploadingState = function getUploadingState(isAllErrored, isAllComplete, files) {
    if (isAllErrored) {
      return statusBarStates.STATE_ERROR;
    }

    if (isAllComplete) {
      return statusBarStates.STATE_COMPLETE;
    }

    var state = statusBarStates.STATE_WAITING;
    var fileIDs = Object.keys(files);

    for (var i = 0; i < fileIDs.length; i++) {
      var progress = files[fileIDs[i]].progress; // If ANY files are being uploaded right now, show the uploading state.

      if (progress.uploadStarted && !progress.uploadComplete) {
        return statusBarStates.STATE_UPLOADING;
      } // If files are being preprocessed AND postprocessed at this time, we show the
      // preprocess state. If any files are being uploaded we show uploading.


      if (progress.preprocess && state !== statusBarStates.STATE_UPLOADING) {
        state = statusBarStates.STATE_PREPROCESSING;
      } // If NO files are being preprocessed or uploaded right now, but some files are
      // being postprocessed, show the postprocess state.


      if (progress.postprocess && state !== statusBarStates.STATE_UPLOADING && state !== statusBarStates.STATE_PREPROCESSING) {
        state = statusBarStates.STATE_POSTPROCESSING;
      }
    }

    return state;
  };

  _proto.render = function render(state) {
    var capabilities = state.capabilities,
        files = state.files,
        allowNewUpload = state.allowNewUpload,
        totalProgress = state.totalProgress,
        error = state.error; // TODO: move this to Core, to share between Status Bar and Dashboard
    // (and any other plugin that might need it, too)

    var filesArray = Object.keys(files).map(function (file) {
      return files[file];
    });
    var newFiles = filesArray.filter(function (file) {
      return !file.progress.uploadStarted && !file.progress.preprocess && !file.progress.postprocess;
    });
    var uploadStartedFiles = filesArray.filter(function (file) {
      return file.progress.uploadStarted;
    });
    var pausedFiles = uploadStartedFiles.filter(function (file) {
      return file.isPaused;
    });
    var completeFiles = filesArray.filter(function (file) {
      return file.progress.uploadComplete;
    });
    var erroredFiles = filesArray.filter(function (file) {
      return file.error;
    });
    var inProgressFiles = filesArray.filter(function (file) {
      return !file.progress.uploadComplete && file.progress.uploadStarted;
    });
    var inProgressNotPausedFiles = inProgressFiles.filter(function (file) {
      return !file.isPaused;
    });
    var startedFiles = filesArray.filter(function (file) {
      return file.progress.uploadStarted || file.progress.preprocess || file.progress.postprocess;
    });
    var processingFiles = filesArray.filter(function (file) {
      return file.progress.preprocess || file.progress.postprocess;
    });
    var totalETA = this.getTotalETA(inProgressNotPausedFiles);
    var totalSize = 0;
    var totalUploadedSize = 0;
    uploadStartedFiles.forEach(function (file) {
      totalSize = totalSize + (file.progress.bytesTotal || 0);
      totalUploadedSize = totalUploadedSize + (file.progress.bytesUploaded || 0);
    });
    var isUploadStarted = uploadStartedFiles.length > 0;
    var isAllComplete = totalProgress === 100 && completeFiles.length === Object.keys(files).length && processingFiles.length === 0;
    var isAllErrored = isUploadStarted && erroredFiles.length === uploadStartedFiles.length;
    var isAllPaused = inProgressFiles.length !== 0 && pausedFiles.length === inProgressFiles.length;
    var isUploadInProgress = inProgressFiles.length > 0;
    var resumableUploads = capabilities.resumableUploads || false;
    var supportsUploadProgress = capabilities.uploadProgress !== false;
    return StatusBarUI({
      error: error,
      uploadState: this.getUploadingState(isAllErrored, isAllComplete, state.files || {}),
      allowNewUpload: allowNewUpload,
      totalProgress: totalProgress,
      totalSize: totalSize,
      totalUploadedSize: totalUploadedSize,
      isAllComplete: isAllComplete,
      isAllPaused: isAllPaused,
      isAllErrored: isAllErrored,
      isUploadStarted: isUploadStarted,
      isUploadInProgress: isUploadInProgress,
      complete: completeFiles.length,
      newFiles: newFiles.length,
      numUploads: startedFiles.length,
      totalETA: totalETA,
      files: files,
      i18n: this.i18n,
      pauseAll: this.uppy.pauseAll,
      resumeAll: this.uppy.resumeAll,
      retryAll: this.uppy.retryAll,
      cancelAll: this.uppy.cancelAll,
      startUpload: this.startUpload,
      resumableUploads: resumableUploads,
      supportsUploadProgress: supportsUploadProgress,
      showProgressDetails: this.opts.showProgressDetails,
      hideUploadButton: this.opts.hideUploadButton,
      hideRetryButton: this.opts.hideRetryButton,
      hidePauseResumeButton: this.opts.hidePauseResumeButton,
      hideCancelButton: this.opts.hideCancelButton,
      hideAfterFinish: this.opts.hideAfterFinish,
      isTargetDOMEl: this.isTargetDOMEl
    });
  };

  _proto.install = function install() {
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.unmount();
  };

  return StatusBar;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":98,"./../../core":45,"./../../utils/lib/Translator":118,"./../../utils/lib/getBytesRemaining":125,"./../../utils/lib/getSpeed":135,"./StatusBar":99,"./StatusBarStates":100}],102:[function(require,module,exports){
module.exports={
  "name": "@uppy/store-default",
  "description": "The default simple object-based store for Uppy.",
  "version": "1.2.0",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-store"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  }
}

},{}],103:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/**
 * Default store that keeps state in a simple object.
 */
var DefaultStore =
/*#__PURE__*/
function () {
  function DefaultStore() {
    this.state = {};
    this.callbacks = [];
  }

  var _proto = DefaultStore.prototype;

  _proto.getState = function getState() {
    return this.state;
  };

  _proto.setState = function setState(patch) {
    var prevState = _extends({}, this.state);

    var nextState = _extends({}, this.state, patch);

    this.state = nextState;

    this._publish(prevState, nextState, patch);
  };

  _proto.subscribe = function subscribe(listener) {
    var _this = this;

    this.callbacks.push(listener);
    return function () {
      // Remove the listener.
      _this.callbacks.splice(_this.callbacks.indexOf(listener), 1);
    };
  };

  _proto._publish = function _publish() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    this.callbacks.forEach(function (listener) {
      listener.apply(void 0, args);
    });
  };

  return DefaultStore;
}();

DefaultStore.VERSION = require('../package.json').version;

module.exports = function defaultStore() {
  return new DefaultStore();
};

},{"../package.json":102}],104:[function(require,module,exports){
module.exports={
  "name": "@uppy/thumbnail-generator",
  "description": "Uppy plugin that generates small previews of images to show on your upload UI.",
  "version": "1.5.2",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "thumbnail",
    "preview",
    "resize"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],105:[function(require,module,exports){
// Adapted from https://github.com/exif-js/exif-js
// Removed XMP and IPTC metadata parsing and EXIF thumbnail generation
// MIT License (c) Jacob Seidelin https://github.com/exif-js/exif-js/blob/master/LICENSE.md
var ExifTags = {
  // version tags
  0x9000: 'ExifVersion',
  // EXIF version
  0xA000: 'FlashpixVersion',
  // Flashpix format version
  // colorspace tags
  0xA001: 'ColorSpace',
  // Color space information tag
  // image configuration
  0xA002: 'PixelXDimension',
  // Valid width of meaningful image
  0xA003: 'PixelYDimension',
  // Valid height of meaningful image
  0x9101: 'ComponentsConfiguration',
  // Information about channels
  0x9102: 'CompressedBitsPerPixel',
  // Compressed bits per pixel
  // user information
  0x927C: 'MakerNote',
  // Any desired information written by the manufacturer
  0x9286: 'UserComment',
  // Comments by user
  // related file
  0xA004: 'RelatedSoundFile',
  // Name of related sound file
  // date and time
  0x9003: 'DateTimeOriginal',
  // Date and time when the original image was generated
  0x9004: 'DateTimeDigitized',
  // Date and time when the image was stored digitally
  0x9290: 'SubsecTime',
  // Fractions of seconds for DateTime
  0x9291: 'SubsecTimeOriginal',
  // Fractions of seconds for DateTimeOriginal
  0x9292: 'SubsecTimeDigitized',
  // Fractions of seconds for DateTimeDigitized
  // picture-taking conditions
  0x829A: 'ExposureTime',
  // Exposure time (in seconds)
  0x829D: 'FNumber',
  // F number
  0x8822: 'ExposureProgram',
  // Exposure program
  0x8824: 'SpectralSensitivity',
  // Spectral sensitivity
  0x8827: 'ISOSpeedRatings',
  // ISO speed rating
  0x8828: 'OECF',
  // Optoelectric conversion factor
  0x9201: 'ShutterSpeedValue',
  // Shutter speed
  0x9202: 'ApertureValue',
  // Lens aperture
  0x9203: 'BrightnessValue',
  // Value of brightness
  0x9204: 'ExposureBias',
  // Exposure bias
  0x9205: 'MaxApertureValue',
  // Smallest F number of lens
  0x9206: 'SubjectDistance',
  // Distance to subject in meters
  0x9207: 'MeteringMode',
  // Metering mode
  0x9208: 'LightSource',
  // Kind of light source
  0x9209: 'Flash',
  // Flash status
  0x9214: 'SubjectArea',
  // Location and area of main subject
  0x920A: 'FocalLength',
  // Focal length of the lens in mm
  0xA20B: 'FlashEnergy',
  // Strobe energy in BCPS
  0xA20C: 'SpatialFrequencyResponse',
  //
  0xA20E: 'FocalPlaneXResolution',
  // Number of pixels in width direction per FocalPlaneResolutionUnit
  0xA20F: 'FocalPlaneYResolution',
  // Number of pixels in height direction per FocalPlaneResolutionUnit
  0xA210: 'FocalPlaneResolutionUnit',
  // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution
  0xA214: 'SubjectLocation',
  // Location of subject in image
  0xA215: 'ExposureIndex',
  // Exposure index selected on camera
  0xA217: 'SensingMethod',
  // Image sensor type
  0xA300: 'FileSource',
  // Image source (3 === DSC)
  0xA301: 'SceneType',
  // Scene type (1 === directly photographed)
  0xA302: 'CFAPattern',
  // Color filter array geometric pattern
  0xA401: 'CustomRendered',
  // Special processing
  0xA402: 'ExposureMode',
  // Exposure mode
  0xA403: 'WhiteBalance',
  // 1 = auto white balance, 2 = manual
  0xA404: 'DigitalZoomRation',
  // Digital zoom ratio
  0xA405: 'FocalLengthIn35mmFilm',
  // Equivalent foacl length assuming 35mm film camera (in mm)
  0xA406: 'SceneCaptureType',
  // Type of scene
  0xA407: 'GainControl',
  // Degree of overall image gain adjustment
  0xA408: 'Contrast',
  // Direction of contrast processing applied by camera
  0xA409: 'Saturation',
  // Direction of saturation processing applied by camera
  0xA40A: 'Sharpness',
  // Direction of sharpness processing applied by camera
  0xA40B: 'DeviceSettingDescription',
  //
  0xA40C: 'SubjectDistanceRange',
  // Distance to subject
  // other tags
  0xA005: 'InteroperabilityIFDPointer',
  0xA420: 'ImageUniqueID' // Identifier assigned uniquely to each image

};
var TiffTags = {
  0x0100: 'ImageWidth',
  0x0101: 'ImageHeight',
  0x8769: 'ExifIFDPointer',
  0x8825: 'GPSInfoIFDPointer',
  0xA005: 'InteroperabilityIFDPointer',
  0x0102: 'BitsPerSample',
  0x0103: 'Compression',
  0x0106: 'PhotometricInterpretation',
  0x0112: 'Orientation',
  0x0115: 'SamplesPerPixel',
  0x011C: 'PlanarConfiguration',
  0x0212: 'YCbCrSubSampling',
  0x0213: 'YCbCrPositioning',
  0x011A: 'XResolution',
  0x011B: 'YResolution',
  0x0128: 'ResolutionUnit',
  0x0111: 'StripOffsets',
  0x0116: 'RowsPerStrip',
  0x0117: 'StripByteCounts',
  0x0201: 'JPEGInterchangeFormat',
  0x0202: 'JPEGInterchangeFormatLength',
  0x012D: 'TransferFunction',
  0x013E: 'WhitePoint',
  0x013F: 'PrimaryChromaticities',
  0x0211: 'YCbCrCoefficients',
  0x0214: 'ReferenceBlackWhite',
  0x0132: 'DateTime',
  0x010E: 'ImageDescription',
  0x010F: 'Make',
  0x0110: 'Model',
  0x0131: 'Software',
  0x013B: 'Artist',
  0x8298: 'Copyright'
};
var GPSTags = {
  0x0000: 'GPSVersionID',
  0x0001: 'GPSLatitudeRef',
  0x0002: 'GPSLatitude',
  0x0003: 'GPSLongitudeRef',
  0x0004: 'GPSLongitude',
  0x0005: 'GPSAltitudeRef',
  0x0006: 'GPSAltitude',
  0x0007: 'GPSTimeStamp',
  0x0008: 'GPSSatellites',
  0x0009: 'GPSStatus',
  0x000A: 'GPSMeasureMode',
  0x000B: 'GPSDOP',
  0x000C: 'GPSSpeedRef',
  0x000D: 'GPSSpeed',
  0x000E: 'GPSTrackRef',
  0x000F: 'GPSTrack',
  0x0010: 'GPSImgDirectionRef',
  0x0011: 'GPSImgDirection',
  0x0012: 'GPSMapDatum',
  0x0013: 'GPSDestLatitudeRef',
  0x0014: 'GPSDestLatitude',
  0x0015: 'GPSDestLongitudeRef',
  0x0016: 'GPSDestLongitude',
  0x0017: 'GPSDestBearingRef',
  0x0018: 'GPSDestBearing',
  0x0019: 'GPSDestDistanceRef',
  0x001A: 'GPSDestDistance',
  0x001B: 'GPSProcessingMethod',
  0x001C: 'GPSAreaInformation',
  0x001D: 'GPSDateStamp',
  0x001E: 'GPSDifferential'
};
var StringValues = {
  ExposureProgram: {
    0: 'Not defined',
    1: 'Manual',
    2: 'Normal program',
    3: 'Aperture priority',
    4: 'Shutter priority',
    5: 'Creative program',
    6: 'Action program',
    7: 'Portrait mode',
    8: 'Landscape mode'
  },
  MeteringMode: {
    0: 'Unknown',
    1: 'Average',
    2: 'CenterWeightedAverage',
    3: 'Spot',
    4: 'MultiSpot',
    5: 'Pattern',
    6: 'Partial',
    255: 'Other'
  },
  LightSource: {
    0: 'Unknown',
    1: 'Daylight',
    2: 'Fluorescent',
    3: 'Tungsten (incandescent light)',
    4: 'Flash',
    9: 'Fine weather',
    10: 'Cloudy weather',
    11: 'Shade',
    12: 'Daylight fluorescent (D 5700 - 7100K)',
    13: 'Day white fluorescent (N 4600 - 5400K)',
    14: 'Cool white fluorescent (W 3900 - 4500K)',
    15: 'White fluorescent (WW 3200 - 3700K)',
    17: 'Standard light A',
    18: 'Standard light B',
    19: 'Standard light C',
    20: 'D55',
    21: 'D65',
    22: 'D75',
    23: 'D50',
    24: 'ISO studio tungsten',
    255: 'Other'
  },
  Flash: {
    0x0000: 'Flash did not fire',
    0x0001: 'Flash fired',
    0x0005: 'Strobe return light not detected',
    0x0007: 'Strobe return light detected',
    0x0009: 'Flash fired, compulsory flash mode',
    0x000D: 'Flash fired, compulsory flash mode, return light not detected',
    0x000F: 'Flash fired, compulsory flash mode, return light detected',
    0x0010: 'Flash did not fire, compulsory flash mode',
    0x0018: 'Flash did not fire, auto mode',
    0x0019: 'Flash fired, auto mode',
    0x001D: 'Flash fired, auto mode, return light not detected',
    0x001F: 'Flash fired, auto mode, return light detected',
    0x0020: 'No flash function',
    0x0041: 'Flash fired, red-eye reduction mode',
    0x0045: 'Flash fired, red-eye reduction mode, return light not detected',
    0x0047: 'Flash fired, red-eye reduction mode, return light detected',
    0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',
    0x004D: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',
    0x004F: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',
    0x0059: 'Flash fired, auto mode, red-eye reduction mode',
    0x005D: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',
    0x005F: 'Flash fired, auto mode, return light detected, red-eye reduction mode'
  },
  SensingMethod: {
    1: 'Not defined',
    2: 'One-chip color area sensor',
    3: 'Two-chip color area sensor',
    4: 'Three-chip color area sensor',
    5: 'Color sequential area sensor',
    7: 'Trilinear sensor',
    8: 'Color sequential linear sensor'
  },
  SceneCaptureType: {
    0: 'Standard',
    1: 'Landscape',
    2: 'Portrait',
    3: 'Night scene'
  },
  SceneType: {
    1: 'Directly photographed'
  },
  CustomRendered: {
    0: 'Normal process',
    1: 'Custom process'
  },
  WhiteBalance: {
    0: 'Auto white balance',
    1: 'Manual white balance'
  },
  GainControl: {
    0: 'None',
    1: 'Low gain up',
    2: 'High gain up',
    3: 'Low gain down',
    4: 'High gain down'
  },
  Contrast: {
    0: 'Normal',
    1: 'Soft',
    2: 'Hard'
  },
  Saturation: {
    0: 'Normal',
    1: 'Low saturation',
    2: 'High saturation'
  },
  Sharpness: {
    0: 'Normal',
    1: 'Soft',
    2: 'Hard'
  },
  SubjectDistanceRange: {
    0: 'Unknown',
    1: 'Macro',
    2: 'Close view',
    3: 'Distant view'
  },
  FileSource: {
    3: 'DSC'
  },
  Components: {
    0: '',
    1: 'Y',
    2: 'Cb',
    3: 'Cr',
    4: 'R',
    5: 'G',
    6: 'B'
  }
};

function imageHasData(img) {
  return !!img.exifdata;
}

function base64ToArrayBuffer(base64, contentType) {
  contentType = contentType || base64.match(/^data:([^;]+);base64,/mi)[1] || ''; // e.g. 'data:image/jpeg;base64,...' => 'image/jpeg'

  base64 = base64.replace(/^data:([^;]+);base64,/gmi, '');
  var binary = atob(base64);
  var len = binary.length;
  var buffer = new ArrayBuffer(len); // eslint-disable-next-line compat/compat

  var view = new Uint8Array(buffer);

  for (var i = 0; i < len; i++) {
    view[i] = binary.charCodeAt(i);
  }

  return buffer;
}

function objectURLToBlob(url, callback) {
  var http = new XMLHttpRequest();
  http.open('GET', url, true);
  http.responseType = 'blob';

  http.onload = function (e) {
    if (this.status === 200 || this.status === 0) {
      callback(this.response);
    }
  };

  http.send();
}

function getImageData(img, callback) {
  function handleBinaryFile(binFile) {
    var data = findEXIFinJPEG(binFile);
    img.exifdata = data || {};

    if (callback) {
      callback.call(img);
    }
  }

  if (img.src) {
    if (/^data:/i.test(img.src)) {
      // Data URI
      var arrayBuffer = base64ToArrayBuffer(img.src);
      handleBinaryFile(arrayBuffer);
    } else if (/^blob:/i.test(img.src)) {
      // Object URL
      var fileReader = new FileReader();

      fileReader.onload = function (e) {
        handleBinaryFile(e.target.result);
      };

      objectURLToBlob(img.src, function (blob) {
        fileReader.readAsArrayBuffer(blob);
      });
    } else {
      var http = new XMLHttpRequest();

      http.onload = function () {
        if (this.status === 200 || this.status === 0) {
          handleBinaryFile(http.response);
        } else {
          throw new Error('Could not load image');
        }

        http = null;
      };

      http.open('GET', img.src, true);
      http.responseType = 'arraybuffer';
      http.send(null);
    }
  } else if (self.FileReader && (img instanceof self.Blob || img instanceof self.File)) {
    var _fileReader = new FileReader();

    _fileReader.onload = function (e) {
      handleBinaryFile(e.target.result);
    };

    _fileReader.readAsArrayBuffer(img);
  }
}

function findEXIFinJPEG(file) {
  var dataView = new DataView(file);

  if (dataView.getUint8(0) !== 0xFF || dataView.getUint8(1) !== 0xD8) {
    return false; // not a valid jpeg
  }

  var offset = 2;
  var length = file.byteLength;
  var marker;

  while (offset < length) {
    if (dataView.getUint8(offset) !== 0xFF) {
      return false; // not a valid marker, something is wrong
    }

    marker = dataView.getUint8(offset + 1); // we could implement handling for other markers here,
    // but we're only looking for 0xFFE1 for EXIF data

    if (marker === 225) {
      return readEXIFData(dataView, offset + 4, dataView.getUint16(offset + 2) - 2);
    } else {
      offset += 2 + dataView.getUint16(offset + 2);
    }
  }
}

function readTags(file, tiffStart, dirStart, strings, bigEnd) {
  var entries = file.getUint16(dirStart, !bigEnd);
  var tags = {};
  var entryOffset;
  var tag;
  var i;

  for (i = 0; i < entries; i++) {
    entryOffset = dirStart + i * 12 + 2;
    tag = strings[file.getUint16(entryOffset, !bigEnd)];
    tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);
  }

  return tags;
}

function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {
  var type = file.getUint16(entryOffset + 2, !bigEnd);
  var numValues = file.getUint32(entryOffset + 4, !bigEnd);
  var valueOffset = file.getUint32(entryOffset + 8, !bigEnd) + tiffStart;
  var offset;
  var vals;
  var val;
  var n;
  var numerator;
  var denominator;

  switch (type) {
    case 1: // byte, 8-bit unsigned int

    case 7:
      // undefined, 8-bit byte, value depending on field
      if (numValues === 1) {
        return file.getUint8(entryOffset + 8, !bigEnd);
      } else {
        offset = numValues > 4 ? valueOffset : entryOffset + 8;
        vals = [];

        for (n = 0; n < numValues; n++) {
          vals[n] = file.getUint8(offset + n);
        }

        return vals;
      }

    case 2:
      // ascii, 8-bit byte
      offset = numValues > 4 ? valueOffset : entryOffset + 8;
      return getStringFromDB(file, offset, numValues - 1);

    case 3:
      // short, 16 bit int
      if (numValues === 1) {
        return file.getUint16(entryOffset + 8, !bigEnd);
      } else {
        offset = numValues > 2 ? valueOffset : entryOffset + 8;
        vals = [];

        for (n = 0; n < numValues; n++) {
          vals[n] = file.getUint16(offset + 2 * n, !bigEnd);
        }

        return vals;
      }

    case 4:
      // long, 32 bit int
      if (numValues === 1) {
        return file.getUint32(entryOffset + 8, !bigEnd);
      } else {
        vals = [];

        for (n = 0; n < numValues; n++) {
          vals[n] = file.getUint32(valueOffset + 4 * n, !bigEnd);
        }

        return vals;
      }

    case 5:
      // rational = two long values, first is numerator, second is denominator
      if (numValues === 1) {
        numerator = file.getUint32(valueOffset, !bigEnd);
        denominator = file.getUint32(valueOffset + 4, !bigEnd);
        val = +(numerator / denominator);
        return val;
      } else {
        vals = [];

        for (n = 0; n < numValues; n++) {
          numerator = file.getUint32(valueOffset + 8 * n, !bigEnd);
          denominator = file.getUint32(valueOffset + 4 + 8 * n, !bigEnd);
          vals[n] = +(numerator / denominator);
        }

        return vals;
      }

    case 9:
      // slong, 32 bit signed int
      if (numValues === 1) {
        return file.getInt32(entryOffset + 8, !bigEnd);
      } else {
        vals = [];

        for (n = 0; n < numValues; n++) {
          vals[n] = file.getInt32(valueOffset + 4 * n, !bigEnd);
        }

        return vals;
      }

    case 10:
      // signed rational, two slongs, first is numerator, second is denominator
      if (numValues === 1) {
        return file.getInt32(valueOffset, !bigEnd) / file.getInt32(valueOffset + 4, !bigEnd);
      } else {
        vals = [];

        for (n = 0; n < numValues; n++) {
          vals[n] = file.getInt32(valueOffset + 8 * n, !bigEnd) / file.getInt32(valueOffset + 4 + 8 * n, !bigEnd);
        }

        return vals;
      }

  }
}

function getStringFromDB(buffer, start, length) {
  var outstr = '';

  for (var n = start; n < start + length; n++) {
    outstr += String.fromCharCode(buffer.getUint8(n));
  }

  return outstr;
}

function readEXIFData(file, start) {
  if (getStringFromDB(file, start, 4) !== 'Exif') {
    return false;
  }

  var bigEnd;
  var tags;
  var tag;
  var exifData;
  var gpsData;
  var tiffOffset = start + 6; // test for TIFF validity and endianness

  if (file.getUint16(tiffOffset) === 0x4949) {
    bigEnd = false;
  } else if (file.getUint16(tiffOffset) === 0x4D4D) {
    bigEnd = true;
  } else {
    return false;
  }

  if (file.getUint16(tiffOffset + 2, !bigEnd) !== 0x002A) {
    return false;
  }

  var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);

  if (firstIFDOffset < 0x00000008) {
    return false;
  }

  tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, TiffTags, bigEnd);

  if (tags.ExifIFDPointer) {
    exifData = readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, ExifTags, bigEnd);

    for (tag in exifData) {
      switch (tag) {
        case 'LightSource':
        case 'Flash':
        case 'MeteringMode':
        case 'ExposureProgram':
        case 'SensingMethod':
        case 'SceneCaptureType':
        case 'SceneType':
        case 'CustomRendered':
        case 'WhiteBalance':
        case 'GainControl':
        case 'Contrast':
        case 'Saturation':
        case 'Sharpness':
        case 'SubjectDistanceRange':
        case 'FileSource':
          exifData[tag] = StringValues[tag][exifData[tag]];
          break;

        case 'ExifVersion':
        case 'FlashpixVersion':
          exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);
          break;

        case 'ComponentsConfiguration':
          exifData[tag] = StringValues.Components[exifData[tag][0]] + StringValues.Components[exifData[tag][1]] + StringValues.Components[exifData[tag][2]] + StringValues.Components[exifData[tag][3]];
          break;
      }

      tags[tag] = exifData[tag];
    }
  }

  if (tags.GPSInfoIFDPointer) {
    gpsData = readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, GPSTags, bigEnd);

    for (tag in gpsData) {
      switch (tag) {
        case 'GPSVersionID':
          gpsData[tag] = gpsData[tag][0] + '.' + gpsData[tag][1] + '.' + gpsData[tag][2] + '.' + gpsData[tag][3];
          break;
      }

      tags[tag] = gpsData[tag];
    }
  }

  return tags;
}

function getData(img, callback) {
  if ((self.Image && img instanceof self.Image || self.HTMLImageElement && img instanceof self.HTMLImageElement) && !img.complete) {
    return false;
  }

  if (!imageHasData(img)) {
    getImageData(img, callback);
  } else {
    if (callback) {
      callback.call(img);
    }
  }

  return true;
}

function getTag(img, tag) {
  if (!imageHasData(img)) return;
  return img.exifdata[tag];
}

function getAllTags(img) {
  if (!imageHasData(img)) return {};
  return img.exifdata;
}

module.exports = {
  getAllTags: getAllTags,
  getData: getData,
  getTag: getTag
};

},{}],106:[function(require,module,exports){
var ORIENTATIONS = {
  1: {
    rotation: 0,
    xScale: 1,
    yScale: 1
  },
  2: {
    rotation: 0,
    xScale: -1,
    yScale: 1
  },
  3: {
    rotation: 180,
    xScale: 1,
    yScale: 1
  },
  4: {
    rotation: 180,
    xScale: -1,
    yScale: 1
  },
  5: {
    rotation: 90,
    xScale: 1,
    yScale: -1
  },
  6: {
    rotation: 90,
    xScale: 1,
    yScale: 1
  },
  7: {
    rotation: 270,
    xScale: 1,
    yScale: -1
  },
  8: {
    rotation: 270,
    xScale: 1,
    yScale: 1
  }
};
module.exports = ORIENTATIONS;

},{}],107:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var Translator = require('./../../utils/lib/Translator');

var dataURItoBlob = require('./../../utils/lib/dataURItoBlob');

var isObjectURL = require('./../../utils/lib/isObjectURL');

var isPreviewSupported = require('./../../utils/lib/isPreviewSupported');

var ORIENTATIONS = require('./image-orientations');

var Exif = require('./exif');
/**
 * The Thumbnail Generator plugin
 */


module.exports = (_temp = _class =
/*#__PURE__*/
function (_Plugin) {
  _inheritsLoose(ThumbnailGenerator, _Plugin);

  function ThumbnailGenerator(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;

    _this.onFileAdded = function (file) {
      if (!file.preview && isPreviewSupported(file.type) && !file.isRemote) {
        _this.addToQueue(file);
      }
    };

    _this.onFileRemoved = function (file) {
      var index = _this.queue.indexOf(file);

      if (index !== -1) {
        _this.queue.splice(index, 1);
      } // Clean up object URLs.


      if (file.preview && isObjectURL(file.preview)) {
        URL.revokeObjectURL(file.preview);
      }
    };

    _this.onRestored = function () {
      var _this$uppy$getState = _this.uppy.getState(),
          files = _this$uppy$getState.files;

      var fileIDs = Object.keys(files);
      fileIDs.forEach(function (fileID) {
        var file = _this.uppy.getFile(fileID);

        if (!file.isRestored) return; // Only add blob URLs; they are likely invalid after being restored.

        if (!file.preview || isObjectURL(file.preview)) {
          _this.addToQueue(file);
        }
      });
    };

    _this.waitUntilAllProcessed = function (fileIDs) {
      fileIDs.forEach(function (fileID) {
        var file = _this.uppy.getFile(fileID);

        _this.uppy.emit('preprocess-progress', file, {
          mode: 'indeterminate',
          message: _this.i18n('generatingThumbnails')
        });
      });

      var emitPreprocessCompleteForAll = function emitPreprocessCompleteForAll() {
        fileIDs.forEach(function (fileID) {
          var file = _this.uppy.getFile(fileID);

          _this.uppy.emit('preprocess-complete', file);
        });
      };

      return new Promise(function (resolve, reject) {
        if (_this.queueProcessing) {
          _this.uppy.once('thumbnail:all-generated', function () {
            emitPreprocessCompleteForAll();
            resolve();
          });
        } else {
          emitPreprocessCompleteForAll();
          resolve();
        }
      });
    };

    _this.type = 'modifier';
    _this.id = _this.opts.id || 'ThumbnailGenerator';
    _this.title = 'Thumbnail Generator';
    _this.queue = [];
    _this.queueProcessing = false;
    _this.defaultThumbnailDimension = 200;
    _this.defaultLocale = {
      strings: {
        generatingThumbnails: 'Generating thumbnails...'
      }
    };
    var defaultOptions = {
      thumbnailWidth: null,
      thumbnailHeight: null,
      waitForThumbnailsBeforeUpload: false
    };
    _this.opts = _extends({}, defaultOptions, {}, opts);

    _this.i18nInit();

    return _this;
  }

  var _proto = ThumbnailGenerator.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, newOpts);

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  }
  /**
   * Create a thumbnail for the given Uppy file object.
   *
   * @param {{data: Blob}} file
   * @param {number} targetWidth
   * @param {number} targetHeight
   * @returns {Promise}
   */
  ;

  _proto.createThumbnail = function createThumbnail(file, targetWidth, targetHeight) {
    var _this2 = this;

    var originalUrl = URL.createObjectURL(file.data);
    var onload = new Promise(function (resolve, reject) {
      var image = new Image();
      image.src = originalUrl;
      image.addEventListener('load', function () {
        URL.revokeObjectURL(originalUrl);
        resolve(image);
      });
      image.addEventListener('error', function (event) {
        URL.revokeObjectURL(originalUrl);
        reject(event.error || new Error('Could not create thumbnail'));
      });
    });
    return Promise.all([onload, this.getOrientation(file)]).then(function (values) {
      var image = values[0];
      var orientation = values[1];

      var dimensions = _this2.getProportionalDimensions(image, targetWidth, targetHeight, orientation.rotation);

      var rotatedImage = _this2.rotateImage(image, orientation);

      var resizedImage = _this2.resizeImage(rotatedImage, dimensions.width, dimensions.height);

      return _this2.canvasToBlob(resizedImage, 'image/png');
    }).then(function (blob) {
      return URL.createObjectURL(blob);
    });
  }
  /**
   * Get the new calculated dimensions for the given image and a target width
   * or height. If both width and height are given, only width is taken into
   * account. If neither width nor height are given, the default dimension
   * is used.
   */
  ;

  _proto.getProportionalDimensions = function getProportionalDimensions(img, width, height, rotation) {
    var aspect = img.width / img.height;

    if (rotation === 90 || rotation === 270) {
      aspect = img.height / img.width;
    }

    if (width != null) {
      return {
        width: width,
        height: Math.round(width / aspect)
      };
    }

    if (height != null) {
      return {
        width: Math.round(height * aspect),
        height: height
      };
    }

    return {
      width: this.defaultThumbnailDimension,
      height: Math.round(this.defaultThumbnailDimension / aspect)
    };
  };

  _proto.getOrientation = function getOrientation(file) {
    var _this3 = this;

    return new Promise(function (resolve) {
      var uppy = _this3.uppy;
      Exif.getData(file.data, function exifGetDataCallback() {
        uppy.setFileMeta(file.id, {
          exifdata: Exif.getAllTags(this)
        });
        var orientation = Exif.getTag(this, 'Orientation') || 1;
        resolve(ORIENTATIONS[orientation]);
      });
    });
  }
  /**
   * Make sure the image doesn’t exceed browser/device canvas limits.
   * For ios with 256 RAM and ie
   */
  ;

  _proto.protect = function protect(image) {
    // https://stackoverflow.com/questions/6081483/maximum-size-of-a-canvas-element
    var ratio = image.width / image.height;
    var maxSquare = 5000000; // ios max canvas square

    var maxSize = 4096; // ie max canvas dimensions

    var maxW = Math.floor(Math.sqrt(maxSquare * ratio));
    var maxH = Math.floor(maxSquare / Math.sqrt(maxSquare * ratio));

    if (maxW > maxSize) {
      maxW = maxSize;
      maxH = Math.round(maxW / ratio);
    }

    if (maxH > maxSize) {
      maxH = maxSize;
      maxW = Math.round(ratio * maxH);
    }

    if (image.width > maxW) {
      var canvas = document.createElement('canvas');
      canvas.width = maxW;
      canvas.height = maxH;
      canvas.getContext('2d').drawImage(image, 0, 0, maxW, maxH);
      image = canvas;
    }

    return image;
  }
  /**
   * Resize an image to the target `width` and `height`.
   *
   * Returns a Canvas with the resized image on it.
   */
  ;

  _proto.resizeImage = function resizeImage(image, targetWidth, targetHeight) {
    // Resizing in steps refactored to use a solution from
    // https://blog.uploadcare.com/image-resize-in-browsers-is-broken-e38eed08df01
    image = this.protect(image); // Use the Polyfill for Math.log2() since IE doesn't support log2
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log2#Polyfill

    var steps = Math.ceil(Math.log(image.width / targetWidth) * Math.LOG2E);

    if (steps < 1) {
      steps = 1;
    }

    var sW = targetWidth * Math.pow(2, steps - 1);
    var sH = targetHeight * Math.pow(2, steps - 1);
    var x = 2;

    while (steps--) {
      var canvas = document.createElement('canvas');
      canvas.width = sW;
      canvas.height = sH;
      canvas.getContext('2d').drawImage(image, 0, 0, sW, sH);
      image = canvas;
      sW = Math.round(sW / x);
      sH = Math.round(sH / x);
    }

    return image;
  };

  _proto.rotateImage = function rotateImage(image, translate) {
    var w = image.width;
    var h = image.height;

    if (translate.rotation === 90 || translate.rotation === 270) {
      w = image.height;
      h = image.width;
    }

    var canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    var context = canvas.getContext('2d');
    context.translate(w / 2, h / 2);
    context.rotate(translate.rotation * Math.PI / 180);
    context.scale(translate.xScale, translate.yScale);
    context.drawImage(image, -image.width / 2, -image.height / 2, image.width, image.height);
    return canvas;
  }
  /**
   * Save a <canvas> element's content to a Blob object.
   *
   * @param {HTMLCanvasElement} canvas
   * @returns {Promise}
   */
  ;

  _proto.canvasToBlob = function canvasToBlob(canvas, type, quality) {
    try {
      canvas.getContext('2d').getImageData(0, 0, 1, 1);
    } catch (err) {
      if (err.code === 18) {
        return Promise.reject(new Error('cannot read image, probably an svg with external resources'));
      }
    }

    if (canvas.toBlob) {
      return new Promise(function (resolve) {
        canvas.toBlob(resolve, type, quality);
      }).then(function (blob) {
        if (blob === null) {
          throw new Error('cannot read image, probably an svg with external resources');
        }

        return blob;
      });
    }

    return Promise.resolve().then(function () {
      return dataURItoBlob(canvas.toDataURL(type, quality), {});
    }).then(function (blob) {
      if (blob === null) {
        throw new Error('could not extract blob, probably an old browser');
      }

      return blob;
    });
  }
  /**
   * Set the preview URL for a file.
   */
  ;

  _proto.setPreviewURL = function setPreviewURL(fileID, preview) {
    this.uppy.setFileState(fileID, {
      preview: preview
    });
  };

  _proto.addToQueue = function addToQueue(item) {
    this.queue.push(item);

    if (this.queueProcessing === false) {
      this.processQueue();
    }
  };

  _proto.processQueue = function processQueue() {
    var _this4 = this;

    this.queueProcessing = true;

    if (this.queue.length > 0) {
      var current = this.queue.shift();
      return this.requestThumbnail(current).catch(function (err) {}) // eslint-disable-line handle-callback-err
      .then(function () {
        return _this4.processQueue();
      });
    } else {
      this.queueProcessing = false;
      this.uppy.log('[ThumbnailGenerator] Emptied thumbnail queue');
      this.uppy.emit('thumbnail:all-generated');
    }
  };

  _proto.requestThumbnail = function requestThumbnail(file) {
    var _this5 = this;

    if (isPreviewSupported(file.type) && !file.isRemote) {
      return this.createThumbnail(file, this.opts.thumbnailWidth, this.opts.thumbnailHeight).then(function (preview) {
        _this5.setPreviewURL(file.id, preview);

        _this5.uppy.log("[ThumbnailGenerator] Generated thumbnail for " + file.id);

        _this5.uppy.emit('thumbnail:generated', _this5.uppy.getFile(file.id), preview);
      }).catch(function (err) {
        _this5.uppy.log("[ThumbnailGenerator] Failed thumbnail for " + file.id + ":", 'warning');

        _this5.uppy.log(err, 'warning');

        _this5.uppy.emit('thumbnail:error', _this5.uppy.getFile(file.id), err);
      });
    }

    return Promise.resolve();
  };

  _proto.install = function install() {
    this.uppy.on('file-removed', this.onFileRemoved);
    this.uppy.on('file-added', this.onFileAdded);
    this.uppy.on('restored', this.onRestored);

    if (this.opts.waitForThumbnailsBeforeUpload) {
      this.uppy.addPreProcessor(this.waitUntilAllProcessed);
    }
  };

  _proto.uninstall = function uninstall() {
    this.uppy.off('file-removed', this.onFileRemoved);
    this.uppy.off('file-added', this.onFileAdded);
    this.uppy.off('restored', this.onRestored);

    if (this.opts.waitForThumbnailsBeforeUpload) {
      this.uppy.removePreProcessor(this.waitUntilAllProcessed);
    }
  };

  return ThumbnailGenerator;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":104,"./../../core":45,"./../../utils/lib/Translator":118,"./../../utils/lib/dataURItoBlob":120,"./../../utils/lib/isObjectURL":139,"./../../utils/lib/isPreviewSupported":140,"./exif":105,"./image-orientations":106}],108:[function(require,module,exports){
module.exports={
  "name": "@uppy/tus",
  "description": "Resumable uploads for Uppy using Tus.io",
  "version": "1.5.2",
  "license": "MIT",
  "main": "lib/index.js",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "upload",
    "resumable",
    "tus"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/utils": "file:../utils",
    "tus-js-client": "^1.8.0"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],109:[function(require,module,exports){
var tus = require('tus-js-client');

function isCordova() {
  return typeof window !== 'undefined' && (typeof window.PhoneGap !== 'undefined' || typeof window.Cordova !== 'undefined' || typeof window.cordova !== 'undefined');
}

function isReactNative() {
  return typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative';
} // We override tus fingerprint to uppy’s `file.id`, since the `file.id`
// now also includes `relativePath` for files added from folders.
// This means you can add 2 identical files, if one is in folder a,
// the other in folder b — `a/file.jpg` and `b/file.jpg`, when added
// together with a folder, will be treated as 2 separate files.
//
// For React Native and Cordova, we let tus-js-client’s default
// fingerprint handling take charge.


module.exports = function getFingerprint(uppyFileObj) {
  return function (file, options, callback) {
    if (isCordova() || isReactNative()) {
      return tus.Upload.defaultOptions.fingerprint(file, options, callback);
    }

    var uppyFingerprint = ['tus', uppyFileObj.id, options.endpoint].join('-');
    return callback(null, uppyFingerprint);
  };
};

},{"tus-js-client":31}],110:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var tus = require('tus-js-client');

var _require2 = require('./../../companion-client'),
    Provider = _require2.Provider,
    RequestClient = _require2.RequestClient,
    Socket = _require2.Socket;

var emitSocketProgress = require('./../../utils/lib/emitSocketProgress');

var getSocketHost = require('./../../utils/lib/getSocketHost');

var settle = require('./../../utils/lib/settle');

var EventTracker = require('./../../utils/lib/EventTracker');

var RateLimitedQueue = require('./../../utils/lib/RateLimitedQueue');

var getFingerprint = require('./getFingerprint');
/** @typedef {import('..').TusOptions} TusOptions */

/** @typedef {import('@uppy/core').Uppy} Uppy */

/** @typedef {import('@uppy/core').UppyFile} UppyFile */

/** @typedef {import('@uppy/core').FailedUppyFile<{}>} FailedUppyFile */

/**
 * Extracted from https://github.com/tus/tus-js-client/blob/master/lib/upload.js#L13
 * excepted we removed 'fingerprint' key to avoid adding more dependencies
 *
 * @type {TusOptions}
 */


var tusDefaultOptions = {
  endpoint: '',
  resume: true,
  onProgress: null,
  onChunkComplete: null,
  onSuccess: null,
  onError: null,
  headers: {},
  chunkSize: Infinity,
  withCredentials: false,
  uploadUrl: null,
  uploadSize: null,
  overridePatchMethod: false,
  retryDelays: null
};
/**
 * Tus resumable file uploader
 */

module.exports = (_temp = _class =
/*#__PURE__*/
function (_Plugin) {
  _inheritsLoose(Tus, _Plugin);

  /**
   * @param {Uppy} uppy
   * @param {TusOptions} opts
   */
  function Tus(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.type = 'uploader';
    _this.id = _this.opts.id || 'Tus';
    _this.title = 'Tus'; // set default options

    var defaultOptions = {
      resume: true,
      autoRetry: true,
      useFastRemoteRetry: true,
      limit: 0,
      retryDelays: [0, 1000, 3000, 5000]
    }; // merge default options with the ones set by user

    /** @type {import("..").TusOptions} */

    _this.opts = _extends({}, defaultOptions, opts);
    /**
     * Simultaneous upload limiting is shared across all uploads with this plugin.
     *
     * @type {RateLimitedQueue}
     */

    _this.requests = new RateLimitedQueue(_this.opts.limit);
    _this.uploaders = Object.create(null);
    _this.uploaderEvents = Object.create(null);
    _this.uploaderSockets = Object.create(null);
    _this.handleResetProgress = _this.handleResetProgress.bind(_assertThisInitialized(_this));
    _this.handleUpload = _this.handleUpload.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = Tus.prototype;

  _proto.handleResetProgress = function handleResetProgress() {
    var files = _extends({}, this.uppy.getState().files);

    Object.keys(files).forEach(function (fileID) {
      // Only clone the file object if it has a Tus `uploadUrl` attached.
      if (files[fileID].tus && files[fileID].tus.uploadUrl) {
        var tusState = _extends({}, files[fileID].tus);

        delete tusState.uploadUrl;
        files[fileID] = _extends({}, files[fileID], {
          tus: tusState
        });
      }
    });
    this.uppy.setState({
      files: files
    });
  }
  /**
   * Clean up all references for a file's upload: the tus.Upload instance,
   * any events related to the file, and the Companion WebSocket connection.
   *
   * @param {string} fileID
   */
  ;

  _proto.resetUploaderReferences = function resetUploaderReferences(fileID, opts) {
    if (opts === void 0) {
      opts = {};
    }

    if (this.uploaders[fileID]) {
      var uploader = this.uploaders[fileID];
      uploader.abort();

      if (opts.abort) {
        // to avoid 423 error from tus server, we wait
        // to be sure the previous request has been aborted before terminating the upload
        // @todo remove the timeout when this "wait" is handled in tus-js-client internally
        setTimeout(function () {
          return uploader.abort(true);
        }, 1000);
      }

      this.uploaders[fileID] = null;
    }

    if (this.uploaderEvents[fileID]) {
      this.uploaderEvents[fileID].remove();
      this.uploaderEvents[fileID] = null;
    }

    if (this.uploaderSockets[fileID]) {
      this.uploaderSockets[fileID].close();
      this.uploaderSockets[fileID] = null;
    }
  }
  /**
   * Create a new Tus upload.
   *
   * A lot can happen during an upload, so this is quite hard to follow!
   * - First, the upload is started. If the file was already paused by the time the upload starts, nothing should happen.
   *   If the `limit` option is used, the upload must be queued onto the `this.requests` queue.
   *   When an upload starts, we store the tus.Upload instance, and an EventTracker instance that manages the event listeners
   *   for pausing, cancellation, removal, etc.
   * - While the upload is in progress, it may be paused or cancelled.
   *   Pausing aborts the underlying tus.Upload, and removes the upload from the `this.requests` queue. All other state is
   *   maintained.
   *   Cancelling removes the upload from the `this.requests` queue, and completely aborts the upload--the tus.Upload instance
   *   is aborted and discarded, the EventTracker instance is destroyed (removing all listeners).
   *   Resuming the upload uses the `this.requests` queue as well, to prevent selectively pausing and resuming uploads from
   *   bypassing the limit.
   * - After completing an upload, the tus.Upload and EventTracker instances are cleaned up, and the upload is marked as done
   *   in the `this.requests` queue.
   * - When an upload completed with an error, the same happens as on successful completion, but the `upload()` promise is rejected.
   *
   * When working on this function, keep in mind:
   *  - When an upload is completed or cancelled for any reason, the tus.Upload and EventTracker instances need to be cleaned up using this.resetUploaderReferences().
   *  - When an upload is cancelled or paused, for any reason, it needs to be removed from the `this.requests` queue using `queuedRequest.abort()`.
   *  - When an upload is completed for any reason, including errors, it needs to be marked as such using `queuedRequest.done()`.
   *  - When an upload is started or resumed, it needs to go through the `this.requests` queue. The `queuedRequest` variable must be updated so the other uses of it are valid.
   *  - Before replacing the `queuedRequest` variable, the previous `queuedRequest` must be aborted, else it will keep taking up a spot in the queue.
   *
   * @param {UppyFile} file for use with upload
   * @param {number} current file in a queue
   * @param {number} total number of files in a queue
   * @returns {Promise<void>}
   */
  ;

  _proto.upload = function upload(file, current, total) {
    var _this2 = this;

    this.resetUploaderReferences(file.id); // Create a new tus upload

    return new Promise(function (resolve, reject) {
      _this2.uppy.emit('upload-started', file);

      var optsTus = _extends({}, tusDefaultOptions, _this2.opts, // Install file-specific upload overrides.
      file.tus || {}); // We override tus fingerprint to uppy’s `file.id`, since the `file.id`
      // now also includes `relativePath` for files added from folders.
      // This means you can add 2 identical files, if one is in folder a,
      // the other in folder b.


      optsTus.fingerprint = getFingerprint(file);

      optsTus.onError = function (err) {
        _this2.uppy.log(err);

        _this2.uppy.emit('upload-error', file, err);

        err.message = "Failed because: " + err.message;

        _this2.resetUploaderReferences(file.id);

        queuedRequest.done();
        reject(err);
      };

      optsTus.onProgress = function (bytesUploaded, bytesTotal) {
        _this2.onReceiveUploadUrl(file, upload.url);

        _this2.uppy.emit('upload-progress', file, {
          uploader: _this2,
          bytesUploaded: bytesUploaded,
          bytesTotal: bytesTotal
        });
      };

      optsTus.onSuccess = function () {
        var uploadResp = {
          uploadURL: upload.url
        };

        _this2.uppy.emit('upload-success', file, uploadResp);

        if (upload.url) {
          _this2.uppy.log('Download ' + upload.file.name + ' from ' + upload.url);
        }

        _this2.resetUploaderReferences(file.id);

        queuedRequest.done();
        resolve(upload);
      };

      var copyProp = function copyProp(obj, srcProp, destProp) {
        if (Object.prototype.hasOwnProperty.call(obj, srcProp) && !Object.prototype.hasOwnProperty.call(obj, destProp)) {
          obj[destProp] = obj[srcProp];
        }
      };

      var meta = {};
      var metaFields = Array.isArray(optsTus.metaFields) ? optsTus.metaFields // Send along all fields by default.
      : Object.keys(file.meta);
      metaFields.forEach(function (item) {
        meta[item] = file.meta[item];
      }); // tusd uses metadata fields 'filetype' and 'filename'

      copyProp(meta, 'type', 'filetype');
      copyProp(meta, 'name', 'filename');
      optsTus.metadata = meta;
      var upload = new tus.Upload(file.data, optsTus);
      _this2.uploaders[file.id] = upload;
      _this2.uploaderEvents[file.id] = new EventTracker(_this2.uppy);

      var queuedRequest = _this2.requests.run(function () {
        if (!file.isPaused) {
          upload.start();
        } // Don't do anything here, the caller will take care of cancelling the upload itself
        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be
        // called when this request is still in the queue, and has not been started yet, too. At
        // that point this cancellation function is not going to be called.
        // Also, we need to remove the request from the queue _without_ destroying everything
        // related to this upload to handle pauses.


        return function () {};
      });

      _this2.onFileRemove(file.id, function (targetFileID) {
        queuedRequest.abort();

        _this2.resetUploaderReferences(file.id, {
          abort: !!upload.url
        });

        resolve("upload " + targetFileID + " was removed");
      });

      _this2.onPause(file.id, function (isPaused) {
        if (isPaused) {
          // Remove this file from the queue so another file can start in its place.
          queuedRequest.abort();
          upload.abort();
        } else {
          // Resuming an upload should be queued, else you could pause and then resume a queued upload to make it skip the queue.
          queuedRequest.abort();
          queuedRequest = _this2.requests.run(function () {
            upload.start();
            return function () {};
          });
        }
      });

      _this2.onPauseAll(file.id, function () {
        queuedRequest.abort();
        upload.abort();
      });

      _this2.onCancelAll(file.id, function () {
        queuedRequest.abort();

        _this2.resetUploaderReferences(file.id, {
          abort: !!upload.url
        });

        resolve("upload " + file.id + " was canceled");
      });

      _this2.onResumeAll(file.id, function () {
        queuedRequest.abort();

        if (file.error) {
          upload.abort();
        }

        queuedRequest = _this2.requests.run(function () {
          upload.start();
          return function () {};
        });
      });
    }).catch(function (err) {
      _this2.uppy.emit('upload-error', file, err);

      throw err;
    });
  }
  /**
   * @param {UppyFile} file for use with upload
   * @param {number} current file in a queue
   * @param {number} total number of files in a queue
   * @returns {Promise<void>}
   */
  ;

  _proto.uploadRemote = function uploadRemote(file, current, total) {
    var _this3 = this;

    this.resetUploaderReferences(file.id);

    var opts = _extends({}, this.opts);

    if (file.tus) {
      // Install file-specific upload overrides.
      _extends(opts, file.tus);
    }

    this.uppy.emit('upload-started', file);
    this.uppy.log(file.remote.url);

    if (file.serverToken) {
      return this.connectToServerSocket(file);
    }

    return new Promise(function (resolve, reject) {
      var Client = file.remote.providerOptions.provider ? Provider : RequestClient;
      var client = new Client(_this3.uppy, file.remote.providerOptions); // !! cancellation is NOT supported at this stage yet

      client.post(file.remote.url, _extends({}, file.remote.body, {
        endpoint: opts.endpoint,
        uploadUrl: opts.uploadUrl,
        protocol: 'tus',
        size: file.data.size,
        metadata: file.meta
      })).then(function (res) {
        _this3.uppy.setFileState(file.id, {
          serverToken: res.token
        });

        file = _this3.uppy.getFile(file.id);
        return _this3.connectToServerSocket(file);
      }).then(function () {
        resolve();
      }).catch(function (err) {
        reject(new Error(err));
      });
    });
  }
  /**
   * See the comment on the upload() method.
   *
   * Additionally, when an upload is removed, completed, or cancelled, we need to close the WebSocket connection. This is handled by the resetUploaderReferences() function, so the same guidelines apply as in upload().
   *
   * @param {UppyFile} file
   */
  ;

  _proto.connectToServerSocket = function connectToServerSocket(file) {
    var _this4 = this;

    return new Promise(function (resolve, reject) {
      var token = file.serverToken;
      var host = getSocketHost(file.remote.companionUrl);
      var socket = new Socket({
        target: host + "/api/" + token,
        autoOpen: false
      });
      _this4.uploaderSockets[file.id] = socket;
      _this4.uploaderEvents[file.id] = new EventTracker(_this4.uppy);

      _this4.onFileRemove(file.id, function () {
        queuedRequest.abort(); // still send pause event in case we are dealing with older version of companion
        // @todo don't send pause event in the next major release.

        socket.send('pause', {});
        socket.send('cancel', {});

        _this4.resetUploaderReferences(file.id);

        resolve("upload " + file.id + " was removed");
      });

      _this4.onPause(file.id, function (isPaused) {
        if (isPaused) {
          // Remove this file from the queue so another file can start in its place.
          queuedRequest.abort();
          socket.send('pause', {});
        } else {
          // Resuming an upload should be queued, else you could pause and then resume a queued upload to make it skip the queue.
          queuedRequest.abort();
          queuedRequest = _this4.requests.run(function () {
            socket.send('resume', {});
            return function () {};
          });
        }
      });

      _this4.onPauseAll(file.id, function () {
        queuedRequest.abort();
        socket.send('pause', {});
      });

      _this4.onCancelAll(file.id, function () {
        queuedRequest.abort(); // still send pause event in case we are dealing with older version of companion
        // @todo don't send pause event in the next major release.

        socket.send('pause', {});
        socket.send('cancel', {});

        _this4.resetUploaderReferences(file.id);

        resolve("upload " + file.id + " was canceled");
      });

      _this4.onResumeAll(file.id, function () {
        queuedRequest.abort();

        if (file.error) {
          socket.send('pause', {});
        }

        queuedRequest = _this4.requests.run(function () {
          socket.send('resume', {});
          return function () {};
        });
      });

      _this4.onRetry(file.id, function () {
        // Only do the retry if the upload is actually in progress;
        // else we could try to send these messages when the upload is still queued.
        // We may need a better check for this since the socket may also be closed
        // for other reasons, like network failures.
        if (socket.isOpen) {
          socket.send('pause', {});
          socket.send('resume', {});
        }
      });

      _this4.onRetryAll(file.id, function () {
        // See the comment in the onRetry() call
        if (socket.isOpen) {
          socket.send('pause', {});
          socket.send('resume', {});
        }
      });

      socket.on('progress', function (progressData) {
        return emitSocketProgress(_this4, progressData, file);
      });
      socket.on('error', function (errData) {
        var message = errData.error.message;

        var error = _extends(new Error(message), {
          cause: errData.error
        }); // If the remote retry optimisation should not be used,
        // close the socket—this will tell companion to clear state and delete the file.


        if (!_this4.opts.useFastRemoteRetry) {
          _this4.resetUploaderReferences(file.id); // Remove the serverToken so that a new one will be created for the retry.


          _this4.uppy.setFileState(file.id, {
            serverToken: null
          });
        } else {
          socket.close();
        }

        _this4.uppy.emit('upload-error', file, error);

        queuedRequest.done();
        reject(error);
      });
      socket.on('success', function (data) {
        var uploadResp = {
          uploadURL: data.url
        };

        _this4.uppy.emit('upload-success', file, uploadResp);

        _this4.resetUploaderReferences(file.id);

        queuedRequest.done();
        resolve();
      });

      var queuedRequest = _this4.requests.run(function () {
        socket.open();

        if (file.isPaused) {
          socket.send('pause', {});
        } // Don't do anything here, the caller will take care of cancelling the upload itself
        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be
        // called when this request is still in the queue, and has not been started yet, too. At
        // that point this cancellation function is not going to be called.
        // Also, we need to remove the request from the queue _without_ destroying everything
        // related to this upload to handle pauses.


        return function () {};
      });
    });
  }
  /**
   * Store the uploadUrl on the file options, so that when Golden Retriever
   * restores state, we will continue uploading to the correct URL.
   *
   * @param {UppyFile} file
   * @param {string} uploadURL
   */
  ;

  _proto.onReceiveUploadUrl = function onReceiveUploadUrl(file, uploadURL) {
    var currentFile = this.uppy.getFile(file.id);
    if (!currentFile) return; // Only do the update if we didn't have an upload URL yet.

    if (!currentFile.tus || currentFile.tus.uploadUrl !== uploadURL) {
      this.uppy.log('[Tus] Storing upload url');
      this.uppy.setFileState(currentFile.id, {
        tus: _extends({}, currentFile.tus, {
          uploadUrl: uploadURL
        })
      });
    }
  }
  /**
   * @param {string} fileID
   * @param {function(string): void} cb
   */
  ;

  _proto.onFileRemove = function onFileRemove(fileID, cb) {
    this.uploaderEvents[fileID].on('file-removed', function (file) {
      if (fileID === file.id) cb(file.id);
    });
  }
  /**
   * @param {string} fileID
   * @param {function(boolean): void} cb
   */
  ;

  _proto.onPause = function onPause(fileID, cb) {
    this.uploaderEvents[fileID].on('upload-pause', function (targetFileID, isPaused) {
      if (fileID === targetFileID) {
        // const isPaused = this.uppy.pauseResume(fileID)
        cb(isPaused);
      }
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onRetry = function onRetry(fileID, cb) {
    this.uploaderEvents[fileID].on('upload-retry', function (targetFileID) {
      if (fileID === targetFileID) {
        cb();
      }
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onRetryAll = function onRetryAll(fileID, cb) {
    var _this5 = this;

    this.uploaderEvents[fileID].on('retry-all', function (filesToRetry) {
      if (!_this5.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onPauseAll = function onPauseAll(fileID, cb) {
    var _this6 = this;

    this.uploaderEvents[fileID].on('pause-all', function () {
      if (!_this6.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onCancelAll = function onCancelAll(fileID, cb) {
    var _this7 = this;

    this.uploaderEvents[fileID].on('cancel-all', function () {
      if (!_this7.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {string} fileID
   * @param {function(): void} cb
   */
  ;

  _proto.onResumeAll = function onResumeAll(fileID, cb) {
    var _this8 = this;

    this.uploaderEvents[fileID].on('resume-all', function () {
      if (!_this8.uppy.getFile(fileID)) return;
      cb();
    });
  }
  /**
   * @param {(UppyFile | FailedUppyFile)[]} files
   */
  ;

  _proto.uploadFiles = function uploadFiles(files) {
    var _this9 = this;

    var promises = files.map(function (file, i) {
      var current = i + 1;
      var total = files.length;

      if ('error' in file && file.error) {
        return Promise.reject(new Error(file.error));
      } else if (file.isRemote) {
        return _this9.uploadRemote(file, current, total);
      } else {
        return _this9.upload(file, current, total);
      }
    });
    return settle(promises);
  }
  /**
   * @param {string[]} fileIDs
   */
  ;

  _proto.handleUpload = function handleUpload(fileIDs) {
    var _this10 = this;

    if (fileIDs.length === 0) {
      this.uppy.log('[Tus] No files to upload');
      return Promise.resolve();
    }

    if (this.opts.limit === 0) {
      this.uppy.log('[Tus] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/tus/#limit-0', 'warning');
    }

    this.uppy.log('[Tus] Uploading...');
    var filesToUpload = fileIDs.map(function (fileID) {
      return _this10.uppy.getFile(fileID);
    });
    return this.uploadFiles(filesToUpload).then(function () {
      return null;
    });
  };

  _proto.install = function install() {
    this.uppy.setState({
      capabilities: _extends({}, this.uppy.getState().capabilities, {
        resumableUploads: true
      })
    });
    this.uppy.addUploader(this.handleUpload);
    this.uppy.on('reset-progress', this.handleResetProgress);

    if (this.opts.autoRetry) {
      this.uppy.on('back-online', this.uppy.retryAll);
    }
  };

  _proto.uninstall = function uninstall() {
    this.uppy.setState({
      capabilities: _extends({}, this.uppy.getState().capabilities, {
        resumableUploads: false
      })
    });
    this.uppy.removeUploader(this.handleUpload);

    if (this.opts.autoRetry) {
      this.uppy.off('back-online', this.uppy.retryAll);
    }
  };

  return Tus;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":108,"./../../companion-client":41,"./../../core":45,"./../../utils/lib/EventTracker":115,"./../../utils/lib/RateLimitedQueue":117,"./../../utils/lib/emitSocketProgress":121,"./../../utils/lib/getSocketHost":134,"./../../utils/lib/settle":146,"./getFingerprint":109,"tus-js-client":31}],111:[function(require,module,exports){
module.exports={
  "name": "@uppy/url",
  "description": "The Url plugin lets users import files from the Internet. Paste any URL and it’ll be added!",
  "version": "1.4.2",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "url",
    "import from url",
    "uppy",
    "uppy-plugin"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/companion-client": "file:../companion-client",
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],112:[function(require,module,exports){
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var UrlUI =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(UrlUI, _Component);

  function UrlUI(props) {
    var _this;

    _this = _Component.call(this, props) || this;
    _this.handleKeyPress = _this.handleKeyPress.bind(_assertThisInitialized(_this));
    _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = UrlUI.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.input.value = '';
  };

  _proto.handleKeyPress = function handleKeyPress(ev) {
    if (ev.keyCode === 13) {
      this.props.addFile(this.input.value);
    }
  };

  _proto.handleClick = function handleClick() {
    this.props.addFile(this.input.value);
  };

  _proto.render = function render() {
    var _this2 = this;

    return h("div", {
      class: "uppy-Url"
    }, h("input", {
      class: "uppy-u-reset uppy-c-textInput uppy-Url-input",
      type: "text",
      "aria-label": this.props.i18n('enterUrlToImport'),
      placeholder: this.props.i18n('enterUrlToImport'),
      onkeyup: this.handleKeyPress,
      ref: function ref(input) {
        _this2.input = input;
      },
      "data-uppy-super-focusable": true
    }), h("button", {
      class: "uppy-u-reset uppy-c-btn uppy-c-btn-primary uppy-Url-importButton",
      type: "button",
      onclick: this.handleClick
    }, this.props.i18n('import')));
  };

  return UrlUI;
}(Component);

module.exports = UrlUI;

},{"preact":17}],113:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('./../../core'),
    Plugin = _require.Plugin;

var Translator = require('./../../utils/lib/Translator');

var _require2 = require('preact'),
    h = _require2.h;

var _require3 = require('./../../companion-client'),
    RequestClient = _require3.RequestClient;

var UrlUI = require('./UrlUI.js');

var forEachDroppedOrPastedUrl = require('./utils/forEachDroppedOrPastedUrl');

function UrlIcon() {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    width: "23",
    height: "23",
    viewBox: "0 0 23 23"
  }, h("path", {
    d: "M20.485 11.236l-2.748 2.737c-.184.182-.367.365-.642.547-1.007.73-2.107 1.095-3.298 1.095-1.65 0-3.298-.73-4.398-2.19-.275-.365-.183-1.003.183-1.277.367-.273 1.008-.182 1.283.183 1.191 1.642 3.482 1.915 5.13.73a.714.714 0 0 0 .367-.365l2.75-2.737c1.373-1.46 1.373-3.74-.093-5.108a3.72 3.72 0 0 0-5.13 0L12.33 6.4a.888.888 0 0 1-1.283 0 .88.88 0 0 1 0-1.277l1.558-1.55a5.38 5.38 0 0 1 7.605 0c2.29 2.006 2.382 5.564.274 7.662zm-8.979 6.294L9.95 19.081a3.72 3.72 0 0 1-5.13 0c-1.467-1.368-1.467-3.74-.093-5.108l2.75-2.737.366-.365c.824-.547 1.74-.82 2.748-.73 1.008.183 1.833.639 2.382 1.46.275.365.917.456 1.283.182.367-.273.458-.912.183-1.277-.916-1.186-2.199-1.915-3.573-2.098-1.374-.273-2.84.091-4.031 1.004l-.55.547-2.749 2.737c-2.107 2.189-2.015 5.655.092 7.753C4.727 21.453 6.101 22 7.475 22c1.374 0 2.749-.547 3.848-1.55l1.558-1.551a.88.88 0 0 0 0-1.278c-.367-.364-1.008-.456-1.375-.09z",
    fill: "#FF814F",
    "fill-rule": "nonzero"
  }));
}
/**
 * Url
 *
 */


module.exports = (_temp = _class =
/*#__PURE__*/
function (_Plugin) {
  _inheritsLoose(Url, _Plugin);

  function Url(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.id = _this.opts.id || 'Url';
    _this.title = _this.opts.title || 'Link';
    _this.type = 'acquirer';

    _this.icon = function () {
      return h(UrlIcon, null);
    }; // Set default options and locale


    _this.defaultLocale = {
      strings: {
        import: 'Import',
        enterUrlToImport: 'Enter URL to import a file',
        failedToFetch: 'Companion failed to fetch this URL, please make sure it’s correct',
        enterCorrectUrl: 'Incorrect URL: Please make sure you are entering a direct link to a file'
      }
    };
    var defaultOptions = {};
    _this.opts = _extends({}, defaultOptions, {}, opts);

    _this.i18nInit();

    _this.hostname = _this.opts.companionUrl;

    if (!_this.hostname) {
      throw new Error('Companion hostname is required, please consult https://uppy.io/docs/companion');
    } // Bind all event handlers for referencability


    _this.getMeta = _this.getMeta.bind(_assertThisInitialized(_this));
    _this.addFile = _this.addFile.bind(_assertThisInitialized(_this));
    _this.handleRootDrop = _this.handleRootDrop.bind(_assertThisInitialized(_this));
    _this.handleRootPaste = _this.handleRootPaste.bind(_assertThisInitialized(_this));
    _this.client = new RequestClient(uppy, {
      companionUrl: _this.opts.companionUrl,
      companionHeaders: _this.opts.companionHeaders || _this.opts.serverHeaders
    });
    return _this;
  }

  var _proto = Url.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, newOpts);

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.i18nArray = this.translator.translateArray.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  };

  _proto.getFileNameFromUrl = function getFileNameFromUrl(url) {
    return url.substring(url.lastIndexOf('/') + 1);
  };

  _proto.checkIfCorrectURL = function checkIfCorrectURL(url) {
    if (!url) return false;
    var protocol = url.match(/^([a-z0-9]+):\/\//)[1];

    if (protocol !== 'http' && protocol !== 'https') {
      return false;
    }

    return true;
  };

  _proto.addProtocolToURL = function addProtocolToURL(url) {
    var protocolRegex = /^[a-z0-9]+:\/\//;
    var defaultProtocol = 'http://';

    if (protocolRegex.test(url)) {
      return url;
    }

    return defaultProtocol + url;
  };

  _proto.getMeta = function getMeta(url) {
    var _this2 = this;

    return this.client.post('url/meta', {
      url: url
    }).then(function (res) {
      if (res.error) {
        _this2.uppy.log('[URL] Error:');

        _this2.uppy.log(res.error);

        throw new Error('Failed to fetch the file');
      }

      return res;
    });
  };

  _proto.addFile = function addFile(url) {
    var _this3 = this;

    url = this.addProtocolToURL(url);

    if (!this.checkIfCorrectURL(url)) {
      this.uppy.log("[URL] Incorrect URL entered: " + url);
      this.uppy.info(this.i18n('enterCorrectUrl'), 'error', 4000);
      return;
    }

    return this.getMeta(url).then(function (meta) {
      var tagFile = {
        source: _this3.id,
        name: _this3.getFileNameFromUrl(url),
        type: meta.type,
        data: {
          size: meta.size
        },
        isRemote: true,
        body: {
          url: url
        },
        remote: {
          companionUrl: _this3.opts.companionUrl,
          url: _this3.hostname + "/url/get",
          body: {
            fileId: url,
            url: url
          },
          providerOptions: _this3.client.opts
        }
      };
      return tagFile;
    }).then(function (tagFile) {
      _this3.uppy.log('[Url] Adding remote file');

      try {
        _this3.uppy.addFile(tagFile);
      } catch (err) {
        if (!err.isRestriction) {
          _this3.uppy.log(err);
        }
      }
    }).catch(function (err) {
      _this3.uppy.log(err);

      _this3.uppy.info({
        message: _this3.i18n('failedToFetch'),
        details: err
      }, 'error', 4000);
    });
  };

  _proto.handleRootDrop = function handleRootDrop(e) {
    var _this4 = this;

    forEachDroppedOrPastedUrl(e.dataTransfer, 'drop', function (url) {
      _this4.uppy.log("[URL] Adding file from dropped url: " + url);

      _this4.addFile(url);
    });
  };

  _proto.handleRootPaste = function handleRootPaste(e) {
    var _this5 = this;

    forEachDroppedOrPastedUrl(e.clipboardData, 'paste', function (url) {
      _this5.uppy.log("[URL] Adding file from pasted url: " + url);

      _this5.addFile(url);
    });
  };

  _proto.render = function render(state) {
    return h(UrlUI, {
      i18n: this.i18n,
      addFile: this.addFile
    });
  };

  _proto.install = function install() {
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    this.unmount();
  };

  return Url;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":111,"./../../companion-client":41,"./../../core":45,"./../../utils/lib/Translator":118,"./UrlUI.js":112,"./utils/forEachDroppedOrPastedUrl":114,"preact":17}],114:[function(require,module,exports){
var toArray = require('./../../../utils/lib/toArray');
/*
  SITUATION

    1. Cross-browser dataTransfer.items

      paste in chrome [Copy Image]:
      0: {kind: "file", type: "image/png"}
      1: {kind: "string", type: "text/html"}
      paste in safari [Copy Image]:
      0: {kind: "file", type: "image/png"}
      1: {kind: "string", type: "text/html"}
      2: {kind: "string", type: "text/plain"}
      3: {kind: "string", type: "text/uri-list"}
      paste in firefox [Copy Image]:
      0: {kind: "file", type: "image/png"}
      1: {kind: "string", type: "text/html"}

      paste in chrome [Copy Image Address]:
      0: {kind: "string", type: "text/plain"}
      paste in safari [Copy Image Address]:
      0: {kind: "string", type: "text/plain"}
      1: {kind: "string", type: "text/uri-list"}
      paste in firefox [Copy Image Address]:
      0: {kind: "string", type: "text/plain"}

      drop in chrome [from browser]:
      0: {kind: "string", type: "text/uri-list"}
      1: {kind: "string", type: "text/html"}
      drop in safari [from browser]:
      0: {kind: "string", type: "text/uri-list"}
      1: {kind: "string", type: "text/html"}
      2: {kind: "file", type: "image/png"}
      drop in firefox [from browser]:
      0: {kind: "string", type: "text/uri-list"}
      1: {kind: "string", type: "text/x-moz-url"}
      2: {kind: "string", type: "text/plain"}

    2. We can determine if it's a 'copypaste' or a 'drop', but we can't discern between [Copy Image] and [Copy Image Address].

  CONCLUSION

    1. 'paste' ([Copy Image] or [Copy Image Address], we can't discern between these two)
      Don't do anything if there is 'file' item. .handlePaste in the DashboardPlugin will deal with all 'file' items.
      If there are no 'file' items - handle 'text/plain' items.

    2. 'drop'
      Take 'text/uri-list' items. Safari has an additional item of .kind === 'file', and you may worry about the item being duplicated (first by DashboardPlugin, and then by UrlPlugin, now), but don't. Directory handling code won't pay attention to this particular item of kind 'file'.
*/

/**
 * Finds all links dropped/pasted from one browser window to another.
 *
 * @param {object} dataTransfer - DataTransfer instance, e.g. e.clipboardData, or e.dataTransfer
 * @param {string} isDropOrPaste - either 'drop' or 'paste'
 * @param {Function} callback - (urlString) => {}
 */


module.exports = function forEachDroppedOrPastedUrl(dataTransfer, isDropOrPaste, callback) {
  var items = toArray(dataTransfer.items);
  var urlItems;

  switch (isDropOrPaste) {
    case 'paste':
      {
        var atLeastOneFileIsDragged = items.some(function (item) {
          return item.kind === 'file';
        });

        if (atLeastOneFileIsDragged) {
          return;
        } else {
          urlItems = items.filter(function (item) {
            return item.kind === 'string' && item.type === 'text/plain';
          });
        }

        break;
      }

    case 'drop':
      {
        urlItems = items.filter(function (item) {
          return item.kind === 'string' && item.type === 'text/uri-list';
        });
        break;
      }

    default:
      {
        throw new Error("isDropOrPaste must be either 'drop' or 'paste', but it's " + isDropOrPaste);
      }
  }

  urlItems.forEach(function (item) {
    item.getAsString(function (urlString) {
      return callback(urlString);
    });
  });
};

},{"./../../../utils/lib/toArray":147}],115:[function(require,module,exports){
/**
 * Create a wrapper around an event emitter with a `remove` method to remove
 * all events that were added using the wrapped emitter.
 */
module.exports =
/*#__PURE__*/
function () {
  function EventTracker(emitter) {
    this._events = [];
    this._emitter = emitter;
  }

  var _proto = EventTracker.prototype;

  _proto.on = function on(event, fn) {
    this._events.push([event, fn]);

    return this._emitter.on(event, fn);
  };

  _proto.remove = function remove() {
    var _this = this;

    this._events.forEach(function (_ref) {
      var event = _ref[0],
          fn = _ref[1];

      _this._emitter.off(event, fn);
    });
  };

  return EventTracker;
}();

},{}],116:[function(require,module,exports){
module.exports = ['a[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'area[href]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'input:not([disabled]):not([inert]):not([aria-hidden])', 'select:not([disabled]):not([inert]):not([aria-hidden])', 'textarea:not([disabled]):not([inert]):not([aria-hidden])', 'button:not([disabled]):not([inert]):not([aria-hidden])', 'iframe:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'object:not([tabindex^="-"]):not([inert]):not([aria-hidden])', 'embed:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[contenteditable]:not([tabindex^="-"]):not([inert]):not([aria-hidden])', '[tabindex]:not([tabindex^="-"]):not([inert]):not([aria-hidden])'];

},{}],117:[function(require,module,exports){
module.exports =
/*#__PURE__*/
function () {
  function RateLimitedQueue(limit) {
    if (typeof limit !== 'number' || limit === 0) {
      this.limit = Infinity;
    } else {
      this.limit = limit;
    }

    this.activeRequests = 0;
    this.queuedHandlers = [];
  }

  var _proto = RateLimitedQueue.prototype;

  _proto._call = function _call(fn) {
    var _this = this;

    this.activeRequests += 1;
    var _done = false;
    var cancelActive;

    try {
      cancelActive = fn();
    } catch (err) {
      this.activeRequests -= 1;
      throw err;
    }

    return {
      abort: function abort() {
        if (_done) return;
        _done = true;
        _this.activeRequests -= 1;
        cancelActive();

        _this._queueNext();
      },
      done: function done() {
        if (_done) return;
        _done = true;
        _this.activeRequests -= 1;

        _this._queueNext();
      }
    };
  };

  _proto._queueNext = function _queueNext() {
    var _this2 = this;

    // Do it soon but not immediately, this allows clearing out the entire queue synchronously
    // one by one without continuously _advancing_ it (and starting new tasks before immediately
    // aborting them)
    Promise.resolve().then(function () {
      _this2._next();
    });
  };

  _proto._next = function _next() {
    if (this.activeRequests >= this.limit) {
      return;
    }

    if (this.queuedHandlers.length === 0) {
      return;
    } // Dispatch the next request, and update the abort/done handlers
    // so that cancelling it does the Right Thing (and doesn't just try
    // to dequeue an already-running request).


    var next = this.queuedHandlers.shift();

    var handler = this._call(next.fn);

    next.abort = handler.abort;
    next.done = handler.done;
  };

  _proto._queue = function _queue(fn) {
    var _this3 = this;

    var handler = {
      fn: fn,
      abort: function abort() {
        _this3._dequeue(handler);
      },
      done: function done() {
        throw new Error('Cannot mark a queued request as done: this indicates a bug');
      }
    };
    this.queuedHandlers.push(handler);
    return handler;
  };

  _proto._dequeue = function _dequeue(handler) {
    var index = this.queuedHandlers.indexOf(handler);

    if (index !== -1) {
      this.queuedHandlers.splice(index, 1);
    }
  };

  _proto.run = function run(fn) {
    if (this.activeRequests < this.limit) {
      return this._call(fn);
    }

    return this._queue(fn);
  };

  _proto.wrapPromiseFunction = function wrapPromiseFunction(fn) {
    var _this4 = this;

    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return new Promise(function (resolve, reject) {
        var queuedRequest = _this4.run(function () {
          var cancelError;
          var promise;

          try {
            promise = Promise.resolve(fn.apply(void 0, args));
          } catch (err) {
            promise = Promise.reject(err);
          }

          promise.then(function (result) {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              resolve(result);
            }
          }, function (err) {
            if (cancelError) {
              reject(cancelError);
            } else {
              queuedRequest.done();
              reject(err);
            }
          });
          return function () {
            cancelError = new Error('Cancelled');
          };
        });
      });
    };
  };

  return RateLimitedQueue;
}();

},{}],118:[function(require,module,exports){
function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var has = require('./hasProperty');
/**
 * Translates strings with interpolation & pluralization support.
 * Extensible with custom dictionaries and pluralization functions.
 *
 * Borrows heavily from and inspired by Polyglot https://github.com/airbnb/polyglot.js,
 * basically a stripped-down version of it. Differences: pluralization functions are not hardcoded
 * and can be easily added among with dictionaries, nested objects are used for pluralization
 * as opposed to `||||` delimeter
 *
 * Usage example: `translator.translate('files_chosen', {smart_count: 3})`
 */


module.exports =
/*#__PURE__*/
function () {
  /**
   * @param {object|Array<object>} locales - locale or list of locales.
   */
  function Translator(locales) {
    var _this = this;

    this.locale = {
      strings: {},
      pluralize: function pluralize(n) {
        if (n === 1) {
          return 0;
        }

        return 1;
      }
    };

    if (Array.isArray(locales)) {
      locales.forEach(function (locale) {
        return _this._apply(locale);
      });
    } else {
      this._apply(locales);
    }
  }

  var _proto = Translator.prototype;

  _proto._apply = function _apply(locale) {
    if (!locale || !locale.strings) {
      return;
    }

    var prevLocale = this.locale;
    this.locale = _extends({}, prevLocale, {
      strings: _extends({}, prevLocale.strings, locale.strings)
    });
    this.locale.pluralize = locale.pluralize || prevLocale.pluralize;
  }
  /**
   * Takes a string with placeholder variables like `%{smart_count} file selected`
   * and replaces it with values from options `{smart_count: 5}`
   *
   * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE
   * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299
   *
   * @param {string} phrase that needs interpolation, with placeholders
   * @param {object} options with values that will be used to replace placeholders
   * @returns {string} interpolated
   */
  ;

  _proto.interpolate = function interpolate(phrase, options) {
    var _String$prototype = String.prototype,
        split = _String$prototype.split,
        replace = _String$prototype.replace;
    var dollarRegex = /\$/g;
    var dollarBillsYall = '$$$$';
    var interpolated = [phrase];

    for (var arg in options) {
      if (arg !== '_' && has(options, arg)) {
        // Ensure replacement value is escaped to prevent special $-prefixed
        // regex replace tokens. the "$$$$" is needed because each "$" needs to
        // be escaped with "$" itself, and we need two in the resulting output.
        var replacement = options[arg];

        if (typeof replacement === 'string') {
          replacement = replace.call(options[arg], dollarRegex, dollarBillsYall);
        } // We create a new `RegExp` each time instead of using a more-efficient
        // string replace so that the same argument can be replaced multiple times
        // in the same phrase.


        interpolated = insertReplacement(interpolated, new RegExp('%\\{' + arg + '\\}', 'g'), replacement);
      }
    }

    return interpolated;

    function insertReplacement(source, rx, replacement) {
      var newParts = [];
      source.forEach(function (chunk) {
        split.call(chunk, rx).forEach(function (raw, i, list) {
          if (raw !== '') {
            newParts.push(raw);
          } // Interlace with the `replacement` value


          if (i < list.length - 1) {
            newParts.push(replacement);
          }
        });
      });
      return newParts;
    }
  }
  /**
   * Public translate method
   *
   * @param {string} key
   * @param {object} options with values that will be used later to replace placeholders in string
   * @returns {string} translated (and interpolated)
   */
  ;

  _proto.translate = function translate(key, options) {
    return this.translateArray(key, options).join('');
  }
  /**
   * Get a translation and return the translated and interpolated parts as an array.
   *
   * @param {string} key
   * @param {object} options with values that will be used to replace placeholders
   * @returns {Array} The translated and interpolated parts, in order.
   */
  ;

  _proto.translateArray = function translateArray(key, options) {
    if (options && typeof options.smart_count !== 'undefined') {
      var plural = this.locale.pluralize(options.smart_count);
      return this.interpolate(this.locale.strings[key][plural], options);
    }

    return this.interpolate(this.locale.strings[key], options);
  };

  return Translator;
}();

},{"./hasProperty":137}],119:[function(require,module,exports){
var dataURItoBlob = require('./dataURItoBlob');
/**
 * Save a <canvas> element's content to a Blob object.
 *
 * @param {HTMLCanvasElement} canvas
 * @returns {Promise}
 */


module.exports = function canvasToBlob(canvas, type, quality) {
  if (canvas.toBlob) {
    return new Promise(function (resolve) {
      canvas.toBlob(resolve, type, quality);
    });
  }

  return Promise.resolve().then(function () {
    return dataURItoBlob(canvas.toDataURL(type, quality), {});
  });
};

},{"./dataURItoBlob":120}],120:[function(require,module,exports){
module.exports = function dataURItoBlob(dataURI, opts, toFile) {
  // get the base64 data
  var data = dataURI.split(',')[1]; // user may provide mime type, if not get it from data URI

  var mimeType = opts.mimeType || dataURI.split(',')[0].split(':')[1].split(';')[0]; // default to plain/text if data URI has no mimeType

  if (mimeType == null) {
    mimeType = 'plain/text';
  }

  var binary = atob(data);
  var array = [];

  for (var i = 0; i < binary.length; i++) {
    array.push(binary.charCodeAt(i));
  }

  var bytes;

  try {
    bytes = new Uint8Array(array); // eslint-disable-line compat/compat
  } catch (err) {
    return null;
  } // Convert to a File?


  if (toFile) {
    return new File([bytes], opts.name || '', {
      type: mimeType
    });
  }

  return new Blob([bytes], {
    type: mimeType
  });
};

},{}],121:[function(require,module,exports){
var throttle = require('lodash.throttle');

function _emitSocketProgress(uploader, progressData, file) {
  var progress = progressData.progress,
      bytesUploaded = progressData.bytesUploaded,
      bytesTotal = progressData.bytesTotal;

  if (progress) {
    uploader.uppy.log("Upload progress: " + progress);
    uploader.uppy.emit('upload-progress', file, {
      uploader: uploader,
      bytesUploaded: bytesUploaded,
      bytesTotal: bytesTotal
    });
  }
}

module.exports = throttle(_emitSocketProgress, 300, {
  leading: true,
  trailing: true
});

},{"lodash.throttle":12}],122:[function(require,module,exports){
var isDOMElement = require('./isDOMElement');
/**
 * Find one or more DOM elements.
 *
 * @param {string} element
 * @returns {Array|null}
 */


module.exports = function findAllDOMElements(element) {
  if (typeof element === 'string') {
    var elements = [].slice.call(document.querySelectorAll(element));
    return elements.length > 0 ? elements : null;
  }

  if (typeof element === 'object' && isDOMElement(element)) {
    return [element];
  }
};

},{"./isDOMElement":138}],123:[function(require,module,exports){
var isDOMElement = require('./isDOMElement');
/**
 * Find a DOM element.
 *
 * @param {Node|string} element
 * @returns {Node|null}
 */


module.exports = function findDOMElement(element, context) {
  if (context === void 0) {
    context = document;
  }

  if (typeof element === 'string') {
    return context.querySelector(element);
  }

  if (typeof element === 'object' && isDOMElement(element)) {
    return element;
  }
};

},{"./isDOMElement":138}],124:[function(require,module,exports){
/**
 * Takes a file object and turns it into fileID, by converting file.name to lowercase,
 * removing extra characters and adding type, size and lastModified
 *
 * @param {object} file
 * @returns {string} the fileID
 */
module.exports = function generateFileID(file) {
  // It's tempting to do `[items].filter(Boolean).join('-')` here, but that
  // is slower! simple string concatenation is fast
  var id = 'uppy';

  if (typeof file.name === 'string') {
    id += '-' + encodeFilename(file.name.toLowerCase());
  }

  if (file.type !== undefined) {
    id += '-' + file.type;
  }

  if (file.meta && typeof file.meta.relativePath === 'string') {
    id += '-' + encodeFilename(file.meta.relativePath.toLowerCase());
  }

  if (file.data.size !== undefined) {
    id += '-' + file.data.size;
  }

  if (file.data.lastModified !== undefined) {
    id += '-' + file.data.lastModified;
  }

  return id;
};

function encodeFilename(name) {
  var suffix = '';
  return name.replace(/[^A-Z0-9]/ig, function (character) {
    suffix += '-' + encodeCharacter(character);
    return '/';
  }) + suffix;
}

function encodeCharacter(character) {
  return character.charCodeAt(0).toString(32);
}

},{}],125:[function(require,module,exports){
module.exports = function getBytesRemaining(fileProgress) {
  return fileProgress.bytesTotal - fileProgress.bytesUploaded;
};

},{}],126:[function(require,module,exports){
var webkitGetAsEntryApi = require('./utils/webkitGetAsEntryApi/index');

var fallbackApi = require('./utils/fallbackApi');
/**
 * Returns a promise that resolves to the array of dropped files (if a folder is dropped, and browser supports folder parsing - promise resolves to the flat array of all files in all directories).
 * Each file has .relativePath prop appended to it (e.g. "/docs/Prague/ticket_from_prague_to_ufa.pdf") if browser supports it. Otherwise it's undefined.
 *
 * @param {DataTransfer} dataTransfer
 * @param {Function} logDropError - a function that's called every time some folder or some file error out (e.g. because of the folder name being too long on Windows). Notice that resulting promise will always be resolved anyway.
 *
 * @returns {Promise} - Array<File>
 */


module.exports = function getDroppedFiles(dataTransfer, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$logDropError = _ref.logDropError,
      logDropError = _ref$logDropError === void 0 ? function () {} : _ref$logDropError;

  // Get all files from all subdirs. Works (at least) in Chrome, Mozilla, and Safari
  if (dataTransfer.items && dataTransfer.items[0] && 'webkitGetAsEntry' in dataTransfer.items[0]) {
    return webkitGetAsEntryApi(dataTransfer, logDropError); // Otherwise just return all first-order files
  } else {
    return fallbackApi(dataTransfer);
  }
};

},{"./utils/fallbackApi":127,"./utils/webkitGetAsEntryApi/index":130}],127:[function(require,module,exports){
var toArray = require('../../toArray'); // .files fallback, should be implemented in any browser


module.exports = function fallbackApi(dataTransfer) {
  var files = toArray(dataTransfer.files);
  return Promise.resolve(files);
};

},{"../../toArray":147}],128:[function(require,module,exports){
/**
 * Recursive function, calls the original callback() when the directory is entirely parsed.
 *
 * @param {FileSystemDirectoryReader} directoryReader
 * @param {Array} oldEntries
 * @param {Function} logDropError
 * @param {Function} callback - called with ([ all files and directories in that directoryReader ])
 */
module.exports = function getFilesAndDirectoriesFromDirectory(directoryReader, oldEntries, logDropError, _ref) {
  var onSuccess = _ref.onSuccess;
  directoryReader.readEntries(function (entries) {
    var newEntries = [].concat(oldEntries, entries); // According to the FileSystem API spec, getFilesAndDirectoriesFromDirectory() must be called until it calls the onSuccess with an empty array.

    if (entries.length) {
      setTimeout(function () {
        getFilesAndDirectoriesFromDirectory(directoryReader, newEntries, logDropError, {
          onSuccess: onSuccess
        });
      }, 0); // Done iterating this particular directory
    } else {
      onSuccess(newEntries);
    }
  }, // Make sure we resolve on error anyway, it's fine if only one directory couldn't be parsed!
  function (error) {
    logDropError(error);
    onSuccess(oldEntries);
  });
};

},{}],129:[function(require,module,exports){
/**
 * Get the relative path from the FileEntry#fullPath, because File#webkitRelativePath is always '', at least onDrop.
 *
 * @param {FileEntry} fileEntry
 *
 * @returns {string|null} - if file is not in a folder - return null (this is to be consistent with .relativePath-s of files selected from My Device). If file is in a folder - return its fullPath, e.g. '/simpsons/hi.jpeg'.
 */
module.exports = function getRelativePath(fileEntry) {
  // fileEntry.fullPath - "/simpsons/hi.jpeg" or undefined (for browsers that don't support it)
  // fileEntry.name - "hi.jpeg"
  if (!fileEntry.fullPath || fileEntry.fullPath === '/' + fileEntry.name) {
    return null;
  } else {
    return fileEntry.fullPath;
  }
};

},{}],130:[function(require,module,exports){
var toArray = require('../../../toArray');

var getRelativePath = require('./getRelativePath');

var getFilesAndDirectoriesFromDirectory = require('./getFilesAndDirectoriesFromDirectory');

module.exports = function webkitGetAsEntryApi(dataTransfer, logDropError) {
  var files = [];
  var rootPromises = [];
  /**
   * Returns a resolved promise, when :files array is enhanced
   *
   * @param {(FileSystemFileEntry|FileSystemDirectoryEntry)} entry
   * @returns {Promise} - empty promise that resolves when :files is enhanced with a file
   */

  var createPromiseToAddFileOrParseDirectory = function createPromiseToAddFileOrParseDirectory(entry) {
    return new Promise(function (resolve) {
      // This is a base call
      if (entry.isFile) {
        // Creates a new File object which can be used to read the file.
        entry.file(function (file) {
          file.relativePath = getRelativePath(entry);
          files.push(file);
          resolve();
        }, // Make sure we resolve on error anyway, it's fine if only one file couldn't be read!
        function (error) {
          logDropError(error);
          resolve();
        }); // This is a recursive call
      } else if (entry.isDirectory) {
        var directoryReader = entry.createReader();
        getFilesAndDirectoriesFromDirectory(directoryReader, [], logDropError, {
          onSuccess: function onSuccess(entries) {
            var promises = entries.map(function (entry) {
              return createPromiseToAddFileOrParseDirectory(entry);
            });
            Promise.all(promises).then(function () {
              return resolve();
            });
          }
        });
      }
    });
  }; // For each dropped item, - make sure it's a file/directory, and start deepening in!


  toArray(dataTransfer.items).forEach(function (item) {
    var entry = item.webkitGetAsEntry(); // :entry can be null when we drop the url e.g.

    if (entry) {
      rootPromises.push(createPromiseToAddFileOrParseDirectory(entry));
    }
  });
  return Promise.all(rootPromises).then(function () {
    return files;
  });
};

},{"../../../toArray":147,"./getFilesAndDirectoriesFromDirectory":128,"./getRelativePath":129}],131:[function(require,module,exports){
/**
 * Takes a full filename string and returns an object {name, extension}
 *
 * @param {string} fullFileName
 * @returns {object} {name, extension}
 */
module.exports = function getFileNameAndExtension(fullFileName) {
  var lastDot = fullFileName.lastIndexOf('.'); // these count as no extension: "no-dot", "trailing-dot."

  if (lastDot === -1 || lastDot === fullFileName.length - 1) {
    return {
      name: fullFileName,
      extension: undefined
    };
  } else {
    return {
      name: fullFileName.slice(0, lastDot),
      extension: fullFileName.slice(lastDot + 1)
    };
  }
};

},{}],132:[function(require,module,exports){
var getFileNameAndExtension = require('./getFileNameAndExtension');

var mimeTypes = require('./mimeTypes');

module.exports = function getFileType(file) {
  var fileExtension = file.name ? getFileNameAndExtension(file.name).extension : null;
  fileExtension = fileExtension ? fileExtension.toLowerCase() : null;

  if (file.type) {
    // if mime type is set in the file object already, use that
    return file.type;
  } else if (fileExtension && mimeTypes[fileExtension]) {
    // else, see if we can map extension to a mime type
    return mimeTypes[fileExtension];
  } else {
    // if all fails, fall back to a generic byte stream type
    return 'application/octet-stream';
  }
};

},{"./getFileNameAndExtension":131,"./mimeTypes":142}],133:[function(require,module,exports){
// TODO Check which types are actually supported in browsers. Chrome likes webm
// from my testing, but we may need more.
// We could use a library but they tend to contain dozens of KBs of mappings,
// most of which will go unused, so not sure if that's worth it.
var mimeToExtensions = {
  'video/ogg': 'ogv',
  'audio/ogg': 'ogg',
  'video/webm': 'webm',
  'audio/webm': 'webm',
  'video/x-matroska': 'mkv',
  'video/mp4': 'mp4',
  'audio/mp3': 'mp3'
};

module.exports = function getFileTypeExtension(mimeType) {
  // Remove the ; bit in 'video/x-matroska;codecs=avc1'
  mimeType = mimeType.replace(/;.*$/, '');
  return mimeToExtensions[mimeType] || null;
};

},{}],134:[function(require,module,exports){
module.exports = function getSocketHost(url) {
  // get the host domain
  var regex = /^(?:https?:\/\/|\/\/)?(?:[^@\n]+@)?(?:www\.)?([^\n]+)/i;
  var host = regex.exec(url)[1];
  var socketProtocol = /^http:\/\//i.test(url) ? 'ws' : 'wss';
  return socketProtocol + "://" + host;
};

},{}],135:[function(require,module,exports){
module.exports = function getSpeed(fileProgress) {
  if (!fileProgress.bytesUploaded) return 0;
  var timeElapsed = new Date() - fileProgress.uploadStarted;
  var uploadSpeed = fileProgress.bytesUploaded / (timeElapsed / 1000);
  return uploadSpeed;
};

},{}],136:[function(require,module,exports){
/**
 * Returns a timestamp in the format of `hours:minutes:seconds`
 */
module.exports = function getTimeStamp() {
  var date = new Date();
  var hours = pad(date.getHours().toString());
  var minutes = pad(date.getMinutes().toString());
  var seconds = pad(date.getSeconds().toString());
  return hours + ':' + minutes + ':' + seconds;
};
/**
 * Adds zero to strings shorter than two characters
 */


function pad(str) {
  return str.length !== 2 ? 0 + str : str;
}

},{}],137:[function(require,module,exports){
module.exports = function has(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
};

},{}],138:[function(require,module,exports){
/**
 * Check if an object is a DOM element. Duck-typing based on `nodeType`.
 *
 * @param {*} obj
 */
module.exports = function isDOMElement(obj) {
  return obj && typeof obj === 'object' && obj.nodeType === Node.ELEMENT_NODE;
};

},{}],139:[function(require,module,exports){
/**
 * Check if a URL string is an object URL from `URL.createObjectURL`.
 *
 * @param {string} url
 * @returns {boolean}
 */
module.exports = function isObjectURL(url) {
  return url.indexOf('blob:') === 0;
};

},{}],140:[function(require,module,exports){
module.exports = function isPreviewSupported(fileType) {
  if (!fileType) return false;
  var fileTypeSpecific = fileType.split('/')[1]; // list of images that browsers can preview

  if (/^(jpe?g|gif|png|svg|svg\+xml|bmp|webp)$/.test(fileTypeSpecific)) {
    return true;
  }

  return false;
};

},{}],141:[function(require,module,exports){
module.exports = function isTouchDevice() {
  // works on most browsers
  if ('ontouchstart' in window) {
    return true;
  } // works on IE10/11 and Surface
  // eslint-disable-next-line compat/compat


  return !!navigator.maxTouchPoints;
};

},{}],142:[function(require,module,exports){
// ___Why not add the mime-types package?
//    It's 19.7kB gzipped, and we only need mime types for well-known extensions (for file previews).
// ___Where to take new extensions from?
//    https://github.com/jshttp/mime-db/blob/master/db.json
module.exports = {
  md: 'text/markdown',
  markdown: 'text/markdown',
  mp4: 'video/mp4',
  mp3: 'audio/mp3',
  svg: 'image/svg+xml',
  jpg: 'image/jpeg',
  png: 'image/png',
  gif: 'image/gif',
  heic: 'image/heic',
  heif: 'image/heif',
  yaml: 'text/yaml',
  yml: 'text/yaml',
  csv: 'text/csv',
  avi: 'video/x-msvideo',
  mks: 'video/x-matroska',
  mkv: 'video/x-matroska',
  mov: 'video/quicktime',
  doc: 'application/msword',
  docm: 'application/vnd.ms-word.document.macroenabled.12',
  docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  dot: 'application/msword',
  dotm: 'application/vnd.ms-word.template.macroenabled.12',
  dotx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',
  xla: 'application/vnd.ms-excel',
  xlam: 'application/vnd.ms-excel.addin.macroenabled.12',
  xlc: 'application/vnd.ms-excel',
  xlf: 'application/x-xliff+xml',
  xlm: 'application/vnd.ms-excel',
  xls: 'application/vnd.ms-excel',
  xlsb: 'application/vnd.ms-excel.sheet.binary.macroenabled.12',
  xlsm: 'application/vnd.ms-excel.sheet.macroenabled.12',
  xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  xlt: 'application/vnd.ms-excel',
  xltm: 'application/vnd.ms-excel.template.macroenabled.12',
  xltx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',
  xlw: 'application/vnd.ms-excel',
  txt: 'text/plain',
  text: 'text/plain',
  conf: 'text/plain',
  log: 'text/plain',
  pdf: 'application/pdf'
};

},{}],143:[function(require,module,exports){
// Adapted from https://github.com/Flet/prettier-bytes/
// Changing 1000 bytes to 1024, so we can keep uppercase KB vs kB
// ISC License (c) Dan Flettre https://github.com/Flet/prettier-bytes/blob/master/LICENSE
module.exports = prettierBytes;

function prettierBytes(num) {
  if (typeof num !== 'number' || isNaN(num)) {
    throw new TypeError('Expected a number, got ' + typeof num);
  }

  var neg = num < 0;
  var units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

  if (neg) {
    num = -num;
  }

  if (num < 1) {
    return (neg ? '-' : '') + num + ' B';
  }

  var exponent = Math.min(Math.floor(Math.log(num) / Math.log(1024)), units.length - 1);
  num = Number(num / Math.pow(1024, exponent));
  var unit = units[exponent];

  if (num >= 10 || num % 1 === 0) {
    // Do not show decimals when the number is two-digit, or if the number has no
    // decimal component.
    return (neg ? '-' : '') + num.toFixed(0) + ' ' + unit;
  } else {
    return (neg ? '-' : '') + num.toFixed(1) + ' ' + unit;
  }
}

},{}],144:[function(require,module,exports){
var secondsToTime = require('./secondsToTime');

module.exports = function prettyETA(seconds) {
  var time = secondsToTime(seconds); // Only display hours and minutes if they are greater than 0 but always
  // display minutes if hours is being displayed
  // Display a leading zero if the there is a preceding unit: 1m 05s, but 5s

  var hoursStr = time.hours ? time.hours + 'h ' : '';
  var minutesVal = time.hours ? ('0' + time.minutes).substr(-2) : time.minutes;
  var minutesStr = minutesVal ? minutesVal + 'm' : '';
  var secondsVal = minutesVal ? ('0' + time.seconds).substr(-2) : time.seconds;
  var secondsStr = time.hours ? '' : minutesVal ? ' ' + secondsVal + 's' : secondsVal + 's';
  return "" + hoursStr + minutesStr + secondsStr;
};

},{"./secondsToTime":145}],145:[function(require,module,exports){
module.exports = function secondsToTime(rawSeconds) {
  var hours = Math.floor(rawSeconds / 3600) % 24;
  var minutes = Math.floor(rawSeconds / 60) % 60;
  var seconds = Math.floor(rawSeconds % 60);
  return {
    hours: hours,
    minutes: minutes,
    seconds: seconds
  };
};

},{}],146:[function(require,module,exports){
module.exports = function settle(promises) {
  var resolutions = [];
  var rejections = [];

  function resolved(value) {
    resolutions.push(value);
  }

  function rejected(error) {
    rejections.push(error);
  }

  var wait = Promise.all(promises.map(function (promise) {
    return promise.then(resolved, rejected);
  }));
  return wait.then(function () {
    return {
      successful: resolutions,
      failed: rejections
    };
  });
};

},{}],147:[function(require,module,exports){
/**
 * Converts list into array
 */
module.exports = function toArray(list) {
  return Array.prototype.slice.call(list || [], 0);
};

},{}],148:[function(require,module,exports){
module.exports={
  "name": "@uppy/webcam",
  "description": "Uppy plugin that takes photos or records videos using the device's camera.",
  "version": "1.5.1",
  "license": "MIT",
  "main": "lib/index.js",
  "style": "dist/style.min.css",
  "types": "types/index.d.ts",
  "keywords": [
    "file uploader",
    "uppy",
    "uppy-plugin",
    "webcam",
    "picture",
    "photo",
    "video",
    "record",
    "mediarecorder"
  ],
  "homepage": "https://uppy.io",
  "bugs": {
    "url": "https://github.com/transloadit/uppy/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/transloadit/uppy.git"
  },
  "dependencies": {
    "@uppy/utils": "file:../utils",
    "preact": "8.2.9"
  },
  "peerDependencies": {
    "@uppy/core": "^1.0.0"
  }
}

},{}],149:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    fill: "#0097DC",
    width: "66",
    height: "55",
    viewBox: "0 0 66 55"
  }, h("path", {
    d: "M57.3 8.433c4.59 0 8.1 3.51 8.1 8.1v29.7c0 4.59-3.51 8.1-8.1 8.1H8.7c-4.59 0-8.1-3.51-8.1-8.1v-29.7c0-4.59 3.51-8.1 8.1-8.1h9.45l4.59-7.02c.54-.54 1.35-1.08 2.16-1.08h16.2c.81 0 1.62.54 2.16 1.08l4.59 7.02h9.45zM33 14.64c-8.62 0-15.393 6.773-15.393 15.393 0 8.62 6.773 15.393 15.393 15.393 8.62 0 15.393-6.773 15.393-15.393 0-8.62-6.773-15.393-15.393-15.393zM33 40c-5.648 0-9.966-4.319-9.966-9.967 0-5.647 4.318-9.966 9.966-9.966s9.966 4.319 9.966 9.966C42.966 35.681 38.648 40 33 40z",
    "fill-rule": "evenodd"
  }));
};

},{"preact":17}],150:[function(require,module,exports){
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('preact'),
    h = _require.h,
    Component = _require.Component;

var SnapshotButton = require('./SnapshotButton');

var RecordButton = require('./RecordButton');

var RecordingLength = require('./RecordingLength');

function isModeAvailable(modes, mode) {
  return modes.indexOf(mode) !== -1;
}

var CameraScreen =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(CameraScreen, _Component);

  function CameraScreen() {
    return _Component.apply(this, arguments) || this;
  }

  var _proto = CameraScreen.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.props.onFocus();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.props.onStop();
  };

  _proto.render = function render() {
    var shouldShowRecordButton = this.props.supportsRecording && (isModeAvailable(this.props.modes, 'video-only') || isModeAvailable(this.props.modes, 'audio-only') || isModeAvailable(this.props.modes, 'video-audio'));
    var shouldShowSnapshotButton = isModeAvailable(this.props.modes, 'picture');
    var shouldShowRecordingLength = this.props.supportsRecording && this.props.showRecordingLength;
    return h("div", {
      class: "uppy uppy-Webcam-container"
    }, h("div", {
      class: "uppy-Webcam-videoContainer"
    }, h("video", {
      class: "uppy-Webcam-video  " + (this.props.mirror ? 'uppy-Webcam-video--mirrored' : ''),
      autoplay: true,
      muted: true,
      playsinline: true,
      srcObject: this.props.src || ''
    })), h("div", {
      class: "uppy-Webcam-buttonContainer"
    }, shouldShowRecordingLength ? RecordingLength(this.props) : null, ' ', shouldShowSnapshotButton ? SnapshotButton(this.props) : null, ' ', shouldShowRecordButton ? RecordButton(this.props) : null));
  };

  return CameraScreen;
}(Component);

module.exports = CameraScreen;

},{"./RecordButton":152,"./RecordingLength":153,"./SnapshotButton":154,"preact":17}],151:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function (props) {
  return h("div", {
    class: "uppy-Webcam-permissons"
  }, h("div", {
    class: "uppy-Webcam-permissonsIcon"
  }, props.icon()), h("h1", {
    class: "uppy-Webcam-title"
  }, props.i18n('allowAccessTitle')), h("p", null, props.i18n('allowAccessDescription')));
};

},{"preact":17}],152:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

module.exports = function RecordButton(_ref) {
  var recording = _ref.recording,
      onStartRecording = _ref.onStartRecording,
      onStopRecording = _ref.onStopRecording,
      i18n = _ref.i18n;

  if (recording) {
    return h("button", {
      class: "uppy-u-reset uppy-c-btn uppy-Webcam-button uppy-Webcam-button--video",
      type: "button",
      title: i18n('stopRecording'),
      "aria-label": i18n('stopRecording'),
      onclick: onStopRecording,
      "data-uppy-super-focusable": true
    }, h("svg", {
      "aria-hidden": "true",
      focusable: "false",
      class: "UppyIcon",
      width: "100",
      height: "100",
      viewBox: "0 0 100 100"
    }, h("rect", {
      x: "15",
      y: "15",
      width: "70",
      height: "70"
    })));
  }

  return h("button", {
    class: "uppy-u-reset uppy-c-btn uppy-Webcam-button uppy-Webcam-button--video",
    type: "button",
    title: i18n('startRecording'),
    "aria-label": i18n('startRecording'),
    onclick: onStartRecording,
    "data-uppy-super-focusable": true
  }, h("svg", {
    "aria-hidden": "true",
    focusable: "false",
    class: "UppyIcon",
    width: "100",
    height: "100",
    viewBox: "0 0 100 100"
  }, h("circle", {
    cx: "50",
    cy: "50",
    r: "40"
  })));
};

},{"preact":17}],153:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var formatSeconds = require('./formatSeconds');

module.exports = function RecordingLength(_ref) {
  var recordingLengthSeconds = _ref.recordingLengthSeconds,
      i18n = _ref.i18n;
  var formattedRecordingLengthSeconds = formatSeconds(recordingLengthSeconds);
  return h("div", {
    class: "uppy-Webcam-recordingLength",
    "aria-label": i18n('recordingLength', {
      recording_length: formattedRecordingLengthSeconds
    })
  }, formattedRecordingLengthSeconds);
};

},{"./formatSeconds":155,"preact":17}],154:[function(require,module,exports){
var _require = require('preact'),
    h = _require.h;

var CameraIcon = require('./CameraIcon');

module.exports = function (_ref) {
  var onSnapshot = _ref.onSnapshot,
      i18n = _ref.i18n;
  return h("button", {
    class: "uppy-u-reset uppy-c-btn uppy-Webcam-button uppy-Webcam-button--picture",
    type: "button",
    title: i18n('takePicture'),
    "aria-label": i18n('takePicture'),
    onclick: onSnapshot,
    "data-uppy-super-focusable": true
  }, CameraIcon());
};

},{"./CameraIcon":149,"preact":17}],155:[function(require,module,exports){
/**
 * Takes an Integer value of seconds (e.g. 83) and converts it into a human-readable formatted string (e.g. '1:23').
 *
 * @param {Integer} seconds
 * @returns {string} the formatted seconds (e.g. '1:23' for 1 minute and 23 seconds)
 *
 */
module.exports = function formatSeconds(seconds) {
  return Math.floor(seconds / 60) + ":" + String(seconds % 60).padStart(2, 0);
};

},{}],156:[function(require,module,exports){
var _class, _temp;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var _require = require('preact'),
    h = _require.h;

var _require2 = require('./../../core'),
    Plugin = _require2.Plugin;

var Translator = require('./../../utils/lib/Translator');

var getFileTypeExtension = require('./../../utils/lib/getFileTypeExtension');

var canvasToBlob = require('./../../utils/lib/canvasToBlob');

var supportsMediaRecorder = require('./supportsMediaRecorder');

var CameraIcon = require('./CameraIcon');

var CameraScreen = require('./CameraScreen');

var PermissionsScreen = require('./PermissionsScreen'); // Setup getUserMedia, with polyfill for older browsers
// Adapted from: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia


function getMediaDevices() {
  // eslint-disable-next-line compat/compat
  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    // eslint-disable-next-line compat/compat
    return navigator.mediaDevices;
  }

  var _getUserMedia = navigator.mozGetUserMedia || navigator.webkitGetUserMedia;

  if (!_getUserMedia) {
    return null;
  }

  return {
    getUserMedia: function getUserMedia(opts) {
      return new Promise(function (resolve, reject) {
        _getUserMedia.call(navigator, opts, resolve, reject);
      });
    }
  };
}
/**
 * Webcam
 */


module.exports = (_temp = _class =
/*#__PURE__*/
function (_Plugin) {
  _inheritsLoose(Webcam, _Plugin);

  function Webcam(uppy, opts) {
    var _this;

    _this = _Plugin.call(this, uppy, opts) || this;
    _this.mediaDevices = getMediaDevices();
    _this.supportsUserMedia = !!_this.mediaDevices;
    _this.protocol = location.protocol.match(/https/i) ? 'https' : 'http';
    _this.id = _this.opts.id || 'Webcam';
    _this.title = _this.opts.title || 'Camera';
    _this.type = 'acquirer';
    _this.icon = CameraIcon;
    _this.defaultLocale = {
      strings: {
        smile: 'Smile!',
        takePicture: 'Take a picture',
        startRecording: 'Begin video recording',
        stopRecording: 'Stop video recording',
        allowAccessTitle: 'Please allow access to your camera',
        allowAccessDescription: 'In order to take pictures or record video with your camera, please allow camera access for this site.',
        recordingLength: 'Recording length %{recording_length}'
      }
    }; // set default options

    var defaultOptions = {
      onBeforeSnapshot: function onBeforeSnapshot() {
        return Promise.resolve();
      },
      countdown: false,
      modes: ['video-audio', 'video-only', 'audio-only', 'picture'],
      mirror: true,
      facingMode: 'user',
      preferredVideoMimeType: null,
      showRecordingLength: false
    };
    _this.opts = _extends({}, defaultOptions, {}, opts);

    _this.i18nInit();

    _this.install = _this.install.bind(_assertThisInitialized(_this));
    _this.setPluginState = _this.setPluginState.bind(_assertThisInitialized(_this));
    _this.render = _this.render.bind(_assertThisInitialized(_this)); // Camera controls

    _this.start = _this.start.bind(_assertThisInitialized(_this));
    _this.stop = _this.stop.bind(_assertThisInitialized(_this));
    _this.takeSnapshot = _this.takeSnapshot.bind(_assertThisInitialized(_this));
    _this.startRecording = _this.startRecording.bind(_assertThisInitialized(_this));
    _this.stopRecording = _this.stopRecording.bind(_assertThisInitialized(_this));
    _this.oneTwoThreeSmile = _this.oneTwoThreeSmile.bind(_assertThisInitialized(_this));
    _this.focus = _this.focus.bind(_assertThisInitialized(_this));
    _this.webcamActive = false;

    if (_this.opts.countdown) {
      _this.opts.onBeforeSnapshot = _this.oneTwoThreeSmile;
    }

    return _this;
  }

  var _proto = Webcam.prototype;

  _proto.setOptions = function setOptions(newOpts) {
    _Plugin.prototype.setOptions.call(this, newOpts);

    this.i18nInit();
  };

  _proto.i18nInit = function i18nInit() {
    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);
    this.i18n = this.translator.translate.bind(this.translator);
    this.i18nArray = this.translator.translateArray.bind(this.translator);
    this.setPluginState(); // so that UI re-renders and we see the updated locale
  };

  _proto.isSupported = function isSupported() {
    return !!this.mediaDevices;
  };

  _proto.getConstraints = function getConstraints() {
    var acceptsAudio = this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('audio-only') !== -1;
    var acceptsVideo = this.opts.modes.indexOf('video-audio') !== -1 || this.opts.modes.indexOf('video-only') !== -1 || this.opts.modes.indexOf('picture') !== -1;
    return {
      audio: acceptsAudio,
      video: acceptsVideo ? {
        facingMode: this.opts.facingMode
      } : false
    };
  };

  _proto.start = function start() {
    var _this2 = this;

    if (!this.isSupported()) {
      return Promise.reject(new Error('Webcam access not supported'));
    }

    this.webcamActive = true;
    var constraints = this.getConstraints(); // ask user for access to their camera

    return this.mediaDevices.getUserMedia(constraints).then(function (stream) {
      _this2.stream = stream; // this.streamSrc = URL.createObjectURL(this.stream)

      _this2.setPluginState({
        cameraReady: true
      });
    }).catch(function (err) {
      _this2.setPluginState({
        cameraError: err
      });
    });
  };

  _proto.startRecording = function startRecording() {
    var _this3 = this;

    var options = {};
    var preferredVideoMimeType = this.opts.preferredVideoMimeType; // Attempt to use the passed preferredVideoMimeType (if any) during recording.
    // If the browser doesn't support it, we'll fall back to the browser default instead

    if (preferredVideoMimeType && MediaRecorder.isTypeSupported(preferredVideoMimeType) && getFileTypeExtension(preferredVideoMimeType)) {
      options.mimeType = preferredVideoMimeType;
    }

    this.recorder = new MediaRecorder(this.stream, options);
    this.recordingChunks = [];
    this.recorder.addEventListener('dataavailable', function (event) {
      _this3.recordingChunks.push(event.data);
    });
    this.recorder.start();

    if (this.opts.showRecordingLength) {
      // Start the recordingLengthTimer if we are showing the recording length.
      this.recordingLengthTimer = setInterval(function () {
        var currentRecordingLength = _this3.getPluginState().recordingLengthSeconds;

        _this3.setPluginState({
          recordingLengthSeconds: currentRecordingLength + 1
        });
      }, 1000);
    }

    this.setPluginState({
      isRecording: true
    });
  };

  _proto.stopRecording = function stopRecording() {
    var _this4 = this;

    var stopped = new Promise(function (resolve, reject) {
      _this4.recorder.addEventListener('stop', function () {
        resolve();
      });

      _this4.recorder.stop();

      if (_this4.opts.showRecordingLength) {
        // Stop the recordingLengthTimer if we are showing the recording length.
        clearInterval(_this4.recordingLengthTimer);

        _this4.setPluginState({
          recordingLengthSeconds: 0
        });
      }
    });
    return stopped.then(function () {
      _this4.setPluginState({
        isRecording: false
      });

      return _this4.getVideo();
    }).then(function (file) {
      try {
        _this4.uppy.addFile(file);
      } catch (err) {
        // Logging the error, exept restrictions, which is handled in Core
        if (!err.isRestriction) {
          _this4.uppy.log(err);
        }
      }
    }).then(function () {
      _this4.recordingChunks = null;
      _this4.recorder = null; // Close the Dashboard panel if plugin is installed
      // into Dashboard (could be other parent UI plugin)
      // if (this.parent && this.parent.hideAllPanels) {
      //   this.parent.hideAllPanels()
      // }
    }, function (error) {
      _this4.recordingChunks = null;
      _this4.recorder = null;
      throw error;
    });
  };

  _proto.stop = function stop() {
    this.stream.getAudioTracks().forEach(function (track) {
      track.stop();
    });
    this.stream.getVideoTracks().forEach(function (track) {
      track.stop();
    });
    this.webcamActive = false;
    this.stream = null;
  };

  _proto.getVideoElement = function getVideoElement() {
    return this.el.querySelector('.uppy-Webcam-video');
  };

  _proto.oneTwoThreeSmile = function oneTwoThreeSmile() {
    var _this5 = this;

    return new Promise(function (resolve, reject) {
      var count = _this5.opts.countdown;
      var countDown = setInterval(function () {
        if (!_this5.webcamActive) {
          clearInterval(countDown);
          _this5.captureInProgress = false;
          return reject(new Error('Webcam is not active'));
        }

        if (count > 0) {
          _this5.uppy.info(count + "...", 'warning', 800);

          count--;
        } else {
          clearInterval(countDown);

          _this5.uppy.info(_this5.i18n('smile'), 'success', 1500);

          setTimeout(function () {
            return resolve();
          }, 1500);
        }
      }, 1000);
    });
  };

  _proto.takeSnapshot = function takeSnapshot() {
    var _this6 = this;

    if (this.captureInProgress) return;
    this.captureInProgress = true;
    this.opts.onBeforeSnapshot().catch(function (err) {
      var message = typeof err === 'object' ? err.message : err;

      _this6.uppy.info(message, 'error', 5000);

      return Promise.reject(new Error("onBeforeSnapshot: " + message));
    }).then(function () {
      return _this6.getImage();
    }).then(function (tagFile) {
      _this6.captureInProgress = false; // Close the Dashboard panel if plugin is installed
      // into Dashboard (could be other parent UI plugin)
      // if (this.parent && this.parent.hideAllPanels) {
      //   this.parent.hideAllPanels()
      // }

      try {
        _this6.uppy.addFile(tagFile);
      } catch (err) {
        // Logging the error, exept restrictions, which is handled in Core
        if (!err.isRestriction) {
          _this6.uppy.log(err);
        }
      }
    }, function (error) {
      _this6.captureInProgress = false;
      throw error;
    });
  };

  _proto.getImage = function getImage() {
    var _this7 = this;

    var video = this.getVideoElement();

    if (!video) {
      return Promise.reject(new Error('No video element found, likely due to the Webcam tab being closed.'));
    }

    var name = "cam-" + Date.now() + ".jpg";
    var mimeType = 'image/jpeg';
    var width = video.videoWidth;
    var height = video.videoHeight; // const scaleH = this.opts.mirror ? -1 : 1 // Set horizontal scale to -1 if flip horizontal
    // const scaleV = 1
    // const posX = this.opts.mirror ? width * -1 : 0 // Set x position to -100% if flip horizontal
    // const posY = 0

    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0); // ctx.save() // Save the current state
    // ctx.scale(scaleH, scaleV) // Set scale to flip the image
    // ctx.drawImage(video, posX, posY, width, height) // draw the image
    // ctx.restore() // Restore the last saved state

    return canvasToBlob(canvas, mimeType).then(function (blob) {
      return {
        source: _this7.id,
        name: name,
        data: new Blob([blob], {
          type: mimeType
        }),
        type: mimeType
      };
    });
  };

  _proto.getVideo = function getVideo() {
    var mimeType = this.recordingChunks[0].type;
    var fileExtension = getFileTypeExtension(mimeType);

    if (!fileExtension) {
      return Promise.reject(new Error("Could not retrieve recording: Unsupported media type \"" + mimeType + "\""));
    }

    var name = "webcam-" + Date.now() + "." + fileExtension;
    var blob = new Blob(this.recordingChunks, {
      type: mimeType
    });
    var file = {
      source: this.id,
      name: name,
      data: new Blob([blob], {
        type: mimeType
      }),
      type: mimeType
    };
    return Promise.resolve(file);
  };

  _proto.focus = function focus() {
    var _this8 = this;

    if (!this.opts.countdown) return;
    setTimeout(function () {
      _this8.uppy.info(_this8.i18n('smile'), 'success', 1500);
    }, 1000);
  };

  _proto.render = function render(state) {
    if (!this.webcamActive) {
      this.start();
    }

    var webcamState = this.getPluginState();

    if (!webcamState.cameraReady) {
      return h(PermissionsScreen, {
        icon: CameraIcon,
        i18n: this.i18n
      });
    }

    return h(CameraScreen, _extends({}, webcamState, {
      onSnapshot: this.takeSnapshot,
      onStartRecording: this.startRecording,
      onStopRecording: this.stopRecording,
      onFocus: this.focus,
      onStop: this.stop,
      i18n: this.i18n,
      modes: this.opts.modes,
      showRecordingLength: this.opts.showRecordingLength,
      supportsRecording: supportsMediaRecorder(),
      recording: webcamState.isRecording,
      mirror: this.opts.mirror,
      src: this.stream
    }));
  };

  _proto.install = function install() {
    this.setPluginState({
      cameraReady: false,
      recordingLengthSeconds: 0
    });
    var target = this.opts.target;

    if (target) {
      this.mount(target, this);
    }
  };

  _proto.uninstall = function uninstall() {
    if (this.stream) {
      this.stop();
    }

    this.unmount();
  };

  return Webcam;
}(Plugin), _class.VERSION = require('../package.json').version, _temp);

},{"../package.json":148,"./../../core":45,"./../../utils/lib/Translator":118,"./../../utils/lib/canvasToBlob":119,"./../../utils/lib/getFileTypeExtension":133,"./CameraIcon":149,"./CameraScreen":150,"./PermissionsScreen":151,"./supportsMediaRecorder":157,"preact":17}],157:[function(require,module,exports){
module.exports = function supportsMediaRecorder() {
  return typeof MediaRecorder === 'function' && !!MediaRecorder.prototype && typeof MediaRecorder.prototype.start === 'function';
};

},{}],158:[function(require,module,exports){
require('es6-promise/auto');

require('whatwg-fetch');

var Uppy = require('./../../../../packages/@uppy/core');

var Dashboard = require('./../../../../packages/@uppy/dashboard');

var GoogleDrive = require('./../../../../packages/@uppy/google-drive');

var Dropbox = require('./../../../../packages/@uppy/dropbox');

var Instagram = require('./../../../../packages/@uppy/instagram');

var Facebook = require('./../../../../packages/@uppy/facebook');

var OneDrive = require('./../../../../packages/@uppy/onedrive');

var Url = require('./../../../../packages/@uppy/url');

var Webcam = require('./../../../../packages/@uppy/webcam');

var Tus = require('./../../../../packages/@uppy/tus');

var localeList = require('../locale_list.json');

var COMPANION = require('../env');

if (typeof window !== 'undefined' && typeof window.Uppy === 'undefined') {
  window.Uppy = {
    locales: {}
  };
}

function uppyInit() {
  if (window.uppy) {
    window.uppy.close();
  }

  var opts = window.uppyOptions;
  var uppy = Uppy({
    logger: Uppy.debugLogger
  });
  uppy.use(Tus, {
    endpoint: 'https://master.tus.io/files/',
    resume: true
  });
  uppy.on('complete', function (result) {
    console.log('successful files:');
    console.log(result.successful);
    console.log('failed files:');
    console.log(result.failed);
  });
  uppy.use(Dashboard, {
    trigger: '.UppyModalOpenerBtn',
    target: opts.DashboardInline ? '.DashboardContainer' : 'body',
    inline: opts.DashboardInline,
    replaceTargetContent: opts.DashboardInline,
    height: 470,
    showProgressDetails: true,
    metaFields: [{
      id: 'name',
      name: 'Name',
      placeholder: 'file name'
    }, {
      id: 'caption',
      name: 'Caption',
      placeholder: 'add description'
    }]
  });
  window.uppy = uppy;
}

function uppySetOptions() {
  var opts = window.uppyOptions;
  var defaultNullRestrictions = {
    maxFileSize: null,
    maxNumberOfFiles: null,
    minNumberOfFiles: null,
    allowedFileTypes: null
  };
  var restrictions = {
    maxFileSize: 1000000,
    maxNumberOfFiles: 3,
    minNumberOfFiles: 2,
    allowedFileTypes: ['image/*', 'video/*']
  };
  window.uppy.setOptions({
    autoProceed: opts.autoProceed,
    restrictions: opts.restrictions ? restrictions : defaultNullRestrictions
  });
  window.uppy.getPlugin('Dashboard').setOptions({
    note: opts.restrictions ? 'Images and video only, 2–3 files, up to 1 MB' : '',
    browserBackButtonClose: opts.browserBackButtonClose
  });
  var GoogleDriveInstance = window.uppy.getPlugin('GoogleDrive');

  if (opts.GoogleDrive && !GoogleDriveInstance) {
    window.uppy.use(GoogleDrive, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.GoogleDrive && GoogleDriveInstance) {
    window.uppy.removePlugin(GoogleDriveInstance);
  }

  var DropboxInstance = window.uppy.getPlugin('Dropbox');

  if (opts.Dropbox && !DropboxInstance) {
    window.uppy.use(Dropbox, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.Dropbox && DropboxInstance) {
    window.uppy.removePlugin(DropboxInstance);
  }

  var InstagramInstance = window.uppy.getPlugin('Instagram');

  if (opts.Instagram && !InstagramInstance) {
    window.uppy.use(Instagram, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.Instagram && InstagramInstance) {
    window.uppy.removePlugin(InstagramInstance);
  }

  var UrlInstance = window.uppy.getPlugin('Url');

  if (opts.Url && !UrlInstance) {
    window.uppy.use(Url, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.Url && UrlInstance) {
    window.uppy.removePlugin(UrlInstance);
  }

  var FacebookInstance = window.uppy.getPlugin('Facebook');

  if (opts.Facebook && !FacebookInstance) {
    uppy.use(Facebook, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.Facebook && FacebookInstance) {
    window.uppy.removePlugin(FacebookInstance);
  }

  var OneDriveInstance = window.uppy.getPlugin('OneDrive');

  if (opts.OneDrive && !OneDriveInstance) {
    uppy.use(OneDrive, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.OneDrive && OneDriveInstance) {
    window.uppy.removePlugin(OneDriveInstance);
  }

  var WebcamInstance = window.uppy.getPlugin('Webcam');

  if (opts.Webcam && !WebcamInstance) {
    window.uppy.use(Webcam, {
      target: Dashboard,
      companionUrl: COMPANION
    });
  }

  if (!opts.Webcam && WebcamInstance) {
    window.uppy.removePlugin(WebcamInstance);
  }
}

function whenLocaleAvailable(localeName, callback) {
  var interval = 100; // ms

  var loop = setInterval(function () {
    if (window.Uppy && window.Uppy.locales && window.Uppy.locales[localeName]) {
      clearInterval(loop);
      callback(window.Uppy.locales[localeName]);
    }
  }, interval);
}

function loadLocaleFromCDN(localeName) {
  var head = document.getElementsByTagName('head')[0];
  var js = document.createElement('script');
  js.type = 'text/javascript';
  js.src = "https://transloadit.edgly.net/releases/uppy/locales/v1.11.0/" + localeName + ".min.js";
  head.appendChild(js);
}

function setLocale(localeName) {
  if (typeof window.Uppy.locales[localeName] === 'undefined') {
    loadLocaleFromCDN(localeName);
  }

  whenLocaleAvailable(localeName, function (localeObj) {
    window.uppy.setOptions({
      locale: localeObj
    });
  });
}

function populateLocaleSelect() {
  var localeSelect = document.getElementById('localeList');
  Object.keys(localeList).forEach(function (localeName) {
    if (localeName === 'en_US') return;
    localeSelect.innerHTML += "<option value=\"" + localeName + "\">" + localeList[localeName] + " \u2014 (" + localeName + ")</option>";
  });
  localeSelect.addEventListener('change', function (event) {
    var localeName = event.target.value;
    setLocale(localeName);
  });
}

window.uppySetOptions = uppySetOptions;
window.uppyInit = uppyInit;
window.uppySetLocale = setLocale;
populateLocaleSelect();
uppyInit();
uppySetOptions();

},{"../env":159,"../locale_list.json":160,"./../../../../packages/@uppy/core":45,"./../../../../packages/@uppy/dashboard":64,"./../../../../packages/@uppy/dropbox":73,"./../../../../packages/@uppy/facebook":75,"./../../../../packages/@uppy/google-drive":78,"./../../../../packages/@uppy/instagram":82,"./../../../../packages/@uppy/onedrive":84,"./../../../../packages/@uppy/tus":110,"./../../../../packages/@uppy/url":113,"./../../../../packages/@uppy/webcam":156,"es6-promise/auto":6,"whatwg-fetch":34}],159:[function(require,module,exports){
var companionEndpoint = 'http://localhost:3020';

if (location.hostname === 'uppy.io') {
  companionEndpoint = '//companion.uppy.io';
}

var COMPANION = companionEndpoint;
module.exports = COMPANION;

},{}],160:[function(require,module,exports){
module.exports={"ar_SA":"Arabic (Saudi Arabia)","cs_CZ":"Czech (Czech Republic)","da_DK":"Danish (Denmark)","de_DE":"German (Germany)","el_GR":"Greek (Greece)","en_US":"English (United States)","es_ES":"Spanish (Spain)","fa_IR":"Persian (Iran, Islamic Republic of)","fi_FI":"Finnish (Finland)","fr_FR":"French (France)","gl_ES":"Galician (Spain)","he_IL":"Hebrew (Israel)","hu_HU":"Hungarian (Hungary)","id_ID":"Indonesian (Indonesia)","is_IS":"Icelandic (Iceland)","it_IT":"Italian (Italy)","ja_JP":"Japanese (Japan)","ko_KR":"Korean (Korea, Republic of)","nl_NL":"Dutch (Netherlands)","pt_BR":"Portuguese (Brazil)","ru_RU":"Russian (Russian Federation)","sr_RS_Cyrillic":"Serbian (Serbia Cyrillic)","sr_RS_Latin":"Serbian (Serbia Latin)","sv_SE":"Swedish (Sweden)","th_TH":"Thai (Thailand)","tr_TR":"Turkish (Turkey)","vi_VN":"Vietnamese (Viet Nam)","zh_CN":"Chinese (China)","zh_TW":"Chinese (Taiwan, Province of China)"}
},{}]},{},[158])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9jdWlkL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2N1aWQvbGliL2ZpbmdlcnByaW50LmJyb3dzZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvY3VpZC9saWIvZ2V0UmFuZG9tVmFsdWUuYnJvd3Nlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9jdWlkL2xpYi9wYWQuanMiLCIuLi9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvYXV0by5qcyIsIi4uL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2V4dGVuZC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9pcy1zaGFsbG93LWVxdWFsL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2pzLWJhc2U2NC9iYXNlNjQuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLmRlYm91bmNlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC50aHJvdHRsZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9tZW1vaXplLW9uZS9kaXN0L21lbW9pemUtb25lLmNqcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9taW1lLW1hdGNoL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL25hbWVzcGFjZS1lbWl0dGVyL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1jc3MtdHJhbnNpdGlvbi1ncm91cC9kaXN0L3ByZWFjdC1jc3MtdHJhbnNpdGlvbi1ncm91cC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QvZGlzdC9wcmVhY3QuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5naWZ5L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3JlcXVpcmVzLXBvcnQvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvcmVzaXplLW9ic2VydmVyLXBvbHlmaWxsL2Rpc3QvUmVzaXplT2JzZXJ2ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Jyb3dzZXIvZmluZ2VycHJpbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Jyb3dzZXIvaXNDb3Jkb3ZhLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9icm93c2VyL2lzUmVhY3ROYXRpdmUuanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Jyb3dzZXIvcmVhZEFzQnl0ZUFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9icm93c2VyL3JlcXVlc3QuanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Jyb3dzZXIvc291cmNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9icm93c2VyL3N0b3JhZ2UuanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L2Jyb3dzZXIvdXJpVG9CbG9iLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3R1cy1qcy1jbGllbnQvbGliLmVzNS9lcnJvci5qcyIsIi4uL25vZGVfbW9kdWxlcy90dXMtanMtY2xpZW50L2xpYi5lczUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvdHVzLWpzLWNsaWVudC9saWIuZXM1L3VwbG9hZC5qcyIsIi4uL25vZGVfbW9kdWxlcy91cmwtcGFyc2UvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvd2hhdHdnLWZldGNoL2Rpc3QvZmV0Y2gudW1kLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3dpbGRjYXJkL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29tcGFuaW9uLWNsaWVudC9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9jb21wYW5pb24tY2xpZW50L3NyYy9BdXRoRXJyb3IuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb21wYW5pb24tY2xpZW50L3NyYy9Qcm92aWRlci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvbXBhbmlvbi1jbGllbnQvc3JjL1JlcXVlc3RDbGllbnQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb21wYW5pb24tY2xpZW50L3NyYy9Tb2NrZXQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb21wYW5pb24tY2xpZW50L3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvbXBhbmlvbi1jbGllbnQvc3JjL3Rva2VuU3RvcmFnZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2NvcmUvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvY29yZS9zcmMvUGx1Z2luLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29yZS9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9jb3JlL3NyYy9sb2dnZXJzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvY29yZS9zcmMvc3VwcG9ydHNVcGxvYWRQcm9ncmVzcy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvQWRkRmlsZXMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvQWRkRmlsZXNQYW5lbC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9EYXNoYm9hcmQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRmlsZUNhcmQvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRmlsZUl0ZW0vQnV0dG9ucy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9GaWxlSXRlbS9GaWxlSW5mby9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9GaWxlSXRlbS9GaWxlUHJldmlld0FuZExpbmsvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRmlsZUl0ZW0vRmlsZVByb2dyZXNzL1BhdXNlUmVzdW1lQ2FuY2VsSWNvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvY29tcG9uZW50cy9GaWxlSXRlbS9GaWxlUHJvZ3Jlc3MvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRmlsZUl0ZW0vaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRmlsZUxpc3QuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvRmlsZVByZXZpZXcuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL2NvbXBvbmVudHMvUGlja2VyUGFuZWxDb250ZW50LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL1BpY2tlclBhbmVsVG9wQmFyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9jb21wb25lbnRzL2ljb25zLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvdXRpbHMvY29weVRvQ2xpcGJvYXJkLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy91dGlscy9jcmVhdGVTdXBlckZvY3VzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZGFzaGJvYXJkL3NyYy91dGlscy9nZXRBY3RpdmVPdmVybGF5RWwuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL3V0aWxzL2dldEZpbGVUeXBlSWNvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvdXRpbHMvaWdub3JlRXZlbnQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kYXNoYm9hcmQvc3JjL3V0aWxzL3RyYXBGb2N1cy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2Rhc2hib2FyZC9zcmMvdXRpbHMvdHJ1bmNhdGVTdHJpbmcuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9kcm9wYm94L3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L2Ryb3Bib3gvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZmFjZWJvb2svcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvZmFjZWJvb2svc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZ29vZ2xlLWRyaXZlL3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L2dvb2dsZS1kcml2ZS9zcmMvRHJpdmVQcm92aWRlclZpZXdzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvZ29vZ2xlLWRyaXZlL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2luZm9ybWVyL3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L2luZm9ybWVyL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L2luc3RhZ3JhbS9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS9pbnN0YWdyYW0vc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvb25lZHJpdmUvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvb25lZHJpdmUvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3MvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL0F1dGhWaWV3LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL0JyZWFkY3J1bWJzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL0Jyb3dzZXIuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvRmlsdGVyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL0Zvb3RlckFjdGlvbnMuanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvSXRlbS9jb21wb25lbnRzL0dyaWRMaS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9JdGVtL2NvbXBvbmVudHMvSXRlbUljb24uanMiLCIuLi9wYWNrYWdlcy9AdXBweS9wcm92aWRlci12aWV3cy9zcmMvSXRlbS9jb21wb25lbnRzL0xpc3RMaS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9JdGVtL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL0l0ZW1MaXN0LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvcHJvdmlkZXItdmlld3Mvc3JjL0xvYWRlci5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3Byb3ZpZGVyLXZpZXdzL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3N0YXR1cy1iYXIvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvc3RhdHVzLWJhci9zcmMvU3RhdHVzQmFyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvc3RhdHVzLWJhci9zcmMvU3RhdHVzQmFyU3RhdGVzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvc3RhdHVzLWJhci9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS9zdG9yZS1kZWZhdWx0L3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L3N0b3JlLWRlZmF1bHQvc3JjL2luZGV4LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdGh1bWJuYWlsLWdlbmVyYXRvci9wYWNrYWdlLmpzb24iLCIuLi9wYWNrYWdlcy9AdXBweS90aHVtYm5haWwtZ2VuZXJhdG9yL3NyYy9leGlmLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdGh1bWJuYWlsLWdlbmVyYXRvci9zcmMvaW1hZ2Utb3JpZW50YXRpb25zLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdGh1bWJuYWlsLWdlbmVyYXRvci9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS90dXMvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvdHVzL3NyYy9nZXRGaW5nZXJwcmludC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3R1cy9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS91cmwvcGFja2FnZS5qc29uIiwiLi4vcGFja2FnZXMvQHVwcHkvdXJsL3NyYy9VcmxVSS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3VybC9zcmMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS91cmwvc3JjL3V0aWxzL2ZvckVhY2hEcm9wcGVkT3JQYXN0ZWRVcmwuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvRXZlbnRUcmFja2VyLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL0ZPQ1VTQUJMRV9FTEVNRU5UUy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9SYXRlTGltaXRlZFF1ZXVlLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL1RyYW5zbGF0b3IuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvY2FudmFzVG9CbG9iLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2RhdGFVUkl0b0Jsb2IuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZW1pdFNvY2tldFByb2dyZXNzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2ZpbmRBbGxET01FbGVtZW50cy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9maW5kRE9NRWxlbWVudC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZW5lcmF0ZUZpbGVJRC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXRCeXRlc1JlbWFpbmluZy5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXREcm9wcGVkRmlsZXMvaW5kZXguanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvZ2V0RHJvcHBlZEZpbGVzL3V0aWxzL2ZhbGxiYWNrQXBpLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldERyb3BwZWRGaWxlcy91dGlscy93ZWJraXRHZXRBc0VudHJ5QXBpL2dldEZpbGVzQW5kRGlyZWN0b3JpZXNGcm9tRGlyZWN0b3J5LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldERyb3BwZWRGaWxlcy91dGlscy93ZWJraXRHZXRBc0VudHJ5QXBpL2dldFJlbGF0aXZlUGF0aC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXREcm9wcGVkRmlsZXMvdXRpbHMvd2Via2l0R2V0QXNFbnRyeUFwaS9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXRGaWxlTmFtZUFuZEV4dGVuc2lvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXRGaWxlVHlwZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXRGaWxlVHlwZUV4dGVuc2lvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9nZXRTb2NrZXRIb3N0LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldFNwZWVkLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2dldFRpbWVTdGFtcC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9oYXNQcm9wZXJ0eS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9pc0RPTUVsZW1lbnQuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvaXNPYmplY3RVUkwuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvaXNQcmV2aWV3U3VwcG9ydGVkLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL2lzVG91Y2hEZXZpY2UuanMiLCIuLi9wYWNrYWdlcy9AdXBweS91dGlscy9zcmMvbWltZVR5cGVzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL3ByZXR0eUJ5dGVzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL3ByZXR0eUVUQS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy9zZWNvbmRzVG9UaW1lLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvdXRpbHMvc3JjL3NldHRsZS5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3V0aWxzL3NyYy90b0FycmF5LmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3BhY2thZ2UuanNvbiIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvQ2FtZXJhSWNvbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvQ2FtZXJhU2NyZWVuLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9QZXJtaXNzaW9uc1NjcmVlbi5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvUmVjb3JkQnV0dG9uLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9SZWNvcmRpbmdMZW5ndGguanMiLCIuLi9wYWNrYWdlcy9AdXBweS93ZWJjYW0vc3JjL1NuYXBzaG90QnV0dG9uLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9mb3JtYXRTZWNvbmRzLmpzIiwiLi4vcGFja2FnZXMvQHVwcHkvd2ViY2FtL3NyYy9pbmRleC5qcyIsIi4uL3BhY2thZ2VzL0B1cHB5L3dlYmNhbS9zcmMvc3VwcG9ydHNNZWRpYVJlY29yZGVyLmpzIiwic3JjL2V4YW1wbGVzL2Rhc2hib2FyZC9hcHAuZXM2Iiwic3JjL2V4YW1wbGVzL2Vudi5qcyIsInNyYy9leGFtcGxlcy9sb2NhbGVfbGlzdC5qc29uIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9wQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDelhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3g2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBOzs7Ozs7Ozs7Ozs7Ozs7O0lBRU0s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ZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiLyohXG4gIENvcHlyaWdodCAoYykgMjAxNyBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMgKCkge1xuXHRcdHZhciBjbGFzc2VzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmICghYXJnKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnVHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGFyZyk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSAmJiBhcmcubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBpbm5lciA9IGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKTtcblx0XHRcdFx0aWYgKGlubmVyKSB7XG5cdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGlubmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Y2xhc3NOYW1lcy5kZWZhdWx0ID0gY2xhc3NOYW1lcztcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuIiwiLyoqXG4gKiBjdWlkLmpzXG4gKiBDb2xsaXNpb24tcmVzaXN0YW50IFVJRCBnZW5lcmF0b3IgZm9yIGJyb3dzZXJzIGFuZCBub2RlLlxuICogU2VxdWVudGlhbCBmb3IgZmFzdCBkYiBsb29rdXBzIGFuZCByZWNlbmN5IHNvcnRpbmcuXG4gKiBTYWZlIGZvciBlbGVtZW50IElEcyBhbmQgc2VydmVyLXNpZGUgbG9va3Vwcy5cbiAqXG4gKiBFeHRyYWN0ZWQgZnJvbSBDTENUUlxuICpcbiAqIENvcHlyaWdodCAoYykgRXJpYyBFbGxpb3R0IDIwMTJcbiAqIE1JVCBMaWNlbnNlXG4gKi9cblxudmFyIGZpbmdlcnByaW50ID0gcmVxdWlyZSgnLi9saWIvZmluZ2VycHJpbnQuanMnKTtcbnZhciBwYWQgPSByZXF1aXJlKCcuL2xpYi9wYWQuanMnKTtcbnZhciBnZXRSYW5kb21WYWx1ZSA9IHJlcXVpcmUoJy4vbGliL2dldFJhbmRvbVZhbHVlLmpzJyk7XG5cbnZhciBjID0gMCxcbiAgYmxvY2tTaXplID0gNCxcbiAgYmFzZSA9IDM2LFxuICBkaXNjcmV0ZVZhbHVlcyA9IE1hdGgucG93KGJhc2UsIGJsb2NrU2l6ZSk7XG5cbmZ1bmN0aW9uIHJhbmRvbUJsb2NrICgpIHtcbiAgcmV0dXJuIHBhZCgoZ2V0UmFuZG9tVmFsdWUoKSAqXG4gICAgZGlzY3JldGVWYWx1ZXMgPDwgMClcbiAgICAudG9TdHJpbmcoYmFzZSksIGJsb2NrU2l6ZSk7XG59XG5cbmZ1bmN0aW9uIHNhZmVDb3VudGVyICgpIHtcbiAgYyA9IGMgPCBkaXNjcmV0ZVZhbHVlcyA/IGMgOiAwO1xuICBjKys7IC8vIHRoaXMgaXMgbm90IHN1YmxpbWluYWxcbiAgcmV0dXJuIGMgLSAxO1xufVxuXG5mdW5jdGlvbiBjdWlkICgpIHtcbiAgLy8gU3RhcnRpbmcgd2l0aCBhIGxvd2VyY2FzZSBsZXR0ZXIgbWFrZXNcbiAgLy8gaXQgSFRNTCBlbGVtZW50IElEIGZyaWVuZGx5LlxuICB2YXIgbGV0dGVyID0gJ2MnLCAvLyBoYXJkLWNvZGVkIGFsbG93cyBmb3Igc2VxdWVudGlhbCBhY2Nlc3NcblxuICAgIC8vIHRpbWVzdGFtcFxuICAgIC8vIHdhcm5pbmc6IHRoaXMgZXhwb3NlcyB0aGUgZXhhY3QgZGF0ZSBhbmQgdGltZVxuICAgIC8vIHRoYXQgdGhlIHVpZCB3YXMgY3JlYXRlZC5cbiAgICB0aW1lc3RhbXAgPSAobmV3IERhdGUoKS5nZXRUaW1lKCkpLnRvU3RyaW5nKGJhc2UpLFxuXG4gICAgLy8gUHJldmVudCBzYW1lLW1hY2hpbmUgY29sbGlzaW9ucy5cbiAgICBjb3VudGVyID0gcGFkKHNhZmVDb3VudGVyKCkudG9TdHJpbmcoYmFzZSksIGJsb2NrU2l6ZSksXG5cbiAgICAvLyBBIGZldyBjaGFycyB0byBnZW5lcmF0ZSBkaXN0aW5jdCBpZHMgZm9yIGRpZmZlcmVudFxuICAgIC8vIGNsaWVudHMgKHNvIGRpZmZlcmVudCBjb21wdXRlcnMgYXJlIGZhciBsZXNzXG4gICAgLy8gbGlrZWx5IHRvIGdlbmVyYXRlIHRoZSBzYW1lIGlkKVxuICAgIHByaW50ID0gZmluZ2VycHJpbnQoKSxcblxuICAgIC8vIEdyYWIgc29tZSBtb3JlIGNoYXJzIGZyb20gTWF0aC5yYW5kb20oKVxuICAgIHJhbmRvbSA9IHJhbmRvbUJsb2NrKCkgKyByYW5kb21CbG9jaygpO1xuXG4gIHJldHVybiBsZXR0ZXIgKyB0aW1lc3RhbXAgKyBjb3VudGVyICsgcHJpbnQgKyByYW5kb207XG59XG5cbmN1aWQuc2x1ZyA9IGZ1bmN0aW9uIHNsdWcgKCkge1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLnRvU3RyaW5nKDM2KSxcbiAgICBjb3VudGVyID0gc2FmZUNvdW50ZXIoKS50b1N0cmluZygzNikuc2xpY2UoLTQpLFxuICAgIHByaW50ID0gZmluZ2VycHJpbnQoKS5zbGljZSgwLCAxKSArXG4gICAgICBmaW5nZXJwcmludCgpLnNsaWNlKC0xKSxcbiAgICByYW5kb20gPSByYW5kb21CbG9jaygpLnNsaWNlKC0yKTtcblxuICByZXR1cm4gZGF0ZS5zbGljZSgtMikgK1xuICAgIGNvdW50ZXIgKyBwcmludCArIHJhbmRvbTtcbn07XG5cbmN1aWQuaXNDdWlkID0gZnVuY3Rpb24gaXNDdWlkIChzdHJpbmdUb0NoZWNrKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nVG9DaGVjayAhPT0gJ3N0cmluZycpIHJldHVybiBmYWxzZTtcbiAgaWYgKHN0cmluZ1RvQ2hlY2suc3RhcnRzV2l0aCgnYycpKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY3VpZC5pc1NsdWcgPSBmdW5jdGlvbiBpc1NsdWcgKHN0cmluZ1RvQ2hlY2spIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmdUb0NoZWNrICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhbHNlO1xuICB2YXIgc3RyaW5nTGVuZ3RoID0gc3RyaW5nVG9DaGVjay5sZW5ndGg7XG4gIGlmIChzdHJpbmdMZW5ndGggPj0gNyAmJiBzdHJpbmdMZW5ndGggPD0gMTApIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5jdWlkLmZpbmdlcnByaW50ID0gZmluZ2VycHJpbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gY3VpZDtcbiIsInZhciBwYWQgPSByZXF1aXJlKCcuL3BhZC5qcycpO1xuXG52YXIgZW52ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgPyB3aW5kb3cgOiBzZWxmO1xudmFyIGdsb2JhbENvdW50ID0gT2JqZWN0LmtleXMoZW52KS5sZW5ndGg7XG52YXIgbWltZVR5cGVzTGVuZ3RoID0gbmF2aWdhdG9yLm1pbWVUeXBlcyA/IG5hdmlnYXRvci5taW1lVHlwZXMubGVuZ3RoIDogMDtcbnZhciBjbGllbnRJZCA9IHBhZCgobWltZVR5cGVzTGVuZ3RoICtcbiAgbmF2aWdhdG9yLnVzZXJBZ2VudC5sZW5ndGgpLnRvU3RyaW5nKDM2KSArXG4gIGdsb2JhbENvdW50LnRvU3RyaW5nKDM2KSwgNCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmluZ2VycHJpbnQgKCkge1xuICByZXR1cm4gY2xpZW50SWQ7XG59O1xuIiwiXG52YXIgZ2V0UmFuZG9tVmFsdWU7XG5cbnZhciBjcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0bztcblxuaWYgKGNyeXB0bykge1xuICAgIHZhciBsaW0gPSBNYXRoLnBvdygyLCAzMikgLSAxO1xuICAgIGdldFJhbmRvbVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMSkpWzBdIC8gbGltKTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBnZXRSYW5kb21WYWx1ZSA9IE1hdGgucmFuZG9tO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhbmRvbVZhbHVlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYWQgKG51bSwgc2l6ZSkge1xuICB2YXIgcyA9ICcwMDAwMDAwMDAnICsgbnVtO1xuICByZXR1cm4gcy5zdWJzdHIocy5sZW5ndGggLSBzaXplKTtcbn07XG4iLCIvLyBUaGlzIGZpbGUgY2FuIGJlIHJlcXVpcmVkIGluIEJyb3dzZXJpZnkgYW5kIE5vZGUuanMgZm9yIGF1dG9tYXRpYyBwb2x5ZmlsbFxuLy8gVG8gdXNlIGl0OiAgcmVxdWlyZSgnZXM2LXByb21pc2UvYXV0bycpO1xuJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLycpLnBvbHlmaWxsKCk7XG4iLCIvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RlZmFucGVubmVyL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIHY0LjIuNSs3ZjJiNTI2ZFxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5FUzZQcm9taXNlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgeDtcbiAgcmV0dXJuIHggIT09IG51bGwgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5cblxudmFyIF9pc0FycmF5ID0gdm9pZCAwO1xuaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xufSBlbHNlIHtcbiAgX2lzQXJyYXkgPSBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG59XG5cbnZhciBpc0FycmF5ID0gX2lzQXJyYXk7XG5cbnZhciBsZW4gPSAwO1xudmFyIHZlcnR4TmV4dCA9IHZvaWQgMDtcbnZhciBjdXN0b21TY2hlZHVsZXJGbiA9IHZvaWQgMDtcblxudmFyIGFzYXAgPSBmdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBhcmcpIHtcbiAgcXVldWVbbGVuXSA9IGNhbGxiYWNrO1xuICBxdWV1ZVtsZW4gKyAxXSA9IGFyZztcbiAgbGVuICs9IDI7XG4gIGlmIChsZW4gPT09IDIpIHtcbiAgICAvLyBJZiBsZW4gaXMgMiwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgaWYgKGN1c3RvbVNjaGVkdWxlckZuKSB7XG4gICAgICBjdXN0b21TY2hlZHVsZXJGbihmbHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlRmx1c2goKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG4gIGN1c3RvbVNjaGVkdWxlckZuID0gc2NoZWR1bGVGbjtcbn1cblxuZnVuY3Rpb24gc2V0QXNhcChhc2FwRm4pIHtcbiAgYXNhcCA9IGFzYXBGbjtcbn1cblxudmFyIGJyb3dzZXJXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbnZhciBicm93c2VyR2xvYmFsID0gYnJvd3NlcldpbmRvdyB8fCB7fTtcbnZhciBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgaXNOb2RlID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbi8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG52YXIgaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBub2RlXG5mdW5jdGlvbiB1c2VOZXh0VGljaygpIHtcbiAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgfTtcbn1cblxuLy8gdmVydHhcbmZ1bmN0aW9uIHVzZVZlcnR4VGltZXIoKSB7XG4gIGlmICh0eXBlb2YgdmVydHhOZXh0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2ZXJ0eE5leHQoZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIG5vZGUuZGF0YSA9IGl0ZXJhdGlvbnMgPSArK2l0ZXJhdGlvbnMgJSAyO1xuICB9O1xufVxuXG4vLyB3ZWIgd29ya2VyXG5mdW5jdGlvbiB1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlU2V0VGltZW91dCgpIHtcbiAgLy8gU3RvcmUgc2V0VGltZW91dCByZWZlcmVuY2Ugc28gZXM2LXByb21pc2Ugd2lsbCBiZSB1bmFmZmVjdGVkIGJ5XG4gIC8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxuICB2YXIgZ2xvYmFsU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbFNldFRpbWVvdXQoZmx1c2gsIDEpO1xuICB9O1xufVxuXG52YXIgcXVldWUgPSBuZXcgQXJyYXkoMTAwMCk7XG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuICAgIHZhciBhcmcgPSBxdWV1ZVtpICsgMV07XG5cbiAgICBjYWxsYmFjayhhcmcpO1xuXG4gICAgcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgcXVldWVbaSArIDFdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFZlcnR4KCkge1xuICB0cnkge1xuICAgIHZhciB2ZXJ0eCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCkucmVxdWlyZSgndmVydHgnKTtcbiAgICB2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgIHJldHVybiB1c2VWZXJ0eFRpbWVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdXNlU2V0VGltZW91dCgpO1xuICB9XG59XG5cbnZhciBzY2hlZHVsZUZsdXNoID0gdm9pZCAwO1xuLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbmlmIChpc05vZGUpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU5leHRUaWNrKCk7XG59IGVsc2UgaWYgKEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNdXRhdGlvbk9ic2VydmVyKCk7XG59IGVsc2UgaWYgKGlzV29ya2VyKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VNZXNzYWdlQ2hhbm5lbCgpO1xufSBlbHNlIGlmIChicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IGF0dGVtcHRWZXJ0eCgpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgcGFyZW50ID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBpZiAoY2hpbGRbUFJPTUlTRV9JRF0gPT09IHVuZGVmaW5lZCkge1xuICAgIG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgfVxuXG4gIHZhciBfc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG5cbiAgaWYgKF9zdGF0ZSkge1xuICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1tfc3RhdGUgLSAxXTtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbnZva2VDYWxsYmFjayhfc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcGFyZW50Ll9yZXN1bHQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gIH1cblxuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZXNvbHZlYCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIHJlc29sdmVkIHdpdGggdGhlXG4gIHBhc3NlZCBgdmFsdWVgLiBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVzb2x2ZSgxKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoMSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZXNvbHZlXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZXNvbHZlZCB3aXRoXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgZnVsZmlsbGVkIHdpdGggdGhlIGdpdmVuXG4gIGB2YWx1ZWBcbiovXG5mdW5jdGlvbiByZXNvbHZlJDEob2JqZWN0KSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG52YXIgUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBQRU5ESU5HID0gdm9pZCAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xuXG52YXIgVFJZX0NBVENIX0VSUk9SID0geyBlcnJvcjogbnVsbCB9O1xuXG5mdW5jdGlvbiBzZWxmRnVsZmlsbG1lbnQoKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbn1cblxuZnVuY3Rpb24gY2Fubm90UmV0dXJuT3duKCkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuKHByb21pc2UpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIFRSWV9DQVRDSF9FUlJPUi5lcnJvciA9IGVycm9yO1xuICAgIHJldHVybiBUUllfQ0FUQ0hfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VGhlbih0aGVuJCQxLCB2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gIHRyeSB7XG4gICAgdGhlbiQkMS5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlLCB0aGVuJCQxKSB7XG4gIGFzYXAoZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gdHJ5VGhlbih0aGVuJCQxLCB0aGVuYWJsZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoc2VhbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuXG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9LCAnU2V0dGxlOiAnICsgKHByb21pc2UuX2xhYmVsIHx8ICcgdW5rbm93biBwcm9taXNlJykpO1xuXG4gICAgaWYgKCFzZWFsZWQgJiYgZXJyb3IpIHtcbiAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgIH1cbiAgfSwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIHRoZW5hYmxlKSB7XG4gIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IEZVTEZJTExFRCkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSBpZiAodGhlbmFibGUuX3N0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBzdWJzY3JpYmUodGhlbmFibGUsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSkge1xuICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJiB0aGVuJCQxID09PSB0aGVuICYmIG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoZW4kJDEgPT09IFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIFRSWV9DQVRDSF9FUlJPUi5lcnJvcik7XG4gICAgICBUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodGhlbiQkMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih0aGVuJCQxKSkge1xuICAgICAgaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBzZWxmRnVsZmlsbG1lbnQoKSk7XG4gIH0gZWxzZSBpZiAob2JqZWN0T3JGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlLCBnZXRUaGVuKHZhbHVlKSk7XG4gIH0gZWxzZSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICB9XG5cbiAgcHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cbiAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzYXAocHVibGlzaCwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cblxuICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gIF9zdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSA9IG9uUmVqZWN0aW9uO1xuXG4gIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMCxcbiAgICAgIGNhbGxiYWNrID0gdm9pZCAwLFxuICAgICAgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgVFJZX0NBVENIX0VSUk9SLmVycm9yID0gZTtcbiAgICByZXR1cm4gVFJZX0NBVENIX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKHNldHRsZWQsIHByb21pc2UsIGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgdmFyIGhhc0NhbGxiYWNrID0gaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICB2YWx1ZSA9IHZvaWQgMCxcbiAgICAgIGVycm9yID0gdm9pZCAwLFxuICAgICAgc3VjY2VlZGVkID0gdm9pZCAwLFxuICAgICAgZmFpbGVkID0gdm9pZCAwO1xuXG4gIGlmIChoYXNDYWxsYmFjaykge1xuICAgIHZhbHVlID0gdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCk7XG5cbiAgICBpZiAodmFsdWUgPT09IFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgIGVycm9yID0gdmFsdWUuZXJyb3I7XG4gICAgICB2YWx1ZS5lcnJvciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gbm9vcFxuICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGZhaWxlZCkge1xuICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gRlVMRklMTEVEKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gIHRyeSB7XG4gICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcbiAgICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIHJlamVjdFByb21pc2UocmVhc29uKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChwcm9taXNlLCBlKTtcbiAgfVxufVxuXG52YXIgaWQgPSAwO1xuZnVuY3Rpb24gbmV4dElkKCkge1xuICByZXR1cm4gaWQrKztcbn1cblxuZnVuY3Rpb24gbWFrZVByb21pc2UocHJvbWlzZSkge1xuICBwcm9taXNlW1BST01JU0VfSURdID0gaWQrKztcbiAgcHJvbWlzZS5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gIHByb21pc2UuX3Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGlvbkVycm9yKCkge1xuICByZXR1cm4gbmV3IEVycm9yKCdBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXknKTtcbn1cblxudmFyIEVudW1lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gICAgdGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3Rvcihub29wKTtcblxuICAgIGlmICghdGhpcy5wcm9taXNlW1BST01JU0VfSURdKSB7XG4gICAgICBtYWtlUHJvbWlzZSh0aGlzLnByb21pc2UpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgICAgdGhpcy5fZW51bWVyYXRlKGlucHV0KTtcbiAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdCh0aGlzLnByb21pc2UsIHZhbGlkYXRpb25FcnJvcigpKTtcbiAgICB9XG4gIH1cblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24gX2VudW1lcmF0ZShpbnB1dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyB0aGlzLl9zdGF0ZSA9PT0gUEVORElORyAmJiBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2VhY2hFbnRyeShpbnB1dFtpXSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9lYWNoRW50cnkgPSBmdW5jdGlvbiBfZWFjaEVudHJ5KGVudHJ5LCBpKSB7XG4gICAgdmFyIGMgPSB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yO1xuICAgIHZhciByZXNvbHZlJCQxID0gYy5yZXNvbHZlO1xuXG5cbiAgICBpZiAocmVzb2x2ZSQkMSA9PT0gcmVzb2x2ZSQxKSB7XG4gICAgICB2YXIgX3RoZW4gPSBnZXRUaGVuKGVudHJ5KTtcblxuICAgICAgaWYgKF90aGVuID09PSB0aGVuICYmIGVudHJ5Ll9zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSQxKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICAgIGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIF90aGVuKTtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KHByb21pc2UsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd2lsbFNldHRsZUF0KG5ldyBjKGZ1bmN0aW9uIChyZXNvbHZlJCQxKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUkJDEoZW50cnkpO1xuICAgICAgICB9KSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChyZXNvbHZlJCQxKGVudHJ5KSwgaSk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbiBfc2V0dGxlZEF0KHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuXG5cbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IFBFTkRJTkcpIHtcbiAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuXG4gICAgICBpZiAoc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICBmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgfVxuICB9O1xuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbiBfd2lsbFNldHRsZUF0KHByb21pc2UsIGkpIHtcbiAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICBzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcmV0dXJuIGVudW1lcmF0b3IuX3NldHRsZWRBdChSRUpFQ1RFRCwgaSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRW51bWVyYXRvcjtcbn0oKTtcblxuLyoqXG4gIGBQcm9taXNlLmFsbGAgYWNjZXB0cyBhbiBhcnJheSBvZiBwcm9taXNlcywgYW5kIHJldHVybnMgYSBuZXcgcHJvbWlzZSB3aGljaFxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSBvZiBmdWxmaWxsbWVudCB2YWx1ZXMgZm9yIHRoZSBwYXNzZWQgcHJvbWlzZXMsIG9yXG4gIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiBvZiB0aGUgZmlyc3QgcGFzc2VkIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQuIEl0IGNhc3RzIGFsbFxuICBlbGVtZW50cyBvZiB0aGUgcGFzc2VkIGl0ZXJhYmxlIHRvIHByb21pc2VzIGFzIGl0IHJ1bnMgdGhpcyBhbGdvcml0aG0uXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlc29sdmUoMik7XG4gIGxldCBwcm9taXNlMyA9IHJlc29sdmUoMyk7XG4gIGxldCBwcm9taXNlcyA9IFsgcHJvbWlzZTEsIHByb21pc2UyLCBwcm9taXNlMyBdO1xuXG4gIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGFycmF5KXtcbiAgICAvLyBUaGUgYXJyYXkgaGVyZSB3b3VsZCBiZSBbIDEsIDIsIDMgXTtcbiAgfSk7XG4gIGBgYFxuXG4gIElmIGFueSBvZiB0aGUgYHByb21pc2VzYCBnaXZlbiB0byBgYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IHJlc29sdmUoMSk7XG4gIGxldCBwcm9taXNlMiA9IHJlamVjdChuZXcgRXJyb3IoXCIyXCIpKTtcbiAgbGV0IHByb21pc2UzID0gcmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBcnJheX0gZW50cmllcyBhcnJheSBvZiBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWwgb3B0aW9uYWwgc3RyaW5nIGZvciBsYWJlbGluZyB0aGUgcHJvbWlzZS5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIGBwcm9taXNlc2AgaGF2ZSBiZWVuXG4gIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQgaWYgYW55IG9mIHRoZW0gYmVjb21lIHJlamVjdGVkLlxuICBAc3RhdGljXG4qL1xuZnVuY3Rpb24gYWxsKGVudHJpZXMpIHtcbiAgcmV0dXJuIG5ldyBFbnVtZXJhdG9yKHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yYWNlYCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2ggaXMgc2V0dGxlZCBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlXG4gIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIHNldHRsZS5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMicpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHJlc3VsdCA9PT0gJ3Byb21pc2UgMicgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFByb21pc2UucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdFxuICBzZXR0bGVkIHByb21pc2UgbWF0dGVycy4gRm9yIGV4YW1wbGUsIGV2ZW4gaWYgb3RoZXIgcHJvbWlzZXMgZ2l2ZW4gdG8gdGhlXG4gIGBwcm9taXNlc2AgYXJyYXkgYXJndW1lbnQgYXJlIHJlc29sdmVkLCBidXQgdGhlIGZpcnN0IHNldHRsZWQgcHJvbWlzZSBoYXNcbiAgYmVjb21lIHJlamVjdGVkIGJlZm9yZSB0aGUgb3RoZXIgcHJvbWlzZXMgYmVjYW1lIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gIHByb21pc2Ugd2lsbCBiZWNvbWUgcmVqZWN0ZWQ6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoJ3Byb21pc2UgMScpO1xuICAgIH0sIDIwMCk7XG4gIH0pO1xuXG4gIGxldCBwcm9taXNlMiA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvbWlzZSAyJykpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFByb21pc2UucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gcmVhc29uLm1lc3NhZ2UgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgcHJvbWlzZSAyIGJlY2FtZSByZWplY3RlZCBiZWZvcmVcbiAgICAvLyBwcm9taXNlIDEgYmVjYW1lIGZ1bGZpbGxlZFxuICB9KTtcbiAgYGBgXG5cbiAgQW4gZXhhbXBsZSByZWFsLXdvcmxkIHVzZSBjYXNlIGlzIGltcGxlbWVudGluZyB0aW1lb3V0czpcblxuICBgYGBqYXZhc2NyaXB0XG4gIFByb21pc2UucmFjZShbYWpheCgnZm9vLmpzb24nKSwgdGltZW91dCg1MDAwKV0pXG4gIGBgYFxuXG4gIEBtZXRob2QgcmFjZVxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2Ugd2hpY2ggc2V0dGxlcyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhlIGZpcnN0IHBhc3NlZFxuICBwcm9taXNlIHRvIHNldHRsZS5cbiovXG5mdW5jdGlvbiByYWNlKGVudHJpZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkoZW50cmllcykpIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBsZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgcGFzc2VkIGByZWFzb25gLlxuICBJdCBpcyBzaG9ydGhhbmQgZm9yIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gcmVhc29uIHZhbHVlIHRoYXQgdGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZWplY3RlZCB3aXRoIHRoZSBnaXZlbiBgcmVhc29uYC5cbiovXG5mdW5jdGlvbiByZWplY3QkMShyZWFzb24pIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbmVlZHNSZXNvbHZlcigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xufVxuXG5mdW5jdGlvbiBuZWVkc05ldygpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTtcbn1cblxuLyoqXG4gIFByb21pc2Ugb2JqZWN0cyByZXByZXNlbnQgdGhlIGV2ZW50dWFsIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiBUaGVcbiAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gIFRlcm1pbm9sb2d5XG4gIC0tLS0tLS0tLS0tXG5cbiAgLSBgcHJvbWlzZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSBgdGhlbmAgbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gIC0gYGV4Y2VwdGlvbmAgaXMgYSB2YWx1ZSB0aGF0IGlzIHRocm93biB1c2luZyB0aGUgdGhyb3cgc3RhdGVtZW50LlxuICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gIEEgcHJvbWlzZSBjYW4gYmUgaW4gb25lIG9mIHRocmVlIHN0YXRlczogcGVuZGluZywgZnVsZmlsbGVkLCBvciByZWplY3RlZC5cblxuICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gIHJlamVjdGVkIHN0YXRlLiAgQSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZXZlciBhIHRoZW5hYmxlLlxuXG4gIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gIHNldHRsZWQgc3RhdGUuICBTbyBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2lsbFxuICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgQmFzaWMgVXNhZ2U6XG4gIC0tLS0tLS0tLS0tLVxuXG4gIGBgYGpzXG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgLy8gb24gc3VjY2Vzc1xuICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgLy8gb24gZmFpbHVyZVxuICAgIHJlamVjdChyZWFzb24pO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIEFkdmFuY2VkIFVzYWdlOlxuICAtLS0tLS0tLS0tLS0tLS1cblxuICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gIGBYTUxIdHRwUmVxdWVzdGBzLlxuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGhhbmRsZXI7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignZ2V0SlNPTjogYCcgKyB1cmwgKyAnYCBmYWlsZWQgd2l0aCBzdGF0dXM6IFsnICsgdGhpcy5zdGF0dXMgKyAnXScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBnZXRKU09OKCcvcG9zdHMuanNvbicpLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIC8vIG9uIHJlamVjdGlvblxuICB9KTtcbiAgYGBgXG5cbiAgVW5saWtlIGNhbGxiYWNrcywgcHJvbWlzZXMgYXJlIGdyZWF0IGNvbXBvc2FibGUgcHJpbWl0aXZlcy5cblxuICBgYGBqc1xuICBQcm9taXNlLmFsbChbXG4gICAgZ2V0SlNPTignL3Bvc3RzJyksXG4gICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgIHZhbHVlc1swXSAvLyA9PiBwb3N0c0pTT05cbiAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9KTtcbiAgYGBgXG5cbiAgQGNsYXNzIFByb21pc2VcbiAgQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZXJcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAY29uc3RydWN0b3JcbiovXG5cbnZhciBQcm9taXNlJDEgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgICB0aGlzW1BST01JU0VfSURdID0gbmV4dElkKCk7XG4gICAgdGhpcy5fcmVzdWx0ID0gdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgIGlmIChub29wICE9PSByZXNvbHZlcikge1xuICAgICAgdHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nICYmIG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgIHRoaXMgaW5zdGFuY2VvZiBQcm9taXNlID8gaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbmVlZHNOZXcoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gIHdoaWNoIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlXG4gIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gIH0pO1xuICBgYGBcbiAgIENoYWluaW5nXG4gIC0tLS0tLS0tXG4gICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZmlyc3QgcHJvbWlzZSdzIGZ1bGZpbGxtZW50XG4gIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAvLyBJZiBgZmluZFVzZXJgIGZ1bGZpbGxlZCwgYHVzZXJOYW1lYCB3aWxsIGJlIHRoZSB1c2VyJ3MgbmFtZSwgb3RoZXJ3aXNlIGl0XG4gICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gIH0pO1xuICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAvLyBJZiBgZmluZFVzZXJgIHJlamVjdGVkLCBgcmVhc29uYCB3aWxsIGJlICdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jy5cbiAgfSk7XG4gIGBgYFxuICBJZiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIGRvZXMgbm90IHNwZWNpZnkgYSByZWplY3Rpb24gaGFuZGxlciwgcmVqZWN0aW9uIHJlYXNvbnMgd2lsbCBiZSBwcm9wYWdhdGVkIGZ1cnRoZXIgZG93bnN0cmVhbS5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBuZXZlciByZWFjaGVkXG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgQXNzaW1pbGF0aW9uXG4gIC0tLS0tLS0tLS0tLVxuICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5LiBUaGlzIGNhbiBiZSBhY2hpZXZlZCBieSByZXR1cm5pbmcgYSBwcm9taXNlIGluIHRoZVxuICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gIH0pO1xuICBgYGBcbiAgIElmIHRoZSBhc3NpbWxpYXRlZCBwcm9taXNlIHJlamVjdHMsIHRoZW4gdGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIGFsc28gcmVqZWN0LlxuICAgYGBganNcbiAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgZnVsZmlsbHMsIHdlJ2xsIGhhdmUgdGhlIHZhbHVlIGhlcmVcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgfSk7XG4gIGBgYFxuICAgU2ltcGxlIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IHJlc3VsdDtcbiAgIHRyeSB7XG4gICAgcmVzdWx0ID0gZmluZFJlc3VsdCgpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyBmYWlsdXJlXG4gIH0pO1xuICBgYGBcbiAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgLS0tLS0tLS0tLS0tLS1cbiAgIFN5bmNocm9ub3VzIEV4YW1wbGVcbiAgIGBgYGphdmFzY3JpcHRcbiAgbGV0IGF1dGhvciwgYm9va3M7XG4gICB0cnkge1xuICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICBib29rcyAgPSBmaW5kQm9va3NCeUF1dGhvcihhdXRob3IpO1xuICAgIC8vIHN1Y2Nlc3NcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAvLyBmYWlsdXJlXG4gIH1cbiAgYGBgXG4gICBFcnJiYWNrIEV4YW1wbGVcbiAgIGBgYGpzXG4gICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG4gICB9XG4gICBmdW5jdGlvbiBmYWlsdXJlKHJlYXNvbikge1xuICAgfVxuICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgaWYgKGVycikge1xuICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgLy8gZmFpbHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmb3VuZEJvb2tzKGJvb2tzKTtcbiAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICB9XG4gICAgICAvLyBzdWNjZXNzXG4gICAgfVxuICB9KTtcbiAgYGBgXG4gICBQcm9taXNlIEV4YW1wbGU7XG4gICBgYGBqYXZhc2NyaXB0XG4gIGZpbmRBdXRob3IoKS5cbiAgICB0aGVuKGZpbmRCb29rc0J5QXV0aG9yKS5cbiAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgIC8vIGZvdW5kIGJvb2tzXG4gIH0pLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfSk7XG4gIGBgYFxuICAgQG1ldGhvZCB0aGVuXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uRnVsZmlsbGVkXG4gIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG4gIC8qKlxuICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG4gIGBgYGpzXG4gIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gIH1cbiAgLy8gc3luY2hyb25vdXNcbiAgdHJ5IHtcbiAgZmluZEF1dGhvcigpO1xuICB9IGNhdGNoKHJlYXNvbikge1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9XG4gIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgQG1ldGhvZCBjYXRjaFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICB9O1xuXG4gIC8qKlxuICAgIGBmaW5hbGx5YCB3aWxsIGJlIGludm9rZWQgcmVnYXJkbGVzcyBvZiB0aGUgcHJvbWlzZSdzIGZhdGUganVzdCBhcyBuYXRpdmVcbiAgICB0cnkvY2F0Y2gvZmluYWxseSBiZWhhdmVzXG4gIFxuICAgIFN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpIHtcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBdXRob3IoKTtcbiAgICB9XG4gIFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZmluZEF1dGhvcigpOyAvLyBzdWNjZWVkIG9yIGZhaWxcbiAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIGFsd2F5cyBydW5zXG4gICAgICAvLyBkb2Vzbid0IGFmZmVjdCB0aGUgcmV0dXJuIHZhbHVlXG4gICAgfVxuICAgIGBgYFxuICBcbiAgICBBc3luY2hyb25vdXMgZXhhbXBsZTpcbiAgXG4gICAgYGBganNcbiAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgIHJldHVybiBmaW5kT3RoZXJBdXRoZXIoKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uKCl7XG4gICAgICAvLyBhdXRob3Igd2FzIGVpdGhlciBmb3VuZCwgb3Igbm90XG4gICAgfSk7XG4gICAgYGBgXG4gIFxuICAgIEBtZXRob2QgZmluYWxseVxuICAgIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuXG4gIFByb21pc2UucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbiBfZmluYWxseShjYWxsYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwcm9taXNlLmNvbnN0cnVjdG9yO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihjYWxsYmFjaywgY2FsbGJhY2spO1xuICB9O1xuXG4gIHJldHVybiBQcm9taXNlO1xufSgpO1xuXG5Qcm9taXNlJDEucHJvdG90eXBlLnRoZW4gPSB0aGVuO1xuUHJvbWlzZSQxLmFsbCA9IGFsbDtcblByb21pc2UkMS5yYWNlID0gcmFjZTtcblByb21pc2UkMS5yZXNvbHZlID0gcmVzb2x2ZSQxO1xuUHJvbWlzZSQxLnJlamVjdCA9IHJlamVjdCQxO1xuUHJvbWlzZSQxLl9zZXRTY2hlZHVsZXIgPSBzZXRTY2hlZHVsZXI7XG5Qcm9taXNlJDEuX3NldEFzYXAgPSBzZXRBc2FwO1xuUHJvbWlzZSQxLl9hc2FwID0gYXNhcDtcblxuLypnbG9iYWwgc2VsZiovXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcbiAgdmFyIGxvY2FsID0gdm9pZCAwO1xuXG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2FsID0gc2VsZjtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgbG9jYWwgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIFAgPSBsb2NhbC5Qcm9taXNlO1xuXG4gIGlmIChQKSB7XG4gICAgdmFyIHByb21pc2VUb1N0cmluZyA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHByb21pc2VUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gc2lsZW50bHkgaWdub3JlZFxuICAgIH1cblxuICAgIGlmIChwcm9taXNlVG9TdHJpbmcgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbG9jYWwuUHJvbWlzZSA9IFByb21pc2UkMTtcbn1cblxuLy8gU3RyYW5nZSBjb21wYXQuLlxuUHJvbWlzZSQxLnBvbHlmaWxsID0gcG9seWZpbGw7XG5Qcm9taXNlJDEuUHJvbWlzZSA9IFByb21pc2UkMTtcblxucmV0dXJuIFByb21pc2UkMTtcblxufSkpKTtcblxuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzNi1wcm9taXNlLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbnZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheShhcnIpIHtcblx0aWYgKHR5cGVvZiBBcnJheS5pc0FycmF5ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKTtcblx0fVxuXG5cdHJldHVybiB0b1N0ci5jYWxsKGFycikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG5cdGlmICghb2JqIHx8IHRvU3RyLmNhbGwob2JqKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgaGFzT3duQ29uc3RydWN0b3IgPSBoYXNPd24uY2FsbChvYmosICdjb25zdHJ1Y3RvcicpO1xuXHR2YXIgaGFzSXNQcm90b3R5cGVPZiA9IG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IucHJvdG90eXBlICYmIGhhc093bi5jYWxsKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsICdpc1Byb3RvdHlwZU9mJyk7XG5cdC8vIE5vdCBvd24gY29uc3RydWN0b3IgcHJvcGVydHkgbXVzdCBiZSBPYmplY3Rcblx0aWYgKG9iai5jb25zdHJ1Y3RvciAmJiAhaGFzT3duQ29uc3RydWN0b3IgJiYgIWhhc0lzUHJvdG90eXBlT2YpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcblx0Ly8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uXG5cdHZhciBrZXk7XG5cdGZvciAoa2V5IGluIG9iaikgeyAvKiovIH1cblxuXHRyZXR1cm4gdHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcgfHwgaGFzT3duLmNhbGwob2JqLCBrZXkpO1xufTtcblxuLy8gSWYgbmFtZSBpcyAnX19wcm90b19fJywgYW5kIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBpcyBhdmFpbGFibGUsIGRlZmluZSBfX3Byb3RvX18gYXMgYW4gb3duIHByb3BlcnR5IG9uIHRhcmdldFxudmFyIHNldFByb3BlcnR5ID0gZnVuY3Rpb24gc2V0UHJvcGVydHkodGFyZ2V0LCBvcHRpb25zKSB7XG5cdGlmIChkZWZpbmVQcm9wZXJ0eSAmJiBvcHRpb25zLm5hbWUgPT09ICdfX3Byb3RvX18nKSB7XG5cdFx0ZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBvcHRpb25zLm5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHR2YWx1ZTogb3B0aW9ucy5uZXdWYWx1ZSxcblx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0dGFyZ2V0W29wdGlvbnMubmFtZV0gPSBvcHRpb25zLm5ld1ZhbHVlO1xuXHR9XG59O1xuXG4vLyBSZXR1cm4gdW5kZWZpbmVkIGluc3RlYWQgb2YgX19wcm90b19fIGlmICdfX3Byb3RvX18nIGlzIG5vdCBhbiBvd24gcHJvcGVydHlcbnZhciBnZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIGdldFByb3BlcnR5KG9iaiwgbmFtZSkge1xuXHRpZiAobmFtZSA9PT0gJ19fcHJvdG9fXycpIHtcblx0XHRpZiAoIWhhc093bi5jYWxsKG9iaiwgbmFtZSkpIHtcblx0XHRcdHJldHVybiB2b2lkIDA7XG5cdFx0fSBlbHNlIGlmIChnT1BEKSB7XG5cdFx0XHQvLyBJbiBlYXJseSB2ZXJzaW9ucyBvZiBub2RlLCBvYmpbJ19fcHJvdG9fXyddIGlzIGJ1Z2d5IHdoZW4gb2JqIGhhc1xuXHRcdFx0Ly8gX19wcm90b19fIGFzIGFuIG93biBwcm9wZXJ0eS4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcigpIHdvcmtzLlxuXHRcdFx0cmV0dXJuIGdPUEQob2JqLCBuYW1lKS52YWx1ZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb2JqW25hbWVdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHRlbmQoKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZTtcblx0dmFyIHRhcmdldCA9IGFyZ3VtZW50c1swXTtcblx0dmFyIGkgPSAxO1xuXHR2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblx0dmFyIGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnYm9vbGVhbicpIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcblx0XHQvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0aSA9IDI7XG5cdH1cblx0aWYgKHRhcmdldCA9PSBudWxsIHx8ICh0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nKSkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Zm9yICg7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbaV07XG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmIChvcHRpb25zICE9IG51bGwpIHtcblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAobmFtZSBpbiBvcHRpb25zKSB7XG5cdFx0XHRcdHNyYyA9IGdldFByb3BlcnR5KHRhcmdldCwgbmFtZSk7XG5cdFx0XHRcdGNvcHkgPSBnZXRQcm9wZXJ0eShvcHRpb25zLCBuYW1lKTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICh0YXJnZXQgIT09IGNvcHkpIHtcblx0XHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0XHRpZiAoZGVlcCAmJiBjb3B5ICYmIChpc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IGlzQXJyYXkoY29weSkpKSkge1xuXHRcdFx0XHRcdFx0aWYgKGNvcHlJc0FycmF5KSB7XG5cdFx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdFx0c2V0UHJvcGVydHkodGFyZ2V0LCB7IG5hbWU6IG5hbWUsIG5ld1ZhbHVlOiBleHRlbmQoZGVlcCwgY2xvbmUsIGNvcHkpIH0pO1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGNvcHkgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0XHRzZXRQcm9wZXJ0eSh0YXJnZXQsIHsgbmFtZTogbmFtZSwgbmV3VmFsdWU6IGNvcHkgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzU2hhbGxvd0VxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZVxuICBmb3IgKHZhciBpIGluIGEpIGlmICghKGkgaW4gYikpIHJldHVybiBmYWxzZVxuICBmb3IgKHZhciBpIGluIGIpIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIHRydWVcbn1cbiIsIi8qXG4gKiAgYmFzZTY0LmpzXG4gKlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBCU0QgMy1DbGF1c2UgTGljZW5zZS5cbiAqICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiAgUmVmZXJlbmNlczpcbiAqICAgIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0XG4gKi9cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShnbG9iYWwpXG4gICAgICAgIDogdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kXG4gICAgICAgID8gZGVmaW5lKGZhY3RvcnkpIDogZmFjdG9yeShnbG9iYWwpXG59KChcbiAgICB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmXG4gICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3dcbiAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFxuOiB0aGlzXG4pLCBmdW5jdGlvbihnbG9iYWwpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gZXhpc3RpbmcgdmVyc2lvbiBmb3Igbm9Db25mbGljdCgpXG4gICAgZ2xvYmFsID0gZ2xvYmFsIHx8IHt9O1xuICAgIHZhciBfQmFzZTY0ID0gZ2xvYmFsLkJhc2U2NDtcbiAgICB2YXIgdmVyc2lvbiA9IFwiMi41LjFcIjtcbiAgICAvLyBpZiBub2RlLmpzIGFuZCBOT1QgUmVhY3QgTmF0aXZlLCB3ZSB1c2UgQnVmZmVyXG4gICAgdmFyIGJ1ZmZlcjtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGV2YWwoXCJyZXF1aXJlKCdidWZmZXInKS5CdWZmZXJcIik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgYnVmZmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnN0YW50c1xuICAgIHZhciBiNjRjaGFyc1xuICAgICAgICA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgICB2YXIgYjY0dGFiID0gZnVuY3Rpb24oYmluKSB7XG4gICAgICAgIHZhciB0ID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYmluLmxlbmd0aDsgaSA8IGw7IGkrKykgdFtiaW4uY2hhckF0KGkpXSA9IGk7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH0oYjY0Y2hhcnMpO1xuICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICAgIC8vIGVuY29kZXIgc3R1ZmZcbiAgICB2YXIgY2JfdXRvYiA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgaWYgKGMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdmFyIGNjID0gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgcmV0dXJuIGNjIDwgMHg4MCA/IGNcbiAgICAgICAgICAgICAgICA6IGNjIDwgMHg4MDAgPyAoZnJvbUNoYXJDb2RlKDB4YzAgfCAoY2MgPj4+IDYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKGNjICYgMHgzZikpKVxuICAgICAgICAgICAgICAgIDogKGZyb21DaGFyQ29kZSgweGUwIHwgKChjYyA+Pj4gMTIpICYgMHgwZikpXG4gICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICgoY2MgPj4+ICA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoIGNjICAgICAgICAgJiAweDNmKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNjID0gMHgxMDAwMFxuICAgICAgICAgICAgICAgICsgKGMuY2hhckNvZGVBdCgwKSAtIDB4RDgwMCkgKiAweDQwMFxuICAgICAgICAgICAgICAgICsgKGMuY2hhckNvZGVBdCgxKSAtIDB4REMwMCk7XG4gICAgICAgICAgICByZXR1cm4gKGZyb21DaGFyQ29kZSgweGYwIHwgKChjYyA+Pj4gMTgpICYgMHgwNykpXG4gICAgICAgICAgICAgICAgICAgICsgZnJvbUNoYXJDb2RlKDB4ODAgfCAoKGNjID4+PiAxMikgJiAweDNmKSlcbiAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoMHg4MCB8ICgoY2MgPj4+ICA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICAgICArIGZyb21DaGFyQ29kZSgweDgwIHwgKCBjYyAgICAgICAgICYgMHgzZikpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlX3V0b2IgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGRl18W15cXHgwMC1cXHg3Rl0vZztcbiAgICB2YXIgdXRvYiA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIHUucmVwbGFjZShyZV91dG9iLCBjYl91dG9iKTtcbiAgICB9O1xuICAgIHZhciBjYl9lbmNvZGUgPSBmdW5jdGlvbihjY2MpIHtcbiAgICAgICAgdmFyIHBhZGxlbiA9IFswLCAyLCAxXVtjY2MubGVuZ3RoICUgM10sXG4gICAgICAgIG9yZCA9IGNjYy5jaGFyQ29kZUF0KDApIDw8IDE2XG4gICAgICAgICAgICB8ICgoY2NjLmxlbmd0aCA+IDEgPyBjY2MuY2hhckNvZGVBdCgxKSA6IDApIDw8IDgpXG4gICAgICAgICAgICB8ICgoY2NjLmxlbmd0aCA+IDIgPyBjY2MuY2hhckNvZGVBdCgyKSA6IDApKSxcbiAgICAgICAgY2hhcnMgPSBbXG4gICAgICAgICAgICBiNjRjaGFycy5jaGFyQXQoIG9yZCA+Pj4gMTgpLFxuICAgICAgICAgICAgYjY0Y2hhcnMuY2hhckF0KChvcmQgPj4+IDEyKSAmIDYzKSxcbiAgICAgICAgICAgIHBhZGxlbiA+PSAyID8gJz0nIDogYjY0Y2hhcnMuY2hhckF0KChvcmQgPj4+IDYpICYgNjMpLFxuICAgICAgICAgICAgcGFkbGVuID49IDEgPyAnPScgOiBiNjRjaGFycy5jaGFyQXQob3JkICYgNjMpXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICB9O1xuICAgIHZhciBidG9hID0gZ2xvYmFsLmJ0b2EgPyBmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWwuYnRvYShiKTtcbiAgICB9IDogZnVuY3Rpb24oYikge1xuICAgICAgICByZXR1cm4gYi5yZXBsYWNlKC9bXFxzXFxTXXsxLDN9L2csIGNiX2VuY29kZSk7XG4gICAgfTtcbiAgICB2YXIgX2VuY29kZSA9IGJ1ZmZlciA/XG4gICAgICAgIGJ1ZmZlci5mcm9tICYmIFVpbnQ4QXJyYXkgJiYgYnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbVxuICAgICAgICA/IGZ1bmN0aW9uICh1KSB7XG4gICAgICAgICAgICByZXR1cm4gKHUuY29uc3RydWN0b3IgPT09IGJ1ZmZlci5jb25zdHJ1Y3RvciA/IHUgOiBidWZmZXIuZnJvbSh1KSlcbiAgICAgICAgICAgICAgICAudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICAgIH1cbiAgICAgICAgOiAgZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgICAgIHJldHVybiAodS5jb25zdHJ1Y3RvciA9PT0gYnVmZmVyLmNvbnN0cnVjdG9yID8gdSA6IG5ldyAgYnVmZmVyKHUpKVxuICAgICAgICAgICAgICAgIC50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uICh1KSB7IHJldHVybiBidG9hKHV0b2IodSkpIH1cbiAgICA7XG4gICAgdmFyIGVuY29kZSA9IGZ1bmN0aW9uKHUsIHVyaXNhZmUpIHtcbiAgICAgICAgcmV0dXJuICF1cmlzYWZlXG4gICAgICAgICAgICA/IF9lbmNvZGUoU3RyaW5nKHUpKVxuICAgICAgICAgICAgOiBfZW5jb2RlKFN0cmluZyh1KSkucmVwbGFjZSgvWytcXC9dL2csIGZ1bmN0aW9uKG0wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG0wID09ICcrJyA/ICctJyA6ICdfJztcbiAgICAgICAgICAgIH0pLnJlcGxhY2UoLz0vZywgJycpO1xuICAgIH07XG4gICAgdmFyIGVuY29kZVVSSSA9IGZ1bmN0aW9uKHUpIHsgcmV0dXJuIGVuY29kZSh1LCB0cnVlKSB9O1xuICAgIC8vIGRlY29kZXIgc3R1ZmZcbiAgICB2YXIgcmVfYnRvdSA9IG5ldyBSZWdFeHAoW1xuICAgICAgICAnW1xceEMwLVxceERGXVtcXHg4MC1cXHhCRl0nLFxuICAgICAgICAnW1xceEUwLVxceEVGXVtcXHg4MC1cXHhCRl17Mn0nLFxuICAgICAgICAnW1xceEYwLVxceEY3XVtcXHg4MC1cXHhCRl17M30nXG4gICAgXS5qb2luKCd8JyksICdnJyk7XG4gICAgdmFyIGNiX2J0b3UgPSBmdW5jdGlvbihjY2NjKSB7XG4gICAgICAgIHN3aXRjaChjY2NjLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB2YXIgY3AgPSAoKDB4MDcgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDE4KVxuICAgICAgICAgICAgICAgIHwgICAgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKSA8PCAxMilcbiAgICAgICAgICAgICAgICB8ICAgICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgyKSkgPDwgIDYpXG4gICAgICAgICAgICAgICAgfCAgICAgKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMykpLFxuICAgICAgICAgICAgb2Zmc2V0ID0gY3AgLSAweDEwMDAwO1xuICAgICAgICAgICAgcmV0dXJuIChmcm9tQ2hhckNvZGUoKG9mZnNldCAgPj4+IDEwKSArIDB4RDgwMClcbiAgICAgICAgICAgICAgICAgICAgKyBmcm9tQ2hhckNvZGUoKG9mZnNldCAmIDB4M0ZGKSArIDB4REMwMCkpO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gZnJvbUNoYXJDb2RlKFxuICAgICAgICAgICAgICAgICgoMHgwZiAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgMTIpXG4gICAgICAgICAgICAgICAgICAgIHwgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKSA8PCA2KVxuICAgICAgICAgICAgICAgICAgICB8ICAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgyKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gIGZyb21DaGFyQ29kZShcbiAgICAgICAgICAgICAgICAoKDB4MWYgJiBjY2NjLmNoYXJDb2RlQXQoMCkpIDw8IDYpXG4gICAgICAgICAgICAgICAgICAgIHwgICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGJ0b3UgPSBmdW5jdGlvbihiKSB7XG4gICAgICAgIHJldHVybiBiLnJlcGxhY2UocmVfYnRvdSwgY2JfYnRvdSk7XG4gICAgfTtcbiAgICB2YXIgY2JfZGVjb2RlID0gZnVuY3Rpb24oY2NjYykge1xuICAgICAgICB2YXIgbGVuID0gY2NjYy5sZW5ndGgsXG4gICAgICAgIHBhZGxlbiA9IGxlbiAlIDQsXG4gICAgICAgIG4gPSAobGVuID4gMCA/IGI2NHRhYltjY2NjLmNoYXJBdCgwKV0gPDwgMTggOiAwKVxuICAgICAgICAgICAgfCAobGVuID4gMSA/IGI2NHRhYltjY2NjLmNoYXJBdCgxKV0gPDwgMTIgOiAwKVxuICAgICAgICAgICAgfCAobGVuID4gMiA/IGI2NHRhYltjY2NjLmNoYXJBdCgyKV0gPDwgIDYgOiAwKVxuICAgICAgICAgICAgfCAobGVuID4gMyA/IGI2NHRhYltjY2NjLmNoYXJBdCgzKV0gICAgICAgOiAwKSxcbiAgICAgICAgY2hhcnMgPSBbXG4gICAgICAgICAgICBmcm9tQ2hhckNvZGUoIG4gPj4+IDE2KSxcbiAgICAgICAgICAgIGZyb21DaGFyQ29kZSgobiA+Pj4gIDgpICYgMHhmZiksXG4gICAgICAgICAgICBmcm9tQ2hhckNvZGUoIG4gICAgICAgICAmIDB4ZmYpXG4gICAgICAgIF07XG4gICAgICAgIGNoYXJzLmxlbmd0aCAtPSBbMCwgMCwgMiwgMV1bcGFkbGVuXTtcbiAgICAgICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xuICAgIH07XG4gICAgdmFyIF9hdG9iID0gZ2xvYmFsLmF0b2IgPyBmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWwuYXRvYihhKTtcbiAgICB9IDogZnVuY3Rpb24oYSl7XG4gICAgICAgIHJldHVybiBhLnJlcGxhY2UoL1xcU3sxLDR9L2csIGNiX2RlY29kZSk7XG4gICAgfTtcbiAgICB2YXIgYXRvYiA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcmV0dXJuIF9hdG9iKFN0cmluZyhhKS5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL10vZywgJycpKTtcbiAgICB9O1xuICAgIHZhciBfZGVjb2RlID0gYnVmZmVyID9cbiAgICAgICAgYnVmZmVyLmZyb20gJiYgVWludDhBcnJheSAmJiBidWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tXG4gICAgICAgID8gZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgcmV0dXJuIChhLmNvbnN0cnVjdG9yID09PSBidWZmZXIuY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgPyBhIDogYnVmZmVyLmZyb20oYSwgJ2Jhc2U2NCcpKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgcmV0dXJuIChhLmNvbnN0cnVjdG9yID09PSBidWZmZXIuY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgPyBhIDogbmV3IGJ1ZmZlcihhLCAnYmFzZTY0JykpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbihhKSB7IHJldHVybiBidG91KF9hdG9iKGEpKSB9O1xuICAgIHZhciBkZWNvZGUgPSBmdW5jdGlvbihhKXtcbiAgICAgICAgcmV0dXJuIF9kZWNvZGUoXG4gICAgICAgICAgICBTdHJpbmcoYSkucmVwbGFjZSgvWy1fXS9nLCBmdW5jdGlvbihtMCkgeyByZXR1cm4gbTAgPT0gJy0nID8gJysnIDogJy8nIH0pXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXS9nLCAnJylcbiAgICAgICAgKTtcbiAgICB9O1xuICAgIHZhciBub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBCYXNlNjQgPSBnbG9iYWwuQmFzZTY0O1xuICAgICAgICBnbG9iYWwuQmFzZTY0ID0gX0Jhc2U2NDtcbiAgICAgICAgcmV0dXJuIEJhc2U2NDtcbiAgICB9O1xuICAgIC8vIGV4cG9ydCBCYXNlNjRcbiAgICBnbG9iYWwuQmFzZTY0ID0ge1xuICAgICAgICBWRVJTSU9OOiB2ZXJzaW9uLFxuICAgICAgICBhdG9iOiBhdG9iLFxuICAgICAgICBidG9hOiBidG9hLFxuICAgICAgICBmcm9tQmFzZTY0OiBkZWNvZGUsXG4gICAgICAgIHRvQmFzZTY0OiBlbmNvZGUsXG4gICAgICAgIHV0b2I6IHV0b2IsXG4gICAgICAgIGVuY29kZTogZW5jb2RlLFxuICAgICAgICBlbmNvZGVVUkk6IGVuY29kZVVSSSxcbiAgICAgICAgYnRvdTogYnRvdSxcbiAgICAgICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgICAgIG5vQ29uZmxpY3Q6IG5vQ29uZmxpY3QsXG4gICAgICAgIF9fYnVmZmVyX186IGJ1ZmZlclxuICAgIH07XG4gICAgLy8gaWYgRVM1IGlzIGF2YWlsYWJsZSwgbWFrZSBCYXNlNjQuZXh0ZW5kU3RyaW5nKCkgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIG5vRW51bSA9IGZ1bmN0aW9uKHYpe1xuICAgICAgICAgICAgcmV0dXJuIHt2YWx1ZTp2LGVudW1lcmFibGU6ZmFsc2Usd3JpdGFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZX07XG4gICAgICAgIH07XG4gICAgICAgIGdsb2JhbC5CYXNlNjQuZXh0ZW5kU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgICAgIFN0cmluZy5wcm90b3R5cGUsICdmcm9tQmFzZTY0Jywgbm9FbnVtKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZSh0aGlzKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICBTdHJpbmcucHJvdG90eXBlLCAndG9CYXNlNjQnLCBub0VudW0oZnVuY3Rpb24gKHVyaXNhZmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZSh0aGlzLCB1cmlzYWZlKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICBTdHJpbmcucHJvdG90eXBlLCAndG9CYXNlNjRVUkknLCBub0VudW0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlKHRoaXMsIHRydWUpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvL1xuICAgIC8vIGV4cG9ydCBCYXNlNjQgdG8gdGhlIG5hbWVzcGFjZVxuICAgIC8vXG4gICAgaWYgKGdsb2JhbFsnTWV0ZW9yJ10pIHsgLy8gTWV0ZW9yLmpzXG4gICAgICAgIEJhc2U2NCA9IGdsb2JhbC5CYXNlNjQ7XG4gICAgfVxuICAgIC8vIG1vZHVsZS5leHBvcnRzIGFuZCBBTUQgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS5cbiAgICAvLyBtb2R1bGUuZXhwb3J0cyBoYXMgcHJlY2VkZW5jZS5cbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMuQmFzZTY0ID0gZ2xvYmFsLkJhc2U2NDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbigpeyByZXR1cm4gZ2xvYmFsLkJhc2U2NCB9KTtcbiAgICB9XG4gICAgLy8gdGhhdCdzIGl0IVxuICAgIHJldHVybiB7QmFzZTY0OiBnbG9iYWwuQmFzZTY0fVxufSkpO1xuIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICByZXN1bHQgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICByZXR1cm4gbWF4aW5nID8gbmF0aXZlTWluKHJlc3VsdCwgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgfVxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xuIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBEYXRlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAqIH0sIF8ubm93KCkpO1xuICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAqL1xudmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICByZXN1bHQgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICByZXR1cm4gbWF4aW5nID8gbmF0aXZlTWluKHJlc3VsdCwgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgfVxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICpcbiAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRocm90dGxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhcmVJbnB1dHNFcXVhbChuZXdJbnB1dHMsIGxhc3RJbnB1dHMpIHtcbiAgICBpZiAobmV3SW5wdXRzLmxlbmd0aCAhPT0gbGFzdElucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0lucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobmV3SW5wdXRzW2ldICE9PSBsYXN0SW5wdXRzW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG1lbW9pemVPbmUocmVzdWx0Rm4sIGlzRXF1YWwpIHtcbiAgICBpZiAoaXNFcXVhbCA9PT0gdm9pZCAwKSB7IGlzRXF1YWwgPSBhcmVJbnB1dHNFcXVhbDsgfVxuICAgIHZhciBsYXN0VGhpcztcbiAgICB2YXIgbGFzdEFyZ3MgPSBbXTtcbiAgICB2YXIgbGFzdFJlc3VsdDtcbiAgICB2YXIgY2FsbGVkT25jZSA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIG1lbW9pemVkKCkge1xuICAgICAgICB2YXIgbmV3QXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbmV3QXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsZWRPbmNlICYmIGxhc3RUaGlzID09PSB0aGlzICYmIGlzRXF1YWwobmV3QXJncywgbGFzdEFyZ3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UmVzdWx0ID0gcmVzdWx0Rm4uYXBwbHkodGhpcywgbmV3QXJncyk7XG4gICAgICAgIGNhbGxlZE9uY2UgPSB0cnVlO1xuICAgICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICAgIGxhc3RBcmdzID0gbmV3QXJncztcbiAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBtZW1vaXplZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplT25lO1xuIiwidmFyIHdpbGRjYXJkID0gcmVxdWlyZSgnd2lsZGNhcmQnKTtcbnZhciByZU1pbWVQYXJ0U3BsaXQgPSAvW1xcL1xcK1xcLl0vO1xuXG4vKipcbiAgIyBtaW1lLW1hdGNoXG5cbiAgQSBzaW1wbGUgZnVuY3Rpb24gdG8gY2hlY2tlciB3aGV0aGVyIGEgdGFyZ2V0IG1pbWUgdHlwZSBtYXRjaGVzIGEgbWltZS10eXBlXG4gIHBhdHRlcm4gKGUuZy4gaW1hZ2UvanBlZyBtYXRjaGVzIGltYWdlL2pwZWcgT1IgaW1hZ2UvKikuXG5cbiAgIyMgRXhhbXBsZSBVc2FnZVxuXG4gIDw8PCBleGFtcGxlLmpzXG5cbioqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIHBhdHRlcm4pIHtcbiAgZnVuY3Rpb24gdGVzdChwYXR0ZXJuKSB7XG4gICAgdmFyIHJlc3VsdCA9IHdpbGRjYXJkKHBhdHRlcm4sIHRhcmdldCwgcmVNaW1lUGFydFNwbGl0KTtcblxuICAgIC8vIGVuc3VyZSB0aGF0IHdlIGhhdmUgYSB2YWxpZCBtaW1lIHR5cGUgKHNob3VsZCBoYXZlIHR3byBwYXJ0cylcbiAgICByZXR1cm4gcmVzdWx0ICYmIHJlc3VsdC5sZW5ndGggPj0gMjtcbiAgfVxuXG4gIHJldHVybiBwYXR0ZXJuID8gdGVzdChwYXR0ZXJuLnNwbGl0KCc7JylbMF0pIDogdGVzdDtcbn07XG4iLCIvKipcbiogQ3JlYXRlIGFuIGV2ZW50IGVtaXR0ZXIgd2l0aCBuYW1lc3BhY2VzXG4qIEBuYW1lIGNyZWF0ZU5hbWVzcGFjZUVtaXR0ZXJcbiogQGV4YW1wbGVcbiogdmFyIGVtaXR0ZXIgPSByZXF1aXJlKCcuL2luZGV4JykoKVxuKlxuKiBlbWl0dGVyLm9uKCcqJywgZnVuY3Rpb24gKCkge1xuKiAgIGNvbnNvbGUubG9nKCdhbGwgZXZlbnRzIGVtaXR0ZWQnLCB0aGlzLmV2ZW50KVxuKiB9KVxuKlxuKiBlbWl0dGVyLm9uKCdleGFtcGxlJywgZnVuY3Rpb24gKCkge1xuKiAgIGNvbnNvbGUubG9nKCdleGFtcGxlIGV2ZW50IGVtaXR0ZWQnKVxuKiB9KVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlTmFtZXNwYWNlRW1pdHRlciAoKSB7XG4gIHZhciBlbWl0dGVyID0ge31cbiAgdmFyIF9mbnMgPSBlbWl0dGVyLl9mbnMgPSB7fVxuXG4gIC8qKlxuICAqIEVtaXQgYW4gZXZlbnQuIE9wdGlvbmFsbHkgbmFtZXNwYWNlIHRoZSBldmVudC4gSGFuZGxlcnMgYXJlIGZpcmVkIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHdlcmUgYWRkZWQgd2l0aCBleGFjdCBtYXRjaGVzIHRha2luZyBwcmVjZWRlbmNlLiBTZXBhcmF0ZSB0aGUgbmFtZXNwYWNlIGFuZCBldmVudCB3aXRoIGEgYDpgXG4gICogQG5hbWUgZW1pdFxuICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCDigJMgdGhlIG5hbWUgb2YgdGhlIGV2ZW50LCB3aXRoIG9wdGlvbmFsIG5hbWVzcGFjZVxuICAqIEBwYXJhbSB7Li4uKn0gZGF0YSDigJMgdXAgdG8gNiBhcmd1bWVudHMgdGhhdCBhcmUgcGFzc2VkIHRvIHRoZSBldmVudCBsaXN0ZW5lclxuICAqIEBleGFtcGxlXG4gICogZW1pdHRlci5lbWl0KCdleGFtcGxlJylcbiAgKiBlbWl0dGVyLmVtaXQoJ2RlbW86dGVzdCcpXG4gICogZW1pdHRlci5lbWl0KCdkYXRhJywgeyBleGFtcGxlOiB0cnVlfSwgJ2Egc3RyaW5nJywgMSlcbiAgKi9cbiAgZW1pdHRlci5lbWl0ID0gZnVuY3Rpb24gZW1pdCAoZXZlbnQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUsIGFyZzYpIHtcbiAgICB2YXIgdG9FbWl0ID0gZ2V0TGlzdGVuZXJzKGV2ZW50KVxuXG4gICAgaWYgKHRvRW1pdC5sZW5ndGgpIHtcbiAgICAgIGVtaXRBbGwoZXZlbnQsIHRvRW1pdCwgW2FyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUsIGFyZzZdKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAqIENyZWF0ZSBlbiBldmVudCBsaXN0ZW5lci5cbiAgKiBAbmFtZSBvblxuICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICogQGV4YW1wbGVcbiAgKiBlbWl0dGVyLm9uKCdleGFtcGxlJywgZnVuY3Rpb24gKCkge30pXG4gICogZW1pdHRlci5vbignZGVtbycsIGZ1bmN0aW9uICgpIHt9KVxuICAqL1xuICBlbWl0dGVyLm9uID0gZnVuY3Rpb24gb24gKGV2ZW50LCBmbikge1xuICAgIGlmICghX2Zuc1tldmVudF0pIHtcbiAgICAgIF9mbnNbZXZlbnRdID0gW11cbiAgICB9XG5cbiAgICBfZm5zW2V2ZW50XS5wdXNoKGZuKVxuICB9XG5cbiAgLyoqXG4gICogQ3JlYXRlIGVuIGV2ZW50IGxpc3RlbmVyIHRoYXQgZmlyZXMgb25jZS5cbiAgKiBAbmFtZSBvbmNlXG4gICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgKiBAZXhhbXBsZVxuICAqIGVtaXR0ZXIub25jZSgnZXhhbXBsZScsIGZ1bmN0aW9uICgpIHt9KVxuICAqIGVtaXR0ZXIub25jZSgnZGVtbycsIGZ1bmN0aW9uICgpIHt9KVxuICAqL1xuICBlbWl0dGVyLm9uY2UgPSBmdW5jdGlvbiBvbmNlIChldmVudCwgZm4pIHtcbiAgICBmdW5jdGlvbiBvbmUgKCkge1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgZW1pdHRlci5vZmYoZXZlbnQsIG9uZSlcbiAgICB9XG4gICAgdGhpcy5vbihldmVudCwgb25lKVxuICB9XG5cbiAgLyoqXG4gICogU3RvcCBsaXN0ZW5pbmcgdG8gYW4gZXZlbnQuIFN0b3AgYWxsIGxpc3RlbmVycyBvbiBhbiBldmVudCBieSBvbmx5IHBhc3NpbmcgdGhlIGV2ZW50IG5hbWUuIFN0b3AgYSBzaW5nbGUgbGlzdGVuZXIgYnkgcGFzc2luZyB0aGF0IGV2ZW50IGhhbmRsZXIgYXMgYSBjYWxsYmFjay5cbiAgKiBZb3UgbXVzdCBiZSBleHBsaWNpdCBhYm91dCB3aGF0IHdpbGwgYmUgdW5zdWJzY3JpYmVkOiBgZW1pdHRlci5vZmYoJ2RlbW8nKWAgd2lsbCB1bnN1YnNjcmliZSBhbiBgZW1pdHRlci5vbignZGVtbycpYCBsaXN0ZW5lcixcbiAgKiBgZW1pdHRlci5vZmYoJ2RlbW86ZXhhbXBsZScpYCB3aWxsIHVuc3Vic2NyaWJlIGFuIGBlbWl0dGVyLm9uKCdkZW1vOmV4YW1wbGUnKWAgbGlzdGVuZXJcbiAgKiBAbmFtZSBvZmZcbiAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIOKAkyB0aGUgc3BlY2lmaWMgaGFuZGxlclxuICAqIEBleGFtcGxlXG4gICogZW1pdHRlci5vZmYoJ2V4YW1wbGUnKVxuICAqIGVtaXR0ZXIub2ZmKCdkZW1vJywgZnVuY3Rpb24gKCkge30pXG4gICovXG4gIGVtaXR0ZXIub2ZmID0gZnVuY3Rpb24gb2ZmIChldmVudCwgZm4pIHtcbiAgICB2YXIga2VlcCA9IFtdXG5cbiAgICBpZiAoZXZlbnQgJiYgZm4pIHtcbiAgICAgIHZhciBmbnMgPSB0aGlzLl9mbnNbZXZlbnRdXG4gICAgICB2YXIgaSA9IDBcbiAgICAgIHZhciBsID0gZm5zID8gZm5zLmxlbmd0aCA6IDBcblxuICAgICAgZm9yIChpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChmbnNbaV0gIT09IGZuKSB7XG4gICAgICAgICAga2VlcC5wdXNoKGZuc1tpXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGtlZXAubGVuZ3RoID8gdGhpcy5fZm5zW2V2ZW50XSA9IGtlZXAgOiBkZWxldGUgdGhpcy5fZm5zW2V2ZW50XVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGlzdGVuZXJzIChlKSB7XG4gICAgdmFyIG91dCA9IF9mbnNbZV0gPyBfZm5zW2VdIDogW11cbiAgICB2YXIgaWR4ID0gZS5pbmRleE9mKCc6JylcbiAgICB2YXIgYXJncyA9IChpZHggPT09IC0xKSA/IFtlXSA6IFtlLnN1YnN0cmluZygwLCBpZHgpLCBlLnN1YnN0cmluZyhpZHggKyAxKV1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoX2ZucylcbiAgICB2YXIgaSA9IDBcbiAgICB2YXIgbCA9IGtleXMubGVuZ3RoXG5cbiAgICBmb3IgKGk7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldXG4gICAgICBpZiAoa2V5ID09PSAnKicpIHtcbiAgICAgICAgb3V0ID0gb3V0LmNvbmNhdChfZm5zW2tleV0pXG4gICAgICB9XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMiAmJiBhcmdzWzBdID09PSBrZXkpIHtcbiAgICAgICAgb3V0ID0gb3V0LmNvbmNhdChfZm5zW2tleV0pXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdEFsbCAoZSwgZm5zLCBhcmdzKSB7XG4gICAgdmFyIGkgPSAwXG4gICAgdmFyIGwgPSBmbnMubGVuZ3RoXG5cbiAgICBmb3IgKGk7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICghZm5zW2ldKSBicmVha1xuICAgICAgZm5zW2ldLmV2ZW50ID0gZVxuICAgICAgZm5zW2ldLmFwcGx5KGZuc1tpXSwgYXJncylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW1pdHRlclxufVxuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3ByZWFjdCcpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ3ByZWFjdCddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwuUHJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwID0gZmFjdG9yeShnbG9iYWwucHJlYWN0KSk7XG59KHRoaXMsIChmdW5jdGlvbiAocHJlYWN0KSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZ2V0S2V5KHZub2RlKSB7XG5cdHJldHVybiB2bm9kZS5hdHRyaWJ1dGVzICYmIHZub2RlLmF0dHJpYnV0ZXMua2V5O1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnRCYXNlKGNvbXBvbmVudCkge1xuXHRyZXR1cm4gY29tcG9uZW50LmJhc2U7XG59XG5cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuXHRyZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW5bMF07XG59XG5cbmZ1bmN0aW9uIGZpbHRlck51bGxDaGlsZHJlbihjaGlsZHJlbikge1xuXHRyZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG5cdFx0cmV0dXJuIGkgIT09IG51bGw7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBmaW5kKGFyciwgaXRlcikge1xuXHRmb3IgKHZhciBpID0gYXJyLmxlbmd0aDsgaS0tOykge1xuXHRcdGlmIChpdGVyKGFycltpXSkpIHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaW5DaGlsZHJlbkJ5S2V5KGNoaWxkcmVuLCBrZXkpIHtcblx0cmV0dXJuIGZpbmQoY2hpbGRyZW4sIGZ1bmN0aW9uIChjKSB7XG5cdFx0cmV0dXJuIGdldEtleShjKSA9PT0ga2V5O1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gaW5DaGlsZHJlbihjaGlsZHJlbiwgY2hpbGQpIHtcblx0cmV0dXJuIGluQ2hpbGRyZW5CeUtleShjaGlsZHJlbiwgZ2V0S2V5KGNoaWxkKSk7XG59XG5cbmZ1bmN0aW9uIGlzU2hvd25JbkNoaWxkcmVuQnlLZXkoY2hpbGRyZW4sIGtleSwgc2hvd1Byb3ApIHtcblx0cmV0dXJuIGZpbmQoY2hpbGRyZW4sIGZ1bmN0aW9uIChjKSB7XG5cdFx0cmV0dXJuIGdldEtleShjKSA9PT0ga2V5ICYmIGMucHJvcHNbc2hvd1Byb3BdO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gaXNTaG93bkluQ2hpbGRyZW4oY2hpbGRyZW4sIGNoaWxkLCBzaG93UHJvcCkge1xuXHRyZXR1cm4gaXNTaG93bkluQ2hpbGRyZW5CeUtleShjaGlsZHJlbiwgZ2V0S2V5KGNoaWxkKSwgc2hvd1Byb3ApO1xufVxuXG5mdW5jdGlvbiBtZXJnZUNoaWxkTWFwcGluZ3MocHJldiwgbmV4dCkge1xuXHR2YXIgcmV0ID0gW107XG5cblx0dmFyIG5leHRDaGlsZHJlblBlbmRpbmcgPSB7fSxcblx0ICAgIHBlbmRpbmdDaGlsZHJlbiA9IFtdO1xuXHRwcmV2LmZvckVhY2goZnVuY3Rpb24gKGMpIHtcblx0XHR2YXIga2V5ID0gZ2V0S2V5KGMpO1xuXHRcdGlmIChpbkNoaWxkcmVuQnlLZXkobmV4dCwga2V5KSkge1xuXHRcdFx0aWYgKHBlbmRpbmdDaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdFx0bmV4dENoaWxkcmVuUGVuZGluZ1trZXldID0gcGVuZGluZ0NoaWxkcmVuO1xuXHRcdFx0XHRwZW5kaW5nQ2hpbGRyZW4gPSBbXTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cGVuZGluZ0NoaWxkcmVuLnB1c2goYyk7XG5cdFx0fVxuXHR9KTtcblxuXHRuZXh0LmZvckVhY2goZnVuY3Rpb24gKGMpIHtcblx0XHR2YXIga2V5ID0gZ2V0S2V5KGMpO1xuXHRcdGlmIChuZXh0Q2hpbGRyZW5QZW5kaW5nLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdHJldCA9IHJldC5jb25jYXQobmV4dENoaWxkcmVuUGVuZGluZ1trZXldKTtcblx0XHR9XG5cdFx0cmV0LnB1c2goYyk7XG5cdH0pO1xuXG5cdHJldHVybiByZXQuY29uY2F0KHBlbmRpbmdDaGlsZHJlbik7XG59XG5cbnZhciBTUEFDRSA9ICcgJztcbnZhciBSRV9DTEFTUyA9IC9bXFxuXFx0XFxyXSsvZztcblxudmFyIG5vcm0gPSBmdW5jdGlvbiAoZWxlbUNsYXNzKSB7XG5cdHJldHVybiAoU1BBQ0UgKyBlbGVtQ2xhc3MgKyBTUEFDRSkucmVwbGFjZShSRV9DTEFTUywgU1BBQ0UpO1xufTtcblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbSwgY2xhc3NOYW1lKSB7XG5cdGlmIChlbGVtLmNsYXNzTGlzdCkge1xuXHRcdHZhciBfZWxlbSRjbGFzc0xpc3Q7XG5cblx0XHQoX2VsZW0kY2xhc3NMaXN0ID0gZWxlbS5jbGFzc0xpc3QpLmFkZC5hcHBseShfZWxlbSRjbGFzc0xpc3QsIGNsYXNzTmFtZS5zcGxpdCgnICcpKTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLmNsYXNzTmFtZSArPSAnICcgKyBjbGFzc05hbWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbSwgbmVlZGxlKSB7XG5cdG5lZWRsZSA9IG5lZWRsZS50cmltKCk7XG5cdGlmIChlbGVtLmNsYXNzTGlzdCkge1xuXHRcdHZhciBfZWxlbSRjbGFzc0xpc3QyO1xuXG5cdFx0KF9lbGVtJGNsYXNzTGlzdDIgPSBlbGVtLmNsYXNzTGlzdCkucmVtb3ZlLmFwcGx5KF9lbGVtJGNsYXNzTGlzdDIsIG5lZWRsZS5zcGxpdCgnICcpKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgZWxlbUNsYXNzID0gZWxlbS5jbGFzc05hbWUudHJpbSgpO1xuXHRcdHZhciBjbGFzc05hbWUgPSBub3JtKGVsZW1DbGFzcyk7XG5cdFx0bmVlZGxlID0gU1BBQ0UgKyBuZWVkbGUgKyBTUEFDRTtcblx0XHR3aGlsZSAoY2xhc3NOYW1lLmluZGV4T2YobmVlZGxlKSA+PSAwKSB7XG5cdFx0XHRjbGFzc05hbWUgPSBjbGFzc05hbWUucmVwbGFjZShuZWVkbGUsIFNQQUNFKTtcblx0XHR9XG5cdFx0ZWxlbS5jbGFzc05hbWUgPSBjbGFzc05hbWUudHJpbSgpO1xuXHR9XG59XG5cbnZhciBFVkVOVF9OQU1FX01BUCA9IHtcblx0dHJhbnNpdGlvbmVuZDoge1xuXHRcdHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJyxcblx0XHRXZWJraXRUcmFuc2l0aW9uOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG5cdFx0TW96VHJhbnNpdGlvbjogJ21velRyYW5zaXRpb25FbmQnLFxuXHRcdE9UcmFuc2l0aW9uOiAnb1RyYW5zaXRpb25FbmQnLFxuXHRcdG1zVHJhbnNpdGlvbjogJ01TVHJhbnNpdGlvbkVuZCdcblx0fSxcblxuXHRhbmltYXRpb25lbmQ6IHtcblx0XHRhbmltYXRpb246ICdhbmltYXRpb25lbmQnLFxuXHRcdFdlYmtpdEFuaW1hdGlvbjogJ3dlYmtpdEFuaW1hdGlvbkVuZCcsXG5cdFx0TW96QW5pbWF0aW9uOiAnbW96QW5pbWF0aW9uRW5kJyxcblx0XHRPQW5pbWF0aW9uOiAnb0FuaW1hdGlvbkVuZCcsXG5cdFx0bXNBbmltYXRpb246ICdNU0FuaW1hdGlvbkVuZCdcblx0fVxufTtcblxudmFyIGVuZEV2ZW50cyA9IFtdO1xuXG5mdW5jdGlvbiBkZXRlY3RFdmVudHMoKSB7XG5cdHZhciB0ZXN0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcblx0ICAgIHN0eWxlID0gdGVzdEVsLnN0eWxlO1xuXG5cdGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuXHRcdGRlbGV0ZSBFVkVOVF9OQU1FX01BUC5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuXHR9XG5cblx0aWYgKCEoJ1RyYW5zaXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuXHRcdGRlbGV0ZSBFVkVOVF9OQU1FX01BUC50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb247XG5cdH1cblxuXHRmb3IgKHZhciBiYXNlRXZlbnROYW1lIGluIEVWRU5UX05BTUVfTUFQKSB7XG5cdFx0dmFyIGJhc2VFdmVudHMgPSBFVkVOVF9OQU1FX01BUFtiYXNlRXZlbnROYW1lXTtcblx0XHRmb3IgKHZhciBzdHlsZU5hbWUgaW4gYmFzZUV2ZW50cykge1xuXHRcdFx0aWYgKHN0eWxlTmFtZSBpbiBzdHlsZSkge1xuXHRcdFx0XHRlbmRFdmVudHMucHVzaChiYXNlRXZlbnRzW3N0eWxlTmFtZV0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdGRldGVjdEV2ZW50cygpO1xufVxuXG5mdW5jdGlvbiBhZGRFbmRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50TGlzdGVuZXIpIHtcblx0aWYgKCFlbmRFdmVudHMubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGV2ZW50TGlzdGVuZXIsIDApO1xuXHR9XG5cdGVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbmRFdmVudCkge1xuXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgZXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRW5kRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudExpc3RlbmVyKSB7XG5cdGlmICghZW5kRXZlbnRzLmxlbmd0aCkgcmV0dXJuO1xuXHRlbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZW5kRXZlbnQpIHtcblx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcblx0fSk7XG59XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7XG4gICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG52YXIgVElDSyA9IDE3O1xuXG52YXIgQ1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuXHRpbmhlcml0cyhDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZCwgX0NvbXBvbmVudCk7XG5cblx0ZnVuY3Rpb24gQ1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQoKSB7XG5cdFx0dmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuXHRcdGNsYXNzQ2FsbENoZWNrKHRoaXMsIENTU1RyYW5zaXRpb25Hcm91cENoaWxkKTtcblxuXHRcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdFx0XHRhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHRcdH1cblxuXHRcdHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwuYXBwbHkoX0NvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmZsdXNoQ2xhc3NOYW1lUXVldWUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoZ2V0Q29tcG9uZW50QmFzZShfdGhpcykpIHtcblx0XHRcdFx0YWRkQ2xhc3MoZ2V0Q29tcG9uZW50QmFzZShfdGhpcyksIF90aGlzLmNsYXNzTmFtZVF1ZXVlLmpvaW4oJyAnKSk7XG5cdFx0XHR9XG5cdFx0XHRfdGhpcy5jbGFzc05hbWVRdWV1ZS5sZW5ndGggPSAwO1xuXHRcdFx0X3RoaXMudGltZW91dCA9IG51bGw7XG5cdFx0fSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcblx0fVxuXG5cdENTU1RyYW5zaXRpb25Hcm91cENoaWxkLnByb3RvdHlwZS50cmFuc2l0aW9uID0gZnVuY3Rpb24gdHJhbnNpdGlvbihhbmltYXRpb25UeXBlLCBmaW5pc2hDYWxsYmFjaywgdGltZW91dCkge1xuXHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdFx0dmFyIG5vZGUgPSBnZXRDb21wb25lbnRCYXNlKHRoaXMpO1xuXG5cdFx0dmFyIGNsYXNzTmFtZSA9IHRoaXMucHJvcHMubmFtZVthbmltYXRpb25UeXBlXSB8fCB0aGlzLnByb3BzLm5hbWUgKyAnLScgKyBhbmltYXRpb25UeXBlO1xuXHRcdHZhciBhY3RpdmVDbGFzc05hbWUgPSB0aGlzLnByb3BzLm5hbWVbYW5pbWF0aW9uVHlwZSArICdBY3RpdmUnXSB8fCBjbGFzc05hbWUgKyAnLWFjdGl2ZSc7XG5cdFx0dmFyIHRpbWVyID0gbnVsbDtcblxuXHRcdGlmICh0aGlzLmVuZExpc3RlbmVyKSB7XG5cdFx0XHR0aGlzLmVuZExpc3RlbmVyKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5lbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRpZiAoZSAmJiBlLnRhcmdldCAhPT0gbm9kZSkgcmV0dXJuO1xuXG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdFx0cmVtb3ZlQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTtcblx0XHRcdHJlbW92ZUNsYXNzKG5vZGUsIGFjdGl2ZUNsYXNzTmFtZSk7XG5cdFx0XHRyZW1vdmVFbmRFdmVudExpc3RlbmVyKG5vZGUsIF90aGlzMi5lbmRMaXN0ZW5lcik7XG5cdFx0XHRfdGhpczIuZW5kTGlzdGVuZXIgPSBudWxsO1xuXG5cdFx0XHRpZiAoZmluaXNoQ2FsbGJhY2spIHtcblx0XHRcdFx0ZmluaXNoQ2FsbGJhY2soKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0aWYgKHRpbWVvdXQpIHtcblx0XHRcdHRpbWVyID0gc2V0VGltZW91dCh0aGlzLmVuZExpc3RlbmVyLCB0aW1lb3V0KTtcblx0XHRcdHRoaXMudHJhbnNpdGlvblRpbWVvdXRzLnB1c2godGltZXIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhZGRFbmRFdmVudExpc3RlbmVyKG5vZGUsIHRoaXMuZW5kTGlzdGVuZXIpO1xuXHRcdH1cblxuXHRcdGFkZENsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG5cblx0XHR0aGlzLnF1ZXVlQ2xhc3MoYWN0aXZlQ2xhc3NOYW1lKTtcblx0fTtcblxuXHRDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZC5wcm90b3R5cGUucXVldWVDbGFzcyA9IGZ1bmN0aW9uIHF1ZXVlQ2xhc3MoY2xhc3NOYW1lKSB7XG5cdFx0dGhpcy5jbGFzc05hbWVRdWV1ZS5wdXNoKGNsYXNzTmFtZSk7XG5cblx0XHRpZiAoIXRoaXMudGltZW91dCkge1xuXHRcdFx0dGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmZsdXNoQ2xhc3NOYW1lUXVldWUsIFRJQ0spO1xuXHRcdH1cblx0fTtcblxuXHRDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG5cdFx0aWYgKHRoaXMudGltZW91dCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG5cdFx0XHR0aGlzLmNsYXNzTmFtZVF1ZXVlLmxlbmd0aCA9IDA7XG5cdFx0XHR0aGlzLnRpbWVvdXQgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAodGhpcy5lbmRMaXN0ZW5lcikge1xuXHRcdFx0dGhpcy5lbmRMaXN0ZW5lcigpO1xuXHRcdH1cblx0fTtcblxuXHRDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuXHRcdHRoaXMuY2xhc3NOYW1lUXVldWUgPSBbXTtcblx0XHR0aGlzLnRyYW5zaXRpb25UaW1lb3V0cyA9IFtdO1xuXHR9O1xuXG5cdENTU1RyYW5zaXRpb25Hcm91cENoaWxkLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdGlmICh0aGlzLnRpbWVvdXQpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuXHRcdH1cblx0XHR0aGlzLnRyYW5zaXRpb25UaW1lb3V0cy5mb3JFYWNoKGZ1bmN0aW9uICh0aW1lb3V0KSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0fSk7XG5cdH07XG5cblx0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxFbnRlciA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxFbnRlcihkb25lKSB7XG5cdFx0aWYgKHRoaXMucHJvcHMuZW50ZXIpIHtcblx0XHRcdHRoaXMudHJhbnNpdGlvbignZW50ZXInLCBkb25lLCB0aGlzLnByb3BzLmVudGVyVGltZW91dCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvbmUoKTtcblx0XHR9XG5cdH07XG5cblx0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxMZWF2ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxMZWF2ZShkb25lKSB7XG5cdFx0aWYgKHRoaXMucHJvcHMubGVhdmUpIHtcblx0XHRcdHRoaXMudHJhbnNpdGlvbignbGVhdmUnLCBkb25lLCB0aGlzLnByb3BzLmxlYXZlVGltZW91dCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvbmUoKTtcblx0XHR9XG5cdH07XG5cblx0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0XHRyZXR1cm4gb25seUNoaWxkKHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuXHR9O1xuXG5cdHJldHVybiBDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZDtcbn0ocHJlYWN0LkNvbXBvbmVudCk7XG5cbnZhciBDU1NUcmFuc2l0aW9uR3JvdXAgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuXHRpbmhlcml0cyhDU1NUcmFuc2l0aW9uR3JvdXAsIF9Db21wb25lbnQpO1xuXG5cdGZ1bmN0aW9uIENTU1RyYW5zaXRpb25Hcm91cChwcm9wcykge1xuXHRcdGNsYXNzQ2FsbENoZWNrKHRoaXMsIENTU1RyYW5zaXRpb25Hcm91cCk7XG5cblx0XHR2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzKSk7XG5cblx0XHRfdGhpcy5yZW5kZXJDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuXHRcdFx0dmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHM7XG5cdFx0XHR2YXIgdHJhbnNpdGlvbk5hbWUgPSBfdGhpcyRwcm9wcy50cmFuc2l0aW9uTmFtZTtcblx0XHRcdHZhciB0cmFuc2l0aW9uRW50ZXIgPSBfdGhpcyRwcm9wcy50cmFuc2l0aW9uRW50ZXI7XG5cdFx0XHR2YXIgdHJhbnNpdGlvbkxlYXZlID0gX3RoaXMkcHJvcHMudHJhbnNpdGlvbkxlYXZlO1xuXHRcdFx0dmFyIHRyYW5zaXRpb25FbnRlclRpbWVvdXQgPSBfdGhpcyRwcm9wcy50cmFuc2l0aW9uRW50ZXJUaW1lb3V0O1xuXHRcdFx0dmFyIHRyYW5zaXRpb25MZWF2ZVRpbWVvdXQgPSBfdGhpcyRwcm9wcy50cmFuc2l0aW9uTGVhdmVUaW1lb3V0O1xuXHRcdFx0dmFyIGtleSA9IGdldEtleShjaGlsZCk7XG5cdFx0XHRyZXR1cm4gcHJlYWN0LmgoXG5cdFx0XHRcdENTU1RyYW5zaXRpb25Hcm91cENoaWxkLFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0a2V5OiBrZXksXG5cdFx0XHRcdFx0cmVmOiBmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRcdFx0aWYgKCEoX3RoaXMucmVmc1trZXldID0gYykpIGNoaWxkID0gbnVsbDtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdG5hbWU6IHRyYW5zaXRpb25OYW1lLFxuXHRcdFx0XHRcdGVudGVyOiB0cmFuc2l0aW9uRW50ZXIsXG5cdFx0XHRcdFx0bGVhdmU6IHRyYW5zaXRpb25MZWF2ZSxcblx0XHRcdFx0XHRlbnRlclRpbWVvdXQ6IHRyYW5zaXRpb25FbnRlclRpbWVvdXQsXG5cdFx0XHRcdFx0bGVhdmVUaW1lb3V0OiB0cmFuc2l0aW9uTGVhdmVUaW1lb3V0IH0sXG5cdFx0XHRcdGNoaWxkXG5cdFx0XHQpO1xuXHRcdH07XG5cblx0XHRfdGhpcy5yZWZzID0ge307XG5cdFx0X3RoaXMuc3RhdGUgPSB7XG5cdFx0XHRjaGlsZHJlbjogKHByb3BzLmNoaWxkcmVuIHx8IFtdKS5zbGljZSgpXG5cdFx0fTtcblx0XHRyZXR1cm4gX3RoaXM7XG5cdH1cblxuXHRDU1NUcmFuc2l0aW9uR3JvdXAucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIHNob3VsZENvbXBvbmVudFVwZGF0ZShfLCBfcmVmKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcblxuXHRcdHJldHVybiBjaGlsZHJlbiAhPT0gdGhpcy5zdGF0ZS5jaGlsZHJlbjtcblx0fTtcblxuXHRDU1NUcmFuc2l0aW9uR3JvdXAucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcblx0XHR0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzID0ge307XG5cdFx0dGhpcy5rZXlzVG9FbnRlciA9IFtdO1xuXHRcdHRoaXMua2V5c1RvTGVhdmUgPSBbXTtcblx0fTtcblxuXHRDU1NUcmFuc2l0aW9uR3JvdXAucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKF9yZWYyKSB7XG5cdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cblx0XHR2YXIgY2hpbGRyZW4gPSBfcmVmMi5jaGlsZHJlbjtcblx0XHR2YXIgZXhjbHVzaXZlID0gX3JlZjIuZXhjbHVzaXZlO1xuXHRcdHZhciBzaG93UHJvcCA9IF9yZWYyLnNob3dQcm9wO1xuXG5cdFx0dmFyIG5leHRDaGlsZE1hcHBpbmcgPSBmaWx0ZXJOdWxsQ2hpbGRyZW4oY2hpbGRyZW4gfHwgW10pLnNsaWNlKCk7XG5cblx0XHR2YXIgcHJldkNoaWxkTWFwcGluZyA9IGZpbHRlck51bGxDaGlsZHJlbihleGNsdXNpdmUgPyB0aGlzLnByb3BzLmNoaWxkcmVuIDogdGhpcy5zdGF0ZS5jaGlsZHJlbik7XG5cblx0XHR2YXIgbmV3Q2hpbGRyZW4gPSBtZXJnZUNoaWxkTWFwcGluZ3MocHJldkNoaWxkTWFwcGluZywgbmV4dENoaWxkTWFwcGluZyk7XG5cblx0XHRpZiAoc2hvd1Byb3ApIHtcblx0XHRcdG5ld0NoaWxkcmVuID0gbmV3Q2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdGlmICghYy5wcm9wc1tzaG93UHJvcF0gJiYgaXNTaG93bkluQ2hpbGRyZW4ocHJldkNoaWxkTWFwcGluZywgYywgc2hvd1Byb3ApKSB7XG5cdFx0XHRcdFx0dmFyIF9jbG9uZUVsZW1lbnQ7XG5cblx0XHRcdFx0XHRjID0gcHJlYWN0LmNsb25lRWxlbWVudChjLCAoX2Nsb25lRWxlbWVudCA9IHt9LCBfY2xvbmVFbGVtZW50W3Nob3dQcm9wXSA9IHRydWUsIF9jbG9uZUVsZW1lbnQpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYztcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmIChleGNsdXNpdmUpIHtcblx0XHRcdG5ld0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0cmV0dXJuIF90aGlzMi5zdG9wKGdldEtleShjKSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0aGlzLnNldFN0YXRlKHsgY2hpbGRyZW46IG5ld0NoaWxkcmVuIH0pO1xuXHRcdHRoaXMuZm9yY2VVcGRhdGUoKTtcblxuXHRcdG5leHRDaGlsZE1hcHBpbmcuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuXHRcdFx0dmFyIGtleSA9IGMua2V5O1xuXHRcdFx0dmFyIGhhc1ByZXYgPSBwcmV2Q2hpbGRNYXBwaW5nICYmIGluQ2hpbGRyZW4ocHJldkNoaWxkTWFwcGluZywgYyk7XG5cdFx0XHRpZiAoc2hvd1Byb3ApIHtcblx0XHRcdFx0aWYgKGhhc1ByZXYpIHtcblx0XHRcdFx0XHR2YXIgc2hvd0luUHJldiA9IGlzU2hvd25JbkNoaWxkcmVuKHByZXZDaGlsZE1hcHBpbmcsIGMsIHNob3dQcm9wKSxcblx0XHRcdFx0XHQgICAgc2hvd0luTm93ID0gYy5wcm9wc1tzaG93UHJvcF07XG5cdFx0XHRcdFx0aWYgKCFzaG93SW5QcmV2ICYmIHNob3dJbk5vdyAmJiAhX3RoaXMyLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV0pIHtcblx0XHRcdFx0XHRcdF90aGlzMi5rZXlzVG9FbnRlci5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCFoYXNQcmV2ICYmICFfdGhpczIuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XSkge1xuXHRcdFx0XHRfdGhpczIua2V5c1RvRW50ZXIucHVzaChrZXkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cHJldkNoaWxkTWFwcGluZy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG5cdFx0XHR2YXIga2V5ID0gYy5rZXk7XG5cdFx0XHR2YXIgaGFzTmV4dCA9IG5leHRDaGlsZE1hcHBpbmcgJiYgaW5DaGlsZHJlbihuZXh0Q2hpbGRNYXBwaW5nLCBjKTtcblx0XHRcdGlmIChzaG93UHJvcCkge1xuXHRcdFx0XHRpZiAoaGFzTmV4dCkge1xuXHRcdFx0XHRcdHZhciBzaG93SW5OZXh0ID0gaXNTaG93bkluQ2hpbGRyZW4obmV4dENoaWxkTWFwcGluZywgYywgc2hvd1Byb3ApO1xuXHRcdFx0XHRcdHZhciBzaG93SW5Ob3cgPSBjLnByb3BzW3Nob3dQcm9wXTtcblx0XHRcdFx0XHRpZiAoIXNob3dJbk5leHQgJiYgc2hvd0luTm93ICYmICFfdGhpczIuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XSkge1xuXHRcdFx0XHRcdFx0X3RoaXMyLmtleXNUb0xlYXZlLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIWhhc05leHQgJiYgIV90aGlzMi5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldKSB7XG5cdFx0XHRcdF90aGlzMi5rZXlzVG9MZWF2ZS5wdXNoKGtleSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0Q1NTVHJhbnNpdGlvbkdyb3VwLnByb3RvdHlwZS5wZXJmb3JtRW50ZXIgPSBmdW5jdGlvbiBwZXJmb3JtRW50ZXIoa2V5KSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cblx0XHR0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV0gPSB0cnVlO1xuXHRcdHZhciBjb21wb25lbnQgPSB0aGlzLnJlZnNba2V5XTtcblx0XHRpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxFbnRlcikge1xuXHRcdFx0Y29tcG9uZW50LmNvbXBvbmVudFdpbGxFbnRlcihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBfdGhpczMuX2hhbmRsZURvbmVFbnRlcmluZyhrZXkpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2hhbmRsZURvbmVFbnRlcmluZyhrZXkpO1xuXHRcdH1cblx0fTtcblxuXHRDU1NUcmFuc2l0aW9uR3JvdXAucHJvdG90eXBlLl9oYW5kbGVEb25lRW50ZXJpbmcgPSBmdW5jdGlvbiBfaGFuZGxlRG9uZUVudGVyaW5nKGtleSkge1xuXHRcdGRlbGV0ZSB0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV07XG5cdFx0dmFyIGN1cnJlbnRDaGlsZE1hcHBpbmcgPSBmaWx0ZXJOdWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiksXG5cdFx0ICAgIHNob3dQcm9wID0gdGhpcy5wcm9wcy5zaG93UHJvcDtcblx0XHRpZiAoIWN1cnJlbnRDaGlsZE1hcHBpbmcgfHwgIXNob3dQcm9wICYmICFpbkNoaWxkcmVuQnlLZXkoY3VycmVudENoaWxkTWFwcGluZywga2V5KSB8fCBzaG93UHJvcCAmJiAhaXNTaG93bkluQ2hpbGRyZW5CeUtleShjdXJyZW50Q2hpbGRNYXBwaW5nLCBrZXksIHNob3dQcm9wKSkge1xuXHRcdFx0dGhpcy5wZXJmb3JtTGVhdmUoa2V5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRTdGF0ZSh7IGNoaWxkcmVuOiBjdXJyZW50Q2hpbGRNYXBwaW5nIH0pO1xuXHRcdH1cblx0fTtcblxuXHRDU1NUcmFuc2l0aW9uR3JvdXAucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKGtleSkge1xuXHRcdGRlbGV0ZSB0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV07XG5cdFx0dmFyIGNvbXBvbmVudCA9IHRoaXMucmVmc1trZXldO1xuXHRcdGlmIChjb21wb25lbnQpIGNvbXBvbmVudC5zdG9wKCk7XG5cdH07XG5cblx0Q1NTVHJhbnNpdGlvbkdyb3VwLnByb3RvdHlwZS5wZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiBwZXJmb3JtTGVhdmUoa2V5KSB7XG5cdFx0dmFyIF90aGlzNCA9IHRoaXM7XG5cblx0XHR0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV0gPSB0cnVlO1xuXHRcdHZhciBjb21wb25lbnQgPSB0aGlzLnJlZnNba2V5XTtcblx0XHRpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5jb21wb25lbnRXaWxsTGVhdmUpIHtcblx0XHRcdGNvbXBvbmVudC5jb21wb25lbnRXaWxsTGVhdmUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gX3RoaXM0Ll9oYW5kbGVEb25lTGVhdmluZyhrZXkpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2hhbmRsZURvbmVMZWF2aW5nKGtleSk7XG5cdFx0fVxuXHR9O1xuXG5cdENTU1RyYW5zaXRpb25Hcm91cC5wcm90b3R5cGUuX2hhbmRsZURvbmVMZWF2aW5nID0gZnVuY3Rpb24gX2hhbmRsZURvbmVMZWF2aW5nKGtleSkge1xuXHRcdGRlbGV0ZSB0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV07XG5cdFx0dmFyIHNob3dQcm9wID0gdGhpcy5wcm9wcy5zaG93UHJvcCxcblx0XHQgICAgY3VycmVudENoaWxkTWFwcGluZyA9IGZpbHRlck51bGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuKTtcblx0XHRpZiAoc2hvd1Byb3AgJiYgY3VycmVudENoaWxkTWFwcGluZyAmJiBpc1Nob3duSW5DaGlsZHJlbkJ5S2V5KGN1cnJlbnRDaGlsZE1hcHBpbmcsIGtleSwgc2hvd1Byb3ApKSB7XG5cdFx0XHR0aGlzLnBlcmZvcm1FbnRlcihrZXkpO1xuXHRcdH0gZWxzZSBpZiAoIXNob3dQcm9wICYmIGN1cnJlbnRDaGlsZE1hcHBpbmcgJiYgaW5DaGlsZHJlbkJ5S2V5KGN1cnJlbnRDaGlsZE1hcHBpbmcsIGtleSkpIHtcblx0XHRcdHRoaXMucGVyZm9ybUVudGVyKGtleSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0U3RhdGUoeyBjaGlsZHJlbjogY3VycmVudENoaWxkTWFwcGluZyB9KTtcblx0XHR9XG5cdH07XG5cblx0Q1NTVHJhbnNpdGlvbkdyb3VwLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG5cdFx0dmFyIF90aGlzNSA9IHRoaXM7XG5cblx0XHR2YXIga2V5c1RvRW50ZXIgPSB0aGlzLmtleXNUb0VudGVyO1xuXHRcdHZhciBrZXlzVG9MZWF2ZSA9IHRoaXMua2V5c1RvTGVhdmU7XG5cblx0XHR0aGlzLmtleXNUb0VudGVyID0gW107XG5cdFx0a2V5c1RvRW50ZXIuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRcdFx0cmV0dXJuIF90aGlzNS5wZXJmb3JtRW50ZXIoayk7XG5cdFx0fSk7XG5cdFx0dGhpcy5rZXlzVG9MZWF2ZSA9IFtdO1xuXHRcdGtleXNUb0xlYXZlLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0XHRcdHJldHVybiBfdGhpczUucGVyZm9ybUxlYXZlKGspO1xuXHRcdH0pO1xuXHR9O1xuXG5cdENTU1RyYW5zaXRpb25Hcm91cC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKF9yZWYzLCBfcmVmNCkge1xuXHRcdHZhciBDb21wb25lbnQgPSBfcmVmMy5jb21wb25lbnQ7XG5cdFx0dmFyIHRyYW5zaXRpb25OYW1lID0gX3JlZjMudHJhbnNpdGlvbk5hbWU7XG5cdFx0dmFyIHRyYW5zaXRpb25FbnRlciA9IF9yZWYzLnRyYW5zaXRpb25FbnRlcjtcblx0XHR2YXIgdHJhbnNpdGlvbkxlYXZlID0gX3JlZjMudHJhbnNpdGlvbkxlYXZlO1xuXHRcdHZhciB0cmFuc2l0aW9uRW50ZXJUaW1lb3V0ID0gX3JlZjMudHJhbnNpdGlvbkVudGVyVGltZW91dDtcblx0XHR2YXIgdHJhbnNpdGlvbkxlYXZlVGltZW91dCA9IF9yZWYzLnRyYW5zaXRpb25MZWF2ZVRpbWVvdXQ7XG5cdFx0dmFyIGMgPSBfcmVmMy5jaGlsZHJlbjtcblx0XHR2YXIgcHJvcHMgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMywgWydjb21wb25lbnQnLCAndHJhbnNpdGlvbk5hbWUnLCAndHJhbnNpdGlvbkVudGVyJywgJ3RyYW5zaXRpb25MZWF2ZScsICd0cmFuc2l0aW9uRW50ZXJUaW1lb3V0JywgJ3RyYW5zaXRpb25MZWF2ZVRpbWVvdXQnLCAnY2hpbGRyZW4nXSk7XG5cdFx0dmFyIGNoaWxkcmVuID0gX3JlZjQuY2hpbGRyZW47XG5cblx0XHRyZXR1cm4gcHJlYWN0LmgoXG5cdFx0XHRDb21wb25lbnQsXG5cdFx0XHRwcm9wcyxcblx0XHRcdGZpbHRlck51bGxDaGlsZHJlbihjaGlsZHJlbikubWFwKHRoaXMucmVuZGVyQ2hpbGQpXG5cdFx0KTtcblx0fTtcblxuXHRyZXR1cm4gQ1NTVHJhbnNpdGlvbkdyb3VwO1xufShwcmVhY3QuQ29tcG9uZW50KTtcbkNTU1RyYW5zaXRpb25Hcm91cC5kZWZhdWx0UHJvcHMgPSB7XG5cdGNvbXBvbmVudDogJ3NwYW4nLFxuXHR0cmFuc2l0aW9uRW50ZXI6IHRydWUsXG5cdHRyYW5zaXRpb25MZWF2ZTogdHJ1ZVxufTtcblxucmV0dXJuIENTU1RyYW5zaXRpb25Hcm91cDtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWFjdC1jc3MtdHJhbnNpdGlvbi1ncm91cC5qcy5tYXBcbiIsIiFmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgZnVuY3Rpb24gVk5vZGUoKSB7fVxuICAgIGZ1bmN0aW9uIGgobm9kZU5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIGxhc3RTaW1wbGUsIGNoaWxkLCBzaW1wbGUsIGksIGNoaWxkcmVuID0gRU1QVFlfQ0hJTERSRU47XG4gICAgICAgIGZvciAoaSA9IGFyZ3VtZW50cy5sZW5ndGg7IGktLSA+IDI7ICkgc3RhY2sucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgICBpZiAoYXR0cmlidXRlcyAmJiBudWxsICE9IGF0dHJpYnV0ZXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICghc3RhY2subGVuZ3RoKSBzdGFjay5wdXNoKGF0dHJpYnV0ZXMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMuY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkgaWYgKChjaGlsZCA9IHN0YWNrLnBvcCgpKSAmJiB2b2lkIDAgIT09IGNoaWxkLnBvcCkgZm9yIChpID0gY2hpbGQubGVuZ3RoOyBpLS07ICkgc3RhY2sucHVzaChjaGlsZFtpXSk7IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCdib29sZWFuJyA9PSB0eXBlb2YgY2hpbGQpIGNoaWxkID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChzaW1wbGUgPSAnZnVuY3Rpb24nICE9IHR5cGVvZiBub2RlTmFtZSkgaWYgKG51bGwgPT0gY2hpbGQpIGNoaWxkID0gJyc7IGVsc2UgaWYgKCdudW1iZXInID09IHR5cGVvZiBjaGlsZCkgY2hpbGQgPSBTdHJpbmcoY2hpbGQpOyBlbHNlIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgY2hpbGQpIHNpbXBsZSA9ICExO1xuICAgICAgICAgICAgaWYgKHNpbXBsZSAmJiBsYXN0U2ltcGxlKSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSArPSBjaGlsZDsgZWxzZSBpZiAoY2hpbGRyZW4gPT09IEVNUFRZX0NISUxEUkVOKSBjaGlsZHJlbiA9IFsgY2hpbGQgXTsgZWxzZSBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIGxhc3RTaW1wbGUgPSBzaW1wbGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAgPSBuZXcgVk5vZGUoKTtcbiAgICAgICAgcC5ub2RlTmFtZSA9IG5vZGVOYW1lO1xuICAgICAgICBwLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHAuYXR0cmlidXRlcyA9IG51bGwgPT0gYXR0cmlidXRlcyA/IHZvaWQgMCA6IGF0dHJpYnV0ZXM7XG4gICAgICAgIHAua2V5ID0gbnVsbCA9PSBhdHRyaWJ1dGVzID8gdm9pZCAwIDogYXR0cmlidXRlcy5rZXk7XG4gICAgICAgIGlmICh2b2lkIDAgIT09IG9wdGlvbnMudm5vZGUpIG9wdGlvbnMudm5vZGUocCk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBleHRlbmQob2JqLCBwcm9wcykge1xuICAgICAgICBmb3IgKHZhciBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvbmVFbGVtZW50KHZub2RlLCBwcm9wcykge1xuICAgICAgICByZXR1cm4gaCh2bm9kZS5ub2RlTmFtZSwgZXh0ZW5kKGV4dGVuZCh7fSwgdm5vZGUuYXR0cmlidXRlcyksIHByb3BzKSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiB2bm9kZS5jaGlsZHJlbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVSZW5kZXIoY29tcG9uZW50KSB7XG4gICAgICAgIGlmICghY29tcG9uZW50Ll9fZCAmJiAoY29tcG9uZW50Ll9fZCA9ICEwKSAmJiAxID09IGl0ZW1zLnB1c2goY29tcG9uZW50KSkgKG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgfHwgZGVmZXIpKHJlcmVuZGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXIoKSB7XG4gICAgICAgIHZhciBwLCBsaXN0ID0gaXRlbXM7XG4gICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgIHdoaWxlIChwID0gbGlzdC5wb3AoKSkgaWYgKHAuX19kKSByZW5kZXJDb21wb25lbnQocCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzU2FtZU5vZGVUeXBlKG5vZGUsIHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgICAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2bm9kZSB8fCAnbnVtYmVyJyA9PSB0eXBlb2Ygdm5vZGUpIHJldHVybiB2b2lkIDAgIT09IG5vZGUuc3BsaXRUZXh0O1xuICAgICAgICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHZub2RlLm5vZGVOYW1lKSByZXR1cm4gIW5vZGUuX2NvbXBvbmVudENvbnN0cnVjdG9yICYmIGlzTmFtZWROb2RlKG5vZGUsIHZub2RlLm5vZGVOYW1lKTsgZWxzZSByZXR1cm4gaHlkcmF0aW5nIHx8IG5vZGUuX2NvbXBvbmVudENvbnN0cnVjdG9yID09PSB2bm9kZS5ub2RlTmFtZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNOYW1lZE5vZGUobm9kZSwgbm9kZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuX19uID09PSBub2RlTmFtZSB8fCBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE5vZGVQcm9wcyh2bm9kZSkge1xuICAgICAgICB2YXIgcHJvcHMgPSBleHRlbmQoe30sIHZub2RlLmF0dHJpYnV0ZXMpO1xuICAgICAgICBwcm9wcy5jaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICB2YXIgZGVmYXVsdFByb3BzID0gdm5vZGUubm9kZU5hbWUuZGVmYXVsdFByb3BzO1xuICAgICAgICBpZiAodm9pZCAwICE9PSBkZWZhdWx0UHJvcHMpIGZvciAodmFyIGkgaW4gZGVmYXVsdFByb3BzKSBpZiAodm9pZCAwID09PSBwcm9wc1tpXSkgcHJvcHNbaV0gPSBkZWZhdWx0UHJvcHNbaV07XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTm9kZShub2RlTmFtZSwgaXNTdmcpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBpc1N2ZyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCBub2RlTmFtZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICAgICAgbm9kZS5fX24gPSBub2RlTmFtZTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldEFjY2Vzc29yKG5vZGUsIG5hbWUsIG9sZCwgdmFsdWUsIGlzU3ZnKSB7XG4gICAgICAgIGlmICgnY2xhc3NOYW1lJyA9PT0gbmFtZSkgbmFtZSA9ICdjbGFzcyc7XG4gICAgICAgIGlmICgna2V5JyA9PT0gbmFtZSkgOyBlbHNlIGlmICgncmVmJyA9PT0gbmFtZSkge1xuICAgICAgICAgICAgaWYgKG9sZCkgb2xkKG51bGwpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB2YWx1ZShub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmICgnY2xhc3MnID09PSBuYW1lICYmICFpc1N2Zykgbm9kZS5jbGFzc05hbWUgPSB2YWx1ZSB8fCAnJzsgZWxzZSBpZiAoJ3N0eWxlJyA9PT0gbmFtZSkge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCAnc3RyaW5nJyA9PSB0eXBlb2YgdmFsdWUgfHwgJ3N0cmluZycgPT0gdHlwZW9mIG9sZCkgbm9kZS5zdHlsZS5jc3NUZXh0ID0gdmFsdWUgfHwgJyc7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgJ29iamVjdCcgPT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBvbGQpIGZvciAodmFyIGkgaW4gb2xkKSBpZiAoIShpIGluIHZhbHVlKSkgbm9kZS5zdHlsZVtpXSA9ICcnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdmFsdWUpIG5vZGUuc3R5bGVbaV0gPSAnbnVtYmVyJyA9PSB0eXBlb2YgdmFsdWVbaV0gJiYgITEgPT09IElTX05PTl9ESU1FTlNJT05BTC50ZXN0KGkpID8gdmFsdWVbaV0gKyAncHgnIDogdmFsdWVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyA9PT0gbmFtZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSBub2RlLmlubmVySFRNTCA9IHZhbHVlLl9faHRtbCB8fCAnJztcbiAgICAgICAgfSBlbHNlIGlmICgnbycgPT0gbmFtZVswXSAmJiAnbicgPT0gbmFtZVsxXSkge1xuICAgICAgICAgICAgdmFyIHVzZUNhcHR1cmUgPSBuYW1lICE9PSAobmFtZSA9IG5hbWUucmVwbGFjZSgvQ2FwdHVyZSQvLCAnJykpO1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9sZCkgbm9kZS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGV2ZW50UHJveHksIHVzZUNhcHR1cmUpO1xuICAgICAgICAgICAgfSBlbHNlIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudFByb3h5LCB1c2VDYXB0dXJlKTtcbiAgICAgICAgICAgIChub2RlLl9fbCB8fCAobm9kZS5fX2wgPSB7fSkpW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoJ2xpc3QnICE9PSBuYW1lICYmICd0eXBlJyAhPT0gbmFtZSAmJiAhaXNTdmcgJiYgbmFtZSBpbiBub2RlKSB7XG4gICAgICAgICAgICBzZXRQcm9wZXJ0eShub2RlLCBuYW1lLCBudWxsID09IHZhbHVlID8gJycgOiB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAobnVsbCA9PSB2YWx1ZSB8fCAhMSA9PT0gdmFsdWUpIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5zID0gaXNTdmcgJiYgbmFtZSAhPT0gKG5hbWUgPSBuYW1lLnJlcGxhY2UoL154bGluazo/LywgJycpKTtcbiAgICAgICAgICAgIGlmIChudWxsID09IHZhbHVlIHx8ICExID09PSB2YWx1ZSkgaWYgKG5zKSBub2RlLnJlbW92ZUF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgbmFtZS50b0xvd2VyQ2FzZSgpKTsgZWxzZSBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTsgZWxzZSBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgdmFsdWUpIGlmIChucykgbm9kZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIG5hbWUudG9Mb3dlckNhc2UoKSwgdmFsdWUpOyBlbHNlIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9kZVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgICBmdW5jdGlvbiBldmVudFByb3h5KGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19sW2UudHlwZV0ob3B0aW9ucy5ldmVudCAmJiBvcHRpb25zLmV2ZW50KGUpIHx8IGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaE1vdW50cygpIHtcbiAgICAgICAgdmFyIGM7XG4gICAgICAgIHdoaWxlIChjID0gbW91bnRzLnBvcCgpKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hZnRlck1vdW50KSBvcHRpb25zLmFmdGVyTW91bnQoYyk7XG4gICAgICAgICAgICBpZiAoYy5jb21wb25lbnREaWRNb3VudCkgYy5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpZmYoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwsIHBhcmVudCwgY29tcG9uZW50Um9vdCkge1xuICAgICAgICBpZiAoIWRpZmZMZXZlbCsrKSB7XG4gICAgICAgICAgICBpc1N2Z01vZGUgPSBudWxsICE9IHBhcmVudCAmJiB2b2lkIDAgIT09IHBhcmVudC5vd25lclNWR0VsZW1lbnQ7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSBudWxsICE9IGRvbSAmJiAhKCdfX3ByZWFjdGF0dHJfJyBpbiBkb20pO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXQgPSBpZGlmZihkb20sIHZub2RlLCBjb250ZXh0LCBtb3VudEFsbCwgY29tcG9uZW50Um9vdCk7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcmV0LnBhcmVudE5vZGUgIT09IHBhcmVudCkgcGFyZW50LmFwcGVuZENoaWxkKHJldCk7XG4gICAgICAgIGlmICghLS1kaWZmTGV2ZWwpIHtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9ICExO1xuICAgICAgICAgICAgaWYgKCFjb21wb25lbnRSb290KSBmbHVzaE1vdW50cygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlkaWZmKGRvbSwgdm5vZGUsIGNvbnRleHQsIG1vdW50QWxsLCBjb21wb25lbnRSb290KSB7XG4gICAgICAgIHZhciBvdXQgPSBkb20sIHByZXZTdmdNb2RlID0gaXNTdmdNb2RlO1xuICAgICAgICBpZiAobnVsbCA9PSB2bm9kZSB8fCAnYm9vbGVhbicgPT0gdHlwZW9mIHZub2RlKSB2bm9kZSA9ICcnO1xuICAgICAgICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHZub2RlIHx8ICdudW1iZXInID09IHR5cGVvZiB2bm9kZSkge1xuICAgICAgICAgICAgaWYgKGRvbSAmJiB2b2lkIDAgIT09IGRvbS5zcGxpdFRleHQgJiYgZG9tLnBhcmVudE5vZGUgJiYgKCFkb20uX2NvbXBvbmVudCB8fCBjb21wb25lbnRSb290KSkge1xuICAgICAgICAgICAgICAgIGlmIChkb20ubm9kZVZhbHVlICE9IHZub2RlKSBkb20ubm9kZVZhbHVlID0gdm5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb20ucGFyZW50Tm9kZSkgZG9tLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG91dCwgZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjb2xsZWN0Tm9kZVRyZWUoZG9tLCAhMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0Ll9fcHJlYWN0YXR0cl8gPSAhMDtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZub2RlTmFtZSA9IHZub2RlLm5vZGVOYW1lO1xuICAgICAgICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygdm5vZGVOYW1lKSByZXR1cm4gYnVpbGRDb21wb25lbnRGcm9tVk5vZGUoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwpO1xuICAgICAgICBpc1N2Z01vZGUgPSAnc3ZnJyA9PT0gdm5vZGVOYW1lID8gITAgOiAnZm9yZWlnbk9iamVjdCcgPT09IHZub2RlTmFtZSA/ICExIDogaXNTdmdNb2RlO1xuICAgICAgICB2bm9kZU5hbWUgPSBTdHJpbmcodm5vZGVOYW1lKTtcbiAgICAgICAgaWYgKCFkb20gfHwgIWlzTmFtZWROb2RlKGRvbSwgdm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgb3V0ID0gY3JlYXRlTm9kZSh2bm9kZU5hbWUsIGlzU3ZnTW9kZSk7XG4gICAgICAgICAgICBpZiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRvbS5maXJzdENoaWxkKSBvdXQuYXBwZW5kQ2hpbGQoZG9tLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmIChkb20ucGFyZW50Tm9kZSkgZG9tLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG91dCwgZG9tKTtcbiAgICAgICAgICAgICAgICByZWNvbGxlY3ROb2RlVHJlZShkb20sICEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZmMgPSBvdXQuZmlyc3RDaGlsZCwgcHJvcHMgPSBvdXQuX19wcmVhY3RhdHRyXywgdmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICAgIGlmIChudWxsID09IHByb3BzKSB7XG4gICAgICAgICAgICBwcm9wcyA9IG91dC5fX3ByZWFjdGF0dHJfID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBhID0gb3V0LmF0dHJpYnV0ZXMsIGkgPSBhLmxlbmd0aDsgaS0tOyApIHByb3BzW2FbaV0ubmFtZV0gPSBhW2ldLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaHlkcmF0aW5nICYmIHZjaGlsZHJlbiAmJiAxID09PSB2Y2hpbGRyZW4ubGVuZ3RoICYmICdzdHJpbmcnID09IHR5cGVvZiB2Y2hpbGRyZW5bMF0gJiYgbnVsbCAhPSBmYyAmJiB2b2lkIDAgIT09IGZjLnNwbGl0VGV4dCAmJiBudWxsID09IGZjLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBpZiAoZmMubm9kZVZhbHVlICE9IHZjaGlsZHJlblswXSkgZmMubm9kZVZhbHVlID0gdmNoaWxkcmVuWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKHZjaGlsZHJlbiAmJiB2Y2hpbGRyZW4ubGVuZ3RoIHx8IG51bGwgIT0gZmMpIGlubmVyRGlmZk5vZGUob3V0LCB2Y2hpbGRyZW4sIGNvbnRleHQsIG1vdW50QWxsLCBoeWRyYXRpbmcgfHwgbnVsbCAhPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCk7XG4gICAgICAgIGRpZmZBdHRyaWJ1dGVzKG91dCwgdm5vZGUuYXR0cmlidXRlcywgcHJvcHMpO1xuICAgICAgICBpc1N2Z01vZGUgPSBwcmV2U3ZnTW9kZTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5uZXJEaWZmTm9kZShkb20sIHZjaGlsZHJlbiwgY29udGV4dCwgbW91bnRBbGwsIGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIHZhciBqLCBjLCBmLCB2Y2hpbGQsIGNoaWxkLCBvcmlnaW5hbENoaWxkcmVuID0gZG9tLmNoaWxkTm9kZXMsIGNoaWxkcmVuID0gW10sIGtleWVkID0ge30sIGtleWVkTGVuID0gMCwgbWluID0gMCwgbGVuID0gb3JpZ2luYWxDaGlsZHJlbi5sZW5ndGgsIGNoaWxkcmVuTGVuID0gMCwgdmxlbiA9IHZjaGlsZHJlbiA/IHZjaGlsZHJlbi5sZW5ndGggOiAwO1xuICAgICAgICBpZiAoMCAhPT0gbGVuKSBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2NoaWxkID0gb3JpZ2luYWxDaGlsZHJlbltpXSwgcHJvcHMgPSBfY2hpbGQuX19wcmVhY3RhdHRyXywga2V5ID0gdmxlbiAmJiBwcm9wcyA/IF9jaGlsZC5fY29tcG9uZW50ID8gX2NoaWxkLl9jb21wb25lbnQuX19rIDogcHJvcHMua2V5IDogbnVsbDtcbiAgICAgICAgICAgIGlmIChudWxsICE9IGtleSkge1xuICAgICAgICAgICAgICAgIGtleWVkTGVuKys7XG4gICAgICAgICAgICAgICAga2V5ZWRba2V5XSA9IF9jaGlsZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcHMgfHwgKHZvaWQgMCAhPT0gX2NoaWxkLnNwbGl0VGV4dCA/IGlzSHlkcmF0aW5nID8gX2NoaWxkLm5vZGVWYWx1ZS50cmltKCkgOiAhMCA6IGlzSHlkcmF0aW5nKSkgY2hpbGRyZW5bY2hpbGRyZW5MZW4rK10gPSBfY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDAgIT09IHZsZW4pIGZvciAodmFyIGkgPSAwOyBpIDwgdmxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2Y2hpbGQgPSB2Y2hpbGRyZW5baV07XG4gICAgICAgICAgICBjaGlsZCA9IG51bGw7XG4gICAgICAgICAgICB2YXIga2V5ID0gdmNoaWxkLmtleTtcbiAgICAgICAgICAgIGlmIChudWxsICE9IGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXllZExlbiAmJiB2b2lkIDAgIT09IGtleWVkW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBrZXllZFtrZXldO1xuICAgICAgICAgICAgICAgICAgICBrZXllZFtrZXldID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBrZXllZExlbi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNoaWxkICYmIG1pbiA8IGNoaWxkcmVuTGVuKSBmb3IgKGogPSBtaW47IGogPCBjaGlsZHJlbkxlbjsgaisrKSBpZiAodm9pZCAwICE9PSBjaGlsZHJlbltqXSAmJiBpc1NhbWVOb2RlVHlwZShjID0gY2hpbGRyZW5bal0sIHZjaGlsZCwgaXNIeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2pdID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSBjaGlsZHJlbkxlbiAtIDEpIGNoaWxkcmVuTGVuLS07XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IG1pbikgbWluKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZCA9IGlkaWZmKGNoaWxkLCB2Y2hpbGQsIGNvbnRleHQsIG1vdW50QWxsKTtcbiAgICAgICAgICAgIGYgPSBvcmlnaW5hbENoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSBkb20gJiYgY2hpbGQgIT09IGYpIGlmIChudWxsID09IGYpIGRvbS5hcHBlbmRDaGlsZChjaGlsZCk7IGVsc2UgaWYgKGNoaWxkID09PSBmLm5leHRTaWJsaW5nKSByZW1vdmVOb2RlKGYpOyBlbHNlIGRvbS5pbnNlcnRCZWZvcmUoY2hpbGQsIGYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXllZExlbikgZm9yICh2YXIgaSBpbiBrZXllZCkgaWYgKHZvaWQgMCAhPT0ga2V5ZWRbaV0pIHJlY29sbGVjdE5vZGVUcmVlKGtleWVkW2ldLCAhMSk7XG4gICAgICAgIHdoaWxlIChtaW4gPD0gY2hpbGRyZW5MZW4pIGlmICh2b2lkIDAgIT09IChjaGlsZCA9IGNoaWxkcmVuW2NoaWxkcmVuTGVuLS1dKSkgcmVjb2xsZWN0Tm9kZVRyZWUoY2hpbGQsICExKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjb2xsZWN0Tm9kZVRyZWUobm9kZSwgdW5tb3VudE9ubHkpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IG5vZGUuX2NvbXBvbmVudDtcbiAgICAgICAgaWYgKGNvbXBvbmVudCkgdW5tb3VudENvbXBvbmVudChjb21wb25lbnQpOyBlbHNlIHtcbiAgICAgICAgICAgIGlmIChudWxsICE9IG5vZGUuX19wcmVhY3RhdHRyXyAmJiBub2RlLl9fcHJlYWN0YXR0cl8ucmVmKSBub2RlLl9fcHJlYWN0YXR0cl8ucmVmKG51bGwpO1xuICAgICAgICAgICAgaWYgKCExID09PSB1bm1vdW50T25seSB8fCBudWxsID09IG5vZGUuX19wcmVhY3RhdHRyXykgcmVtb3ZlTm9kZShub2RlKTtcbiAgICAgICAgICAgIHJlbW92ZUNoaWxkcmVuKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKG5vZGUpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIHJlY29sbGVjdE5vZGVUcmVlKG5vZGUsICEwKTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpZmZBdHRyaWJ1dGVzKGRvbSwgYXR0cnMsIG9sZCkge1xuICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgZm9yIChuYW1lIGluIG9sZCkgaWYgKCghYXR0cnMgfHwgbnVsbCA9PSBhdHRyc1tuYW1lXSkgJiYgbnVsbCAhPSBvbGRbbmFtZV0pIHNldEFjY2Vzc29yKGRvbSwgbmFtZSwgb2xkW25hbWVdLCBvbGRbbmFtZV0gPSB2b2lkIDAsIGlzU3ZnTW9kZSk7XG4gICAgICAgIGZvciAobmFtZSBpbiBhdHRycykgaWYgKCEoJ2NoaWxkcmVuJyA9PT0gbmFtZSB8fCAnaW5uZXJIVE1MJyA9PT0gbmFtZSB8fCBuYW1lIGluIG9sZCAmJiBhdHRyc1tuYW1lXSA9PT0gKCd2YWx1ZScgPT09IG5hbWUgfHwgJ2NoZWNrZWQnID09PSBuYW1lID8gZG9tW25hbWVdIDogb2xkW25hbWVdKSkpIHNldEFjY2Vzc29yKGRvbSwgbmFtZSwgb2xkW25hbWVdLCBvbGRbbmFtZV0gPSBhdHRyc1tuYW1lXSwgaXNTdmdNb2RlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29sbGVjdENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBjb21wb25lbnQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgKGNvbXBvbmVudHNbbmFtZV0gfHwgKGNvbXBvbmVudHNbbmFtZV0gPSBbXSkpLnB1c2goY29tcG9uZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KEN0b3IsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpbnN0LCBsaXN0ID0gY29tcG9uZW50c1tDdG9yLm5hbWVdO1xuICAgICAgICBpZiAoQ3Rvci5wcm90b3R5cGUgJiYgQ3Rvci5wcm90b3R5cGUucmVuZGVyKSB7XG4gICAgICAgICAgICBpbnN0ID0gbmV3IEN0b3IocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgQ29tcG9uZW50LmNhbGwoaW5zdCwgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5zdCA9IG5ldyBDb21wb25lbnQocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgaW5zdC5jb25zdHJ1Y3RvciA9IEN0b3I7XG4gICAgICAgICAgICBpbnN0LnJlbmRlciA9IGRvUmVuZGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0KSBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGg7IGktLTsgKSBpZiAobGlzdFtpXS5jb25zdHJ1Y3RvciA9PT0gQ3Rvcikge1xuICAgICAgICAgICAgaW5zdC5fX2IgPSBsaXN0W2ldLl9fYjtcbiAgICAgICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRvUmVuZGVyKHByb3BzLCBzdGF0ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldENvbXBvbmVudFByb3BzKGNvbXBvbmVudCwgcHJvcHMsIG9wdHMsIGNvbnRleHQsIG1vdW50QWxsKSB7XG4gICAgICAgIGlmICghY29tcG9uZW50Ll9feCkge1xuICAgICAgICAgICAgY29tcG9uZW50Ll9feCA9ICEwO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5fX3IgPSBwcm9wcy5yZWYpIGRlbGV0ZSBwcm9wcy5yZWY7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50Ll9fayA9IHByb3BzLmtleSkgZGVsZXRlIHByb3BzLmtleTtcbiAgICAgICAgICAgIGlmICghY29tcG9uZW50LmJhc2UgfHwgbW91bnRBbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxNb3VudCkgY29tcG9uZW50LmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykgY29tcG9uZW50LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMocHJvcHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dCAhPT0gY29tcG9uZW50LmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudC5fX2MpIGNvbXBvbmVudC5fX2MgPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudC5fX3ApIGNvbXBvbmVudC5fX3AgPSBjb21wb25lbnQucHJvcHM7XG4gICAgICAgICAgICBjb21wb25lbnQucHJvcHMgPSBwcm9wcztcbiAgICAgICAgICAgIGNvbXBvbmVudC5fX3ggPSAhMTtcbiAgICAgICAgICAgIGlmICgwICE9PSBvcHRzKSBpZiAoMSA9PT0gb3B0cyB8fCAhMSAhPT0gb3B0aW9ucy5zeW5jQ29tcG9uZW50VXBkYXRlcyB8fCAhY29tcG9uZW50LmJhc2UpIHJlbmRlckNvbXBvbmVudChjb21wb25lbnQsIDEsIG1vdW50QWxsKTsgZWxzZSBlbnF1ZXVlUmVuZGVyKGNvbXBvbmVudCk7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50Ll9fcikgY29tcG9uZW50Ll9fcihjb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudChjb21wb25lbnQsIG9wdHMsIG1vdW50QWxsLCBpc0NoaWxkKSB7XG4gICAgICAgIGlmICghY29tcG9uZW50Ll9feCkge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkLCBpbnN0LCBjYmFzZSwgcHJvcHMgPSBjb21wb25lbnQucHJvcHMsIHN0YXRlID0gY29tcG9uZW50LnN0YXRlLCBjb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQsIHByZXZpb3VzUHJvcHMgPSBjb21wb25lbnQuX19wIHx8IHByb3BzLCBwcmV2aW91c1N0YXRlID0gY29tcG9uZW50Ll9fcyB8fCBzdGF0ZSwgcHJldmlvdXNDb250ZXh0ID0gY29tcG9uZW50Ll9fYyB8fCBjb250ZXh0LCBpc1VwZGF0ZSA9IGNvbXBvbmVudC5iYXNlLCBuZXh0QmFzZSA9IGNvbXBvbmVudC5fX2IsIGluaXRpYWxCYXNlID0gaXNVcGRhdGUgfHwgbmV4dEJhc2UsIGluaXRpYWxDaGlsZENvbXBvbmVudCA9IGNvbXBvbmVudC5fY29tcG9uZW50LCBza2lwID0gITE7XG4gICAgICAgICAgICBpZiAoaXNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQucHJvcHMgPSBwcmV2aW91c1Byb3BzO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zdGF0ZSA9IHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICAgICAgICAgICAgaWYgKDIgIT09IG9wdHMgJiYgY29tcG9uZW50LnNob3VsZENvbXBvbmVudFVwZGF0ZSAmJiAhMSA9PT0gY29tcG9uZW50LnNob3VsZENvbXBvbmVudFVwZGF0ZShwcm9wcywgc3RhdGUsIGNvbnRleHQpKSBza2lwID0gITA7IGVsc2UgaWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsVXBkYXRlKSBjb21wb25lbnQuY29tcG9uZW50V2lsbFVwZGF0ZShwcm9wcywgc3RhdGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudC5fX3AgPSBjb21wb25lbnQuX19zID0gY29tcG9uZW50Ll9fYyA9IGNvbXBvbmVudC5fX2IgPSBudWxsO1xuICAgICAgICAgICAgY29tcG9uZW50Ll9fZCA9ICExO1xuICAgICAgICAgICAgaWYgKCFza2lwKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWQgPSBjb21wb25lbnQucmVuZGVyKHByb3BzLCBzdGF0ZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5nZXRDaGlsZENvbnRleHQpIGNvbnRleHQgPSBleHRlbmQoZXh0ZW5kKHt9LCBjb250ZXh0KSwgY29tcG9uZW50LmdldENoaWxkQ29udGV4dCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgdG9Vbm1vdW50LCBiYXNlLCBjaGlsZENvbXBvbmVudCA9IHJlbmRlcmVkICYmIHJlbmRlcmVkLm5vZGVOYW1lO1xuICAgICAgICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBjaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRQcm9wcyA9IGdldE5vZGVQcm9wcyhyZW5kZXJlZCk7XG4gICAgICAgICAgICAgICAgICAgIGluc3QgPSBpbml0aWFsQ2hpbGRDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0ICYmIGluc3QuY29uc3RydWN0b3IgPT09IGNoaWxkQ29tcG9uZW50ICYmIGNoaWxkUHJvcHMua2V5ID09IGluc3QuX19rKSBzZXRDb21wb25lbnRQcm9wcyhpbnN0LCBjaGlsZFByb3BzLCAxLCBjb250ZXh0LCAhMSk7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9Vbm1vdW50ID0gaW5zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5fY29tcG9uZW50ID0gaW5zdCA9IGNyZWF0ZUNvbXBvbmVudChjaGlsZENvbXBvbmVudCwgY2hpbGRQcm9wcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0Ll9fYiA9IGluc3QuX19iIHx8IG5leHRCYXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdC5fX3UgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDb21wb25lbnRQcm9wcyhpbnN0LCBjaGlsZFByb3BzLCAwLCBjb250ZXh0LCAhMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJDb21wb25lbnQoaW5zdCwgMSwgbW91bnRBbGwsICEwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiYXNlID0gaW5zdC5iYXNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNiYXNlID0gaW5pdGlhbEJhc2U7XG4gICAgICAgICAgICAgICAgICAgIHRvVW5tb3VudCA9IGluaXRpYWxDaGlsZENvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvVW5tb3VudCkgY2Jhc2UgPSBjb21wb25lbnQuX2NvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsQmFzZSB8fCAxID09PSBvcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2Jhc2UpIGNiYXNlLl9jb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGRpZmYoY2Jhc2UsIHJlbmRlcmVkLCBjb250ZXh0LCBtb3VudEFsbCB8fCAhaXNVcGRhdGUsIGluaXRpYWxCYXNlICYmIGluaXRpYWxCYXNlLnBhcmVudE5vZGUsICEwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbEJhc2UgJiYgYmFzZSAhPT0gaW5pdGlhbEJhc2UgJiYgaW5zdCAhPT0gaW5pdGlhbENoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlUGFyZW50ID0gaW5pdGlhbEJhc2UucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VQYXJlbnQgJiYgYmFzZSAhPT0gYmFzZVBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVBhcmVudC5yZXBsYWNlQ2hpbGQoYmFzZSwgaW5pdGlhbEJhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0b1VubW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQmFzZS5fY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvbGxlY3ROb2RlVHJlZShpbml0aWFsQmFzZSwgITEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b1VubW91bnQpIHVubW91bnRDb21wb25lbnQodG9Vbm1vdW50KTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuYmFzZSA9IGJhc2U7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2UgJiYgIWlzQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudFJlZiA9IGNvbXBvbmVudCwgdCA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHQgPSB0Ll9fdSkgKGNvbXBvbmVudFJlZiA9IHQpLmJhc2UgPSBiYXNlO1xuICAgICAgICAgICAgICAgICAgICBiYXNlLl9jb21wb25lbnQgPSBjb21wb25lbnRSZWY7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UuX2NvbXBvbmVudENvbnN0cnVjdG9yID0gY29tcG9uZW50UmVmLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNVcGRhdGUgfHwgbW91bnRBbGwpIG1vdW50cy51bnNoaWZ0KGNvbXBvbmVudCk7IGVsc2UgaWYgKCFza2lwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRVcGRhdGUpIGNvbXBvbmVudC5jb21wb25lbnREaWRVcGRhdGUocHJldmlvdXNQcm9wcywgcHJldmlvdXNTdGF0ZSwgcHJldmlvdXNDb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hZnRlclVwZGF0ZSkgb3B0aW9ucy5hZnRlclVwZGF0ZShjb21wb25lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bGwgIT0gY29tcG9uZW50Ll9faCkgd2hpbGUgKGNvbXBvbmVudC5fX2gubGVuZ3RoKSBjb21wb25lbnQuX19oLnBvcCgpLmNhbGwoY29tcG9uZW50KTtcbiAgICAgICAgICAgIGlmICghZGlmZkxldmVsICYmICFpc0NoaWxkKSBmbHVzaE1vdW50cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ1aWxkQ29tcG9uZW50RnJvbVZOb2RlKGRvbSwgdm5vZGUsIGNvbnRleHQsIG1vdW50QWxsKSB7XG4gICAgICAgIHZhciBjID0gZG9tICYmIGRvbS5fY29tcG9uZW50LCBvcmlnaW5hbENvbXBvbmVudCA9IGMsIG9sZERvbSA9IGRvbSwgaXNEaXJlY3RPd25lciA9IGMgJiYgZG9tLl9jb21wb25lbnRDb25zdHJ1Y3RvciA9PT0gdm5vZGUubm9kZU5hbWUsIGlzT3duZXIgPSBpc0RpcmVjdE93bmVyLCBwcm9wcyA9IGdldE5vZGVQcm9wcyh2bm9kZSk7XG4gICAgICAgIHdoaWxlIChjICYmICFpc093bmVyICYmIChjID0gYy5fX3UpKSBpc093bmVyID0gYy5jb25zdHJ1Y3RvciA9PT0gdm5vZGUubm9kZU5hbWU7XG4gICAgICAgIGlmIChjICYmIGlzT3duZXIgJiYgKCFtb3VudEFsbCB8fCBjLl9jb21wb25lbnQpKSB7XG4gICAgICAgICAgICBzZXRDb21wb25lbnRQcm9wcyhjLCBwcm9wcywgMywgY29udGV4dCwgbW91bnRBbGwpO1xuICAgICAgICAgICAgZG9tID0gYy5iYXNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsQ29tcG9uZW50ICYmICFpc0RpcmVjdE93bmVyKSB7XG4gICAgICAgICAgICAgICAgdW5tb3VudENvbXBvbmVudChvcmlnaW5hbENvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgZG9tID0gb2xkRG9tID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgPSBjcmVhdGVDb21wb25lbnQodm5vZGUubm9kZU5hbWUsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChkb20gJiYgIWMuX19iKSB7XG4gICAgICAgICAgICAgICAgYy5fX2IgPSBkb207XG4gICAgICAgICAgICAgICAgb2xkRG9tID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENvbXBvbmVudFByb3BzKGMsIHByb3BzLCAxLCBjb250ZXh0LCBtb3VudEFsbCk7XG4gICAgICAgICAgICBkb20gPSBjLmJhc2U7XG4gICAgICAgICAgICBpZiAob2xkRG9tICYmIGRvbSAhPT0gb2xkRG9tKSB7XG4gICAgICAgICAgICAgICAgb2xkRG9tLl9jb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlY29sbGVjdE5vZGVUcmVlKG9sZERvbSwgITEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVubW91bnRDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmJlZm9yZVVubW91bnQpIG9wdGlvbnMuYmVmb3JlVW5tb3VudChjb21wb25lbnQpO1xuICAgICAgICB2YXIgYmFzZSA9IGNvbXBvbmVudC5iYXNlO1xuICAgICAgICBjb21wb25lbnQuX194ID0gITA7XG4gICAgICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbFVubW91bnQpIGNvbXBvbmVudC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgICAgICBjb21wb25lbnQuYmFzZSA9IG51bGw7XG4gICAgICAgIHZhciBpbm5lciA9IGNvbXBvbmVudC5fY29tcG9uZW50O1xuICAgICAgICBpZiAoaW5uZXIpIHVubW91bnRDb21wb25lbnQoaW5uZXIpOyBlbHNlIGlmIChiYXNlKSB7XG4gICAgICAgICAgICBpZiAoYmFzZS5fX3ByZWFjdGF0dHJfICYmIGJhc2UuX19wcmVhY3RhdHRyXy5yZWYpIGJhc2UuX19wcmVhY3RhdHRyXy5yZWYobnVsbCk7XG4gICAgICAgICAgICBjb21wb25lbnQuX19iID0gYmFzZTtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUoYmFzZSk7XG4gICAgICAgICAgICBjb2xsZWN0Q29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICAgICAgICByZW1vdmVDaGlsZHJlbihiYXNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcG9uZW50Ll9fcikgY29tcG9uZW50Ll9fcihudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX19kID0gITA7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGUgfHwge307XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlcih2bm9kZSwgcGFyZW50LCBtZXJnZSkge1xuICAgICAgICByZXR1cm4gZGlmZihtZXJnZSwgdm5vZGUsIHt9LCAhMSwgcGFyZW50LCAhMSk7XG4gICAgfVxuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIEVNUFRZX0NISUxEUkVOID0gW107XG4gICAgdmFyIGRlZmVyID0gJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgUHJvbWlzZSA/IFByb21pc2UucmVzb2x2ZSgpLnRoZW4uYmluZChQcm9taXNlLnJlc29sdmUoKSkgOiBzZXRUaW1lb3V0O1xuICAgIHZhciBJU19OT05fRElNRU5TSU9OQUwgPSAvYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmQvaTtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB2YXIgbW91bnRzID0gW107XG4gICAgdmFyIGRpZmZMZXZlbCA9IDA7XG4gICAgdmFyIGlzU3ZnTW9kZSA9ICExO1xuICAgIHZhciBoeWRyYXRpbmcgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50cyA9IHt9O1xuICAgIGV4dGVuZChDb21wb25lbnQucHJvdG90eXBlLCB7XG4gICAgICAgIHNldFN0YXRlOiBmdW5jdGlvbihzdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fX3MpIHRoaXMuX19zID0gZXh0ZW5kKHt9LCBzKTtcbiAgICAgICAgICAgIGV4dGVuZChzLCAnZnVuY3Rpb24nID09IHR5cGVvZiBzdGF0ZSA/IHN0YXRlKHMsIHRoaXMucHJvcHMpIDogc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSAodGhpcy5fX2ggPSB0aGlzLl9faCB8fCBbXSkucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICBlbnF1ZXVlUmVuZGVyKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgKHRoaXMuX19oID0gdGhpcy5fX2ggfHwgW10pLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgcmVuZGVyQ29tcG9uZW50KHRoaXMsIDIpO1xuICAgICAgICB9LFxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge31cbiAgICB9KTtcbiAgICB2YXIgcHJlYWN0ID0ge1xuICAgICAgICBoOiBoLFxuICAgICAgICBjcmVhdGVFbGVtZW50OiBoLFxuICAgICAgICBjbG9uZUVsZW1lbnQ6IGNsb25lRWxlbWVudCxcbiAgICAgICAgQ29tcG9uZW50OiBDb21wb25lbnQsXG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICByZXJlbmRlcjogcmVyZW5kZXIsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9O1xuICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgbW9kdWxlKSBtb2R1bGUuZXhwb3J0cyA9IHByZWFjdDsgZWxzZSBzZWxmLnByZWFjdCA9IHByZWFjdDtcbn0oKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWFjdC5qcy5tYXAiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHVuZGVmO1xuXG4vKipcbiAqIERlY29kZSBhIFVSSSBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFVSSSBlbmNvZGVkIHN0cmluZy5cbiAqIEByZXR1cm5zIHtTdHJpbmd8TnVsbH0gVGhlIGRlY29kZWQgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoaW5wdXQucmVwbGFjZSgvXFwrL2csICcgJykpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBlbmNvZGUgYSBnaXZlbiBpbnB1dC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIGVuY29kZWQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfE51bGx9IFRoZSBlbmNvZGVkIHN0cmluZy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU2ltcGxlIHF1ZXJ5IHN0cmluZyBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBwYXJzZWQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnkpIHtcbiAgdmFyIHBhcnNlciA9IC8oW149PyZdKyk9PyhbXiZdKikvZ1xuICAgICwgcmVzdWx0ID0ge31cbiAgICAsIHBhcnQ7XG5cbiAgd2hpbGUgKHBhcnQgPSBwYXJzZXIuZXhlYyhxdWVyeSkpIHtcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRbMV0pXG4gICAgICAsIHZhbHVlID0gZGVjb2RlKHBhcnRbMl0pO1xuXG4gICAgLy9cbiAgICAvLyBQcmV2ZW50IG92ZXJyaWRpbmcgb2YgZXhpc3RpbmcgcHJvcGVydGllcy4gVGhpcyBlbnN1cmVzIHRoYXQgYnVpbGQtaW5cbiAgICAvLyBtZXRob2RzIGxpa2UgYHRvU3RyaW5nYCBvciBfX3Byb3RvX18gYXJlIG5vdCBvdmVycmlkZW4gYnkgbWFsaWNpb3VzXG4gICAgLy8gcXVlcnlzdHJpbmdzLlxuICAgIC8vXG4gICAgLy8gSW4gdGhlIGNhc2UgaWYgZmFpbGVkIGRlY29kaW5nLCB3ZSB3YW50IHRvIG9taXQgdGhlIGtleS92YWx1ZSBwYWlyc1xuICAgIC8vIGZyb20gdGhlIHJlc3VsdC5cbiAgICAvL1xuICAgIGlmIChrZXkgPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGwgfHwga2V5IGluIHJlc3VsdCkgY29udGludWU7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcXVlcnkgc3RyaW5nIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwgcHJlZml4LlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5naWZ5KG9iaiwgcHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICB2YXIgcGFpcnMgPSBbXVxuICAgICwgdmFsdWVcbiAgICAsIGtleTtcblxuICAvL1xuICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxuICAvL1xuICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcmVmaXgpIHByZWZpeCA9ICc/JztcblxuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgICAvL1xuICAgICAgLy8gRWRnZSBjYXNlcyB3aGVyZSB3ZSBhY3R1YWxseSB3YW50IHRvIGVuY29kZSB0aGUgdmFsdWUgdG8gYW4gZW1wdHlcbiAgICAgIC8vIHN0cmluZyBpbnN0ZWFkIG9mIHRoZSBzdHJpbmdpZmllZCB2YWx1ZS5cbiAgICAgIC8vXG4gICAgICBpZiAoIXZhbHVlICYmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWYgfHwgaXNOYU4odmFsdWUpKSkge1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSBlbmNvZGVVUklDb21wb25lbnQoa2V5KTtcbiAgICAgIHZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcblxuICAgICAgLy9cbiAgICAgIC8vIElmIHdlIGZhaWxlZCB0byBlbmNvZGUgdGhlIHN0cmluZ3MsIHdlIHNob3VsZCBiYWlsIG91dCBhcyB3ZSBkb24ndFxuICAgICAgLy8gd2FudCB0byBhZGQgaW52YWxpZCBzdHJpbmdzIHRvIHRoZSBxdWVyeS5cbiAgICAgIC8vXG4gICAgICBpZiAoa2V5ID09PSBudWxsIHx8IHZhbHVlID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIHBhaXJzLnB1c2goa2V5ICsnPScrIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFpcnMubGVuZ3RoID8gcHJlZml4ICsgcGFpcnMuam9pbignJicpIDogJyc7XG59XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5leHBvcnRzLnN0cmluZ2lmeSA9IHF1ZXJ5c3RyaW5naWZ5O1xuZXhwb3J0cy5wYXJzZSA9IHF1ZXJ5c3RyaW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIHJlcXVpcmVkIHRvIGFkZCBhIHBvcnQgbnVtYmVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkZWZhdWx0LXBvcnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcG9ydCBQb3J0IG51bWJlciB3ZSBuZWVkIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IElzIGl0IGEgZGVmYXVsdCBwb3J0IGZvciB0aGUgZ2l2ZW4gcHJvdG9jb2xcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVkKHBvcnQsIHByb3RvY29sKSB7XG4gIHByb3RvY29sID0gcHJvdG9jb2wuc3BsaXQoJzonKVswXTtcbiAgcG9ydCA9ICtwb3J0O1xuXG4gIGlmICghcG9ydCkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICd3cyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDgwO1xuXG4gICAgY2FzZSAnaHR0cHMnOlxuICAgIGNhc2UgJ3dzcyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDQ0MztcblxuICAgIGNhc2UgJ2Z0cCc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDIxO1xuXG4gICAgY2FzZSAnZ29waGVyJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNzA7XG5cbiAgICBjYXNlICdmaWxlJzpcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcG9ydCAhPT0gMDtcbn07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwuUmVzaXplT2JzZXJ2ZXIgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcclxuICAgICAqIEEgY29sbGVjdGlvbiBvZiBzaGltcyB0aGF0IHByb3ZpZGUgbWluaW1hbCBmdW5jdGlvbmFsaXR5IG9mIHRoZSBFUzYgY29sbGVjdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogVGhlc2UgaW1wbGVtZW50YXRpb25zIGFyZSBub3QgbWVhbnQgdG8gYmUgdXNlZCBvdXRzaWRlIG9mIHRoZSBSZXNpemVPYnNlcnZlclxyXG4gICAgICogbW9kdWxlcyBhcyB0aGV5IGNvdmVyIG9ubHkgYSBsaW1pdGVkIHJhbmdlIG9mIHVzZSBjYXNlcy5cclxuICAgICAqL1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1qc2RvYywgdmFsaWQtanNkb2MgKi9cclxuICAgIHZhciBNYXBTaGltID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBpbmRleCBpbiBwcm92aWRlZCBhcnJheSB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gYXJyXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldEluZGV4KGFyciwga2V5KSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAtMTtcclxuICAgICAgICAgICAgYXJyLnNvbWUoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5WzBdID09PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzXzEucHJvdG90eXBlLCBcInNpemVcIiwge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19lbnRyaWVzX18ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9fZW50cmllc19fW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVsxXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICAgICAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fW2luZGV4XVsxXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5wdXNoKFtrZXksIHZhbHVlXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5fX2VudHJpZXNfXztcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KGVudHJpZXMsIGtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAofmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gISF+Z2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnNwbGljZSgwKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Kn0gW2N0eD1udWxsXVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGN0eCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN0eCA9PT0gdm9pZCAwKSB7IGN0eCA9IG51bGw7IH1cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLl9fZW50cmllc19fOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZW50cnlbMV0sIGVudHJ5WzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzXzE7XHJcbiAgICAgICAgfSgpKTtcclxuICAgIH0pKCk7XG5cbiAgICAvKipcclxuICAgICAqIERldGVjdHMgd2hldGhlciB3aW5kb3cgYW5kIGRvY3VtZW50IG9iamVjdHMgYXJlIGF2YWlsYWJsZSBpbiBjdXJyZW50IGVudmlyb25tZW50LlxyXG4gICAgICovXHJcbiAgICB2YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgPT09IGRvY3VtZW50O1xuXG4gICAgLy8gUmV0dXJucyBnbG9iYWwgb2JqZWN0IG9mIGEgY3VycmVudCBlbnZpcm9ubWVudC5cclxuICAgIHZhciBnbG9iYWwkMSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09PSBNYXRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXHJcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XHJcbiAgICB9KSgpO1xuXG4gICAgLyoqXHJcbiAgICAgKiBBIHNoaW0gZm9yIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgd2hpY2ggZmFsbHMgYmFjayB0byB0aGUgc2V0VGltZW91dCBpZlxyXG4gICAgICogZmlyc3Qgb25lIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmVxdWVzdHMnIGlkZW50aWZpZXIuXHJcbiAgICAgKi9cclxuICAgIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgLy8gSXQncyByZXF1aXJlZCB0byB1c2UgYSBib3VuZGVkIGZ1bmN0aW9uIGJlY2F1c2UgSUUgc29tZXRpbWVzIHRocm93c1xyXG4gICAgICAgICAgICAvLyBhbiBcIkludmFsaWQgY2FsbGluZyBvYmplY3RcIiBlcnJvciBpZiByQUYgaXMgaW52b2tlZCB3aXRob3V0IHRoZSBnbG9iYWxcclxuICAgICAgICAgICAgLy8gb2JqZWN0IG9uIHRoZSBsZWZ0IGhhbmQgc2lkZS5cclxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKGdsb2JhbCQxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjayhEYXRlLm5vdygpKTsgfSwgMTAwMCAvIDYwKTsgfTtcclxuICAgIH0pKCk7XG5cbiAgICAvLyBEZWZpbmVzIG1pbmltdW0gdGltZW91dCBiZWZvcmUgYWRkaW5nIGEgdHJhaWxpbmcgY2FsbC5cclxuICAgIHZhciB0cmFpbGluZ1RpbWVvdXQgPSAyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgd3JhcHBlciBmdW5jdGlvbiB3aGljaCBlbnN1cmVzIHRoYXQgcHJvdmlkZWQgY2FsbGJhY2sgd2lsbCBiZVxyXG4gICAgICogaW52b2tlZCBvbmx5IG9uY2UgZHVyaW5nIHRoZSBzcGVjaWZpZWQgZGVsYXkgcGVyaW9kLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgZGVsYXkgcGVyaW9kLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IC0gRGVsYXkgYWZ0ZXIgd2hpY2ggdG8gaW52b2tlIGNhbGxiYWNrLlxyXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0aHJvdHRsZSAoY2FsbGJhY2ssIGRlbGF5KSB7XHJcbiAgICAgICAgdmFyIGxlYWRpbmdDYWxsID0gZmFsc2UsIHRyYWlsaW5nQ2FsbCA9IGZhbHNlLCBsYXN0Q2FsbFRpbWUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEludm9rZXMgdGhlIG9yaWdpbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIGFuZCBzY2hlZHVsZXMgbmV3IGludm9jYXRpb24gaWZcclxuICAgICAgICAgKiB0aGUgXCJwcm94eVwiIHdhcyBjYWxsZWQgZHVyaW5nIGN1cnJlbnQgcmVxdWVzdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHJlc29sdmVQZW5kaW5nKCkge1xyXG4gICAgICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgICAgIGxlYWRpbmdDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0cmFpbGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgICAgIHByb3h5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsbGJhY2sgaW52b2tlZCBhZnRlciB0aGUgc3BlY2lmaWVkIGRlbGF5LiBJdCB3aWxsIGZ1cnRoZXIgcG9zdHBvbmVcclxuICAgICAgICAgKiBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBkZWxlZ2F0aW5nIGl0IHRvIHRoZVxyXG4gICAgICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHtcclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEocmVzb2x2ZVBlbmRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTY2hlZHVsZXMgaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBwcm94eSgpIHtcclxuICAgICAgICAgICAgdmFyIHRpbWVTdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVqZWN0IGltbWVkaWF0ZWx5IGZvbGxvd2luZyBjYWxscy5cclxuICAgICAgICAgICAgICAgIGlmICh0aW1lU3RhbXAgLSBsYXN0Q2FsbFRpbWUgPCB0cmFpbGluZ1RpbWVvdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBTY2hlZHVsZSBuZXcgY2FsbCB0byBiZSBpbiBpbnZva2VkIHdoZW4gdGhlIHBlbmRpbmcgb25lIGlzIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIFwidHJhbnNpdGlvbnNcIiB3aGljaCBuZXZlciBhY3R1YWxseSBzdGFydFxyXG4gICAgICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHkgc28gdGhlcmUgaXMgYSBjaGFuY2UgdGhhdCB3ZSBtaWdodCBtaXNzIG9uZSBpZiBjaGFuZ2VcclxuICAgICAgICAgICAgICAgIC8vIGhhcHBlbnMgYW1pZHMgdGhlIHBlbmRpbmcgaW52b2NhdGlvbi5cclxuICAgICAgICAgICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZWFkaW5nQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0cmFpbGluZ0NhbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodGltZW91dENhbGxiYWNrLCBkZWxheSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFzdENhbGxUaW1lID0gdGltZVN0YW1wO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJveHk7XHJcbiAgICB9XG5cbiAgICAvLyBNaW5pbXVtIGRlbGF5IGJlZm9yZSBpbnZva2luZyB0aGUgdXBkYXRlIG9mIG9ic2VydmVycy5cclxuICAgIHZhciBSRUZSRVNIX0RFTEFZID0gMjA7XHJcbiAgICAvLyBBIGxpc3Qgb2Ygc3Vic3RyaW5ncyBvZiBDU1MgcHJvcGVydGllcyB1c2VkIHRvIGZpbmQgdHJhbnNpdGlvbiBldmVudHMgdGhhdFxyXG4gICAgLy8gbWlnaHQgYWZmZWN0IGRpbWVuc2lvbnMgb2Ygb2JzZXJ2ZWQgZWxlbWVudHMuXHJcbiAgICB2YXIgdHJhbnNpdGlvbktleXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCcsICd3aWR0aCcsICdoZWlnaHQnLCAnc2l6ZScsICd3ZWlnaHQnXTtcclxuICAgIC8vIENoZWNrIGlmIE11dGF0aW9uT2JzZXJ2ZXIgaXMgYXZhaWxhYmxlLlxyXG4gICAgdmFyIG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XHJcbiAgICAvKipcclxuICAgICAqIFNpbmdsZXRvbiBjb250cm9sbGVyIGNsYXNzIHdoaWNoIGhhbmRsZXMgdXBkYXRlcyBvZiBSZXNpemVPYnNlcnZlciBpbnN0YW5jZXMuXHJcbiAgICAgKi9cclxuICAgIHZhciBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIERPTSBsaXN0ZW5lcnMgaGF2ZSBiZWVuIGFkZGVkLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGVsbHMgdGhhdCBjb250cm9sbGVyIGhhcyBzdWJzY3JpYmVkIGZvciBNdXRhdGlvbiBFdmVudHMuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogS2VlcHMgcmVmZXJlbmNlIHRvIHRoZSBpbnN0YW5jZSBvZiBNdXRhdGlvbk9ic2VydmVyLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZSB7TXV0YXRpb25PYnNlcnZlcn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgbGlzdCBvZiBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZSB7QXJyYXk8UmVzaXplT2JzZXJ2ZXJTUEk+fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnNfID0gW107XHJcbiAgICAgICAgICAgIHRoaXMub25UcmFuc2l0aW9uRW5kXyA9IHRoaXMub25UcmFuc2l0aW9uRW5kXy5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2ggPSB0aHJvdHRsZSh0aGlzLnJlZnJlc2guYmluZCh0aGlzKSwgUkVGUkVTSF9ERUxBWSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgb2JzZXJ2ZXIgdG8gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyU1BJfSBvYnNlcnZlciAtIE9ic2VydmVyIHRvIGJlIGFkZGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuYWRkT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgaWYgKCF+dGhpcy5vYnNlcnZlcnNfLmluZGV4T2Yob2JzZXJ2ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVyc18ucHVzaChvYnNlcnZlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQWRkIGxpc3RlbmVycyBpZiB0aGV5IGhhdmVuJ3QgYmVlbiBhZGRlZCB5ZXQuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RfKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJTUEl9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgcmVtb3ZlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZU9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVyc187XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IG9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIG9ic2VydmVyIGlmIGl0J3MgcHJlc2VudCBpbiByZWdpc3RyeS5cclxuICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGxpc3RlbmVycyBpZiBjb250cm9sbGVyIGhhcyBubyBjb25uZWN0ZWQgb2JzZXJ2ZXJzLlxyXG4gICAgICAgICAgICBpZiAoIW9ic2VydmVycy5sZW5ndGggJiYgdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RfKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEludm9rZXMgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuIEl0IHdpbGwgY29udGludWUgcnVubmluZyB1cGRhdGVzIGluc29mYXJcclxuICAgICAgICAgKiBpdCBkZXRlY3RzIGNoYW5nZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGFuZ2VzRGV0ZWN0ZWQgPSB0aGlzLnVwZGF0ZU9ic2VydmVyc18oKTtcclxuICAgICAgICAgICAgLy8gQ29udGludWUgcnVubmluZyB1cGRhdGVzIGlmIGNoYW5nZXMgaGF2ZSBiZWVuIGRldGVjdGVkIGFzIHRoZXJlIG1pZ2h0XHJcbiAgICAgICAgICAgIC8vIGJlIGZ1dHVyZSBvbmVzIGNhdXNlZCBieSBDU1MgdHJhbnNpdGlvbnMuXHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzRGV0ZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIGV2ZXJ5IG9ic2VydmVyIGZyb20gb2JzZXJ2ZXJzIGxpc3QgYW5kIG5vdGlmaWVzIHRoZW0gb2YgcXVldWVkXHJcbiAgICAgICAgICogZW50cmllcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgXCJ0cnVlXCIgaWYgYW55IG9ic2VydmVyIGhhcyBkZXRlY3RlZCBjaGFuZ2VzIGluXHJcbiAgICAgICAgICogICAgICBkaW1lbnNpb25zIG9mIGl0J3MgZWxlbWVudHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS51cGRhdGVPYnNlcnZlcnNfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBDb2xsZWN0IG9ic2VydmVycyB0aGF0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICAgICAgdmFyIGFjdGl2ZU9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzXy5maWx0ZXIoZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZ2F0aGVyQWN0aXZlKCksIG9ic2VydmVyLmhhc0FjdGl2ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gRGVsaXZlciBub3RpZmljYXRpb25zIGluIGEgc2VwYXJhdGUgY3ljbGUgaW4gb3JkZXIgdG8gYXZvaWQgYW55XHJcbiAgICAgICAgICAgIC8vIGNvbGxpc2lvbnMgYmV0d2VlbiBvYnNlcnZlcnMsIGUuZy4gd2hlbiBtdWx0aXBsZSBpbnN0YW5jZXMgb2ZcclxuICAgICAgICAgICAgLy8gUmVzaXplT2JzZXJ2ZXIgYXJlIHRyYWNraW5nIHRoZSBzYW1lIGVsZW1lbnQgYW5kIHRoZSBjYWxsYmFjayBvZiBvbmVcclxuICAgICAgICAgICAgLy8gb2YgdGhlbSBjaGFuZ2VzIGNvbnRlbnQgZGltZW5zaW9ucyBvZiB0aGUgb2JzZXJ2ZWQgdGFyZ2V0LiBTb21ldGltZXNcclxuICAgICAgICAgICAgLy8gdGhpcyBtYXkgcmVzdWx0IGluIG5vdGlmaWNhdGlvbnMgYmVpbmcgYmxvY2tlZCBmb3IgdGhlIHJlc3Qgb2Ygb2JzZXJ2ZXJzLlxyXG4gICAgICAgICAgICBhY3RpdmVPYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHsgcmV0dXJuIG9ic2VydmVyLmJyb2FkY2FzdEFjdGl2ZSgpOyB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZU9ic2VydmVycy5sZW5ndGggPiAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgRE9NIGxpc3RlbmVycy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5jb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBydW5uaW5nIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQgb3IgaWYgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IGFkZGVkLlxyXG4gICAgICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTdWJzY3JpcHRpb24gdG8gdGhlIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGlzIHVzZWQgYXMgYSB3b3JrYXJvdW5kIGZvclxyXG4gICAgICAgICAgICAvLyBkZWxheWVkIHRyYW5zaXRpb25zLiBUaGlzIHdheSBpdCdzIHBvc3NpYmxlIHRvIGNhcHR1cmUgYXQgbGVhc3QgdGhlXHJcbiAgICAgICAgICAgIC8vIGZpbmFsIHN0YXRlIG9mIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgaWYgKG11dGF0aW9uT2JzZXJ2ZXJTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLm9ic2VydmUoZG9jdW1lbnQsIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRyZWU6IHRydWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUuZGlzY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG4gICAgICAgICAgICAvLyBoYXZlIGJlZW4gYWxyZWFkeSByZW1vdmVkLlxyXG4gICAgICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCAhdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMub25UcmFuc2l0aW9uRW5kXyk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXykge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25FdmVudHNBZGRlZF8gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBcIlRyYW5zaXRpb25lbmRcIiBldmVudCBoYW5kbGVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge1RyYW5zaXRpb25FdmVudH0gZXZlbnRcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uVHJhbnNpdGlvbkVuZF8gPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIF9iID0gX2EucHJvcGVydHlOYW1lLCBwcm9wZXJ0eU5hbWUgPSBfYiA9PT0gdm9pZCAwID8gJycgOiBfYjtcclxuICAgICAgICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgdHJhbnNpdGlvbiBtYXkgYWZmZWN0IGRpbWVuc2lvbnMgb2YgYW4gZWxlbWVudC5cclxuICAgICAgICAgICAgdmFyIGlzUmVmbG93UHJvcGVydHkgPSB0cmFuc2l0aW9uS2V5cy5zb21lKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhIX5wcm9wZXJ0eU5hbWUuaW5kZXhPZihrZXkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGlzUmVmbG93UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGluc3RhbmNlIG9mIHRoZSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZV8gPSBuZXcgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VfO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSG9sZHMgcmVmZXJlbmNlIHRvIHRoZSBjb250cm9sbGVyJ3MgaW5zdGFuY2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5pbnN0YW5jZV8gPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXI7XHJcbiAgICB9KCkpO1xuXG4gICAgLyoqXHJcbiAgICAgKiBEZWZpbmVzIG5vbi13cml0YWJsZS9lbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHByb3ZpZGVkIHRhcmdldCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAtIE9iamVjdCBmb3Igd2hpY2ggdG8gZGVmaW5lIHByb3BlcnRpZXMuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBQcm9wZXJ0aWVzIHRvIGJlIGRlZmluZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUYXJnZXQgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB2YXIgZGVmaW5lQ29uZmlndXJhYmxlID0gKGZ1bmN0aW9uICh0YXJnZXQsIHByb3BzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKHByb3BzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IF9hW19pXTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJvcHNba2V5XSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfSk7XG5cbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGdsb2JhbCBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdmFyIGdldFdpbmRvd09mID0gKGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAvLyBBc3N1bWUgdGhhdCB0aGUgZWxlbWVudCBpcyBhbiBpbnN0YW5jZSBvZiBOb2RlLCB3aGljaCBtZWFucyB0aGF0IGl0XHJcbiAgICAgICAgLy8gaGFzIHRoZSBcIm93bmVyRG9jdW1lbnRcIiBwcm9wZXJ0eSBmcm9tIHdoaWNoIHdlIGNhbiByZXRyaWV2ZSBhXHJcbiAgICAgICAgLy8gY29ycmVzcG9uZGluZyBnbG9iYWwgb2JqZWN0LlxyXG4gICAgICAgIHZhciBvd25lckdsb2JhbCA9IHRhcmdldCAmJiB0YXJnZXQub3duZXJEb2N1bWVudCAmJiB0YXJnZXQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcclxuICAgICAgICAvLyBSZXR1cm4gdGhlIGxvY2FsIGdsb2JhbCBvYmplY3QgaWYgaXQncyBub3QgcG9zc2libGUgZXh0cmFjdCBvbmUgZnJvbVxyXG4gICAgICAgIC8vIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgICAgcmV0dXJuIG93bmVyR2xvYmFsIHx8IGdsb2JhbCQxO1xyXG4gICAgfSk7XG5cbiAgICAvLyBQbGFjZWhvbGRlciBvZiBhbiBlbXB0eSBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgIHZhciBlbXB0eVJlY3QgPSBjcmVhdGVSZWN0SW5pdCgwLCAwLCAwLCAwKTtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgcHJvdmlkZWQgc3RyaW5nIHRvIGEgbnVtYmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRvRmxvYXQodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXh0cmFjdHMgYm9yZGVycyBzaXplIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXHJcbiAgICAgKiBAcGFyYW0gey4uLnN0cmluZ30gcG9zaXRpb25zIC0gQm9yZGVycyBwb3NpdGlvbnMgKHRvcCwgcmlnaHQsIC4uLilcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcykge1xyXG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBwb3NpdGlvbnNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb3NpdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChzaXplLCBwb3NpdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ2JvcmRlci0nICsgcG9zaXRpb24gKyAnLXdpZHRoJ107XHJcbiAgICAgICAgICAgIHJldHVybiBzaXplICsgdG9GbG9hdCh2YWx1ZSk7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4dHJhY3RzIHBhZGRpbmdzIHNpemVzIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBQYWRkaW5ncyBib3guXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldFBhZGRpbmdzKHN0eWxlcykge1xyXG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xyXG4gICAgICAgIHZhciBwYWRkaW5ncyA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcG9zaXRpb25zXzEgPSBwb3NpdGlvbnM7IF9pIDwgcG9zaXRpb25zXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHBvc2l0aW9uc18xW19pXTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVzWydwYWRkaW5nLScgKyBwb3NpdGlvbl07XHJcbiAgICAgICAgICAgIHBhZGRpbmdzW3Bvc2l0aW9uXSA9IHRvRmxvYXQodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFkZGluZ3M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgU1ZHIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTVkdHcmFwaGljc0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHNcclxuICAgICAqICAgICAgdG8gYmUgY2FsY3VsYXRlZC5cclxuICAgICAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0U1ZHQ29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIGJib3ggPSB0YXJnZXQuZ2V0QkJveCgpO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVSZWN0SW5pdCgwLCAwLCBiYm94LndpZHRoLCBiYm94LmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgSFRNTEVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCBmb3Igd2hpY2ggdG8gY2FsY3VsYXRlIHRoZSBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRDb250ZW50UmVjdCh0YXJnZXQpIHtcclxuICAgICAgICAvLyBDbGllbnQgd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBjYW4ndCBiZVxyXG4gICAgICAgIC8vIHVzZWQgZXhjbHVzaXZlbHkgYXMgdGhleSBwcm92aWRlIHJvdW5kZWQgdmFsdWVzLlxyXG4gICAgICAgIHZhciBjbGllbnRXaWR0aCA9IHRhcmdldC5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0ID0gdGFyZ2V0LmNsaWVudEhlaWdodDtcclxuICAgICAgICAvLyBCeSB0aGlzIGNvbmRpdGlvbiB3ZSBjYW4gY2F0Y2ggYWxsIG5vbi1yZXBsYWNlZCBpbmxpbmUsIGhpZGRlbiBhbmRcclxuICAgICAgICAvLyBkZXRhY2hlZCBlbGVtZW50cy4gVGhvdWdoIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBsZXNzXHJcbiAgICAgICAgLy8gdGhhbiAwLjUgd2lsbCBiZSBkaXNjYXJkZWQgYXMgd2VsbC5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFdpdGhvdXQgaXQgd2Ugd291bGQgbmVlZCB0byBpbXBsZW1lbnQgc2VwYXJhdGUgbWV0aG9kcyBmb3IgZWFjaCBvZlxyXG4gICAgICAgIC8vIHRob3NlIGNhc2VzIGFuZCBpdCdzIG5vdCBwb3NzaWJsZSB0byBwZXJmb3JtIGEgcHJlY2lzZSBhbmQgcGVyZm9ybWFuY2VcclxuICAgICAgICAvLyBlZmZlY3RpdmUgdGVzdCBmb3IgaGlkZGVuIGVsZW1lbnRzLiBFLmcuIGV2ZW4galF1ZXJ5J3MgJzp2aXNpYmxlJyBmaWx0ZXJcclxuICAgICAgICAvLyBnaXZlcyB3cm9uZyByZXN1bHRzIGZvciBlbGVtZW50cyB3aXRoIHdpZHRoICYgaGVpZ2h0IGxlc3MgdGhhbiAwLjUuXHJcbiAgICAgICAgaWYgKCFjbGllbnRXaWR0aCAmJiAhY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbXB0eVJlY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdHlsZXMgPSBnZXRXaW5kb3dPZih0YXJnZXQpLmdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcclxuICAgICAgICB2YXIgcGFkZGluZ3MgPSBnZXRQYWRkaW5ncyhzdHlsZXMpO1xyXG4gICAgICAgIHZhciBob3JpelBhZCA9IHBhZGRpbmdzLmxlZnQgKyBwYWRkaW5ncy5yaWdodDtcclxuICAgICAgICB2YXIgdmVydFBhZCA9IHBhZGRpbmdzLnRvcCArIHBhZGRpbmdzLmJvdHRvbTtcclxuICAgICAgICAvLyBDb21wdXRlZCBzdHlsZXMgb2Ygd2lkdGggJiBoZWlnaHQgYXJlIGJlaW5nIHVzZWQgYmVjYXVzZSB0aGV5IGFyZSB0aGVcclxuICAgICAgICAvLyBvbmx5IGRpbWVuc2lvbnMgYXZhaWxhYmxlIHRvIEpTIHRoYXQgY29udGFpbiBub24tcm91bmRlZCB2YWx1ZXMuIEl0IGNvdWxkXHJcbiAgICAgICAgLy8gYmUgcG9zc2libGUgdG8gdXRpbGl6ZSB0aGUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlmIG9ubHkgaXQncyBkYXRhIHdhc24ndFxyXG4gICAgICAgIC8vIGFmZmVjdGVkIGJ5IENTUyB0cmFuc2Zvcm1hdGlvbnMgbGV0IGFsb25lIHBhZGRpbmdzLCBib3JkZXJzIGFuZCBzY3JvbGwgYmFycy5cclxuICAgICAgICB2YXIgd2lkdGggPSB0b0Zsb2F0KHN0eWxlcy53aWR0aCksIGhlaWdodCA9IHRvRmxvYXQoc3R5bGVzLmhlaWdodCk7XHJcbiAgICAgICAgLy8gV2lkdGggJiBoZWlnaHQgaW5jbHVkZSBwYWRkaW5ncyBhbmQgYm9yZGVycyB3aGVuIHRoZSAnYm9yZGVyLWJveCcgYm94XHJcbiAgICAgICAgLy8gbW9kZWwgaXMgYXBwbGllZCAoZXhjZXB0IGZvciBJRSkuXHJcbiAgICAgICAgaWYgKHN0eWxlcy5ib3hTaXppbmcgPT09ICdib3JkZXItYm94Jykge1xyXG4gICAgICAgICAgICAvLyBGb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgcmVxdWlyZWQgdG8gaGFuZGxlIEludGVybmV0IEV4cGxvcmVyIHdoaWNoXHJcbiAgICAgICAgICAgIC8vIGRvZXNuJ3QgaW5jbHVkZSBwYWRkaW5ncyBhbmQgYm9yZGVycyB0byBjb21wdXRlZCBDU1MgZGltZW5zaW9ucy5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gV2UgY2FuIHNheSB0aGF0IGlmIENTUyBkaW1lbnNpb25zICsgcGFkZGluZ3MgYXJlIGVxdWFsIHRvIHRoZSBcImNsaWVudFwiXHJcbiAgICAgICAgICAgIC8vIHByb3BlcnRpZXMgdGhlbiBpdCdzIGVpdGhlciBJRSwgYW5kIHRodXMgd2UgZG9uJ3QgbmVlZCB0byBzdWJ0cmFjdFxyXG4gICAgICAgICAgICAvLyBhbnl0aGluZywgb3IgYW4gZWxlbWVudCBtZXJlbHkgZG9lc24ndCBoYXZlIHBhZGRpbmdzL2JvcmRlcnMgc3R5bGVzLlxyXG4gICAgICAgICAgICBpZiAoTWF0aC5yb3VuZCh3aWR0aCArIGhvcml6UGFkKSAhPT0gY2xpZW50V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ2xlZnQnLCAncmlnaHQnKSArIGhvcml6UGFkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChNYXRoLnJvdW5kKGhlaWdodCArIHZlcnRQYWQpICE9PSBjbGllbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd0b3AnLCAnYm90dG9tJykgKyB2ZXJ0UGFkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEZvbGxvd2luZyBzdGVwcyBjYW4ndCBiZSBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudCdzIHJvb3QgZWxlbWVudCBhcyBpdHNcclxuICAgICAgICAvLyBjbGllbnRbV2lkdGgvSGVpZ2h0XSBwcm9wZXJ0aWVzIHJlcHJlc2VudCB2aWV3cG9ydCBhcmVhIG9mIHRoZSB3aW5kb3cuXHJcbiAgICAgICAgLy8gQmVzaWRlcywgaXQncyBhcyB3ZWxsIG5vdCBuZWNlc3NhcnkgYXMgdGhlIDxodG1sPiBpdHNlbGYgbmVpdGhlciBoYXNcclxuICAgICAgICAvLyByZW5kZXJlZCBzY3JvbGwgYmFycyBub3IgaXQgY2FuIGJlIGNsaXBwZWQuXHJcbiAgICAgICAgaWYgKCFpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMgKG9ubHkgaW4gRmlyZWZveCwgYWN0dWFsbHkpIENTUyB3aWR0aCAmIGhlaWdodFxyXG4gICAgICAgICAgICAvLyBpbmNsdWRlIHNjcm9sbCBiYXJzIHNpemUgd2hpY2ggY2FuIGJlIHJlbW92ZWQgYXQgdGhpcyBzdGVwIGFzIHNjcm9sbFxyXG4gICAgICAgICAgICAvLyBiYXJzIGFyZSB0aGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gcm91bmRlZCBkaW1lbnNpb25zICsgcGFkZGluZ3NcclxuICAgICAgICAgICAgLy8gYW5kIFwiY2xpZW50XCIgcHJvcGVydGllcywgdGhvdWdoIHRoYXQgaXMgbm90IGFsd2F5cyB0cnVlIGluIENocm9tZS5cclxuICAgICAgICAgICAgdmFyIHZlcnRTY3JvbGxiYXIgPSBNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpIC0gY2xpZW50V2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBob3JpelNjcm9sbGJhciA9IE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgLSBjbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgIC8vIENocm9tZSBoYXMgYSByYXRoZXIgd2VpcmQgcm91bmRpbmcgb2YgXCJjbGllbnRcIiBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAvLyBFLmcuIGZvciBhbiBlbGVtZW50IHdpdGggY29udGVudCB3aWR0aCBvZiAzMTQuMnB4IGl0IHNvbWV0aW1lcyBnaXZlc1xyXG4gICAgICAgICAgICAvLyB0aGUgY2xpZW50IHdpZHRoIG9mIDMxNXB4IGFuZCBmb3IgdGhlIHdpZHRoIG9mIDMxNC43cHggaXQgbWF5IGdpdmVcclxuICAgICAgICAgICAgLy8gMzE0cHguIEFuZCBpdCBkb2Vzbid0IGhhcHBlbiBhbGwgdGhlIHRpbWUuIFNvIGp1c3QgaWdub3JlIHRoaXMgZGVsdGFcclxuICAgICAgICAgICAgLy8gYXMgYSBub24tcmVsZXZhbnQuXHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh2ZXJ0U2Nyb2xsYmFyKSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgd2lkdGggLT0gdmVydFNjcm9sbGJhcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoaG9yaXpTY3JvbGxiYXIpICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgLT0gaG9yaXpTY3JvbGxiYXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3RJbml0KHBhZGRpbmdzLmxlZnQsIHBhZGRpbmdzLnRvcCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHByb3ZpZGVkIGVsZW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIFNWR0dyYXBoaWNzRWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB2YXIgaXNTVkdHcmFwaGljc0VsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFNvbWUgYnJvd3NlcnMsIG5hbWVseSBJRSBhbmQgRWRnZSwgZG9uJ3QgaGF2ZSB0aGUgU1ZHR3JhcGhpY3NFbGVtZW50XHJcbiAgICAgICAgLy8gaW50ZXJmYWNlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgU1ZHR3JhcGhpY3NFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdHcmFwaGljc0VsZW1lbnQ7IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGl0J3Mgc28sIHRoZW4gY2hlY2sgdGhhdCBlbGVtZW50IGlzIGF0IGxlYXN0IGFuIGluc3RhbmNlIG9mIHRoZVxyXG4gICAgICAgIC8vIFNWR0VsZW1lbnQgYW5kIHRoYXQgaXQgaGFzIHRoZSBcImdldEJCb3hcIiBtZXRob2QuXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXBhcmVuc1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiAodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdFbGVtZW50ICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiB0YXJnZXQuZ2V0QkJveCA9PT0gJ2Z1bmN0aW9uJyk7IH07XHJcbiAgICB9KSgpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciBwcm92aWRlZCBlbGVtZW50IGlzIGEgZG9jdW1lbnQgZWxlbWVudCAoPGh0bWw+KS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0ID09PSBnZXRXaW5kb3dPZih0YXJnZXQpLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyBhbiBhcHByb3ByaWF0ZSBjb250ZW50IHJlY3RhbmdsZSBmb3IgcHJvdmlkZWQgaHRtbCBvciBzdmcgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHMgdG8gYmUgY2FsY3VsYXRlZC5cclxuICAgICAqIEByZXR1cm5zIHtET01SZWN0SW5pdH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5UmVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzU1ZHR3JhcGhpY3NFbGVtZW50KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldFNWR0NvbnRlbnRSZWN0KHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBnZXRIVE1MRWxlbWVudENvbnRlbnRSZWN0KHRhcmdldCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgcmVjdGFuZ2xlIHdpdGggYW4gaW50ZXJmYWNlIG9mIHRoZSBET01SZWN0UmVhZE9ubHkuXHJcbiAgICAgKiBTcGVjOiBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jZG9tcmVjdHJlYWRvbmx5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtET01SZWN0SW5pdH0gcmVjdEluaXQgLSBPYmplY3Qgd2l0aCByZWN0YW5nbGUncyB4L3kgY29vcmRpbmF0ZXMgYW5kIGRpbWVuc2lvbnMuXHJcbiAgICAgKiBAcmV0dXJucyB7RE9NUmVjdFJlYWRPbmx5fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVSZWFkT25seVJlY3QoX2EpIHtcclxuICAgICAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55LCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XHJcbiAgICAgICAgLy8gSWYgRE9NUmVjdFJlYWRPbmx5IGlzIGF2YWlsYWJsZSB1c2UgaXQgYXMgYSBwcm90b3R5cGUgZm9yIHRoZSByZWN0YW5nbGUuXHJcbiAgICAgICAgdmFyIENvbnN0ciA9IHR5cGVvZiBET01SZWN0UmVhZE9ubHkgIT09ICd1bmRlZmluZWQnID8gRE9NUmVjdFJlYWRPbmx5IDogT2JqZWN0O1xyXG4gICAgICAgIHZhciByZWN0ID0gT2JqZWN0LmNyZWF0ZShDb25zdHIucHJvdG90eXBlKTtcclxuICAgICAgICAvLyBSZWN0YW5nbGUncyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlLlxyXG4gICAgICAgIGRlZmluZUNvbmZpZ3VyYWJsZShyZWN0LCB7XHJcbiAgICAgICAgICAgIHg6IHgsIHk6IHksIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgIHRvcDogeSxcclxuICAgICAgICAgICAgcmlnaHQ6IHggKyB3aWR0aCxcclxuICAgICAgICAgICAgYm90dG9tOiBoZWlnaHQgKyB5LFxyXG4gICAgICAgICAgICBsZWZ0OiB4XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgRE9NUmVjdEluaXQgb2JqZWN0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBkaW1lbnNpb25zIGFuZCB0aGUgeC95IGNvb3JkaW5hdGVzLlxyXG4gICAgICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RpY3RkZWYtZG9tcmVjdGluaXRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFggY29vcmRpbmF0ZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBjb29yZGluYXRlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gUmVjdGFuZ2xlJ3Mgd2lkdGguXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gUmVjdGFuZ2xlJ3MgaGVpZ2h0LlxyXG4gICAgICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVSZWN0SW5pdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG4gICAgfVxuXG4gICAgLyoqXHJcbiAgICAgKiBDbGFzcyB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBjb21wdXRhdGlvbnMgb2YgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlIG9mXHJcbiAgICAgKiBwcm92aWRlZCBET00gZWxlbWVudCBhbmQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgaXQncyBjaGFuZ2VzLlxyXG4gICAgICovXHJcbiAgICB2YXIgUmVzaXplT2JzZXJ2YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBiZSBvYnNlcnZlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEJyb2FkY2FzdGVkIHdpZHRoIG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCcm9hZGNhc3RlZCBoZWlnaHQgb2YgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlIHtET01SZWN0SW5pdH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY29udGVudFJlY3RfID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIGFuZCB0ZWxscyB3aGV0aGVyIGl0J3Mgd2lkdGggb3IgaGVpZ2h0IHByb3BlcnRpZXNcclxuICAgICAgICAgKiBoYXZlIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYnJvYWRjYXN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVjdCA9IGdldENvbnRlbnRSZWN0KHRoaXMudGFyZ2V0KTtcclxuICAgICAgICAgICAgdGhpcy5jb250ZW50UmVjdF8gPSByZWN0O1xyXG4gICAgICAgICAgICByZXR1cm4gKHJlY3Qud2lkdGggIT09IHRoaXMuYnJvYWRjYXN0V2lkdGggfHxcclxuICAgICAgICAgICAgICAgIHJlY3QuaGVpZ2h0ICE9PSB0aGlzLmJyb2FkY2FzdEhlaWdodCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzICdicm9hZGNhc3RXaWR0aCcgYW5kICdicm9hZGNhc3RIZWlnaHQnIHByb3BlcnRpZXMgd2l0aCBhIGRhdGFcclxuICAgICAgICAgKiBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnRpZXMgb2YgdGhlIGxhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9IExhc3Qgb2JzZXJ2ZWQgY29udGVudCByZWN0YW5nbGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmJyb2FkY2FzdFJlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5jb250ZW50UmVjdF87XHJcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0V2lkdGggPSByZWN0LndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgICAgICByZXR1cm4gcmVjdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBSZXNpemVPYnNlcnZhdGlvbjtcclxuICAgIH0oKSk7XG5cbiAgICB2YXIgUmVzaXplT2JzZXJ2ZXJFbnRyeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFJlc2l6ZU9ic2VydmVyRW50cnkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdGhhdCBpcyBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge0RPTVJlY3RJbml0fSByZWN0SW5pdCAtIERhdGEgb2YgdGhlIGVsZW1lbnQncyBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5KHRhcmdldCwgcmVjdEluaXQpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRlbnRSZWN0ID0gY3JlYXRlUmVhZE9ubHlSZWN0KHJlY3RJbml0KTtcclxuICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpY2F0aW9uIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGVcclxuICAgICAgICAgICAgLy8gYW5kIGFyZSBhbHNvIG5vdCBlbnVtZXJhYmxlIGluIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIFByb3BlcnR5IGFjY2Vzc29ycyBhcmUgbm90IGJlaW5nIHVzZWQgYXMgdGhleSdkIHJlcXVpcmUgdG8gZGVmaW5lIGFcclxuICAgICAgICAgICAgLy8gcHJpdmF0ZSBXZWFrTWFwIHN0b3JhZ2Ugd2hpY2ggbWF5IGNhdXNlIG1lbW9yeSBsZWFrcyBpbiBicm93c2VycyB0aGF0XHJcbiAgICAgICAgICAgIC8vIGRvbid0IHN1cHBvcnQgdGhpcyB0eXBlIG9mIGNvbGxlY3Rpb25zLlxyXG4gICAgICAgICAgICBkZWZpbmVDb25maWd1cmFibGUodGhpcywgeyB0YXJnZXQ6IHRhcmdldCwgY29udGVudFJlY3Q6IGNvbnRlbnRSZWN0IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJFbnRyeTtcclxuICAgIH0oKSk7XG5cbiAgICB2YXIgUmVzaXplT2JzZXJ2ZXJTUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIGludm9rZWRcclxuICAgICAgICAgKiAgICAgIHdoZW4gb25lIG9mIHRoZSBvYnNlcnZlZCBlbGVtZW50cyBjaGFuZ2VzIGl0J3MgY29udGVudCBkaW1lbnNpb25zLlxyXG4gICAgICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfSBjb250cm9sbGVyIC0gQ29udHJvbGxlciBpbnN0YW5jZSB3aGljaFxyXG4gICAgICAgICAqICAgICAgaXMgcmVzcG9uc2libGUgZm9yIHRoZSB1cGRhdGVzIG9mIG9ic2VydmVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJ9IGNhbGxiYWNrQ3R4IC0gUmVmZXJlbmNlIHRvIHRoZSBwdWJsaWNcclxuICAgICAgICAgKiAgICAgIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyU1BJKGNhbGxiYWNrLCBjb250cm9sbGVyLCBjYWxsYmFja0N0eCkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29sbGVjdGlvbiBvZiByZXNpemUgb2JzZXJ2YXRpb25zIHRoYXQgaGF2ZSBkZXRlY3RlZCBjaGFuZ2VzIGluIGRpbWVuc2lvbnNcclxuICAgICAgICAgICAgICogb2YgZWxlbWVudHMuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlIHtBcnJheTxSZXNpemVPYnNlcnZhdGlvbj59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18gPSBbXTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlZ2lzdHJ5IG9mIHRoZSBSZXNpemVPYnNlcnZhdGlvbiBpbnN0YW5jZXMuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBwcml2YXRlIHtNYXA8RWxlbWVudCwgUmVzaXplT2JzZXJ2YXRpb24+fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfID0gbmV3IE1hcFNoaW0oKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGNhbGxiYWNrIHByb3ZpZGVkIGFzIHBhcmFtZXRlciAxIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tfID0gY2FsbGJhY2s7XHJcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcl8gPSBjb250cm9sbGVyO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrQ3R4XyA9IGNhbGxiYWNrQ3R4O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdGFydHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICEoRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLkVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgb2JzZXJ2YXRpb25zID0gdGhpcy5vYnNlcnZhdGlvbnNfO1xyXG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICAgICAgaWYgKG9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9ic2VydmF0aW9ucy5zZXQodGFyZ2V0LCBuZXcgUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0KSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcl8uYWRkT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICAgICAgICAgIC8vIEZvcmNlIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2YXRpb25zLlxyXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlZnJlc2goKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0b3BzIG9ic2VydmluZyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIHN0b3Agb2JzZXJ2aW5nLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS51bm9ic2VydmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICEoRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLkVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgb2JzZXJ2YXRpb25zID0gdGhpcy5vYnNlcnZhdGlvbnNfO1xyXG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGVsZW1lbnQgaXMgbm90IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgICAgICBpZiAoIW9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9ic2VydmF0aW9ucy5kZWxldGUodGFyZ2V0KTtcclxuICAgICAgICAgICAgaWYgKCFvYnNlcnZhdGlvbnMuc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyXy5yZW1vdmVPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RvcHMgb2JzZXJ2aW5nIGFsbCBlbGVtZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXy5jbGVhcigpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlbW92ZU9ic2VydmVyKHRoaXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29sbGVjdHMgb2JzZXJ2YXRpb24gaW5zdGFuY2VzIHRoZSBhc3NvY2lhdGVkIGVsZW1lbnQgb2Ygd2hpY2ggaGFzIGNoYW5nZWRcclxuICAgICAgICAgKiBpdCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmdhdGhlckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18uZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZhdGlvbi5pc0FjdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5wdXNoKG9ic2VydmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnZva2VzIGluaXRpYWwgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBhIGxpc3Qgb2YgUmVzaXplT2JzZXJ2ZXJFbnRyeVxyXG4gICAgICAgICAqIGluc3RhbmNlcyBjb2xsZWN0ZWQgZnJvbSBhY3RpdmUgcmVzaXplIG9ic2VydmF0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5icm9hZGNhc3RBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgb2JzZXJ2ZXIgZG9lc24ndCBoYXZlIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNhbGxiYWNrQ3R4XztcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIFJlc2l6ZU9ic2VydmVyRW50cnkgaW5zdGFuY2UgZm9yIGV2ZXJ5IGFjdGl2ZSBvYnNlcnZhdGlvbi5cclxuICAgICAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ubWFwKGZ1bmN0aW9uIChvYnNlcnZhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlckVudHJ5KG9ic2VydmF0aW9uLnRhcmdldCwgb2JzZXJ2YXRpb24uYnJvYWRjYXN0UmVjdCgpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tfLmNhbGwoY3R4LCBlbnRyaWVzLCBjdHgpO1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyQWN0aXZlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhcnMgdGhlIGNvbGxlY3Rpb24gb2YgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5jbGVhckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLnNwbGljZSgwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlbGxzIHdoZXRoZXIgb2JzZXJ2ZXIgaGFzIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUuaGFzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUmVzaXplT2JzZXJ2ZXJTUEk7XHJcbiAgICB9KCkpO1xuXG4gICAgLy8gUmVnaXN0cnkgb2YgaW50ZXJuYWwgb2JzZXJ2ZXJzLiBJZiBXZWFrTWFwIGlzIG5vdCBhdmFpbGFibGUgdXNlIGN1cnJlbnQgc2hpbVxyXG4gICAgLy8gZm9yIHRoZSBNYXAgY29sbGVjdGlvbiBhcyBpdCBoYXMgYWxsIHJlcXVpcmVkIG1ldGhvZHMgYW5kIGJlY2F1c2UgV2Vha01hcFxyXG4gICAgLy8gY2FuJ3QgYmUgZnVsbHkgcG9seWZpbGxlZCBhbnl3YXkuXHJcbiAgICB2YXIgb2JzZXJ2ZXJzID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnID8gbmV3IFdlYWtNYXAoKSA6IG5ldyBNYXBTaGltKCk7XHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZU9ic2VydmVyIEFQSS4gRW5jYXBzdWxhdGVzIHRoZSBSZXNpemVPYnNlcnZlciBTUEkgaW1wbGVtZW50YXRpb25cclxuICAgICAqIGV4cG9zaW5nIG9ubHkgdGhvc2UgbWV0aG9kcyBhbmQgcHJvcGVydGllcyB0aGF0IGFyZSBkZWZpbmVkIGluIHRoZSBzcGVjLlxyXG4gICAgICovXHJcbiAgICB2YXIgUmVzaXplT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsYmFjayB0aGF0IGlzIGludm9rZWQgd2hlblxyXG4gICAgICAgICAqICAgICAgZGltZW5zaW9ucyBvZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudHMgY2hhbmdlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNpemVPYnNlcnZlcikpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29udHJvbGxlciA9IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXJTUEkoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIHRoaXMpO1xyXG4gICAgICAgICAgICBvYnNlcnZlcnMuc2V0KHRoaXMsIG9ic2VydmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xyXG4gICAgfSgpKTtcclxuICAgIC8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kcyBvZiBSZXNpemVPYnNlcnZlci5cclxuICAgIFtcclxuICAgICAgICAnb2JzZXJ2ZScsXHJcbiAgICAgICAgJ3Vub2JzZXJ2ZScsXHJcbiAgICAgICAgJ2Rpc2Nvbm5lY3QnXHJcbiAgICBdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gICAgICAgIFJlc2l6ZU9ic2VydmVyLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBvYnNlcnZlcnMuZ2V0KHRoaXMpKVttZXRob2RdLmFwcGx5KF9hLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcblxuICAgIHZhciBpbmRleCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRXhwb3J0IGV4aXN0aW5nIGltcGxlbWVudGF0aW9uIGlmIGF2YWlsYWJsZS5cclxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsJDEuUmVzaXplT2JzZXJ2ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZXNpemVPYnNlcnZlcjtcclxuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gaW5kZXg7XG5cbn0pKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZpbmdlcnByaW50O1xuXG52YXIgX2lzUmVhY3ROYXRpdmUgPSByZXF1aXJlKFwiLi9pc1JlYWN0TmF0aXZlXCIpO1xuXG52YXIgX2lzUmVhY3ROYXRpdmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNSZWFjdE5hdGl2ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogR2VuZXJhdGUgYSBmaW5nZXJwcmludCBmb3IgYSBmaWxlIHdoaWNoIHdpbGwgYmUgdXNlZCB0aGUgc3RvcmUgdGhlIGVuZHBvaW50XG4gKlxuICogQHBhcmFtIHtGaWxlfSBmaWxlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gZmluZ2VycHJpbnQoZmlsZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYgKCgwLCBfaXNSZWFjdE5hdGl2ZTIuZGVmYXVsdCkoKSkge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZWFjdE5hdGl2ZUZpbmdlcnByaW50KGZpbGUsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjayhudWxsLCBbXCJ0dXMtYnJcIiwgZmlsZS5uYW1lLCBmaWxlLnR5cGUsIGZpbGUuc2l6ZSwgZmlsZS5sYXN0TW9kaWZpZWQsIG9wdGlvbnMuZW5kcG9pbnRdLmpvaW4oXCItXCIpKTtcbn1cblxuZnVuY3Rpb24gcmVhY3ROYXRpdmVGaW5nZXJwcmludChmaWxlLCBvcHRpb25zKSB7XG4gIHZhciBleGlmSGFzaCA9IGZpbGUuZXhpZiA/IGhhc2hDb2RlKEpTT04uc3RyaW5naWZ5KGZpbGUuZXhpZikpIDogXCJub2V4aWZcIjtcbiAgcmV0dXJuIFtcInR1cy1yblwiLCBmaWxlLm5hbWUgfHwgXCJub25hbWVcIiwgZmlsZS5zaXplIHx8IFwibm9zaXplXCIsIGV4aWZIYXNoLCBvcHRpb25zLmVuZHBvaW50XS5qb2luKFwiL1wiKTtcbn1cblxuZnVuY3Rpb24gaGFzaENvZGUoc3RyKSB7XG4gIC8vIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg4MzE5MzcvMTUxNjY2XG4gIHZhciBoYXNoID0gMDtcbiAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gaGFzaDtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGFyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIGNoYXI7XG4gICAgaGFzaCA9IGhhc2ggJiBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuICByZXR1cm4gaGFzaDtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBpc0NvcmRvdmEgPSBmdW5jdGlvbiBpc0NvcmRvdmEoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgJiYgKHR5cGVvZiB3aW5kb3cuUGhvbmVHYXAgIT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2Ygd2luZG93LkNvcmRvdmEgIT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2Ygd2luZG93LmNvcmRvdmEgIT0gXCJ1bmRlZmluZWRcIik7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBpc0NvcmRvdmE7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgaXNSZWFjdE5hdGl2ZSA9IGZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKSB7XG4gIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJzdHJpbmdcIiAmJiBuYXZpZ2F0b3IucHJvZHVjdC50b0xvd2VyQ2FzZSgpID09PSBcInJlYWN0bmF0aXZlXCI7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBpc1JlYWN0TmF0aXZlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLyoqXG4gKiByZWFkQXNCeXRlQXJyYXkgY29udmVydHMgYSBGaWxlIG9iamVjdCB0byBhIFVpbnQ4QXJyYXkuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgdXNlZCBvbiB0aGUgQXBhY2hlIENvcmRvdmEgcGxhdGZvcm0uXG4gKiBTZWUgaHR0cHM6Ly9jb3Jkb3ZhLmFwYWNoZS5vcmcvZG9jcy9lbi9sYXRlc3QvcmVmZXJlbmNlL2NvcmRvdmEtcGx1Z2luLWZpbGUvaW5kZXguaHRtbCNyZWFkLWEtZmlsZVxuICovXG5mdW5jdGlvbiByZWFkQXNCeXRlQXJyYXkoY2h1bmssIGNhbGxiYWNrKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrKG51bGwsIG5ldyBVaW50OEFycmF5KHJlYWRlci5yZXN1bHQpKTtcbiAgfTtcbiAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfTtcbiAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGNodW5rKTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gcmVhZEFzQnl0ZUFycmF5OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5uZXdSZXF1ZXN0ID0gbmV3UmVxdWVzdDtcbmV4cG9ydHMucmVzb2x2ZVVybCA9IHJlc29sdmVVcmw7XG5cbnZhciBfdXJsUGFyc2UgPSByZXF1aXJlKFwidXJsLXBhcnNlXCIpO1xuXG52YXIgX3VybFBhcnNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VybFBhcnNlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gbmV3UmVxdWVzdCgpIHtcbiAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcbn0gLyogZ2xvYmFsIHdpbmRvdyAqL1xuZnVuY3Rpb24gcmVzb2x2ZVVybChvcmlnaW4sIGxpbmspIHtcbiAgcmV0dXJuIG5ldyBfdXJsUGFyc2UyLmRlZmF1bHQobGluaywgb3JpZ2luKS50b1N0cmluZygpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5leHBvcnRzLmdldFNvdXJjZSA9IGdldFNvdXJjZTtcblxudmFyIF9pc1JlYWN0TmF0aXZlID0gcmVxdWlyZShcIi4vaXNSZWFjdE5hdGl2ZVwiKTtcblxudmFyIF9pc1JlYWN0TmF0aXZlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUmVhY3ROYXRpdmUpO1xuXG52YXIgX3VyaVRvQmxvYiA9IHJlcXVpcmUoXCIuL3VyaVRvQmxvYlwiKTtcblxudmFyIF91cmlUb0Jsb2IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXJpVG9CbG9iKTtcblxudmFyIF9pc0NvcmRvdmEgPSByZXF1aXJlKFwiLi9pc0NvcmRvdmFcIik7XG5cbnZhciBfaXNDb3Jkb3ZhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzQ29yZG92YSk7XG5cbnZhciBfcmVhZEFzQnl0ZUFycmF5ID0gcmVxdWlyZShcIi4vcmVhZEFzQnl0ZUFycmF5XCIpO1xuXG52YXIgX3JlYWRBc0J5dGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFkQXNCeXRlQXJyYXkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgRmlsZVNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmlsZVNvdXJjZShmaWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpbGVTb3VyY2UpO1xuXG4gICAgdGhpcy5fZmlsZSA9IGZpbGU7XG4gICAgdGhpcy5zaXplID0gZmlsZS5zaXplO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZpbGVTb3VyY2UsIFt7XG4gICAga2V5OiBcInNsaWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBJbiBBcGFjaGUgQ29yZG92YSBhcHBsaWNhdGlvbnMsIGEgRmlsZSBtdXN0IGJlIHJlc29sdmVkIHVzaW5nXG4gICAgICAvLyBGaWxlUmVhZGVyIGluc3RhbmNlcywgc2VlXG4gICAgICAvLyBodHRwczovL2NvcmRvdmEuYXBhY2hlLm9yZy9kb2NzL2VuLzgueC9yZWZlcmVuY2UvY29yZG92YS1wbHVnaW4tZmlsZS9pbmRleC5odG1sI3JlYWQtYS1maWxlXG4gICAgICBpZiAoKDAsIF9pc0NvcmRvdmEyLmRlZmF1bHQpKCkpIHtcbiAgICAgICAgKDAsIF9yZWFkQXNCeXRlQXJyYXkyLmRlZmF1bHQpKHRoaXMuX2ZpbGUuc2xpY2Uoc3RhcnQsIGVuZCksIGZ1bmN0aW9uIChlcnIsIGNodW5rKSB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG5cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBjaHVuayk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIHRoaXMuX2ZpbGUuc2xpY2Uoc3RhcnQsIGVuZCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHt9XG4gIH1dKTtcblxuICByZXR1cm4gRmlsZVNvdXJjZTtcbn0oKTtcblxudmFyIFN0cmVhbVNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RyZWFtU291cmNlKHJlYWRlciwgY2h1bmtTaXplKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cmVhbVNvdXJjZSk7XG5cbiAgICB0aGlzLl9jaHVua1NpemUgPSBjaHVua1NpemU7XG4gICAgdGhpcy5fYnVmZmVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2J1ZmZlck9mZnNldCA9IDA7XG4gICAgdGhpcy5fcmVhZGVyID0gcmVhZGVyO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdHJlYW1Tb3VyY2UsIFt7XG4gICAga2V5OiBcInNsaWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoc3RhcnQgPCB0aGlzLl9idWZmZXJPZmZzZXQpIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKFwiUmVxdWVzdGVkIGRhdGEgaXMgYmVmb3JlIHRoZSByZWFkZXIncyBjdXJyZW50IG9mZnNldFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRVbnRpbEVub3VnaERhdGFPckRvbmUoc3RhcnQsIGVuZCwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVhZFVudGlsRW5vdWdoRGF0YU9yRG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVhZFVudGlsRW5vdWdoRGF0YU9yRG9uZShzdGFydCwgZW5kLCBjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGhhc0Vub3VnaERhdGEgPSBlbmQgPD0gdGhpcy5fYnVmZmVyT2Zmc2V0ICsgbGVuKHRoaXMuX2J1ZmZlcik7XG4gICAgICBpZiAodGhpcy5fZG9uZSB8fCBoYXNFbm91Z2hEYXRhKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2dldERhdGFGcm9tQnVmZmVyKHN0YXJ0LCBlbmQpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCB2YWx1ZSwgdmFsdWUgPT0gbnVsbCA/IHRoaXMuX2RvbmUgOiBmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlLFxuICAgICAgICAgICAgZG9uZSA9IF9yZWYuZG9uZTtcblxuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIF90aGlzLl9kb25lID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChfdGhpcy5fYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBfdGhpcy5fYnVmZmVyID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuX2J1ZmZlciA9IGNvbmNhdChfdGhpcy5fYnVmZmVyLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5fcmVhZFVudGlsRW5vdWdoRGF0YU9yRG9uZShzdGFydCwgZW5kLCBjYWxsYmFjayk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcIkVycm9yIGR1cmluZyByZWFkOiBcIiArIGVycikpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREYXRhRnJvbUJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGF0YUZyb21CdWZmZXIoc3RhcnQsIGVuZCkge1xuICAgICAgLy8gUmVtb3ZlIGRhdGEgZnJvbSBidWZmZXIgYmVmb3JlIGBzdGFydGAuXG4gICAgICAvLyBEYXRhIG1pZ2h0IGJlIHJlcmVhZCBmcm9tIHRoZSBidWZmZXIgaWYgYW4gdXBsb2FkIGZhaWxzLCBzbyB3ZSBjYW4gb25seVxuICAgICAgLy8gc2FmZWx5IGRlbGV0ZSBkYXRhIHdoZW4gaXQgY29tZXMgKmJlZm9yZSogd2hhdCBpcyBjdXJyZW50bHkgYmVpbmcgcmVhZC5cbiAgICAgIGlmIChzdGFydCA+IHRoaXMuX2J1ZmZlck9mZnNldCkge1xuICAgICAgICB0aGlzLl9idWZmZXIgPSB0aGlzLl9idWZmZXIuc2xpY2Uoc3RhcnQgLSB0aGlzLl9idWZmZXJPZmZzZXQpO1xuICAgICAgICB0aGlzLl9idWZmZXJPZmZzZXQgPSBzdGFydDtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBidWZmZXIgaXMgZW1wdHkgYWZ0ZXIgcmVtb3Zpbmcgb2xkIGRhdGEsIGFsbCBkYXRhIGhhcyBiZWVuIHJlYWQuXG4gICAgICB2YXIgaGFzQWxsRGF0YUJlZW5SZWFkID0gbGVuKHRoaXMuX2J1ZmZlcikgPT09IDA7XG4gICAgICBpZiAodGhpcy5fZG9uZSAmJiBoYXNBbGxEYXRhQmVlblJlYWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBXZSBhbHJlYWR5IHJlbW92ZWQgZGF0YSBiZWZvcmUgYHN0YXJ0YCwgc28gd2UganVzdCByZXR1cm4gdGhlIGZpcnN0XG4gICAgICAvLyBjaHVuayBmcm9tIHRoZSBidWZmZXIuXG4gICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLnNsaWNlKDAsIGVuZCAtIHN0YXJ0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAodGhpcy5fcmVhZGVyLmNhbmNlbCkge1xuICAgICAgICB0aGlzLl9yZWFkZXIuY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0cmVhbVNvdXJjZTtcbn0oKTtcblxuZnVuY3Rpb24gbGVuKGJsb2JPckFycmF5KSB7XG4gIGlmIChibG9iT3JBcnJheSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcbiAgaWYgKGJsb2JPckFycmF5LnNpemUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGJsb2JPckFycmF5LnNpemU7XG4gIHJldHVybiBibG9iT3JBcnJheS5sZW5ndGg7XG59XG5cbi8qXG4gIFR5cGVkIGFycmF5cyBhbmQgYmxvYnMgZG9uJ3QgaGF2ZSBhIGNvbmNhdCBtZXRob2QuXG4gIFRoaXMgZnVuY3Rpb24gaGVscHMgU3RyZWFtU291cmNlIGFjY3VtdWxhdGUgZGF0YSB0byByZWFjaCBjaHVua1NpemUuXG4qL1xuZnVuY3Rpb24gY29uY2F0KGEsIGIpIHtcbiAgaWYgKGEuY29uY2F0KSB7XG4gICAgLy8gSXMgYGFgIGFuIEFycmF5P1xuICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgfVxuICBpZiAoYSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gbmV3IEJsb2IoW2EsIGJdLCB7IHR5cGU6IGEudHlwZSB9KTtcbiAgfVxuICBpZiAoYS5zZXQpIHtcbiAgICAvLyBJcyBgYWAgYSB0eXBlZCBhcnJheT9cbiAgICB2YXIgYyA9IG5ldyBhLmNvbnN0cnVjdG9yKGEubGVuZ3RoICsgYi5sZW5ndGgpO1xuICAgIGMuc2V0KGEpO1xuICAgIGMuc2V0KGIsIGEubGVuZ3RoKTtcbiAgICByZXR1cm4gYztcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZVwiKTtcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlKGlucHV0LCBjaHVua1NpemUsIGNhbGxiYWNrKSB7XG4gIC8vIEluIFJlYWN0IE5hdGl2ZSwgd2hlbiB1c2VyIHNlbGVjdHMgYSBmaWxlLCBpbnN0ZWFkIG9mIGEgRmlsZSBvciBCbG9iLFxuICAvLyB5b3UgdXN1YWxseSBnZXQgYSBmaWxlIG9iamVjdCB7fSB3aXRoIGEgdXJpIHByb3BlcnR5IHRoYXQgY29udGFpbnNcbiAgLy8gYSBsb2NhbCBwYXRoIHRvIHRoZSBmaWxlLiBXZSB1c2UgWE1MSHR0cFJlcXVlc3QgdG8gZmV0Y2hcbiAgLy8gdGhlIGZpbGUgYmxvYiwgYmVmb3JlIHVwbG9hZGluZyB3aXRoIHR1cy5cbiAgaWYgKCgwLCBfaXNSZWFjdE5hdGl2ZTIuZGVmYXVsdCkoKSAmJiBpbnB1dCAmJiB0eXBlb2YgaW5wdXQudXJpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgKDAsIF91cmlUb0Jsb2IyLmRlZmF1bHQpKGlucHV0LnVyaSwgZnVuY3Rpb24gKGVyciwgYmxvYikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwidHVzOiBjYW5ub3QgZmV0Y2ggYGZpbGUudXJpYCBhcyBCbG9iLCBtYWtlIHN1cmUgdGhlIHVyaSBpcyBjb3JyZWN0IGFuZCBhY2Nlc3NpYmxlLiBcIiArIGVycikpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgbmV3IEZpbGVTb3VyY2UoYmxvYikpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFNpbmNlIHdlIGVtdWxhdGUgdGhlIEJsb2IgdHlwZSBpbiBvdXIgdGVzdHMgKG5vdCBhbGwgdGFyZ2V0IGJyb3dzZXJzXG4gIC8vIHN1cHBvcnQgaXQpLCB3ZSBjYW5ub3QgdXNlIGBpbnN0YW5jZW9mYCBmb3IgdGVzdGluZyB3aGV0aGVyIHRoZSBpbnB1dCB2YWx1ZVxuICAvLyBjYW4gYmUgaGFuZGxlZC4gSW5zdGVhZCwgd2Ugc2ltcGx5IGNoZWNrIGlzIHRoZSBzbGljZSgpIGZ1bmN0aW9uIGFuZCB0aGVcbiAgLy8gc2l6ZSBwcm9wZXJ0eSBhcmUgYXZhaWxhYmxlLlxuICBpZiAodHlwZW9mIGlucHV0LnNsaWNlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGlucHV0LnNpemUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjYWxsYmFjayhudWxsLCBuZXcgRmlsZVNvdXJjZShpbnB1dCkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5wdXQucmVhZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY2h1bmtTaXplID0gK2NodW5rU2l6ZTtcbiAgICBpZiAoIWlzRmluaXRlKGNodW5rU2l6ZSkpIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcImNhbm5vdCBjcmVhdGUgc291cmNlIGZvciBzdHJlYW0gd2l0aG91dCBhIGZpbml0ZSB2YWx1ZSBmb3IgdGhlIGBjaHVua1NpemVgIG9wdGlvblwiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIG5ldyBTdHJlYW1Tb3VyY2UoaW5wdXQsIGNodW5rU2l6ZSkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNhbGxiYWNrKG5ldyBFcnJvcihcInNvdXJjZSBvYmplY3QgbWF5IG9ubHkgYmUgYW4gaW5zdGFuY2Ugb2YgRmlsZSwgQmxvYiwgb3IgUmVhZGVyIGluIHRoaXMgZW52aXJvbm1lbnRcIikpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5leHBvcnRzLmdldFN0b3JhZ2UgPSBnZXRTdG9yYWdlO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKiBnbG9iYWwgd2luZG93LCBsb2NhbFN0b3JhZ2UgKi9cblxudmFyIGhhc1N0b3JhZ2UgPSBmYWxzZTtcbnRyeSB7XG4gIGhhc1N0b3JhZ2UgPSBcImxvY2FsU3RvcmFnZVwiIGluIHdpbmRvdztcblxuICAvLyBBdHRlbXB0IHRvIHN0b3JlIGFuZCByZWFkIGVudHJpZXMgZnJvbSB0aGUgbG9jYWwgc3RvcmFnZSB0byBkZXRlY3QgUHJpdmF0ZVxuICAvLyBNb2RlIG9uIFNhZmFyaSBvbiBpT1MgKHNlZSAjNDkpXG4gIHZhciBrZXkgPSBcInR1c1N1cHBvcnRcIjtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKTtcbn0gY2F0Y2ggKGUpIHtcbiAgLy8gSWYgd2UgdHJ5IHRvIGFjY2VzcyBsb2NhbFN0b3JhZ2UgaW5zaWRlIGEgc2FuZGJveGVkIGlmcmFtZSwgYSBTZWN1cml0eUVycm9yXG4gIC8vIGlzIHRocm93bi4gV2hlbiBpbiBwcml2YXRlIG1vZGUgb24gaU9TIFNhZmFyaSwgYSBRdW90YUV4Y2VlZGVkRXJyb3IgaXNcbiAgLy8gdGhyb3duIChzZWUgIzQ5KVxuICBpZiAoZS5jb2RlID09PSBlLlNFQ1VSSVRZX0VSUiB8fCBlLmNvZGUgPT09IGUuUVVPVEFfRVhDRUVERURfRVJSKSB7XG4gICAgaGFzU3RvcmFnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGU7XG4gIH1cbn1cblxudmFyIGNhblN0b3JlVVJMcyA9IGV4cG9ydHMuY2FuU3RvcmVVUkxzID0gaGFzU3RvcmFnZTtcblxudmFyIExvY2FsU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTG9jYWxTdG9yYWdlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb2NhbFN0b3JhZ2UpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExvY2FsU3RvcmFnZSwgW3tcbiAgICBrZXk6IFwic2V0SXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJdGVtKGtleSwgdmFsdWUsIGNiKSB7XG4gICAgICBjYihudWxsLCBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEl0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SXRlbShrZXksIGNiKSB7XG4gICAgICBjYihudWxsLCBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlSXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJdGVtKGtleSwgY2IpIHtcbiAgICAgIGNiKG51bGwsIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMb2NhbFN0b3JhZ2U7XG59KCk7XG5cbmZ1bmN0aW9uIGdldFN0b3JhZ2UoKSB7XG4gIHJldHVybiBoYXNTdG9yYWdlID8gbmV3IExvY2FsU3RvcmFnZSgpIDogbnVsbDtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8qKlxuICogdXJpVG9CbG9iIHJlc29sdmVzIGEgVVJJIHRvIGEgQmxvYiBvYmplY3QuIFRoaXMgaXMgdXNlZCBmb3JcbiAqIFJlYWN0IE5hdGl2ZSB0byByZXRyaWV2ZSBhIGZpbGUgKGlkZW50aWZpZWQgYnkgYSBmaWxlOi8vXG4gKiBVUkkpIGFzIGEgYmxvYi5cbiAqL1xuZnVuY3Rpb24gdXJpVG9CbG9iKHVyaSwgZG9uZSkge1xuICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHhoci5yZXNwb25zZVR5cGUgPSBcImJsb2JcIjtcbiAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYmxvYiA9IHhoci5yZXNwb25zZTtcbiAgICBkb25lKG51bGwsIGJsb2IpO1xuICB9O1xuICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBkb25lKGVycik7XG4gIH07XG4gIHhoci5vcGVuKFwiR0VUXCIsIHVyaSk7XG4gIHhoci5zZW5kKCk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHVyaVRvQmxvYjsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgRGV0YWlsZWRFcnJvciA9IGZ1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKERldGFpbGVkRXJyb3IsIF9FcnJvcik7XG5cbiAgZnVuY3Rpb24gRGV0YWlsZWRFcnJvcihlcnJvcikge1xuICAgIHZhciBjYXVzaW5nRXJyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgIHZhciB4aHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGV0YWlsZWRFcnJvcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRGV0YWlsZWRFcnJvci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERldGFpbGVkRXJyb3IpKS5jYWxsKHRoaXMsIGVycm9yLm1lc3NhZ2UpKTtcblxuICAgIF90aGlzLm9yaWdpbmFsUmVxdWVzdCA9IHhocjtcbiAgICBfdGhpcy5jYXVzaW5nRXJyb3IgPSBjYXVzaW5nRXJyO1xuXG4gICAgdmFyIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIGlmIChjYXVzaW5nRXJyICE9IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UgKz0gXCIsIGNhdXNlZCBieSBcIiArIGNhdXNpbmdFcnIudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHhociAhPSBudWxsKSB7XG4gICAgICBtZXNzYWdlICs9IFwiLCBvcmlnaW5hdGVkIGZyb20gcmVxdWVzdCAocmVzcG9uc2UgY29kZTogXCIgKyB4aHIuc3RhdHVzICsgXCIsIHJlc3BvbnNlIHRleHQ6IFwiICsgeGhyLnJlc3BvbnNlVGV4dCArIFwiKVwiO1xuICAgIH1cbiAgICBfdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gRGV0YWlsZWRFcnJvcjtcbn0oRXJyb3IpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEZXRhaWxlZEVycm9yOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3VwbG9hZCA9IHJlcXVpcmUoXCIuL3VwbG9hZFwiKTtcblxudmFyIF91cGxvYWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXBsb2FkKTtcblxudmFyIF9zdG9yYWdlID0gcmVxdWlyZShcIi4vbm9kZS9zdG9yYWdlXCIpO1xuXG52YXIgc3RvcmFnZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9zdG9yYWdlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyogZ2xvYmFsIHdpbmRvdyAqL1xudmFyIGRlZmF1bHRPcHRpb25zID0gX3VwbG9hZDIuZGVmYXVsdC5kZWZhdWx0T3B0aW9ucztcblxuXG52YXIgbW9kdWxlRXhwb3J0ID0ge1xuICBVcGxvYWQ6IF91cGxvYWQyLmRlZmF1bHQsXG4gIGNhblN0b3JlVVJMczogc3RvcmFnZS5jYW5TdG9yZVVSTHMsXG4gIGRlZmF1bHRPcHRpb25zOiBkZWZhdWx0T3B0aW9uc1xufTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgLy8gQnJvd3NlciBlbnZpcm9ubWVudCB1c2luZyBYTUxIdHRwUmVxdWVzdFxuICB2YXIgX3dpbmRvdyA9IHdpbmRvdyxcbiAgICAgIFhNTEh0dHBSZXF1ZXN0ID0gX3dpbmRvdy5YTUxIdHRwUmVxdWVzdCxcbiAgICAgIEJsb2IgPSBfd2luZG93LkJsb2I7XG5cblxuICBtb2R1bGVFeHBvcnQuaXNTdXBwb3J0ZWQgPSBYTUxIdHRwUmVxdWVzdCAmJiBCbG9iICYmIHR5cGVvZiBCbG9iLnByb3RvdHlwZS5zbGljZSA9PT0gXCJmdW5jdGlvblwiO1xufSBlbHNlIHtcbiAgLy8gTm9kZS5qcyBlbnZpcm9ubWVudCB1c2luZyBodHRwIG1vZHVsZVxuICBtb2R1bGVFeHBvcnQuaXNTdXBwb3J0ZWQgPSB0cnVlO1xuICAvLyBtYWtlIEZpbGVTdG9yYWdlIG1vZHVsZSBhdmFpbGFibGUgYXMgaXQgd2lsbCBub3QgYmUgc2V0IGJ5IGRlZmF1bHQuXG4gIG1vZHVsZUV4cG9ydC5GaWxlU3RvcmFnZSA9IHN0b3JhZ2UuRmlsZVN0b3JhZ2U7XG59XG5cbi8vIFRoZSB1c2FnZSBvZiB0aGUgY29tbW9uanMgZXhwb3J0aW5nIHN5bnRheCBpbnN0ZWFkIG9mIHRoZSBuZXcgRUNNQVNjcmlwdFxuLy8gb25lIGlzIGFjdHVhbGx5IGludGVkZWQgYW5kIHByZXZlbnRzIHdlaXJkIGJlaGF2aW91ciBpZiB3ZSBhcmUgdHJ5aW5nIHRvXG4vLyBpbXBvcnQgdGhpcyBtb2R1bGUgaW4gYW5vdGhlciBtb2R1bGUgdXNpbmcgQmFiZWwuXG5tb2R1bGUuZXhwb3J0cyA9IG1vZHVsZUV4cG9ydDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG5cbi8vIFdlIGltcG9ydCB0aGUgZmlsZXMgdXNlZCBpbnNpZGUgdGhlIE5vZGUgZW52aXJvbm1lbnQgd2hpY2ggYXJlIHJld3JpdHRlblxuLy8gZm9yIGJyb3dzZXJzIHVzaW5nIHRoZSBydWxlcyBkZWZpbmVkIGluIHRoZSBwYWNrYWdlLmpzb25cblxuXG52YXIgX2Vycm9yID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG5cbnZhciBfZXJyb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXJyb3IpO1xuXG52YXIgX2V4dGVuZCA9IHJlcXVpcmUoXCJleHRlbmRcIik7XG5cbnZhciBfZXh0ZW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dGVuZCk7XG5cbnZhciBfanNCYXNlID0gcmVxdWlyZShcImpzLWJhc2U2NFwiKTtcblxudmFyIF9yZXF1ZXN0ID0gcmVxdWlyZShcIi4vbm9kZS9yZXF1ZXN0XCIpO1xuXG52YXIgX3NvdXJjZSA9IHJlcXVpcmUoXCIuL25vZGUvc291cmNlXCIpO1xuXG52YXIgX3N0b3JhZ2UgPSByZXF1aXJlKFwiLi9ub2RlL3N0b3JhZ2VcIik7XG5cbnZhciBfZmluZ2VycHJpbnQgPSByZXF1aXJlKFwiLi9ub2RlL2ZpbmdlcnByaW50XCIpO1xuXG52YXIgX2ZpbmdlcnByaW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZpbmdlcnByaW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBlbmRwb2ludDogbnVsbCxcbiAgZmluZ2VycHJpbnQ6IF9maW5nZXJwcmludDIuZGVmYXVsdCxcbiAgcmVzdW1lOiB0cnVlLFxuICBvblByb2dyZXNzOiBudWxsLFxuICBvbkNodW5rQ29tcGxldGU6IG51bGwsXG4gIG9uU3VjY2VzczogbnVsbCxcbiAgb25FcnJvcjogbnVsbCxcbiAgaGVhZGVyczoge30sXG4gIGNodW5rU2l6ZTogSW5maW5pdHksXG4gIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXG4gIHVwbG9hZFVybDogbnVsbCxcbiAgdXBsb2FkU2l6ZTogbnVsbCxcbiAgb3ZlcnJpZGVQYXRjaE1ldGhvZDogZmFsc2UsXG4gIHJldHJ5RGVsYXlzOiBudWxsLFxuICByZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzczogZmFsc2UsXG4gIHVwbG9hZExlbmd0aERlZmVycmVkOiBmYWxzZSxcbiAgdXJsU3RvcmFnZTogbnVsbCxcbiAgZmlsZVJlYWRlcjogbnVsbCxcbiAgdXBsb2FkRGF0YUR1cmluZ0NyZWF0aW9uOiBmYWxzZVxufTtcblxudmFyIFVwbG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVXBsb2FkKGZpbGUsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVXBsb2FkKTtcblxuICAgIHRoaXMub3B0aW9ucyA9ICgwLCBfZXh0ZW5kMi5kZWZhdWx0KSh0cnVlLCB7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgLy8gVGhlIHN0b3JhZ2UgbW9kdWxlIHVzZWQgdG8gc3RvcmUgVVJMc1xuICAgIHRoaXMuX3N0b3JhZ2UgPSB0aGlzLm9wdGlvbnMudXJsU3RvcmFnZTtcblxuICAgIC8vIFRoZSB1bmRlcmx5aW5nIEZpbGUvQmxvYiBvYmplY3RcbiAgICB0aGlzLmZpbGUgPSBmaWxlO1xuXG4gICAgLy8gVGhlIFVSTCBhZ2FpbnN0IHdoaWNoIHRoZSBmaWxlIHdpbGwgYmUgdXBsb2FkZWRcbiAgICB0aGlzLnVybCA9IG51bGw7XG5cbiAgICAvLyBUaGUgdW5kZXJseWluZyBYSFIgb2JqZWN0IGZvciB0aGUgY3VycmVudCBQQVRDSCByZXF1ZXN0XG4gICAgdGhpcy5feGhyID0gbnVsbDtcblxuICAgIC8vIFRoZSBmaW5nZXJwaW5ydCBmb3IgdGhlIGN1cnJlbnQgZmlsZSAoc2V0IGFmdGVyIHN0YXJ0KCkpXG4gICAgdGhpcy5fZmluZ2VycHJpbnQgPSBudWxsO1xuXG4gICAgLy8gVGhlIG9mZnNldCB1c2VkIGluIHRoZSBjdXJyZW50IFBBVENIIHJlcXVlc3RcbiAgICB0aGlzLl9vZmZzZXQgPSBudWxsO1xuXG4gICAgLy8gVHJ1ZSBpZiB0aGUgY3VycmVudCBQQVRDSCByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWRcbiAgICB0aGlzLl9hYm9ydGVkID0gZmFsc2U7XG5cbiAgICAvLyBUaGUgZmlsZSdzIHNpemUgaW4gYnl0ZXNcbiAgICB0aGlzLl9zaXplID0gbnVsbDtcblxuICAgIC8vIFRoZSBTb3VyY2Ugb2JqZWN0IHdoaWNoIHdpbGwgd3JhcCBhcm91bmQgdGhlIGdpdmVuIGZpbGUgYW5kIHByb3ZpZGVzIHVzXG4gICAgLy8gd2l0aCBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBnZXR0aW5nIGl0cyBzaXplIGFuZCBzbGljZSBjaHVua3MgZnJvbSBpdHNcbiAgICAvLyBjb250ZW50IGFsbG93aW5nIHVzIHRvIGVhc2lseSBoYW5kbGUgRmlsZXMsIEJsb2JzLCBCdWZmZXJzIGFuZCBTdHJlYW1zLlxuICAgIHRoaXMuX3NvdXJjZSA9IG51bGw7XG5cbiAgICAvLyBUaGUgY3VycmVudCBjb3VudCBvZiBhdHRlbXB0cyB3aGljaCBoYXZlIGJlZW4gbWFkZS4gTnVsbCBpbmRpY2F0ZXMgbm9uZS5cbiAgICB0aGlzLl9yZXRyeUF0dGVtcHQgPSAwO1xuXG4gICAgLy8gVGhlIHRpbWVvdXQncyBJRCB3aGljaCBpcyB1c2VkIHRvIGRlbGF5IHRoZSBuZXh0IHJldHJ5XG4gICAgdGhpcy5fcmV0cnlUaW1lb3V0ID0gbnVsbDtcblxuICAgIC8vIFRoZSBvZmZzZXQgb2YgdGhlIHJlbW90ZSB1cGxvYWQgYmVmb3JlIHRoZSBsYXRlc3QgYXR0ZW1wdCB3YXMgc3RhcnRlZC5cbiAgICB0aGlzLl9vZmZzZXRCZWZvcmVSZXRyeSA9IDA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVXBsb2FkLCBbe1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBmaWxlID0gdGhpcy5maWxlO1xuXG4gICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogbm8gZmlsZSBvciBzdHJlYW0gdG8gdXBsb2FkIHByb3ZpZGVkXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmRwb2ludCAmJiAhdGhpcy5vcHRpb25zLnVwbG9hZFVybCkge1xuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwidHVzOiBuZWl0aGVyIGFuIGVuZHBvaW50IG9yIGFuIHVwbG9hZCBVUkwgaXMgcHJvdmlkZWRcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVzdW1lICYmIHRoaXMuX3N0b3JhZ2UgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9zdG9yYWdlID0gKDAsIF9zdG9yYWdlLmdldFN0b3JhZ2UpKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcbiAgICAgICAgdGhpcy5fc3RhcnQodGhpcy5fc291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmaWxlUmVhZGVyID0gdGhpcy5vcHRpb25zLmZpbGVSZWFkZXIgfHwgX3NvdXJjZS5nZXRTb3VyY2U7XG4gICAgICAgIGZpbGVSZWFkZXIoZmlsZSwgdGhpcy5vcHRpb25zLmNodW5rU2l6ZSwgZnVuY3Rpb24gKGVyciwgc291cmNlKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgX3RoaXMuX2VtaXRFcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgX3RoaXMuX3N0YXJ0KHNvdXJjZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0KHNvdXJjZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBmaWxlID0gdGhpcy5maWxlO1xuXG4gICAgICAvLyBGaXJzdCwgd2UgbG9vayBhdCB0aGUgdXBsb2FkTGVuZ3RoRGVmZXJyZWQgb3B0aW9uLlxuICAgICAgLy8gTmV4dCwgd2UgY2hlY2sgaWYgdGhlIGNhbGxlciBoYXMgc3VwcGxpZWQgYSBtYW51YWwgdXBsb2FkIHNpemUuXG4gICAgICAvLyBGaW5hbGx5LCB3ZSB0cnkgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHNpemUgZnJvbSB0aGUgc291cmNlIG9iamVjdC5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy51cGxvYWRTaXplICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9ICt0aGlzLm9wdGlvbnMudXBsb2FkU2l6ZTtcbiAgICAgICAgaWYgKGlzTmFOKHRoaXMuX3NpemUpKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogY2Fubm90IGNvbnZlcnQgYHVwbG9hZFNpemVgIG9wdGlvbiBpbnRvIGEgbnVtYmVyXCIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSBzb3VyY2Uuc2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuX3NpemUgPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJ0dXM6IGNhbm5vdCBhdXRvbWF0aWNhbGx5IGRlcml2ZSB1cGxvYWQncyBzaXplIGZyb20gaW5wdXQgYW5kIG11c3QgYmUgc3BlY2lmaWVkIG1hbnVhbGx5IHVzaW5nIHRoZSBgdXBsb2FkU2l6ZWAgb3B0aW9uXCIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJldHJ5RGVsYXlzID0gdGhpcy5vcHRpb25zLnJldHJ5RGVsYXlzO1xuICAgICAgaWYgKHJldHJ5RGVsYXlzICE9IG51bGwpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZXRyeURlbGF5cykgIT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJ0dXM6IHRoZSBgcmV0cnlEZWxheXNgIG9wdGlvbiBtdXN0IGVpdGhlciBiZSBhbiBhcnJheSBvciBudWxsXCIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVycm9yQ2FsbGJhY2sgPSB0aGlzLm9wdGlvbnMub25FcnJvcjtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGVycm9yIGNhbGxiYWNrIHdoaWNoIG1heSBoYXZlIGJlZW4gc2V0LlxuICAgICAgICAgICAgX3RoaXMyLm9wdGlvbnMub25FcnJvciA9IGVycm9yQ2FsbGJhY2s7XG5cbiAgICAgICAgICAgIC8vIFdlIHdpbGwgcmVzZXQgdGhlIGF0dGVtcHQgY291bnRlciBpZlxuICAgICAgICAgICAgLy8gLSB3ZSB3ZXJlIGFscmVhZHkgYWJsZSB0byBjb25uZWN0IHRvIHRoZSBzZXJ2ZXIgKG9mZnNldCAhPSBudWxsKSBhbmRcbiAgICAgICAgICAgIC8vIC0gd2Ugd2VyZSBhYmxlIHRvIHVwbG9hZCBhIHNtYWxsIGNodW5rIG9mIGRhdGEgdG8gdGhlIHNlcnZlclxuICAgICAgICAgICAgdmFyIHNob3VsZFJlc2V0RGVsYXlzID0gX3RoaXMyLl9vZmZzZXQgIT0gbnVsbCAmJiBfdGhpczIuX29mZnNldCA+IF90aGlzMi5fb2Zmc2V0QmVmb3JlUmV0cnk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkUmVzZXREZWxheXMpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLl9yZXRyeUF0dGVtcHQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaXNPbmxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJuYXZpZ2F0b3JcIiBpbiB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvci5vbkxpbmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGlzT25saW5lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgYXR0ZW1wdCBhIHJldHJ5IGlmXG4gICAgICAgICAgICAvLyAtIHdlIGRpZG4ndCBleGNlZWQgdGhlIG1heGl1bSBudW1iZXIgb2YgcmV0cmllcywgeWV0LCBhbmRcbiAgICAgICAgICAgIC8vIC0gdGhpcyBlcnJvciB3YXMgY2F1c2VkIGJ5IGEgcmVxdWVzdCBvciBpdCdzIHJlc3BvbnNlIGFuZFxuICAgICAgICAgICAgLy8gLSB0aGUgZXJyb3IgaXMgc2VydmVyIGVycm9yIChpLmUuIG5vIGEgc3RhdHVzIDR4eCBvciBhIDQwOSBvciA0MjMpIGFuZFxuICAgICAgICAgICAgLy8gLSB0aGUgYnJvd3NlciBkb2VzIG5vdCBpbmRpY2F0ZSB0aGF0IHdlIGFyZSBvZmZsaW5lXG4gICAgICAgICAgICB2YXIgc3RhdHVzID0gZXJyLm9yaWdpbmFsUmVxdWVzdCA/IGVyci5vcmlnaW5hbFJlcXVlc3Quc3RhdHVzIDogMDtcbiAgICAgICAgICAgIHZhciBpc1NlcnZlckVycm9yID0gIWluU3RhdHVzQ2F0ZWdvcnkoc3RhdHVzLCA0MDApIHx8IHN0YXR1cyA9PT0gNDA5IHx8IHN0YXR1cyA9PT0gNDIzO1xuICAgICAgICAgICAgdmFyIHNob3VsZFJldHJ5ID0gX3RoaXMyLl9yZXRyeUF0dGVtcHQgPCByZXRyeURlbGF5cy5sZW5ndGggJiYgZXJyLm9yaWdpbmFsUmVxdWVzdCAhPSBudWxsICYmIGlzU2VydmVyRXJyb3IgJiYgaXNPbmxpbmU7XG5cbiAgICAgICAgICAgIGlmICghc2hvdWxkUmV0cnkpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLl9lbWl0RXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGVsYXkgPSByZXRyeURlbGF5c1tfdGhpczIuX3JldHJ5QXR0ZW1wdCsrXTtcblxuICAgICAgICAgICAgX3RoaXMyLl9vZmZzZXRCZWZvcmVSZXRyeSA9IF90aGlzMi5fb2Zmc2V0O1xuICAgICAgICAgICAgX3RoaXMyLm9wdGlvbnMudXBsb2FkVXJsID0gX3RoaXMyLnVybDtcblxuICAgICAgICAgICAgX3RoaXMyLl9yZXRyeVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLnN0YXJ0KCk7XG4gICAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZXNldCB0aGUgYWJvcnRlZCBmbGFnIHdoZW4gdGhlIHVwbG9hZCBpcyBzdGFydGVkIG9yIGVsc2UgdGhlXG4gICAgICAvLyBfc3RhcnRVcGxvYWQgd2lsbCBzdG9wIGJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdCBpZiB0aGUgdXBsb2FkIGhhcyBiZWVuXG4gICAgICAvLyBhYm9ydGVkIHByZXZpb3VzbHkuXG4gICAgICB0aGlzLl9hYm9ydGVkID0gZmFsc2U7XG5cbiAgICAgIC8vIFRoZSB1cGxvYWQgaGFkIGJlZW4gc3RhcnRlZCBwcmV2aW91c2x5IGFuZCB3ZSBzaG91bGQgcmV1c2UgdGhpcyBVUkwuXG4gICAgICBpZiAodGhpcy51cmwgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9yZXN1bWVVcGxvYWQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBIFVSTCBoYXMgbWFudWFsbHkgYmVlbiBzcGVjaWZpZWQsIHNvIHdlIHRyeSB0byByZXN1bWVcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkVXJsICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy51cmwgPSB0aGlzLm9wdGlvbnMudXBsb2FkVXJsO1xuICAgICAgICB0aGlzLl9yZXN1bWVVcGxvYWQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUcnkgdG8gZmluZCB0aGUgZW5kcG9pbnQgZm9yIHRoZSBmaWxlIGluIHRoZSBzdG9yYWdlXG4gICAgICBpZiAodGhpcy5faGFzU3RvcmFnZSgpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5maW5nZXJwcmludChmaWxlLCB0aGlzLm9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIGZpbmdlcnByaW50VmFsdWUpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBfdGhpczIuX2VtaXRFcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzMi5fZmluZ2VycHJpbnQgPSBmaW5nZXJwcmludFZhbHVlO1xuICAgICAgICAgIF90aGlzMi5fc3RvcmFnZS5nZXRJdGVtKF90aGlzMi5fZmluZ2VycHJpbnQsIGZ1bmN0aW9uIChlcnIsIHJlc3VtZWRVcmwpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLl9lbWl0RXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVzdW1lZFVybCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIF90aGlzMi51cmwgPSByZXN1bWVkVXJsO1xuICAgICAgICAgICAgICBfdGhpczIuX3Jlc3VtZVVwbG9hZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXMyLl9jcmVhdGVVcGxvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBbiB1cGxvYWQgaGFzIG5vdCBzdGFydGVkIGZvciB0aGUgZmlsZSB5ZXQsIHNvIHdlIHN0YXJ0IGEgbmV3IG9uZVxuICAgICAgICB0aGlzLl9jcmVhdGVVcGxvYWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWJvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnQoc2hvdWxkVGVybWluYXRlLCBjYikge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl94aHIgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5feGhyLmFib3J0KCk7XG4gICAgICAgIHRoaXMuX3NvdXJjZS5jbG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWJvcnRlZCA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLl9yZXRyeVRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmV0cnlUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5fcmV0cnlUaW1lb3V0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY2IgPSBjYiB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIGlmIChzaG91bGRUZXJtaW5hdGUpIHtcbiAgICAgICAgVXBsb2FkLnRlcm1pbmF0ZSh0aGlzLnVybCwgdGhpcy5vcHRpb25zLCBmdW5jdGlvbiAoZXJyLCB4aHIpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IoZXJyLCB4aHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzMy5faGFzU3RvcmFnZSgpID8gX3RoaXMzLl9zdG9yYWdlLnJlbW92ZUl0ZW0oX3RoaXMzLl9maW5nZXJwcmludCwgY2IpIDogY2IoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaGFzU3RvcmFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFzU3RvcmFnZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmVzdW1lICYmIHRoaXMuX3N0b3JhZ2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9lbWl0WGhyRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRYaHJFcnJvcih4aHIsIGVyciwgY2F1c2luZ0Vycikge1xuICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBfZXJyb3IyLmRlZmF1bHQoZXJyLCBjYXVzaW5nRXJyLCB4aHIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdEVycm9yKGVycikge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25FcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkVycm9yKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9lbWl0U3VjY2Vzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdFN1Y2Nlc3MoKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vblN1Y2Nlc3MgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25TdWNjZXNzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVibGlzaGVzIG5vdGlmaWNhdGlvbiB3aGVuIGRhdGEgaGFzIGJlZW4gc2VudCB0byB0aGUgc2VydmVyLiBUaGlzXG4gICAgICogZGF0YSBtYXkgbm90IGhhdmUgYmVlbiBhY2NlcHRlZCBieSB0aGUgc2VydmVyIHlldC5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGJ5dGVzU2VudCAgTnVtYmVyIG9mIGJ5dGVzIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGJ5dGVzVG90YWwgVG90YWwgbnVtYmVyIG9mIGJ5dGVzIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9lbWl0UHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRQcm9ncmVzcyhieXRlc1NlbnQsIGJ5dGVzVG90YWwpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uUHJvZ3Jlc3MgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Qcm9ncmVzcyhieXRlc1NlbnQsIGJ5dGVzVG90YWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2hlcyBub3RpZmljYXRpb24gd2hlbiBhIGNodW5rIG9mIGRhdGEgaGFzIGJlZW4gc2VudCB0byB0aGUgc2VydmVyXG4gICAgICogYW5kIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBjaHVua1NpemUgIFNpemUgb2YgdGhlIGNodW5rIHRoYXQgd2FzIGFjY2VwdGVkIGJ5IHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIuXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBieXRlc0FjY2VwdGVkIFRvdGFsIG51bWJlciBvZiBieXRlcyB0aGF0IGhhdmUgYmVlblxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHRlZCBieSB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gYnl0ZXNUb3RhbCBUb3RhbCBudW1iZXIgb2YgYnl0ZXMgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRDaHVua0NvbXBsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbWl0Q2h1bmtDb21wbGV0ZShjaHVua1NpemUsIGJ5dGVzQWNjZXB0ZWQsIGJ5dGVzVG90YWwpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uQ2h1bmtDb21wbGV0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNodW5rQ29tcGxldGUoY2h1bmtTaXplLCBieXRlc0FjY2VwdGVkLCBieXRlc1RvdGFsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGhlYWRlcnMgdXNlZCBpbiB0aGUgcmVxdWVzdCBhbmQgdGhlIHdpdGhDcmVkZW50aWFscyBwcm9wZXJ0eVxuICAgICAqIGFzIGRlZmluZWQgaW4gdGhlIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R9IHhoclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldHVwWEhSXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cFhIUih4aHIpIHtcbiAgICAgIHRoaXMuX3hociA9IHhocjtcbiAgICAgIHNldHVwWEhSKHhociwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgdXBsb2FkIHVzaW5nIHRoZSBjcmVhdGlvbiBleHRlbnNpb24gYnkgc2VuZGluZyBhIFBPU1RcbiAgICAgKiByZXF1ZXN0IHRvIHRoZSBlbmRwb2ludC4gQWZ0ZXIgc3VjY2Vzc2Z1bCBjcmVhdGlvbiB0aGUgZmlsZSB3aWxsIGJlXG4gICAgICogdXBsb2FkZWRcbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlVXBsb2FkKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuZHBvaW50KSB7XG4gICAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoXCJ0dXM6IHVuYWJsZSB0byBjcmVhdGUgdXBsb2FkIGJlY2F1c2Ugbm8gZW5kcG9pbnQgaXMgcHJvdmlkZWRcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB4aHIgPSAoMCwgX3JlcXVlc3QubmV3UmVxdWVzdCkoKTtcbiAgICAgIHhoci5vcGVuKFwiUE9TVFwiLCB0aGlzLm9wdGlvbnMuZW5kcG9pbnQsIHRydWUpO1xuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWluU3RhdHVzQ2F0ZWdvcnkoeGhyLnN0YXR1cywgMjAwKSkge1xuICAgICAgICAgIF90aGlzNC5fZW1pdFhockVycm9yKHhociwgbmV3IEVycm9yKFwidHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIGNyZWF0aW5nIHVwbG9hZFwiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2F0aW9uID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiTG9jYXRpb25cIik7XG4gICAgICAgIGlmIChsb2NhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgX3RoaXM0Ll9lbWl0WGhyRXJyb3IoeGhyLCBuZXcgRXJyb3IoXCJ0dXM6IGludmFsaWQgb3IgbWlzc2luZyBMb2NhdGlvbiBoZWFkZXJcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzNC51cmwgPSAoMCwgX3JlcXVlc3QucmVzb2x2ZVVybCkoX3RoaXM0Lm9wdGlvbnMuZW5kcG9pbnQsIGxvY2F0aW9uKTtcblxuICAgICAgICBpZiAoX3RoaXM0Ll9zaXplID09PSAwKSB7XG4gICAgICAgICAgLy8gTm90aGluZyB0byB1cGxvYWQgYW5kIGZpbGUgd2FzIHN1Y2Nlc3NmdWxseSBjcmVhdGVkXG4gICAgICAgICAgX3RoaXM0Ll9lbWl0U3VjY2VzcygpO1xuICAgICAgICAgIF90aGlzNC5fc291cmNlLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzNC5faGFzU3RvcmFnZSgpKSB7XG4gICAgICAgICAgX3RoaXM0Ll9zdG9yYWdlLnNldEl0ZW0oX3RoaXM0Ll9maW5nZXJwcmludCwgX3RoaXM0LnVybCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBfdGhpczQuX2VtaXRFcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzNC5vcHRpb25zLnVwbG9hZERhdGFEdXJpbmdDcmVhdGlvbikge1xuICAgICAgICAgIF90aGlzNC5faGFuZGxlVXBsb2FkUmVzcG9uc2UoeGhyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczQuX29mZnNldCA9IDA7XG4gICAgICAgICAgX3RoaXM0Ll9zdGFydFVwbG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3RoaXM0Ll9lbWl0WGhyRXJyb3IoeGhyLCBuZXcgRXJyb3IoXCJ0dXM6IGZhaWxlZCB0byBjcmVhdGUgdXBsb2FkXCIpLCBlcnIpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fc2V0dXBYSFIoeGhyKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJVcGxvYWQtRGVmZXItTGVuZ3RoXCIsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJVcGxvYWQtTGVuZ3RoXCIsIHRoaXMuX3NpemUpO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgbWV0YWRhdGEgaWYgdmFsdWVzIGhhdmUgYmVlbiBhZGRlZFxuICAgICAgdmFyIG1ldGFkYXRhID0gZW5jb2RlTWV0YWRhdGEodGhpcy5vcHRpb25zLm1ldGFkYXRhKTtcbiAgICAgIGlmIChtZXRhZGF0YSAhPT0gXCJcIikge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlVwbG9hZC1NZXRhZGF0YVwiLCBtZXRhZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkRGF0YUR1cmluZ0NyZWF0aW9uICYmICF0aGlzLm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5fYWRkQ2h1bmtUb1JlcXVlc3QoeGhyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgICogVHJ5IHRvIHJlc3VtZSBhbiBleGlzdGluZyB1cGxvYWQuIEZpcnN0IGEgSEVBRCByZXF1ZXN0IHdpbGwgYmUgc2VudFxuICAgICAqIHRvIHJldHJpZXZlIHRoZSBvZmZzZXQuIElmIHRoZSByZXF1ZXN0IGZhaWxzIGEgbmV3IHVwbG9hZCB3aWxsIGJlXG4gICAgICogY3JlYXRlZC4gSW4gdGhlIGNhc2Ugb2YgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIHRoZSBmaWxlIHdpbGwgYmUgdXBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZXN1bWVVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc3VtZVVwbG9hZCgpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgeGhyID0gKDAsIF9yZXF1ZXN0Lm5ld1JlcXVlc3QpKCk7XG4gICAgICB4aHIub3BlbihcIkhFQURcIiwgdGhpcy51cmwsIHRydWUpO1xuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWluU3RhdHVzQ2F0ZWdvcnkoeGhyLnN0YXR1cywgMjAwKSkge1xuICAgICAgICAgIGlmIChfdGhpczUuX2hhc1N0b3JhZ2UoKSAmJiBpblN0YXR1c0NhdGVnb3J5KHhoci5zdGF0dXMsIDQwMCkpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBzdG9yZWQgZmluZ2VycHJpbnQgYW5kIGNvcnJlc3BvbmRpbmcgZW5kcG9pbnQsXG4gICAgICAgICAgICAvLyBvbiBjbGllbnQgZXJyb3JzIHNpbmNlIHRoZSBmaWxlIGNhbiBub3QgYmUgZm91bmRcbiAgICAgICAgICAgIF90aGlzNS5fc3RvcmFnZS5yZW1vdmVJdGVtKF90aGlzNS5fZmluZ2VycHJpbnQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIF90aGlzNS5fZW1pdEVycm9yKGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSB1cGxvYWQgaXMgbG9ja2VkIChpbmRpY2F0ZWQgYnkgdGhlIDQyMyBMb2NrZWQgc3RhdHVzIGNvZGUpLCB3ZVxuICAgICAgICAgIC8vIGVtaXQgYW4gZXJyb3IgaW5zdGVhZCBvZiBkaXJlY3RseSBzdGFydGluZyBhIG5ldyB1cGxvYWQuIFRoaXMgd2F5IHRoZVxuICAgICAgICAgIC8vIHJldHJ5IGxvZ2ljIGNhbiBjYXRjaCB0aGUgZXJyb3IgYW5kIHdpbGwgcmV0cnkgdGhlIHVwbG9hZC4gQW4gdXBsb2FkXG4gICAgICAgICAgLy8gaXMgdXN1YWxseSBsb2NrZWQgZm9yIGEgc2hvcnQgcGVyaW9kIG9mIHRpbWUgYW5kIHdpbGwgYmUgYXZhaWxhYmxlXG4gICAgICAgICAgLy8gYWZ0ZXJ3YXJkcy5cbiAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gNDIzKSB7XG4gICAgICAgICAgICBfdGhpczUuX2VtaXRYaHJFcnJvcih4aHIsIG5ldyBFcnJvcihcInR1czogdXBsb2FkIGlzIGN1cnJlbnRseSBsb2NrZWQ7IHJldHJ5IGxhdGVyXCIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIV90aGlzNS5vcHRpb25zLmVuZHBvaW50KSB7XG4gICAgICAgICAgICAvLyBEb24ndCBhdHRlbXB0IHRvIGNyZWF0ZSBhIG5ldyB1cGxvYWQgaWYgbm8gZW5kcG9pbnQgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICBfdGhpczUuX2VtaXRYaHJFcnJvcih4aHIsIG5ldyBFcnJvcihcInR1czogdW5hYmxlIHRvIHJlc3VtZSB1cGxvYWQgKG5ldyB1cGxvYWQgY2Fubm90IGJlIGNyZWF0ZWQgd2l0aG91dCBhbiBlbmRwb2ludClcIikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRyeSB0byBjcmVhdGUgYSBuZXcgdXBsb2FkXG4gICAgICAgICAgX3RoaXM1LnVybCA9IG51bGw7XG4gICAgICAgICAgX3RoaXM1Ll9jcmVhdGVVcGxvYWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2Zmc2V0ID0gcGFyc2VJbnQoeGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiVXBsb2FkLU9mZnNldFwiKSwgMTApO1xuICAgICAgICBpZiAoaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgICAgIF90aGlzNS5fZW1pdFhockVycm9yKHhociwgbmV3IEVycm9yKFwidHVzOiBpbnZhbGlkIG9yIG1pc3Npbmcgb2Zmc2V0IHZhbHVlXCIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gcGFyc2VJbnQoeGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiVXBsb2FkLUxlbmd0aFwiKSwgMTApO1xuICAgICAgICBpZiAoaXNOYU4obGVuZ3RoKSAmJiAhX3RoaXM1Lm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgICBfdGhpczUuX2VtaXRYaHJFcnJvcih4aHIsIG5ldyBFcnJvcihcInR1czogaW52YWxpZCBvciBtaXNzaW5nIGxlbmd0aCB2YWx1ZVwiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBsb2FkIGhhcyBhbHJlYWR5IGJlZW4gY29tcGxldGVkIGFuZCB3ZSBkbyBub3QgbmVlZCB0byBzZW5kIGFkZGl0aW9uYWxcbiAgICAgICAgLy8gZGF0YSB0byB0aGUgc2VydmVyXG4gICAgICAgIGlmIChvZmZzZXQgPT09IGxlbmd0aCkge1xuICAgICAgICAgIF90aGlzNS5fZW1pdFByb2dyZXNzKGxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgICBfdGhpczUuX2VtaXRTdWNjZXNzKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM1Ll9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIF90aGlzNS5fc3RhcnRVcGxvYWQoKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfdGhpczUuX2VtaXRYaHJFcnJvcih4aHIsIG5ldyBFcnJvcihcInR1czogZmFpbGVkIHRvIHJlc3VtZSB1cGxvYWRcIiksIGVycik7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zZXR1cFhIUih4aHIpO1xuICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgdXBsb2FkaW5nIHRoZSBmaWxlIHVzaW5nIFBBVENIIHJlcXVlc3RzLiBUaGUgZmlsZSB3aWxsIGJlIGRpdmlkZWRcbiAgICAgKiBpbnRvIGNodW5rcyBhcyBzcGVjaWZpZWQgaW4gdGhlIGNodW5rU2l6ZSBvcHRpb24uIER1cmluZyB0aGUgdXBsb2FkXG4gICAgICogdGhlIG9uUHJvZ3Jlc3MgZXZlbnQgaGFuZGxlciBtYXkgYmUgaW52b2tlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0YXJ0VXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFydFVwbG9hZCgpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAvLyBJZiB0aGUgdXBsb2FkIGhhcyBiZWVuIGFib3J0ZWQsIHdlIHdpbGwgbm90IHNlbmQgdGhlIG5leHQgUEFUQ0ggcmVxdWVzdC5cbiAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGlmIHRoZSBhYm9ydCBtZXRob2Qgd2FzIGNhbGxlZCBkdXJpbmcgYSBjYWxsYmFjaywgc3VjaFxuICAgICAgLy8gYXMgb25DaHVua0NvbXBsZXRlIG9yIG9uUHJvZ3Jlc3MuXG4gICAgICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB4aHIgPSAoMCwgX3JlcXVlc3QubmV3UmVxdWVzdCkoKTtcblxuICAgICAgLy8gU29tZSBicm93c2VyIGFuZCBzZXJ2ZXJzIG1heSBub3Qgc3VwcG9ydCB0aGUgUEFUQ0ggbWV0aG9kLiBGb3IgdGhvc2VcbiAgICAgIC8vIGNhc2VzLCB5b3UgY2FuIHRlbGwgdHVzLWpzLWNsaWVudCB0byB1c2UgYSBQT1NUIHJlcXVlc3Qgd2l0aCB0aGVcbiAgICAgIC8vIFgtSFRUUC1NZXRob2QtT3ZlcnJpZGUgaGVhZGVyIGZvciBzaW11bGF0aW5nIGEgUEFUQ0ggcmVxdWVzdC5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcnJpZGVQYXRjaE1ldGhvZCkge1xuICAgICAgICB4aHIub3BlbihcIlBPU1RcIiwgdGhpcy51cmwsIHRydWUpO1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlgtSFRUUC1NZXRob2QtT3ZlcnJpZGVcIiwgXCJQQVRDSFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhoci5vcGVuKFwiUEFUQ0hcIiwgdGhpcy51cmwsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWluU3RhdHVzQ2F0ZWdvcnkoeGhyLnN0YXR1cywgMjAwKSkge1xuICAgICAgICAgIF90aGlzNi5fZW1pdFhockVycm9yKHhociwgbmV3IEVycm9yKFwidHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIHVwbG9hZGluZyBjaHVua1wiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM2Ll9oYW5kbGVVcGxvYWRSZXNwb25zZSh4aHIpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8vIERvbid0IGVtaXQgYW4gZXJyb3IgaWYgdGhlIHVwbG9hZCB3YXMgYWJvcnRlZCBtYW51YWxseVxuICAgICAgICBpZiAoX3RoaXM2Ll9hYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM2Ll9lbWl0WGhyRXJyb3IoeGhyLCBuZXcgRXJyb3IoXCJ0dXM6IGZhaWxlZCB0byB1cGxvYWQgY2h1bmsgYXQgb2Zmc2V0IFwiICsgX3RoaXM2Ll9vZmZzZXQpLCBlcnIpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fc2V0dXBYSFIoeGhyKTtcblxuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJVcGxvYWQtT2Zmc2V0XCIsIHRoaXMuX29mZnNldCk7XG4gICAgICB0aGlzLl9hZGRDaHVua1RvUmVxdWVzdCh4aHIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIF9hZGRDaHVua3RvUmVxdWVzdCByZWFkcyBhIGNodW5rIGZyb20gdGhlIHNvdXJjZSBhbmQgc2VuZHMgaXQgdXNpbmcgdGhlXG4gICAgICogc3VwcGxpZWQgWEhSIG9iamVjdC4gSXQgd2lsbCBub3QgaGFuZGxlIHRoZSByZXNwb25zZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRDaHVua1RvUmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkQ2h1bmtUb1JlcXVlc3QoeGhyKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgLy8gVGVzdCBzdXBwb3J0IGZvciBwcm9ncmVzcyBldmVudHMgYmVmb3JlIGF0dGFjaGluZyBhbiBldmVudCBsaXN0ZW5lclxuICAgICAgaWYgKFwidXBsb2FkXCIgaW4geGhyKSB7XG4gICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKCFlLmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpczcuX2VtaXRQcm9ncmVzcyhzdGFydCArIGUubG9hZGVkLCBfdGhpczcuX3NpemUpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW1cIik7XG5cbiAgICAgIHZhciBzdGFydCA9IHRoaXMuX29mZnNldDtcbiAgICAgIHZhciBlbmQgPSB0aGlzLl9vZmZzZXQgKyB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuXG4gICAgICAvLyBUaGUgc3BlY2lmaWVkIGNodW5rU2l6ZSBtYXkgYmUgSW5maW5pdHkgb3IgdGhlIGNhbGNsdWF0ZWQgZW5kIHBvc2l0aW9uXG4gICAgICAvLyBtYXkgZXhjZWVkIHRoZSBmaWxlJ3Mgc2l6ZS4gSW4gYm90aCBjYXNlcywgd2UgbGltaXQgdGhlIGVuZCBwb3NpdGlvbiB0b1xuICAgICAgLy8gdGhlIGlucHV0J3MgdG90YWwgc2l6ZSBmb3Igc2ltcGxlciBjYWxjdWxhdGlvbnMgYW5kIGNvcnJlY3RuZXNzLlxuICAgICAgaWYgKChlbmQgPT09IEluZmluaXR5IHx8IGVuZCA+IHRoaXMuX3NpemUpICYmICF0aGlzLm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgZW5kID0gdGhpcy5fc2l6ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc291cmNlLnNsaWNlKHN0YXJ0LCBlbmQsIGZ1bmN0aW9uIChlcnIsIHZhbHVlLCBjb21wbGV0ZSkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgX3RoaXM3Ll9lbWl0RXJyb3IoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXM3Lm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgIF90aGlzNy5fc2l6ZSA9IF90aGlzNy5fb2Zmc2V0ICsgKHZhbHVlICYmIHZhbHVlLnNpemUgPyB2YWx1ZS5zaXplIDogMCk7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlVwbG9hZC1MZW5ndGhcIiwgX3RoaXM3Ll9zaXplKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZW5kKHZhbHVlKTtcbiAgICAgICAgICBfdGhpczcuX2VtaXRQcm9ncmVzcyhfdGhpczcuX29mZnNldCwgX3RoaXM3Ll9zaXplKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogX2hhbmRsZVVwbG9hZFJlc3BvbnNlIGlzIHVzZWQgYnkgcmVxdWVzdHMgdGhhdCBoYXZlbiBiZWVuIHNlbnQgdXNpbmcgX2FkZENodW5rVG9SZXF1ZXN0XG4gICAgICogYW5kIGFscmVhZHkgaGF2ZSByZWNlaXZlZCBhIHJlc3BvbnNlLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZVVwbG9hZFJlc3BvbnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVVcGxvYWRSZXNwb25zZSh4aHIpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gcGFyc2VJbnQoeGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiVXBsb2FkLU9mZnNldFwiKSwgMTApO1xuICAgICAgaWYgKGlzTmFOKG9mZnNldCkpIHtcbiAgICAgICAgdGhpcy5fZW1pdFhockVycm9yKHhociwgbmV3IEVycm9yKFwidHVzOiBpbnZhbGlkIG9yIG1pc3Npbmcgb2Zmc2V0IHZhbHVlXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbWl0UHJvZ3Jlc3Mob2Zmc2V0LCB0aGlzLl9zaXplKTtcbiAgICAgIHRoaXMuX2VtaXRDaHVua0NvbXBsZXRlKG9mZnNldCAtIHRoaXMuX29mZnNldCwgb2Zmc2V0LCB0aGlzLl9zaXplKTtcblxuICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgICBpZiAob2Zmc2V0ID09IHRoaXMuX3NpemUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzcyAmJiB0aGlzLm9wdGlvbnMucmVzdW1lKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHN0b3JlZCBmaW5nZXJwcmludCBhbmQgY29ycmVzcG9uZGluZyBlbmRwb2ludC4gVGhpcyBjYXVzZXNcbiAgICAgICAgICAvLyBuZXcgdXBsb2FkIG9mIHRoZSBzYW1lIGZpbGUgbXVzdCBiZSB0cmVhdGVkIGFzIGEgZGlmZmVyZW50IGZpbGUuXG4gICAgICAgICAgdGhpcy5fc3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuX2ZpbmdlcnByaW50LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIF90aGlzOC5fZW1pdEVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBZYXksIGZpbmFsbHkgZG9uZSA6KVxuICAgICAgICB0aGlzLl9lbWl0U3VjY2VzcygpO1xuICAgICAgICB0aGlzLl9zb3VyY2UuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zdGFydFVwbG9hZCgpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInRlcm1pbmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXJtaW5hdGUodXJsLCBvcHRpb25zLCBjYikge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGNiICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHVzOiBhIGNhbGxiYWNrIGZ1bmN0aW9uIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYiA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIHhociA9ICgwLCBfcmVxdWVzdC5uZXdSZXF1ZXN0KSgpO1xuICAgICAgeGhyLm9wZW4oXCJERUxFVEVcIiwgdXJsLCB0cnVlKTtcblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgIT09IDIwNCkge1xuICAgICAgICAgIGNiKG5ldyBfZXJyb3IyLmRlZmF1bHQobmV3IEVycm9yKFwidHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIHRlcm1pbmF0aW5nIHVwbG9hZFwiKSwgbnVsbCwgeGhyKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2IoKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBjYihuZXcgX2Vycm9yMi5kZWZhdWx0KGVyciwgbmV3IEVycm9yKFwidHVzOiBmYWlsZWQgdG8gdGVybWluYXRlIHVwbG9hZFwiKSwgeGhyKSk7XG4gICAgICB9O1xuXG4gICAgICBzZXR1cFhIUih4aHIsIG9wdGlvbnMpO1xuICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFVwbG9hZDtcbn0oKTtcblxuZnVuY3Rpb24gZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgdmFyIGVuY29kZWQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gbWV0YWRhdGEpIHtcbiAgICBlbmNvZGVkLnB1c2goa2V5ICsgXCIgXCIgKyBfanNCYXNlLkJhc2U2NC5lbmNvZGUobWV0YWRhdGFba2V5XSkpO1xuICB9XG5cbiAgcmV0dXJuIGVuY29kZWQuam9pbihcIixcIik7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBnaXZlbiBzdGF0dXMgaXMgaW4gdGhlIHJhbmdlIG9mIHRoZSBleHBlY3RlZCBjYXRlZ29yeS5cbiAqIEZvciBleGFtcGxlLCBvbmx5IGEgc3RhdHVzIGJldHdlZW4gMjAwIGFuZCAyOTkgd2lsbCBzYXRpc2Z5IHRoZSBjYXRlZ29yeSAyMDAuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluU3RhdHVzQ2F0ZWdvcnkoc3RhdHVzLCBjYXRlZ29yeSkge1xuICByZXR1cm4gc3RhdHVzID49IGNhdGVnb3J5ICYmIHN0YXR1cyA8IGNhdGVnb3J5ICsgMTAwO1xufVxuXG5mdW5jdGlvbiBzZXR1cFhIUih4aHIsIG9wdGlvbnMpIHtcbiAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJUdXMtUmVzdW1hYmxlXCIsIFwiMS4wLjBcIik7XG4gIHZhciBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuXG4gIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykge1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICB9XG5cbiAgeGhyLndpdGhDcmVkZW50aWFscyA9IG9wdGlvbnMud2l0aENyZWRlbnRpYWxzO1xufVxuXG5VcGxvYWQuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcblxuZXhwb3J0cy5kZWZhdWx0ID0gVXBsb2FkOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVkID0gcmVxdWlyZSgncmVxdWlyZXMtcG9ydCcpXG4gICwgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZ2lmeScpXG4gICwgc2xhc2hlcyA9IC9eW0EtWmEtel1bQS1aYS16MC05Ky0uXSo6XFwvXFwvL1xuICAsIHByb3RvY29scmUgPSAvXihbYS16XVthLXowLTkuKy1dKjopPyhcXC9cXC8pPyhbXFxTXFxzXSopL2lcbiAgLCB3aGl0ZXNwYWNlID0gJ1tcXFxceDA5XFxcXHgwQVxcXFx4MEJcXFxceDBDXFxcXHgwRFxcXFx4MjBcXFxceEEwXFxcXHUxNjgwXFxcXHUxODBFXFxcXHUyMDAwXFxcXHUyMDAxXFxcXHUyMDAyXFxcXHUyMDAzXFxcXHUyMDA0XFxcXHUyMDA1XFxcXHUyMDA2XFxcXHUyMDA3XFxcXHUyMDA4XFxcXHUyMDA5XFxcXHUyMDBBXFxcXHUyMDJGXFxcXHUyMDVGXFxcXHUzMDAwXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHVGRUZGXSdcbiAgLCBsZWZ0ID0gbmV3IFJlZ0V4cCgnXicrIHdoaXRlc3BhY2UgKycrJyk7XG5cbi8qKlxuICogVHJpbSBhIGdpdmVuIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byB0cmltLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0cmltTGVmdChzdHIpIHtcbiAgcmV0dXJuIChzdHIgPyBzdHIgOiAnJykudG9TdHJpbmcoKS5yZXBsYWNlKGxlZnQsICcnKTtcbn1cblxuLyoqXG4gKiBUaGVzZSBhcmUgdGhlIHBhcnNlIHJ1bGVzIGZvciB0aGUgVVJMIHBhcnNlciwgaXQgaW5mb3JtcyB0aGUgcGFyc2VyXG4gKiBhYm91dDpcbiAqXG4gKiAwLiBUaGUgY2hhciBpdCBOZWVkcyB0byBwYXJzZSwgaWYgaXQncyBhIHN0cmluZyBpdCBzaG91bGQgYmUgZG9uZSB1c2luZ1xuICogICAgaW5kZXhPZiwgUmVnRXhwIHVzaW5nIGV4ZWMgYW5kIE5hTiBtZWFucyBzZXQgYXMgY3VycmVudCB2YWx1ZS5cbiAqIDEuIFRoZSBwcm9wZXJ0eSB3ZSBzaG91bGQgc2V0IHdoZW4gcGFyc2luZyB0aGlzIHZhbHVlLlxuICogMi4gSW5kaWNhdGlvbiBpZiBpdCdzIGJhY2t3YXJkcyBvciBmb3J3YXJkIHBhcnNpbmcsIHdoZW4gc2V0IGFzIG51bWJlciBpdCdzXG4gKiAgICB0aGUgdmFsdWUgb2YgZXh0cmEgY2hhcnMgdGhhdCBzaG91bGQgYmUgc3BsaXQgb2ZmLlxuICogMy4gSW5oZXJpdCBmcm9tIGxvY2F0aW9uIGlmIG5vbiBleGlzdGluZyBpbiB0aGUgcGFyc2VyLlxuICogNC4gYHRvTG93ZXJDYXNlYCB0aGUgcmVzdWx0aW5nIHZhbHVlLlxuICovXG52YXIgcnVsZXMgPSBbXG4gIFsnIycsICdoYXNoJ10sICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJz8nLCAncXVlcnknXSwgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgZnVuY3Rpb24gc2FuaXRpemUoYWRkcmVzcykgeyAgICAgICAgICAvLyBTYW5pdGl6ZSB3aGF0IGlzIGxlZnQgb2YgdGhlIGFkZHJlc3NcbiAgICByZXR1cm4gYWRkcmVzcy5yZXBsYWNlKCdcXFxcJywgJy8nKTtcbiAgfSxcbiAgWycvJywgJ3BhdGhuYW1lJ10sICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnQCcsICdhdXRoJywgMV0sICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBmcm9udC5cbiAgW05hTiwgJ2hvc3QnLCB1bmRlZmluZWQsIDEsIDFdLCAgICAgICAvLyBTZXQgbGVmdCBvdmVyIHZhbHVlLlxuICBbLzooXFxkKykkLywgJ3BvcnQnLCB1bmRlZmluZWQsIDFdLCAgICAvLyBSZWdFeHAgdGhlIGJhY2suXG4gIFtOYU4sICdob3N0bmFtZScsIHVuZGVmaW5lZCwgMSwgMV0gICAgLy8gU2V0IGxlZnQgb3Zlci5cbl07XG5cbi8qKlxuICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgbm90IGJlIGNvcGllZCBvciBpbmhlcml0ZWQgZnJvbS4gVGhpcyBpcyBvbmx5IG5lZWRlZFxuICogZm9yIGFsbCBub24gYmxvYiBVUkwncyBhcyBhIGJsb2IgVVJMIGRvZXMgbm90IGluY2x1ZGUgYSBoYXNoLCBvbmx5IHRoZVxuICogb3JpZ2luLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgaWdub3JlID0geyBoYXNoOiAxLCBxdWVyeTogMSB9O1xuXG4vKipcbiAqIFRoZSBsb2NhdGlvbiBvYmplY3QgZGlmZmVycyB3aGVuIHlvdXIgY29kZSBpcyBsb2FkZWQgdGhyb3VnaCBhIG5vcm1hbCBwYWdlLFxuICogV29ya2VyIG9yIHRocm91Z2ggYSB3b3JrZXIgdXNpbmcgYSBibG9iLiBBbmQgd2l0aCB0aGUgYmxvYmJsZSBiZWdpbnMgdGhlXG4gKiB0cm91YmxlIGFzIHRoZSBsb2NhdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIHRoZSBVUkwgb2YgdGhlIGJsb2IsIG5vdCB0aGVcbiAqIGxvY2F0aW9uIG9mIHRoZSBwYWdlIHdoZXJlIG91ciBjb2RlIGlzIGxvYWRlZCBpbi4gVGhlIGFjdHVhbCBvcmlnaW4gaXNcbiAqIGVuY29kZWQgaW4gdGhlIGBwYXRobmFtZWAgc28gd2UgY2FuIHRoYW5rZnVsbHkgZ2VuZXJhdGUgYSBnb29kIFwiZGVmYXVsdFwiXG4gKiBsb2NhdGlvbiBmcm9tIGl0IHNvIHdlIGNhbiBnZW5lcmF0ZSBwcm9wZXIgcmVsYXRpdmUgVVJMJ3MgYWdhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2MgT3B0aW9uYWwgZGVmYXVsdCBsb2NhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2xjYXRpb24gb2JqZWN0LlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBsb2xjYXRpb24obG9jKSB7XG4gIHZhciBnbG9iYWxWYXI7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSB3aW5kb3c7XG4gIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSBnbG9iYWw7XG4gIGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgZ2xvYmFsVmFyID0gc2VsZjtcbiAgZWxzZSBnbG9iYWxWYXIgPSB7fTtcblxuICB2YXIgbG9jYXRpb24gPSBnbG9iYWxWYXIubG9jYXRpb24gfHwge307XG4gIGxvYyA9IGxvYyB8fCBsb2NhdGlvbjtcblxuICB2YXIgZmluYWxkZXN0aW5hdGlvbiA9IHt9XG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY1xuICAgICwga2V5O1xuXG4gIGlmICgnYmxvYjonID09PSBsb2MucHJvdG9jb2wpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybCh1bmVzY2FwZShsb2MucGF0aG5hbWUpLCB7fSk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGUpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybChsb2MsIHt9KTtcbiAgICBmb3IgKGtleSBpbiBpZ25vcmUpIGRlbGV0ZSBmaW5hbGRlc3RpbmF0aW9uW2tleV07XG4gIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGUpIHtcbiAgICBmb3IgKGtleSBpbiBsb2MpIHtcbiAgICAgIGlmIChrZXkgaW4gaWdub3JlKSBjb250aW51ZTtcbiAgICAgIGZpbmFsZGVzdGluYXRpb25ba2V5XSA9IGxvY1trZXldO1xuICAgIH1cblxuICAgIGlmIChmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID0gc2xhc2hlcy50ZXN0KGxvYy5ocmVmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmluYWxkZXN0aW5hdGlvbjtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBQcm90b2NvbEV4dHJhY3RcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIG1hdGNoZWQgaW4gdGhlIFVSTCwgaW4gbG93ZXJjYXNlLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBzbGFzaGVzIGB0cnVlYCBpZiBwcm90b2NvbCBpcyBmb2xsb3dlZCBieSBcIi8vXCIsIGVsc2UgYGZhbHNlYC5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZXN0IFJlc3Qgb2YgdGhlIFVSTCB0aGF0IGlzIG5vdCBwYXJ0IG9mIHRoZSBwcm90b2NvbC5cbiAqL1xuXG4vKipcbiAqIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gZnJvbSBhIFVSTCB3aXRoL3dpdGhvdXQgZG91YmxlIHNsYXNoIChcIi8vXCIpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIGV4dHJhY3QgZnJvbS5cbiAqIEByZXR1cm4ge1Byb3RvY29sRXh0cmFjdH0gRXh0cmFjdGVkIGluZm9ybWF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MpIHtcbiAgYWRkcmVzcyA9IHRyaW1MZWZ0KGFkZHJlc3MpO1xuICB2YXIgbWF0Y2ggPSBwcm90b2NvbHJlLmV4ZWMoYWRkcmVzcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogbWF0Y2hbMV0gPyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIDogJycsXG4gICAgc2xhc2hlczogISFtYXRjaFsyXSxcbiAgICByZXN0OiBtYXRjaFszXVxuICB9O1xufVxuXG4vKipcbiAqIFJlc29sdmUgYSByZWxhdGl2ZSBVUkwgcGF0aG5hbWUgYWdhaW5zdCBhIGJhc2UgVVJMIHBhdGhuYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWxhdGl2ZSBQYXRobmFtZSBvZiB0aGUgcmVsYXRpdmUgVVJMLlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2UgUGF0aG5hbWUgb2YgdGhlIGJhc2UgVVJMLlxuICogQHJldHVybiB7U3RyaW5nfSBSZXNvbHZlZCBwYXRobmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUocmVsYXRpdmUsIGJhc2UpIHtcbiAgaWYgKHJlbGF0aXZlID09PSAnJykgcmV0dXJuIGJhc2U7XG5cbiAgdmFyIHBhdGggPSAoYmFzZSB8fCAnLycpLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmNvbmNhdChyZWxhdGl2ZS5zcGxpdCgnLycpKVxuICAgICwgaSA9IHBhdGgubGVuZ3RoXG4gICAgLCBsYXN0ID0gcGF0aFtpIC0gMV1cbiAgICAsIHVuc2hpZnQgPSBmYWxzZVxuICAgICwgdXAgPSAwO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocGF0aFtpXSA9PT0gJy4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhdGhbaV0gPT09ICcuLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBpZiAoaSA9PT0gMCkgdW5zaGlmdCA9IHRydWU7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuc2hpZnQpIHBhdGgudW5zaGlmdCgnJyk7XG4gIGlmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgcGF0aC5wdXNoKCcnKTtcblxuICByZXR1cm4gcGF0aC5qb2luKCcvJyk7XG59XG5cbi8qKlxuICogVGhlIGFjdHVhbCBVUkwgaW5zdGFuY2UuIEluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIG9iamVjdCB3ZSd2ZSBvcHRlZC1pbiB0b1xuICogY3JlYXRlIGFuIGFjdHVhbCBjb25zdHJ1Y3RvciBhcyBpdCdzIG11Y2ggbW9yZSBtZW1vcnkgZWZmaWNpZW50IGFuZFxuICogZmFzdGVyIGFuZCBpdCBwbGVhc2VzIG15IE9DRC5cbiAqXG4gKiBJdCBpcyB3b3J0aCBub3RpbmcgdGhhdCB3ZSBzaG91bGQgbm90IHVzZSBgVVJMYCBhcyBjbGFzcyBuYW1lIHRvIHByZXZlbnRcbiAqIGNsYXNoZXMgd2l0aCB0aGUgZ2xvYmFsIFVSTCBpbnN0YW5jZSB0aGF0IGdvdCBpbnRyb2R1Y2VkIGluIGJyb3dzZXJzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gcGFyc2UuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtsb2NhdGlvbl0gTG9jYXRpb24gZGVmYXVsdHMgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBbcGFyc2VyXSBQYXJzZXIgZm9yIHRoZSBxdWVyeSBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcikge1xuICBhZGRyZXNzID0gdHJpbUxlZnQoYWRkcmVzcyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVybCkpIHtcbiAgICByZXR1cm4gbmV3IFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKTtcbiAgfVxuXG4gIHZhciByZWxhdGl2ZSwgZXh0cmFjdGVkLCBwYXJzZSwgaW5zdHJ1Y3Rpb24sIGluZGV4LCBrZXlcbiAgICAsIGluc3RydWN0aW9ucyA9IHJ1bGVzLnNsaWNlKClcbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jYXRpb25cbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIGkgPSAwO1xuXG4gIC8vXG4gIC8vIFRoZSBmb2xsb3dpbmcgaWYgc3RhdGVtZW50cyBhbGxvd3MgdGhpcyBtb2R1bGUgdHdvIGhhdmUgY29tcGF0aWJpbGl0eSB3aXRoXG4gIC8vIDIgZGlmZmVyZW50IEFQSTpcbiAgLy9cbiAgLy8gMS4gTm9kZS5qcydzIGB1cmwucGFyc2VgIGFwaSB3aGljaCBhY2NlcHRzIGEgVVJMLCBib29sZWFuIGFzIGFyZ3VtZW50c1xuICAvLyAgICB3aGVyZSB0aGUgYm9vbGVhbiBpbmRpY2F0ZXMgdGhhdCB0aGUgcXVlcnkgc3RyaW5nIHNob3VsZCBhbHNvIGJlIHBhcnNlZC5cbiAgLy9cbiAgLy8gMi4gVGhlIGBVUkxgIGludGVyZmFjZSBvZiB0aGUgYnJvd3NlciB3aGljaCBhY2NlcHRzIGEgVVJMLCBvYmplY3QgYXNcbiAgLy8gICAgYXJndW1lbnRzLiBUaGUgc3VwcGxpZWQgb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0IHZhbHVlcyAvIGZhbGwtYmFja1xuICAvLyAgICBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gIC8vXG4gIGlmICgnb2JqZWN0JyAhPT0gdHlwZSAmJiAnc3RyaW5nJyAhPT0gdHlwZSkge1xuICAgIHBhcnNlciA9IGxvY2F0aW9uO1xuICAgIGxvY2F0aW9uID0gbnVsbDtcbiAgfVxuXG4gIGlmIChwYXJzZXIgJiYgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHBhcnNlcikgcGFyc2VyID0gcXMucGFyc2U7XG5cbiAgbG9jYXRpb24gPSBsb2xjYXRpb24obG9jYXRpb24pO1xuXG4gIC8vXG4gIC8vIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gYmVmb3JlIHJ1bm5pbmcgdGhlIGluc3RydWN0aW9ucy5cbiAgLy9cbiAgZXh0cmFjdGVkID0gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MgfHwgJycpO1xuICByZWxhdGl2ZSA9ICFleHRyYWN0ZWQucHJvdG9jb2wgJiYgIWV4dHJhY3RlZC5zbGFzaGVzO1xuICB1cmwuc2xhc2hlcyA9IGV4dHJhY3RlZC5zbGFzaGVzIHx8IHJlbGF0aXZlICYmIGxvY2F0aW9uLnNsYXNoZXM7XG4gIHVybC5wcm90b2NvbCA9IGV4dHJhY3RlZC5wcm90b2NvbCB8fCBsb2NhdGlvbi5wcm90b2NvbCB8fCAnJztcbiAgYWRkcmVzcyA9IGV4dHJhY3RlZC5yZXN0O1xuXG4gIC8vXG4gIC8vIFdoZW4gdGhlIGF1dGhvcml0eSBjb21wb25lbnQgaXMgYWJzZW50IHRoZSBVUkwgc3RhcnRzIHdpdGggYSBwYXRoXG4gIC8vIGNvbXBvbmVudC5cbiAgLy9cbiAgaWYgKCFleHRyYWN0ZWQuc2xhc2hlcykgaW5zdHJ1Y3Rpb25zWzNdID0gWy8oLiopLywgJ3BhdGhuYW1lJ107XG5cbiAgZm9yICg7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1tpXTtcblxuICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFkZHJlc3MgPSBpbnN0cnVjdGlvbihhZGRyZXNzKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBhcnNlID0gaW5zdHJ1Y3Rpb25bMF07XG4gICAga2V5ID0gaW5zdHJ1Y3Rpb25bMV07XG5cbiAgICBpZiAocGFyc2UgIT09IHBhcnNlKSB7XG4gICAgICB1cmxba2V5XSA9IGFkZHJlc3M7XG4gICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBhcnNlKSB7XG4gICAgICBpZiAofihpbmRleCA9IGFkZHJlc3MuaW5kZXhPZihwYXJzZSkpKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGluc3RydWN0aW9uWzJdKSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZShpbmRleCArIGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGluZGV4ID0gcGFyc2UuZXhlYyhhZGRyZXNzKSkpIHtcbiAgICAgIHVybFtrZXldID0gaW5kZXhbMV07XG4gICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleC5pbmRleCk7XG4gICAgfVxuXG4gICAgdXJsW2tleV0gPSB1cmxba2V5XSB8fCAoXG4gICAgICByZWxhdGl2ZSAmJiBpbnN0cnVjdGlvblszXSA/IGxvY2F0aW9uW2tleV0gfHwgJycgOiAnJ1xuICAgICk7XG5cbiAgICAvL1xuICAgIC8vIEhvc3RuYW1lLCBob3N0IGFuZCBwcm90b2NvbCBzaG91bGQgYmUgbG93ZXJjYXNlZCBzbyB0aGV5IGNhbiBiZSB1c2VkIHRvXG4gICAgLy8gY3JlYXRlIGEgcHJvcGVyIGBvcmlnaW5gLlxuICAgIC8vXG4gICAgaWYgKGluc3RydWN0aW9uWzRdKSB1cmxba2V5XSA9IHVybFtrZXldLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICAvL1xuICAvLyBBbHNvIHBhcnNlIHRoZSBzdXBwbGllZCBxdWVyeSBzdHJpbmcgaW4gdG8gYW4gb2JqZWN0LiBJZiB3ZSdyZSBzdXBwbGllZFxuICAvLyB3aXRoIGEgY3VzdG9tIHBhcnNlciBhcyBmdW5jdGlvbiB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJ1aWxkLWluXG4gIC8vIHBhcnNlci5cbiAgLy9cbiAgaWYgKHBhcnNlcikgdXJsLnF1ZXJ5ID0gcGFyc2VyKHVybC5xdWVyeSk7XG5cbiAgLy9cbiAgLy8gSWYgdGhlIFVSTCBpcyByZWxhdGl2ZSwgcmVzb2x2ZSB0aGUgcGF0aG5hbWUgYWdhaW5zdCB0aGUgYmFzZSBVUkwuXG4gIC8vXG4gIGlmIChcbiAgICAgIHJlbGF0aXZlXG4gICAgJiYgbG9jYXRpb24uc2xhc2hlc1xuICAgICYmIHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJ1xuICAgICYmICh1cmwucGF0aG5hbWUgIT09ICcnIHx8IGxvY2F0aW9uLnBhdGhuYW1lICE9PSAnJylcbiAgKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gcmVzb2x2ZSh1cmwucGF0aG5hbWUsIGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIHNob3VsZCBub3QgYWRkIHBvcnQgbnVtYmVycyBpZiB0aGV5IGFyZSBhbHJlYWR5IHRoZSBkZWZhdWx0IHBvcnQgbnVtYmVyXG4gIC8vIGZvciBhIGdpdmVuIHByb3RvY29sLiBBcyB0aGUgaG9zdCBhbHNvIGNvbnRhaW5zIHRoZSBwb3J0IG51bWJlciB3ZSdyZSBnb2luZ1xuICAvLyBvdmVycmlkZSBpdCB3aXRoIHRoZSBob3N0bmFtZSB3aGljaCBjb250YWlucyBubyBwb3J0IG51bWJlci5cbiAgLy9cbiAgaWYgKCFyZXF1aXJlZCh1cmwucG9ydCwgdXJsLnByb3RvY29sKSkge1xuICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIHVybC5wb3J0ID0gJyc7XG4gIH1cblxuICAvL1xuICAvLyBQYXJzZSBkb3duIHRoZSBgYXV0aGAgZm9yIHRoZSB1c2VybmFtZSBhbmQgcGFzc3dvcmQuXG4gIC8vXG4gIHVybC51c2VybmFtZSA9IHVybC5wYXNzd29yZCA9ICcnO1xuICBpZiAodXJsLmF1dGgpIHtcbiAgICBpbnN0cnVjdGlvbiA9IHVybC5hdXRoLnNwbGl0KCc6Jyk7XG4gICAgdXJsLnVzZXJuYW1lID0gaW5zdHJ1Y3Rpb25bMF0gfHwgJyc7XG4gICAgdXJsLnBhc3N3b3JkID0gaW5zdHJ1Y3Rpb25bMV0gfHwgJyc7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIC8vXG4gIC8vIFRoZSBocmVmIGlzIGp1c3QgdGhlIGNvbXBpbGVkIHJlc3VsdC5cbiAgLy9cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY2hhbmdpbmcgcHJvcGVydGllcyBpbiB0aGUgVVJMIGluc3RhbmNlIHRvXG4gKiBpbnN1cmUgdGhhdCB0aGV5IGFsbCBwcm9wYWdhdGUgY29ycmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJ0ICAgICAgICAgIFByb3BlcnR5IHdlIG5lZWQgdG8gYWRqdXN0LlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgICAgICAgICAgVGhlIG5ld2x5IGFzc2lnbmVkIHZhbHVlLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBmbiAgV2hlbiBzZXR0aW5nIHRoZSBxdWVyeSwgaXQgd2lsbCBiZSB0aGUgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgdG8gcGFyc2UgdGhlIHF1ZXJ5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiBzZXR0aW5nIHRoZSBwcm90b2NvbCwgZG91YmxlIHNsYXNoIHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgZnJvbSB0aGUgZmluYWwgdXJsIGlmIGl0IGlzIHRydWUuXG4gKiBAcmV0dXJucyB7VVJMfSBVUkwgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXQocGFydCwgdmFsdWUsIGZuKSB7XG4gIHZhciB1cmwgPSB0aGlzO1xuXG4gIHN3aXRjaCAocGFydCkge1xuICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IChmbiB8fCBxcy5wYXJzZSkodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncG9ydCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKCFyZXF1aXJlZCh2YWx1ZSwgdXJsLnByb3RvY29sKSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgdXJsW3BhcnRdID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lICsnOicrIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3RuYW1lJzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAodXJsLnBvcnQpIHZhbHVlICs9ICc6JysgdXJsLnBvcnQ7XG4gICAgICB1cmwuaG9zdCA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoLzpcXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnOicpO1xuICAgICAgICB1cmwucG9ydCA9IHZhbHVlLnBvcCgpO1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZS5qb2luKCc6Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZTtcbiAgICAgICAgdXJsLnBvcnQgPSAnJztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwcm90b2NvbCc6XG4gICAgICB1cmwucHJvdG9jb2wgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdXJsLnNsYXNoZXMgPSAhZm47XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BhdGhuYW1lJzpcbiAgICBjYXNlICdoYXNoJzpcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgY2hhciA9IHBhcnQgPT09ICdwYXRobmFtZScgPyAnLycgOiAnIyc7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlLmNoYXJBdCgwKSAhPT0gY2hhciA/IGNoYXIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zID0gcnVsZXNbaV07XG5cbiAgICBpZiAoaW5zWzRdKSB1cmxbaW5zWzFdXSA9IHVybFtpbnNbMV1dLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgYmFjayBpbiB0byBhIHZhbGlkIGFuZCBmdWxsIFVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5naWZ5IE9wdGlvbmFsIHF1ZXJ5IHN0cmluZ2lmeSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IENvbXBpbGVkIHZlcnNpb24gb2YgdGhlIFVSTC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZ5KSB7XG4gIGlmICghc3RyaW5naWZ5IHx8ICdmdW5jdGlvbicgIT09IHR5cGVvZiBzdHJpbmdpZnkpIHN0cmluZ2lmeSA9IHFzLnN0cmluZ2lmeTtcblxuICB2YXIgcXVlcnlcbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIHByb3RvY29sID0gdXJsLnByb3RvY29sO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5jaGFyQXQocHJvdG9jb2wubGVuZ3RoIC0gMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIHZhciByZXN1bHQgPSBwcm90b2NvbCArICh1cmwuc2xhc2hlcyA/ICcvLycgOiAnJyk7XG5cbiAgaWYgKHVybC51c2VybmFtZSkge1xuICAgIHJlc3VsdCArPSB1cmwudXNlcm5hbWU7XG4gICAgaWYgKHVybC5wYXNzd29yZCkgcmVzdWx0ICs9ICc6JysgdXJsLnBhc3N3b3JkO1xuICAgIHJlc3VsdCArPSAnQCc7XG4gIH1cblxuICByZXN1bHQgKz0gdXJsLmhvc3QgKyB1cmwucGF0aG5hbWU7XG5cbiAgcXVlcnkgPSAnb2JqZWN0JyA9PT0gdHlwZW9mIHVybC5xdWVyeSA/IHN0cmluZ2lmeSh1cmwucXVlcnkpIDogdXJsLnF1ZXJ5O1xuICBpZiAocXVlcnkpIHJlc3VsdCArPSAnPycgIT09IHF1ZXJ5LmNoYXJBdCgwKSA/ICc/JysgcXVlcnkgOiBxdWVyeTtcblxuICBpZiAodXJsLmhhc2gpIHJlc3VsdCArPSB1cmwuaGFzaDtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5VcmwucHJvdG90eXBlID0geyBzZXQ6IHNldCwgdG9TdHJpbmc6IHRvU3RyaW5nIH07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIFVSTCBwYXJzZXIgYW5kIHNvbWUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgYmUgdXNlZnVsIGZvclxuLy8gb3RoZXJzIG9yIHRlc3RpbmcuXG4vL1xuVXJsLmV4dHJhY3RQcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbDtcblVybC5sb2NhdGlvbiA9IGxvbGNhdGlvbjtcblVybC50cmltTGVmdCA9IHRyaW1MZWZ0O1xuVXJsLnFzID0gcXM7XG5cbm1vZHVsZS5leHBvcnRzID0gVXJsO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgoZ2xvYmFsLldIQVRXR0ZldGNoID0ge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBzZWxmLFxuICAgIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBzZWxmICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICAgIGJsb2I6XG4gICAgICAnRmlsZVJlYWRlcicgaW4gc2VsZiAmJlxuICAgICAgJ0Jsb2InIGluIHNlbGYgJiZcbiAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXcgQmxvYigpO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfTtcblxuICBmdW5jdGlvbiBpc0RhdGFWaWV3KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgICBdO1xuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICAgIEFycmF5QnVmZmVyLmlzVmlldyB8fFxuICAgICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXTtcbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgfTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICAgIGlmIChidWYuc2xpY2UpIHtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKTtcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcik7XG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7XG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHM7XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kO1xuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTtcbiAgICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsO1xuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXQ7XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpO1xuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJztcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGw7XG4gICAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbDtcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbDtcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSk7XG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7Ym9keTogdGhpcy5fYm9keUluaXR9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBib2R5XG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoJyYnKVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjJcbiAgICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKTtcbiAgICBwcmVQcm9jZXNzZWRIZWFkZXJzLnNwbGl0KC9cXHI/XFxuLykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKCk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKCk7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnO1xuICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzO1xuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDA7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJ3N0YXR1c1RleHQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiAnT0snO1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJztcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdCk7XG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKTtcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9O1xuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSk7XG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcic7XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH07XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdO1xuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH07XG5cbiAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBzZWxmLkRPTUV4Y2VwdGlvbjtcbiAgdHJ5IHtcbiAgICBuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIH07XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGV4cG9ydHMuRE9NRXhjZXB0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KTtcblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LnVybCwgdHJ1ZSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG5cbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdCk7XG4gICAgfSlcbiAgfVxuXG4gIGZldGNoLnBvbHlmaWxsID0gdHJ1ZTtcblxuICBpZiAoIXNlbGYuZmV0Y2gpIHtcbiAgICBzZWxmLmZldGNoID0gZmV0Y2g7XG4gICAgc2VsZi5IZWFkZXJzID0gSGVhZGVycztcbiAgICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICAgIHNlbGYuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgfVxuXG4gIGV4cG9ydHMuSGVhZGVycyA9IEhlYWRlcnM7XG4gIGV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIGV4cG9ydHMuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgZXhwb3J0cy5mZXRjaCA9IGZldGNoO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvKiBqc2hpbnQgbm9kZTogdHJ1ZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAgIyB3aWxkY2FyZFxuXG4gIFZlcnkgc2ltcGxlIHdpbGRjYXJkIG1hdGNoaW5nLCB3aGljaCBpcyBkZXNpZ25lZCB0byBwcm92aWRlIHRoZSBzYW1lXG4gIGZ1bmN0aW9uYWxpdHkgdGhhdCBpcyBmb3VuZCBpbiB0aGVcbiAgW2V2ZV0oaHR0cHM6Ly9naXRodWIuY29tL2Fkb2JlLXdlYnBsYXRmb3JtL2V2ZSkgZXZlbnRpbmcgbGlicmFyeS5cblxuICAjIyBVc2FnZVxuXG4gIEl0IHdvcmtzIHdpdGggc3RyaW5nczpcblxuICA8PDwgZXhhbXBsZXMvc3RyaW5ncy5qc1xuXG4gIEFycmF5czpcblxuICA8PDwgZXhhbXBsZXMvYXJyYXlzLmpzXG5cbiAgT2JqZWN0cyAobWF0Y2hpbmcgYWdhaW5zdCBrZXlzKTpcblxuICA8PDwgZXhhbXBsZXMvb2JqZWN0cy5qc1xuXG4gIFdoaWxlIHRoZSBsaWJyYXJ5IHdvcmtzIGluIE5vZGUsIGlmIHlvdSBhcmUgYXJlIGxvb2tpbmcgZm9yIGZpbGUtYmFzZWRcbiAgd2lsZGNhcmQgbWF0Y2hpbmcgdGhlbiB5b3Ugc2hvdWxkIGhhdmUgYSBsb29rIGF0OlxuXG4gIDxodHRwczovL2dpdGh1Yi5jb20vaXNhYWNzL25vZGUtZ2xvYj5cbioqL1xuXG5mdW5jdGlvbiBXaWxkY2FyZE1hdGNoZXIodGV4dCwgc2VwYXJhdG9yKSB7XG4gIHRoaXMudGV4dCA9IHRleHQgPSB0ZXh0IHx8ICcnO1xuICB0aGlzLmhhc1dpbGQgPSB+dGV4dC5pbmRleE9mKCcqJyk7XG4gIHRoaXMuc2VwYXJhdG9yID0gc2VwYXJhdG9yO1xuICB0aGlzLnBhcnRzID0gdGV4dC5zcGxpdChzZXBhcmF0b3IpO1xufVxuXG5XaWxkY2FyZE1hdGNoZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIG1hdGNoZXMgPSB0cnVlO1xuICB2YXIgcGFydHMgPSB0aGlzLnBhcnRzO1xuICB2YXIgaWk7XG4gIHZhciBwYXJ0c0NvdW50ID0gcGFydHMubGVuZ3RoO1xuICB2YXIgdGVzdFBhcnRzO1xuXG4gIGlmICh0eXBlb2YgaW5wdXQgPT0gJ3N0cmluZycgfHwgaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMuaGFzV2lsZCAmJiB0aGlzLnRleHQgIT0gaW5wdXQpIHtcbiAgICAgIG1hdGNoZXMgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGVzdFBhcnRzID0gKGlucHV0IHx8ICcnKS5zcGxpdCh0aGlzLnNlcGFyYXRvcik7XG4gICAgICBmb3IgKGlpID0gMDsgbWF0Y2hlcyAmJiBpaSA8IHBhcnRzQ291bnQ7IGlpKyspIHtcbiAgICAgICAgaWYgKHBhcnRzW2lpXSA9PT0gJyonKSAge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGlpIDwgdGVzdFBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgIG1hdGNoZXMgPSBwYXJ0c1tpaV0gPT09IHRlc3RQYXJ0c1tpaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG1hdGNoZXMsIHRoZW4gcmV0dXJuIHRoZSBjb21wb25lbnQgcGFydHNcbiAgICAgIG1hdGNoZXMgPSBtYXRjaGVzICYmIHRlc3RQYXJ0cztcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGlucHV0LnNwbGljZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgbWF0Y2hlcyA9IFtdO1xuXG4gICAgZm9yIChpaSA9IGlucHV0Lmxlbmd0aDsgaWktLTsgKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaChpbnB1dFtpaV0pKSB7XG4gICAgICAgIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGhdID0gaW5wdXRbaWldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT0gJ29iamVjdCcpIHtcbiAgICBtYXRjaGVzID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gaW5wdXQpIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKGtleSkpIHtcbiAgICAgICAgbWF0Y2hlc1trZXldID0gaW5wdXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGV4dCwgdGVzdCwgc2VwYXJhdG9yKSB7XG4gIHZhciBtYXRjaGVyID0gbmV3IFdpbGRjYXJkTWF0Y2hlcih0ZXh0LCBzZXBhcmF0b3IgfHwgL1tcXC9cXC5dLyk7XG4gIGlmICh0eXBlb2YgdGVzdCAhPSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBtYXRjaGVyLm1hdGNoKHRlc3QpO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXI7XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9jb21wYW5pb24tY2xpZW50XCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJDbGllbnQgbGlicmFyeSBmb3IgY29tbXVuaWNhdGlvbiB3aXRoIENvbXBhbmlvbi4gSW50ZW5kZWQgZm9yIHVzZSBpbiBVcHB5IHBsdWdpbnMuXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuNC4xXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiLFxuICAgIFwiY29tcGFuaW9uXCIsXG4gICAgXCJwcm92aWRlclwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwibmFtZXNwYWNlLWVtaXR0ZXJcIjogXCJeMi4wLjFcIlxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuY2xhc3MgQXV0aEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoJ0F1dGhvcml6YXRpb24gcmVxdWlyZWQnKVxuICAgIHRoaXMubmFtZSA9ICdBdXRoRXJyb3InXG4gICAgdGhpcy5pc0F1dGhFcnJvciA9IHRydWVcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dGhFcnJvclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFJlcXVlc3RDbGllbnQgPSByZXF1aXJlKCcuL1JlcXVlc3RDbGllbnQnKVxuY29uc3QgdG9rZW5TdG9yYWdlID0gcmVxdWlyZSgnLi90b2tlblN0b3JhZ2UnKVxuXG5jb25zdCBfZ2V0TmFtZSA9IChpZCkgPT4ge1xuICByZXR1cm4gaWQuc3BsaXQoJy0nKS5tYXAoKHMpID0+IHMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpKS5qb2luKCcgJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBQcm92aWRlciBleHRlbmRzIFJlcXVlc3RDbGllbnQge1xuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5wcm92aWRlciA9IG9wdHMucHJvdmlkZXJcbiAgICB0aGlzLmlkID0gdGhpcy5wcm92aWRlclxuICAgIHRoaXMuYXV0aFByb3ZpZGVyID0gb3B0cy5hdXRoUHJvdmlkZXIgfHwgdGhpcy5wcm92aWRlclxuICAgIHRoaXMubmFtZSA9IHRoaXMub3B0cy5uYW1lIHx8IF9nZXROYW1lKHRoaXMuaWQpXG4gICAgdGhpcy5wbHVnaW5JZCA9IHRoaXMub3B0cy5wbHVnaW5JZFxuICAgIHRoaXMudG9rZW5LZXkgPSBgY29tcGFuaW9uLSR7dGhpcy5wbHVnaW5JZH0tYXV0aC10b2tlbmBcbiAgfVxuXG4gIGhlYWRlcnMgKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzdXBlci5oZWFkZXJzKCkudGhlbigoaGVhZGVycykgPT4ge1xuICAgICAgICB0aGlzLmdldEF1dGhUb2tlbigpLnRoZW4oKHRva2VuKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShPYmplY3QuYXNzaWduKHt9LCBoZWFkZXJzLCB7ICd1cHB5LWF1dGgtdG9rZW4nOiB0b2tlbiB9KSlcbiAgICAgICAgfSlcbiAgICAgIH0pLmNhdGNoKHJlamVjdClcbiAgICB9KVxuICB9XG5cbiAgb25SZWNlaXZlUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gICAgcmVzcG9uc2UgPSBzdXBlci5vblJlY2VpdmVSZXNwb25zZShyZXNwb25zZSlcbiAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKHRoaXMucGx1Z2luSWQpXG4gICAgY29uc3Qgb2xkQXV0aGVudGljYXRlZCA9IHBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpLmF1dGhlbnRpY2F0ZWRcbiAgICBjb25zdCBhdXRoZW50aWNhdGVkID0gb2xkQXV0aGVudGljYXRlZCA/IHJlc3BvbnNlLnN0YXR1cyAhPT0gNDAxIDogcmVzcG9uc2Uuc3RhdHVzIDwgNDAwXG4gICAgcGx1Z2luLnNldFBsdWdpblN0YXRlKHsgYXV0aGVudGljYXRlZCB9KVxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgLy8gQHRvZG8oaS5vbGFyZXdhanUpIGNvbnNpZGVyIHdoZXRoZXIgb3Igbm90IHRoaXMgbWV0aG9kIHNob3VsZCBiZSBleHBvc2VkXG4gIHNldEF1dGhUb2tlbiAodG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy51cHB5LmdldFBsdWdpbih0aGlzLnBsdWdpbklkKS5zdG9yYWdlLnNldEl0ZW0odGhpcy50b2tlbktleSwgdG9rZW4pXG4gIH1cblxuICBnZXRBdXRoVG9rZW4gKCkge1xuICAgIHJldHVybiB0aGlzLnVwcHkuZ2V0UGx1Z2luKHRoaXMucGx1Z2luSWQpLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnRva2VuS2V5KVxuICB9XG5cbiAgYXV0aFVybCAoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuaG9zdG5hbWV9LyR7dGhpcy5pZH0vY29ubmVjdGBcbiAgfVxuXG4gIGZpbGVVcmwgKGlkKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuaG9zdG5hbWV9LyR7dGhpcy5pZH0vZ2V0LyR7aWR9YFxuICB9XG5cbiAgbGlzdCAoZGlyZWN0b3J5KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGAke3RoaXMuaWR9L2xpc3QvJHtkaXJlY3RvcnkgfHwgJyd9YClcbiAgfVxuXG4gIGxvZ291dCAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuZ2V0KGAke3RoaXMuaWR9L2xvZ291dGApXG4gICAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICB0aGlzLnVwcHkuZ2V0UGx1Z2luKHRoaXMucGx1Z2luSWQpLnN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnRva2VuS2V5KVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gcmVzb2x2ZShyZXMpKVxuICAgICAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICAgICAgfSkuY2F0Y2gocmVqZWN0KVxuICAgIH0pXG4gIH1cblxuICBzdGF0aWMgaW5pdFBsdWdpbiAocGx1Z2luLCBvcHRzLCBkZWZhdWx0T3B0cykge1xuICAgIHBsdWdpbi50eXBlID0gJ2FjcXVpcmVyJ1xuICAgIHBsdWdpbi5maWxlcyA9IFtdXG4gICAgaWYgKGRlZmF1bHRPcHRzKSB7XG4gICAgICBwbHVnaW4ub3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRzLCBvcHRzKVxuICAgIH1cblxuICAgIGlmIChvcHRzLnNlcnZlclVybCB8fCBvcHRzLnNlcnZlclBhdHRlcm4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHNlcnZlclVybGAgYW5kIGBzZXJ2ZXJQYXR0ZXJuYCBoYXZlIGJlZW4gcmVuYW1lZCB0byBgY29tcGFuaW9uVXJsYCBhbmQgYGNvbXBhbmlvbkFsbG93ZWRIb3N0c2AgcmVzcGVjdGl2ZWx5IGluIHRoZSAwLjMwLjUgcmVsZWFzZS4gUGxlYXNlIGNvbnN1bHQgdGhlIGRvY3MgKGZvciBleGFtcGxlLCBodHRwczovL3VwcHkuaW8vZG9jcy9pbnN0YWdyYW0vIGZvciB0aGUgSW5zdGFncmFtIHBsdWdpbikgYW5kIHVzZSB0aGUgdXBkYXRlZCBvcHRpb25zLmAnKVxuICAgIH1cblxuICAgIGlmIChvcHRzLmNvbXBhbmlvbkFsbG93ZWRIb3N0cykge1xuICAgICAgY29uc3QgcGF0dGVybiA9IG9wdHMuY29tcGFuaW9uQWxsb3dlZEhvc3RzXG4gICAgICAvLyB2YWxpZGF0ZSBjb21wYW5pb25BbGxvd2VkSG9zdHMgcGFyYW1cbiAgICAgIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkocGF0dGVybikgJiYgIShwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3BsdWdpbi5pZH06IHRoZSBvcHRpb24gXCJjb21wYW5pb25BbGxvd2VkSG9zdHNcIiBtdXN0IGJlIG9uZSBvZiBzdHJpbmcsIEFycmF5LCBSZWdFeHBgKVxuICAgICAgfVxuICAgICAgcGx1Z2luLm9wdHMuY29tcGFuaW9uQWxsb3dlZEhvc3RzID0gcGF0dGVyblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkb2VzIG5vdCBzdGFydCB3aXRoIGh0dHBzOi8vXG4gICAgICBpZiAoL14oPyFodHRwcz86XFwvXFwvKS4qJC9pLnRlc3Qob3B0cy5jb21wYW5pb25VcmwpKSB7XG4gICAgICAgIHBsdWdpbi5vcHRzLmNvbXBhbmlvbkFsbG93ZWRIb3N0cyA9IGBodHRwczovLyR7b3B0cy5jb21wYW5pb25VcmwucmVwbGFjZSgvXlxcL1xcLy8sICcnKX1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwbHVnaW4ub3B0cy5jb21wYW5pb25BbGxvd2VkSG9zdHMgPSBvcHRzLmNvbXBhbmlvblVybFxuICAgICAgfVxuICAgIH1cblxuICAgIHBsdWdpbi5zdG9yYWdlID0gcGx1Z2luLm9wdHMuc3RvcmFnZSB8fCB0b2tlblN0b3JhZ2VcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEF1dGhFcnJvciA9IHJlcXVpcmUoJy4vQXV0aEVycm9yJylcblxuLy8gUmVtb3ZlIHRoZSB0cmFpbGluZyBzbGFzaCBzbyB3ZSBjYW4gYWx3YXlzIHNhZmVseSBhcHBlbmQgL3h5ei5cbmZ1bmN0aW9uIHN0cmlwU2xhc2ggKHVybCkge1xuICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcLyQvLCAnJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBSZXF1ZXN0Q2xpZW50IHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICB0aGlzLnVwcHkgPSB1cHB5XG4gICAgdGhpcy5vcHRzID0gb3B0c1xuICAgIHRoaXMub25SZWNlaXZlUmVzcG9uc2UgPSB0aGlzLm9uUmVjZWl2ZVJlc3BvbnNlLmJpbmQodGhpcylcbiAgICB0aGlzLmFsbG93ZWRIZWFkZXJzID0gWydhY2NlcHQnLCAnY29udGVudC10eXBlJywgJ3VwcHktYXV0aC10b2tlbiddXG4gICAgdGhpcy5wcmVmbGlnaHREb25lID0gZmFsc2VcbiAgfVxuXG4gIGdldCBob3N0bmFtZSAoKSB7XG4gICAgY29uc3QgeyBjb21wYW5pb24gfSA9IHRoaXMudXBweS5nZXRTdGF0ZSgpXG4gICAgY29uc3QgaG9zdCA9IHRoaXMub3B0cy5jb21wYW5pb25VcmxcbiAgICByZXR1cm4gc3RyaXBTbGFzaChjb21wYW5pb24gJiYgY29tcGFuaW9uW2hvc3RdID8gY29tcGFuaW9uW2hvc3RdIDogaG9zdClcbiAgfVxuXG4gIGdldCBkZWZhdWx0SGVhZGVycyAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICdVcHB5LVZlcnNpb25zJzogYEB1cHB5L2NvbXBhbmlvbi1jbGllbnQ9JHtSZXF1ZXN0Q2xpZW50LlZFUlNJT059YFxuICAgIH1cbiAgfVxuXG4gIGhlYWRlcnMgKCkge1xuICAgIGNvbnN0IHVzZXJIZWFkZXJzID0gdGhpcy5vcHRzLmNvbXBhbmlvbkhlYWRlcnMgfHwgdGhpcy5vcHRzLnNlcnZlckhlYWRlcnMgfHwge31cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIC4uLnRoaXMuZGVmYXVsdEhlYWRlcnMsXG4gICAgICAuLi51c2VySGVhZGVyc1xuICAgIH0pXG4gIH1cblxuICBfZ2V0UG9zdFJlc3BvbnNlRnVuYyAoc2tpcCkge1xuICAgIHJldHVybiAocmVzcG9uc2UpID0+IHtcbiAgICAgIGlmICghc2tpcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vblJlY2VpdmVSZXNwb25zZShyZXNwb25zZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgfVxuICB9XG5cbiAgb25SZWNlaXZlUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnVwcHkuZ2V0U3RhdGUoKVxuICAgIGNvbnN0IGNvbXBhbmlvbiA9IHN0YXRlLmNvbXBhbmlvbiB8fCB7fVxuICAgIGNvbnN0IGhvc3QgPSB0aGlzLm9wdHMuY29tcGFuaW9uVXJsXG4gICAgY29uc3QgaGVhZGVycyA9IHJlc3BvbnNlLmhlYWRlcnNcbiAgICAvLyBTdG9yZSB0aGUgc2VsZi1pZGVudGlmaWVkIGRvbWFpbiBuYW1lIGZvciB0aGUgQ29tcGFuaW9uIGluc3RhbmNlIHdlIGp1c3QgaGl0LlxuICAgIGlmIChoZWFkZXJzLmhhcygnaS1hbScpICYmIGhlYWRlcnMuZ2V0KCdpLWFtJykgIT09IGNvbXBhbmlvbltob3N0XSkge1xuICAgICAgdGhpcy51cHB5LnNldFN0YXRlKHtcbiAgICAgICAgY29tcGFuaW9uOiBPYmplY3QuYXNzaWduKHt9LCBjb21wYW5pb24sIHtcbiAgICAgICAgICBbaG9zdF06IGhlYWRlcnMuZ2V0KCdpLWFtJylcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgX2dldFVybCAodXJsKSB7XG4gICAgaWYgKC9eKGh0dHBzPzp8KVxcL1xcLy8udGVzdCh1cmwpKSB7XG4gICAgICByZXR1cm4gdXJsXG4gICAgfVxuICAgIHJldHVybiBgJHt0aGlzLmhvc3RuYW1lfS8ke3VybH1gXG4gIH1cblxuICBfanNvbiAocmVzKSB7XG4gICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgdGhyb3cgbmV3IEF1dGhFcnJvcigpXG4gICAgfVxuXG4gICAgaWYgKHJlcy5zdGF0dXMgPCAyMDAgfHwgcmVzLnN0YXR1cyA+IDMwMCkge1xuICAgICAgbGV0IGVyck1zZyA9IGBGYWlsZWQgcmVxdWVzdCB3aXRoIHN0YXR1czogJHtyZXMuc3RhdHVzfS4gJHtyZXMuc3RhdHVzVGV4dH1gXG4gICAgICByZXR1cm4gcmVzLmpzb24oKVxuICAgICAgICAudGhlbigoZXJyRGF0YSkgPT4ge1xuICAgICAgICAgIGVyck1zZyA9IGVyckRhdGEubWVzc2FnZSA/IGAke2Vyck1zZ30gbWVzc2FnZTogJHtlcnJEYXRhLm1lc3NhZ2V9YCA6IGVyck1zZ1xuICAgICAgICAgIGVyck1zZyA9IGVyckRhdGEucmVxdWVzdElkID8gYCR7ZXJyTXNnfSByZXF1ZXN0LUlkOiAke2VyckRhdGEucmVxdWVzdElkfWAgOiBlcnJNc2dcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKVxuICAgICAgICB9KS5jYXRjaCgoKSA9PiB7IHRocm93IG5ldyBFcnJvcihlcnJNc2cpIH0pXG4gICAgfVxuICAgIHJldHVybiByZXMuanNvbigpXG4gIH1cblxuICBwcmVmbGlnaHQgKHBhdGgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMucHJlZmxpZ2h0RG9uZSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSh0aGlzLmFsbG93ZWRIZWFkZXJzLnNsaWNlKCkpXG4gICAgICB9XG5cbiAgICAgIGZldGNoKHRoaXMuX2dldFVybChwYXRoKSwge1xuICAgICAgICBtZXRob2Q6ICdPUFRJT05TJ1xuICAgICAgfSlcbiAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuaGFzKCdhY2Nlc3MtY29udHJvbC1hbGxvdy1oZWFkZXJzJykpIHtcbiAgICAgICAgICAgIHRoaXMuYWxsb3dlZEhlYWRlcnMgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnYWNjZXNzLWNvbnRyb2wtYWxsb3ctaGVhZGVycycpXG4gICAgICAgICAgICAgIC5zcGxpdCgnLCcpLm1hcCgoaGVhZGVyTmFtZSkgPT4gaGVhZGVyTmFtZS50cmltKCkudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wcmVmbGlnaHREb25lID0gdHJ1ZVxuICAgICAgICAgIHJlc29sdmUodGhpcy5hbGxvd2VkSGVhZGVycy5zbGljZSgpKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHRoaXMudXBweS5sb2coYFtDb21wYW5pb25DbGllbnRdIHVuYWJsZSB0byBtYWtlIHByZWZsaWdodCByZXF1ZXN0ICR7ZXJyfWAsICd3YXJuaW5nJylcbiAgICAgICAgICB0aGlzLnByZWZsaWdodERvbmUgPSB0cnVlXG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLmFsbG93ZWRIZWFkZXJzLnNsaWNlKCkpXG4gICAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHByZWZsaWdodEFuZEhlYWRlcnMgKHBhdGgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3RoaXMucHJlZmxpZ2h0KHBhdGgpLCB0aGlzLmhlYWRlcnMoKV0pXG4gICAgICAudGhlbigoW2FsbG93ZWRIZWFkZXJzLCBoZWFkZXJzXSkgPT4ge1xuICAgICAgICAvLyBmaWx0ZXIgdG8ga2VlcCBvbmx5IGFsbG93ZWQgSGVhZGVyc1xuICAgICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKS5mb3JFYWNoKChoZWFkZXIpID0+IHtcbiAgICAgICAgICBpZiAoYWxsb3dlZEhlYWRlcnMuaW5kZXhPZihoZWFkZXIudG9Mb3dlckNhc2UoKSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnVwcHkubG9nKGBbQ29tcGFuaW9uQ2xpZW50XSBleGNsdWRpbmcgdW5hbGxvd2VkIGhlYWRlciAke2hlYWRlcn1gKVxuICAgICAgICAgICAgZGVsZXRlIGhlYWRlcnNbaGVhZGVyXVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gaGVhZGVyc1xuICAgICAgfSlcbiAgfVxuXG4gIGdldCAocGF0aCwgc2tpcFBvc3RSZXNwb25zZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnByZWZsaWdodEFuZEhlYWRlcnMocGF0aCkudGhlbigoaGVhZGVycykgPT4ge1xuICAgICAgICBmZXRjaCh0aGlzLl9nZXRVcmwocGF0aCksIHtcbiAgICAgICAgICBtZXRob2Q6ICdnZXQnLFxuICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidcbiAgICAgICAgfSlcbiAgICAgICAgICAudGhlbih0aGlzLl9nZXRQb3N0UmVzcG9uc2VGdW5jKHNraXBQb3N0UmVzcG9uc2UpKVxuICAgICAgICAgIC50aGVuKChyZXMpID0+IHRoaXMuX2pzb24ocmVzKS50aGVuKHJlc29sdmUpKVxuICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBlcnIgPSBlcnIuaXNBdXRoRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoYENvdWxkIG5vdCBnZXQgJHt0aGlzLl9nZXRVcmwocGF0aCl9LiAke2Vycn1gKVxuICAgICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgICB9KVxuICAgICAgfSkuY2F0Y2gocmVqZWN0KVxuICAgIH0pXG4gIH1cblxuICBwb3N0IChwYXRoLCBkYXRhLCBza2lwUG9zdFJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucHJlZmxpZ2h0QW5kSGVhZGVycyhwYXRoKS50aGVuKChoZWFkZXJzKSA9PiB7XG4gICAgICAgIGZldGNoKHRoaXMuX2dldFVybChwYXRoKSwge1xuICAgICAgICAgIG1ldGhvZDogJ3Bvc3QnLFxuICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgICAgICAgfSlcbiAgICAgICAgICAudGhlbih0aGlzLl9nZXRQb3N0UmVzcG9uc2VGdW5jKHNraXBQb3N0UmVzcG9uc2UpKVxuICAgICAgICAgIC50aGVuKChyZXMpID0+IHRoaXMuX2pzb24ocmVzKS50aGVuKHJlc29sdmUpKVxuICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBlcnIgPSBlcnIuaXNBdXRoRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoYENvdWxkIG5vdCBwb3N0ICR7dGhpcy5fZ2V0VXJsKHBhdGgpfS4gJHtlcnJ9YClcbiAgICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgICAgfSlcbiAgICAgIH0pLmNhdGNoKHJlamVjdClcbiAgICB9KVxuICB9XG5cbiAgZGVsZXRlIChwYXRoLCBkYXRhLCBza2lwUG9zdFJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucHJlZmxpZ2h0QW5kSGVhZGVycyhwYXRoKS50aGVuKChoZWFkZXJzKSA9PiB7XG4gICAgICAgIGZldGNoKGAke3RoaXMuaG9zdG5hbWV9LyR7cGF0aH1gLCB7XG4gICAgICAgICAgbWV0aG9kOiAnZGVsZXRlJyxcbiAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgICAgICAgIGJvZHk6IGRhdGEgPyBKU09OLnN0cmluZ2lmeShkYXRhKSA6IG51bGxcbiAgICAgICAgfSlcbiAgICAgICAgICAudGhlbih0aGlzLl9nZXRQb3N0UmVzcG9uc2VGdW5jKHNraXBQb3N0UmVzcG9uc2UpKVxuICAgICAgICAgIC50aGVuKChyZXMpID0+IHRoaXMuX2pzb24ocmVzKS50aGVuKHJlc29sdmUpKVxuICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBlcnIgPSBlcnIuaXNBdXRoRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoYENvdWxkIG5vdCBkZWxldGUgJHt0aGlzLl9nZXRVcmwocGF0aCl9LiAke2Vycn1gKVxuICAgICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgICB9KVxuICAgICAgfSkuY2F0Y2gocmVqZWN0KVxuICAgIH0pXG4gIH1cbn1cbiIsImNvbnN0IGVlID0gcmVxdWlyZSgnbmFtZXNwYWNlLWVtaXR0ZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFVwcHlTb2NrZXQge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHRoaXMub3B0cyA9IG9wdHNcbiAgICB0aGlzLl9xdWV1ZWQgPSBbXVxuICAgIHRoaXMuaXNPcGVuID0gZmFsc2VcbiAgICB0aGlzLmVtaXR0ZXIgPSBlZSgpXG5cbiAgICB0aGlzLl9oYW5kbGVNZXNzYWdlID0gdGhpcy5faGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLmNsb3NlID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5lbWl0ID0gdGhpcy5lbWl0LmJpbmQodGhpcylcbiAgICB0aGlzLm9uID0gdGhpcy5vbi5iaW5kKHRoaXMpXG4gICAgdGhpcy5vbmNlID0gdGhpcy5vbmNlLmJpbmQodGhpcylcbiAgICB0aGlzLnNlbmQgPSB0aGlzLnNlbmQuYmluZCh0aGlzKVxuXG4gICAgaWYgKCFvcHRzIHx8IG9wdHMuYXV0b09wZW4gIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLm9wZW4oKVxuICAgIH1cbiAgfVxuXG4gIG9wZW4gKCkge1xuICAgIHRoaXMuc29ja2V0ID0gbmV3IFdlYlNvY2tldCh0aGlzLm9wdHMudGFyZ2V0KVxuXG4gICAgdGhpcy5zb2NrZXQub25vcGVuID0gKGUpID0+IHtcbiAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZVxuXG4gICAgICB3aGlsZSAodGhpcy5fcXVldWVkLmxlbmd0aCA+IDAgJiYgdGhpcy5pc09wZW4pIHtcbiAgICAgICAgY29uc3QgZmlyc3QgPSB0aGlzLl9xdWV1ZWRbMF1cbiAgICAgICAgdGhpcy5zZW5kKGZpcnN0LmFjdGlvbiwgZmlyc3QucGF5bG9hZClcbiAgICAgICAgdGhpcy5fcXVldWVkID0gdGhpcy5fcXVldWVkLnNsaWNlKDEpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zb2NrZXQub25jbG9zZSA9IChlKSA9PiB7XG4gICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlXG4gICAgfVxuXG4gICAgdGhpcy5zb2NrZXQub25tZXNzYWdlID0gdGhpcy5faGFuZGxlTWVzc2FnZVxuICB9XG5cbiAgY2xvc2UgKCkge1xuICAgIGlmICh0aGlzLnNvY2tldCkge1xuICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIHNlbmQgKGFjdGlvbiwgcGF5bG9hZCkge1xuICAgIC8vIGF0dGFjaCB1dWlkXG5cbiAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICB0aGlzLl9xdWV1ZWQucHVzaCh7IGFjdGlvbiwgcGF5bG9hZCB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICBhY3Rpb24sXG4gICAgICBwYXlsb2FkXG4gICAgfSkpXG4gIH1cblxuICBvbiAoYWN0aW9uLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5lbWl0dGVyLm9uKGFjdGlvbiwgaGFuZGxlcilcbiAgfVxuXG4gIGVtaXQgKGFjdGlvbiwgcGF5bG9hZCkge1xuICAgIHRoaXMuZW1pdHRlci5lbWl0KGFjdGlvbiwgcGF5bG9hZClcbiAgfVxuXG4gIG9uY2UgKGFjdGlvbiwgaGFuZGxlcikge1xuICAgIHRoaXMuZW1pdHRlci5vbmNlKGFjdGlvbiwgaGFuZGxlcilcbiAgfVxuXG4gIF9oYW5kbGVNZXNzYWdlIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnBhcnNlKGUuZGF0YSlcbiAgICAgIHRoaXMuZW1pdChtZXNzYWdlLmFjdGlvbiwgbWVzc2FnZS5wYXlsb2FkKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5sb2coZXJyKVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTWFuYWdlcyBjb21tdW5pY2F0aW9ucyB3aXRoIENvbXBhbmlvblxuICovXG5cbmNvbnN0IFJlcXVlc3RDbGllbnQgPSByZXF1aXJlKCcuL1JlcXVlc3RDbGllbnQnKVxuY29uc3QgUHJvdmlkZXIgPSByZXF1aXJlKCcuL1Byb3ZpZGVyJylcbmNvbnN0IFNvY2tldCA9IHJlcXVpcmUoJy4vU29ja2V0JylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJlcXVlc3RDbGllbnQsXG4gIFByb3ZpZGVyLFxuICBTb2NrZXRcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIFRoaXMgbW9kdWxlIHNlcnZlcyBhcyBhbiBBc3luYyB3cmFwcGVyIGZvciBMb2NhbFN0b3JhZ2VcbiAqL1xubW9kdWxlLmV4cG9ydHMuc2V0SXRlbSA9IChrZXksIHZhbHVlKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpXG4gICAgcmVzb2x2ZSgpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzLmdldEl0ZW0gPSAoa2V5KSA9PiB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSlcbn1cblxubW9kdWxlLmV4cG9ydHMucmVtb3ZlSXRlbSA9IChrZXkpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KVxuICAgIHJlc29sdmUoKVxuICB9KVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9jb3JlXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJDb3JlIG1vZHVsZSBmb3IgdGhlIGV4dGVuc2libGUgSmF2YVNjcmlwdCBmaWxlIHVwbG9hZCB3aWRnZXQgd2l0aCBzdXBwb3J0IGZvciBkcmFnJmRyb3AsIHJlc3VtYWJsZSB1cGxvYWRzLCBwcmV2aWV3cywgcmVzdHJpY3Rpb25zLCBmaWxlIHByb2Nlc3NpbmcvZW5jb2RpbmcsIHJlbW90ZSBwcm92aWRlcnMgbGlrZSBJbnN0YWdyYW0sIERyb3Bib3gsIEdvb2dsZSBEcml2ZSwgUzMgYW5kIG1vcmUgOmRvZzpcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS43LjFcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInN0eWxlXCI6IFwiZGlzdC9zdHlsZS5taW4uY3NzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L3N0b3JlLWRlZmF1bHRcIjogXCJmaWxlOi4uL3N0b3JlLWRlZmF1bHRcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwiY3VpZFwiOiBcIl4yLjEuMVwiLFxuICAgIFwibG9kYXNoLnRocm90dGxlXCI6IFwiXjQuMS4xXCIsXG4gICAgXCJtaW1lLW1hdGNoXCI6IFwiXjEuMC4yXCIsXG4gICAgXCJuYW1lc3BhY2UtZW1pdHRlclwiOiBcIl4yLjAuMVwiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9XG59XG4iLCJjb25zdCBwcmVhY3QgPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgZmluZERPTUVsZW1lbnQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZmluZERPTUVsZW1lbnQnKVxuXG4vKipcbiAqIERlZmVyIGEgZnJlcXVlbnQgY2FsbCB0byB0aGUgbWljcm90YXNrIHF1ZXVlLlxuICovXG5mdW5jdGlvbiBkZWJvdW5jZSAoZm4pIHtcbiAgbGV0IGNhbGxpbmcgPSBudWxsXG4gIGxldCBsYXRlc3RBcmdzID0gbnVsbFxuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICBsYXRlc3RBcmdzID0gYXJnc1xuICAgIGlmICghY2FsbGluZykge1xuICAgICAgY2FsbGluZyA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBjYWxsaW5nID0gbnVsbFxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IGBhcmdzYCBtYXkgYmUgZGlmZmVyZW50IGZyb20gdGhlIG1vc3RcbiAgICAgICAgLy8gcmVjZW50IHN0YXRlLCBpZiBtdWx0aXBsZSBjYWxscyBoYXBwZW5lZCBzaW5jZSB0aGlzIHRhc2tcbiAgICAgICAgLy8gd2FzIHF1ZXVlZC4gU28gd2UgdXNlIHRoZSBgbGF0ZXN0QXJnc2AsIHdoaWNoIGRlZmluaXRlbHlcbiAgICAgICAgLy8gaXMgdGhlIG1vc3QgcmVjZW50IGNhbGwuXG4gICAgICAgIHJldHVybiBmbiguLi5sYXRlc3RBcmdzKVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxpbmdcbiAgfVxufVxuXG4vKipcbiAqIEJvaWxlcnBsYXRlIHRoYXQgYWxsIFBsdWdpbnMgc2hhcmUgLSBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkXG4gKiBkaXJlY3RseS4gSXQgYWxzbyBzaG93cyB3aGljaCBtZXRob2RzIGZpbmFsIHBsdWdpbnMgc2hvdWxkIGltcGxlbWVudC9vdmVycmlkZSxcbiAqIHRoaXMgZGVjaWRpbmcgb24gc3RydWN0dXJlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBtYWluIFVwcHkgY29yZSBvYmplY3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3Qgd2l0aCBwbHVnaW4gb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5fHN0cmluZ30gZmlsZXMgb3Igc3VjY2Vzcy9mYWlsIG1lc3NhZ2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBQbHVnaW4ge1xuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHRoaXMudXBweSA9IHVwcHlcbiAgICB0aGlzLm9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICB0aGlzLnVwZGF0ZSA9IHRoaXMudXBkYXRlLmJpbmQodGhpcylcbiAgICB0aGlzLm1vdW50ID0gdGhpcy5tb3VudC5iaW5kKHRoaXMpXG4gICAgdGhpcy5pbnN0YWxsID0gdGhpcy5pbnN0YWxsLmJpbmQodGhpcylcbiAgICB0aGlzLnVuaW5zdGFsbCA9IHRoaXMudW5pbnN0YWxsLmJpbmQodGhpcylcbiAgfVxuXG4gIGdldFBsdWdpblN0YXRlICgpIHtcbiAgICBjb25zdCB7IHBsdWdpbnMgfSA9IHRoaXMudXBweS5nZXRTdGF0ZSgpXG4gICAgcmV0dXJuIHBsdWdpbnNbdGhpcy5pZF0gfHwge31cbiAgfVxuXG4gIHNldFBsdWdpblN0YXRlICh1cGRhdGUpIHtcbiAgICBjb25zdCB7IHBsdWdpbnMgfSA9IHRoaXMudXBweS5nZXRTdGF0ZSgpXG5cbiAgICB0aGlzLnVwcHkuc2V0U3RhdGUoe1xuICAgICAgcGx1Z2luczoge1xuICAgICAgICAuLi5wbHVnaW5zLFxuICAgICAgICBbdGhpcy5pZF06IHtcbiAgICAgICAgICAuLi5wbHVnaW5zW3RoaXMuaWRdLFxuICAgICAgICAgIC4uLnVwZGF0ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHNldE9wdGlvbnMgKG5ld09wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSB7IC4uLnRoaXMub3B0cywgLi4ubmV3T3B0cyB9XG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSgpIC8vIHNvIHRoYXQgVUkgcmUtcmVuZGVycyB3aXRoIG5ldyBvcHRpb25zXG4gIH1cblxuICB1cGRhdGUgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmVsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3VwZGF0ZVVJKSB7XG4gICAgICB0aGlzLl91cGRhdGVVSShzdGF0ZSlcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgYWZ0ZXIgZXZlcnkgc3RhdGUgdXBkYXRlLCBhZnRlciBldmVyeXRoaW5nJ3MgbW91bnRlZC4gRGVib3VuY2VkLlxuICBhZnRlclVwZGF0ZSAoKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBwbHVnaW4gaXMgbW91bnRlZCwgd2hldGhlciBpbiBET00gb3IgaW50byBhbm90aGVyIHBsdWdpbi5cbiAgICogTmVlZGVkIGJlY2F1c2Ugc29tZXRpbWVzIHBsdWdpbnMgYXJlIG1vdW50ZWQgc2VwYXJhdGVseS9hZnRlciBgaW5zdGFsbGAsXG4gICAqIHNvIHRoaXMuZWwgYW5kIHRoaXMucGFyZW50IG1pZ2h0IG5vdCBiZSBhdmFpbGFibGUgaW4gYGluc3RhbGxgLlxuICAgKiBUaGlzIGlzIHRoZSBjYXNlIHdpdGggQHVwcHkvcmVhY3QgcGx1Z2lucywgZm9yIGV4YW1wbGUuXG4gICAqL1xuICBvbk1vdW50ICgpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHN1cHBsaWVkIGB0YXJnZXRgIGlzIGEgRE9NIGVsZW1lbnQgb3IgYW4gYG9iamVjdGAuXG4gICAqIElmIGl04oCZcyBhbiBvYmplY3Qg4oCUIHRhcmdldCBpcyBhIHBsdWdpbiwgYW5kIHdlIHNlYXJjaCBgcGx1Z2luc2BcbiAgICogZm9yIGEgcGx1Z2luIHdpdGggc2FtZSBuYW1lIGFuZCByZXR1cm4gaXRzIHRhcmdldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSB0YXJnZXRcbiAgICpcbiAgICovXG4gIG1vdW50ICh0YXJnZXQsIHBsdWdpbikge1xuICAgIGNvbnN0IGNhbGxlclBsdWdpbk5hbWUgPSBwbHVnaW4uaWRcblxuICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBmaW5kRE9NRWxlbWVudCh0YXJnZXQpXG5cbiAgICBpZiAodGFyZ2V0RWxlbWVudCkge1xuICAgICAgdGhpcy5pc1RhcmdldERPTUVsID0gdHJ1ZVxuXG4gICAgICAvLyBBUEkgZm9yIHBsdWdpbnMgdGhhdCByZXF1aXJlIGEgc3luY2hyb25vdXMgcmVyZW5kZXIuXG4gICAgICB0aGlzLnJlcmVuZGVyID0gKHN0YXRlKSA9PiB7XG4gICAgICAgIC8vIHBsdWdpbiBjb3VsZCBiZSByZW1vdmVkLCBidXQgdGhpcy5yZXJlbmRlciBpcyBkZWJvdW5jZWQgYmVsb3csXG4gICAgICAgIC8vIHNvIGl0IGNvdWxkIHN0aWxsIGJlIGNhbGxlZCBldmVuIGFmdGVyIHVwcHkucmVtb3ZlUGx1Z2luIG9yIHVwcHkuY2xvc2VcbiAgICAgICAgLy8gaGVuY2UgdGhlIGNoZWNrXG4gICAgICAgIGlmICghdGhpcy51cHB5LmdldFBsdWdpbih0aGlzLmlkKSkgcmV0dXJuXG4gICAgICAgIHRoaXMuZWwgPSBwcmVhY3QucmVuZGVyKHRoaXMucmVuZGVyKHN0YXRlKSwgdGFyZ2V0RWxlbWVudCwgdGhpcy5lbClcbiAgICAgICAgdGhpcy5hZnRlclVwZGF0ZSgpXG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVVSSA9IGRlYm91bmNlKHRoaXMucmVyZW5kZXIpXG5cbiAgICAgIHRoaXMudXBweS5sb2coYEluc3RhbGxpbmcgJHtjYWxsZXJQbHVnaW5OYW1lfSB0byBhIERPTSBlbGVtZW50ICcke3RhcmdldH0nYClcblxuICAgICAgLy8gY2xlYXIgZXZlcnl0aGluZyBpbnNpZGUgdGhlIHRhcmdldCBjb250YWluZXJcbiAgICAgIGlmICh0aGlzLm9wdHMucmVwbGFjZVRhcmdldENvbnRlbnQpIHtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5pbm5lckhUTUwgPSAnJ1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsID0gcHJlYWN0LnJlbmRlcih0aGlzLnJlbmRlcih0aGlzLnVwcHkuZ2V0U3RhdGUoKSksIHRhcmdldEVsZW1lbnQpXG5cbiAgICAgIHRoaXMub25Nb3VudCgpXG4gICAgICByZXR1cm4gdGhpcy5lbFxuICAgIH1cblxuICAgIGxldCB0YXJnZXRQbHVnaW5cbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgdGFyZ2V0IGluc3RhbmNlb2YgUGx1Z2luKSB7XG4gICAgICAvLyBUYXJnZXRpbmcgYSBwbHVnaW4gKmluc3RhbmNlKlxuICAgICAgdGFyZ2V0UGx1Z2luID0gdGFyZ2V0XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBUYXJnZXRpbmcgYSBwbHVnaW4gdHlwZVxuICAgICAgY29uc3QgVGFyZ2V0ID0gdGFyZ2V0XG4gICAgICAvLyBGaW5kIHRoZSB0YXJnZXQgcGx1Z2luIGluc3RhbmNlLlxuICAgICAgdGhpcy51cHB5Lml0ZXJhdGVQbHVnaW5zKChwbHVnaW4pID0+IHtcbiAgICAgICAgaWYgKHBsdWdpbiBpbnN0YW5jZW9mIFRhcmdldCkge1xuICAgICAgICAgIHRhcmdldFBsdWdpbiA9IHBsdWdpblxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0YXJnZXRQbHVnaW4pIHtcbiAgICAgIHRoaXMudXBweS5sb2coYEluc3RhbGxpbmcgJHtjYWxsZXJQbHVnaW5OYW1lfSB0byAke3RhcmdldFBsdWdpbi5pZH1gKVxuICAgICAgdGhpcy5wYXJlbnQgPSB0YXJnZXRQbHVnaW5cbiAgICAgIHRoaXMuZWwgPSB0YXJnZXRQbHVnaW4uYWRkVGFyZ2V0KHBsdWdpbilcblxuICAgICAgdGhpcy5vbk1vdW50KClcbiAgICAgIHJldHVybiB0aGlzLmVsXG4gICAgfVxuXG4gICAgdGhpcy51cHB5LmxvZyhgTm90IGluc3RhbGxpbmcgJHtjYWxsZXJQbHVnaW5OYW1lfWApXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRhcmdldCBvcHRpb24gZ2l2ZW4gdG8gJHtjYWxsZXJQbHVnaW5OYW1lfS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGF0IHRoZSBlbGVtZW50XG4gICAgICBleGlzdHMgb24gdGhlIHBhZ2UsIG9yIHRoYXQgdGhlIHBsdWdpbiB5b3UgYXJlIHRhcmdldGluZyBoYXMgYmVlbiBpbnN0YWxsZWQuIENoZWNrIHRoYXQgdGhlIDxzY3JpcHQ+IHRhZyBpbml0aWFsaXppbmcgVXBweVxuICAgICAgY29tZXMgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcGFnZSwgYmVmb3JlIHRoZSBjbG9zaW5nIDwvYm9keT4gdGFnIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzLzEwNDIpLmApXG4gIH1cblxuICByZW5kZXIgKHN0YXRlKSB7XG4gICAgdGhyb3cgKG5ldyBFcnJvcignRXh0ZW5kIHRoZSByZW5kZXIgbWV0aG9kIHRvIGFkZCB5b3VyIHBsdWdpbiB0byBhIERPTSBlbGVtZW50JykpXG4gIH1cblxuICBhZGRUYXJnZXQgKHBsdWdpbikge1xuICAgIHRocm93IChuZXcgRXJyb3IoJ0V4dGVuZCB0aGUgYWRkVGFyZ2V0IG1ldGhvZCB0byBhZGQgeW91ciBwbHVnaW4gdG8gYW5vdGhlciBwbHVnaW5cXCdzIHRhcmdldCcpKVxuICB9XG5cbiAgdW5tb3VudCAoKSB7XG4gICAgaWYgKHRoaXMuaXNUYXJnZXRET01FbCAmJiB0aGlzLmVsICYmIHRoaXMuZWwucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpXG4gICAgfVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG5cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy51bm1vdW50KClcbiAgfVxufVxuIiwiY29uc3QgVHJhbnNsYXRvciA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9UcmFuc2xhdG9yJylcbmNvbnN0IGVlID0gcmVxdWlyZSgnbmFtZXNwYWNlLWVtaXR0ZXInKVxuY29uc3QgY3VpZCA9IHJlcXVpcmUoJ2N1aWQnKVxuY29uc3QgdGhyb3R0bGUgPSByZXF1aXJlKCdsb2Rhc2gudGhyb3R0bGUnKVxuY29uc3QgcHJldHR5Qnl0ZXMgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvcHJldHR5Qnl0ZXMnKVxuY29uc3QgbWF0Y2ggPSByZXF1aXJlKCdtaW1lLW1hdGNoJylcbmNvbnN0IERlZmF1bHRTdG9yZSA9IHJlcXVpcmUoJ0B1cHB5L3N0b3JlLWRlZmF1bHQnKVxuY29uc3QgZ2V0RmlsZVR5cGUgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0RmlsZVR5cGUnKVxuY29uc3QgZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24gPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2V0RmlsZU5hbWVBbmRFeHRlbnNpb24nKVxuY29uc3QgZ2VuZXJhdGVGaWxlSUQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvZ2VuZXJhdGVGaWxlSUQnKVxuY29uc3Qgc3VwcG9ydHNVcGxvYWRQcm9ncmVzcyA9IHJlcXVpcmUoJy4vc3VwcG9ydHNVcGxvYWRQcm9ncmVzcycpXG5jb25zdCB7IG51bGxMb2dnZXIsIGRlYnVnTG9nZ2VyIH0gPSByZXF1aXJlKCcuL2xvZ2dlcnMnKVxuY29uc3QgUGx1Z2luID0gcmVxdWlyZSgnLi9QbHVnaW4nKSAvLyBFeHBvcnRlZCBmcm9tIGhlcmUuXG5cbmNsYXNzIFJlc3RyaWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcbiAgICB0aGlzLmlzUmVzdHJpY3Rpb24gPSB0cnVlXG4gIH1cbn1cblxuLyoqXG4gKiBVcHB5IENvcmUgbW9kdWxlLlxuICogTWFuYWdlcyBwbHVnaW5zLCBzdGF0ZSB1cGRhdGVzLCBhY3RzIGFzIGFuIGV2ZW50IGJ1cyxcbiAqIGFkZHMvcmVtb3ZlcyBmaWxlcyBhbmQgbWV0YWRhdGEuXG4gKi9cbmNsYXNzIFVwcHkge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICAvKipcbiAgICogSW5zdGFudGlhdGUgVXBweVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyDigJQgVXBweSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IHtcbiAgICAgIHN0cmluZ3M6IHtcbiAgICAgICAgYWRkQnVsa0ZpbGVzRmFpbGVkOiB7XG4gICAgICAgICAgMDogJ0ZhaWxlZCB0byBhZGQgJXtzbWFydF9jb3VudH0gZmlsZSBkdWUgdG8gYW4gaW50ZXJuYWwgZXJyb3InLFxuICAgICAgICAgIDE6ICdGYWlsZWQgdG8gYWRkICV7c21hcnRfY291bnR9IGZpbGVzIGR1ZSB0byBpbnRlcm5hbCBlcnJvcnMnXG4gICAgICAgIH0sXG4gICAgICAgIHlvdUNhbk9ubHlVcGxvYWRYOiB7XG4gICAgICAgICAgMDogJ1lvdSBjYW4gb25seSB1cGxvYWQgJXtzbWFydF9jb3VudH0gZmlsZScsXG4gICAgICAgICAgMTogJ1lvdSBjYW4gb25seSB1cGxvYWQgJXtzbWFydF9jb3VudH0gZmlsZXMnLFxuICAgICAgICAgIDI6ICdZb3UgY2FuIG9ubHkgdXBsb2FkICV7c21hcnRfY291bnR9IGZpbGVzJ1xuICAgICAgICB9LFxuICAgICAgICB5b3VIYXZlVG9BdExlYXN0U2VsZWN0WDoge1xuICAgICAgICAgIDA6ICdZb3UgaGF2ZSB0byBzZWxlY3QgYXQgbGVhc3QgJXtzbWFydF9jb3VudH0gZmlsZScsXG4gICAgICAgICAgMTogJ1lvdSBoYXZlIHRvIHNlbGVjdCBhdCBsZWFzdCAle3NtYXJ0X2NvdW50fSBmaWxlcycsXG4gICAgICAgICAgMjogJ1lvdSBoYXZlIHRvIHNlbGVjdCBhdCBsZWFzdCAle3NtYXJ0X2NvdW50fSBmaWxlcydcbiAgICAgICAgfSxcbiAgICAgICAgZXhjZWVkc1NpemU6ICdUaGlzIGZpbGUgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgc2l6ZSBvZicsXG4gICAgICAgIHlvdUNhbk9ubHlVcGxvYWRGaWxlVHlwZXM6ICdZb3UgY2FuIG9ubHkgdXBsb2FkOiAle3R5cGVzfScsXG4gICAgICAgIGNvbXBhbmlvbkVycm9yOiAnQ29ubmVjdGlvbiB3aXRoIENvbXBhbmlvbiBmYWlsZWQnLFxuICAgICAgICBjb21wYW5pb25BdXRoRXJyb3I6ICdBdXRob3JpemF0aW9uIHJlcXVpcmVkJyxcbiAgICAgICAgY29tcGFuaW9uVW5hdXRob3JpemVIaW50OiAnVG8gdW5hdXRob3JpemUgdG8geW91ciAle3Byb3ZpZGVyfSBhY2NvdW50LCBwbGVhc2UgZ28gdG8gJXt1cmx9JyxcbiAgICAgICAgZmFpbGVkVG9VcGxvYWQ6ICdGYWlsZWQgdG8gdXBsb2FkICV7ZmlsZX0nLFxuICAgICAgICBub0ludGVybmV0Q29ubmVjdGlvbjogJ05vIEludGVybmV0IGNvbm5lY3Rpb24nLFxuICAgICAgICBjb25uZWN0ZWRUb0ludGVybmV0OiAnQ29ubmVjdGVkIHRvIHRoZSBJbnRlcm5ldCcsXG4gICAgICAgIC8vIFN0cmluZ3MgZm9yIHJlbW90ZSBwcm92aWRlcnNcbiAgICAgICAgbm9GaWxlc0ZvdW5kOiAnWW91IGhhdmUgbm8gZmlsZXMgb3IgZm9sZGVycyBoZXJlJyxcbiAgICAgICAgc2VsZWN0WDoge1xuICAgICAgICAgIDA6ICdTZWxlY3QgJXtzbWFydF9jb3VudH0nLFxuICAgICAgICAgIDE6ICdTZWxlY3QgJXtzbWFydF9jb3VudH0nLFxuICAgICAgICAgIDI6ICdTZWxlY3QgJXtzbWFydF9jb3VudH0nXG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdEFsbEZpbGVzRnJvbUZvbGRlck5hbWVkOiAnU2VsZWN0IGFsbCBmaWxlcyBmcm9tIGZvbGRlciAle25hbWV9JyxcbiAgICAgICAgdW5zZWxlY3RBbGxGaWxlc0Zyb21Gb2xkZXJOYW1lZDogJ1Vuc2VsZWN0IGFsbCBmaWxlcyBmcm9tIGZvbGRlciAle25hbWV9JyxcbiAgICAgICAgc2VsZWN0RmlsZU5hbWVkOiAnU2VsZWN0IGZpbGUgJXtuYW1lfScsXG4gICAgICAgIHVuc2VsZWN0RmlsZU5hbWVkOiAnVW5zZWxlY3QgZmlsZSAle25hbWV9JyxcbiAgICAgICAgb3BlbkZvbGRlck5hbWVkOiAnT3BlbiBmb2xkZXIgJXtuYW1lfScsXG4gICAgICAgIGNhbmNlbDogJ0NhbmNlbCcsXG4gICAgICAgIGxvZ091dDogJ0xvZyBvdXQnLFxuICAgICAgICBmaWx0ZXI6ICdGaWx0ZXInLFxuICAgICAgICByZXNldEZpbHRlcjogJ1Jlc2V0IGZpbHRlcicsXG4gICAgICAgIGxvYWRpbmc6ICdMb2FkaW5nLi4uJyxcbiAgICAgICAgYXV0aGVudGljYXRlV2l0aFRpdGxlOiAnUGxlYXNlIGF1dGhlbnRpY2F0ZSB3aXRoICV7cGx1Z2luTmFtZX0gdG8gc2VsZWN0IGZpbGVzJyxcbiAgICAgICAgYXV0aGVudGljYXRlV2l0aDogJ0Nvbm5lY3QgdG8gJXtwbHVnaW5OYW1lfScsXG4gICAgICAgIGVtcHR5Rm9sZGVyQWRkZWQ6ICdObyBmaWxlcyB3ZXJlIGFkZGVkIGZyb20gZW1wdHkgZm9sZGVyJyxcbiAgICAgICAgZm9sZGVyQWRkZWQ6IHtcbiAgICAgICAgICAwOiAnQWRkZWQgJXtzbWFydF9jb3VudH0gZmlsZSBmcm9tICV7Zm9sZGVyfScsXG4gICAgICAgICAgMTogJ0FkZGVkICV7c21hcnRfY291bnR9IGZpbGVzIGZyb20gJXtmb2xkZXJ9JyxcbiAgICAgICAgICAyOiAnQWRkZWQgJXtzbWFydF9jb3VudH0gZmlsZXMgZnJvbSAle2ZvbGRlcn0nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGlkOiAndXBweScsXG4gICAgICBhdXRvUHJvY2VlZDogZmFsc2UsXG4gICAgICBhbGxvd011bHRpcGxlVXBsb2FkczogdHJ1ZSxcbiAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgIHJlc3RyaWN0aW9uczoge1xuICAgICAgICBtYXhGaWxlU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4TnVtYmVyT2ZGaWxlczogbnVsbCxcbiAgICAgICAgbWluTnVtYmVyT2ZGaWxlczogbnVsbCxcbiAgICAgICAgYWxsb3dlZEZpbGVUeXBlczogbnVsbFxuICAgICAgfSxcbiAgICAgIG1ldGE6IHt9LFxuICAgICAgb25CZWZvcmVGaWxlQWRkZWQ6IChjdXJyZW50RmlsZSwgZmlsZXMpID0+IGN1cnJlbnRGaWxlLFxuICAgICAgb25CZWZvcmVVcGxvYWQ6IChmaWxlcykgPT4gZmlsZXMsXG4gICAgICBzdG9yZTogRGVmYXVsdFN0b3JlKCksXG4gICAgICBsb2dnZXI6IG51bGxMb2dnZXJcbiAgICB9XG5cbiAgICAvLyBNZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgb25lcyBzZXQgYnkgdXNlcixcbiAgICAvLyBtYWtpbmcgc3VyZSB0byBtZXJnZSByZXN0cmljdGlvbnMgdG9vXG4gICAgdGhpcy5vcHRzID0ge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRzLFxuICAgICAgcmVzdHJpY3Rpb25zOiB7XG4gICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLnJlc3RyaWN0aW9ucyxcbiAgICAgICAgLi4uKG9wdHMgJiYgb3B0cy5yZXN0cmljdGlvbnMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydCBkZWJ1ZzogdHJ1ZSBmb3IgYmFja3dhcmRzLWNvbXBhdGFiaWxpdHksIHVubGVzcyBsb2dnZXIgaXMgc2V0IGluIG9wdHNcbiAgICAvLyBvcHRzIGluc3RlYWQgb2YgdGhpcy5vcHRzIHRvIGF2b2lkIGNvbXBhcmluZyBvYmplY3RzIOKAlCB3ZSBzZXQgbG9nZ2VyOiBudWxsTG9nZ2VyIGluIGRlZmF1bHRPcHRpb25zXG4gICAgaWYgKG9wdHMgJiYgb3B0cy5sb2dnZXIgJiYgb3B0cy5kZWJ1Zykge1xuICAgICAgdGhpcy5sb2coJ1lvdSBhcmUgdXNpbmcgYSBjdXN0b20gYGxvZ2dlcmAsIGJ1dCBhbHNvIHNldCBgZGVidWc6IHRydWVgLCB3aGljaCB1c2VzIGJ1aWx0LWluIGxvZ2dlciB0byBvdXRwdXQgbG9ncyB0byBjb25zb2xlLiBJZ25vcmluZyBgZGVidWc6IHRydWVgIGFuZCB1c2luZyB5b3VyIGN1c3RvbSBgbG9nZ2VyYC4nLCAnd2FybmluZycpXG4gICAgfSBlbHNlIGlmIChvcHRzICYmIG9wdHMuZGVidWcpIHtcbiAgICAgIHRoaXMub3B0cy5sb2dnZXIgPSBkZWJ1Z0xvZ2dlclxuICAgIH1cblxuICAgIHRoaXMubG9nKGBVc2luZyBDb3JlIHYke3RoaXMuY29uc3RydWN0b3IuVkVSU0lPTn1gKVxuXG4gICAgaWYgKHRoaXMub3B0cy5yZXN0cmljdGlvbnMuYWxsb3dlZEZpbGVUeXBlcyAmJlxuICAgICAgICB0aGlzLm9wdHMucmVzdHJpY3Rpb25zLmFsbG93ZWRGaWxlVHlwZXMgIT09IG51bGwgJiZcbiAgICAgICAgIUFycmF5LmlzQXJyYXkodGhpcy5vcHRzLnJlc3RyaWN0aW9ucy5hbGxvd2VkRmlsZVR5cGVzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYHJlc3RyaWN0aW9ucy5hbGxvd2VkRmlsZVR5cGVzYCBtdXN0IGJlIGFuIGFycmF5JylcbiAgICB9XG5cbiAgICB0aGlzLmkxOG5Jbml0KClcblxuICAgIC8vIENvbnRhaW5lciBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIHBsdWdpbnNcbiAgICB0aGlzLnBsdWdpbnMgPSB7fVxuXG4gICAgdGhpcy5nZXRTdGF0ZSA9IHRoaXMuZ2V0U3RhdGUuYmluZCh0aGlzKVxuICAgIHRoaXMuZ2V0UGx1Z2luID0gdGhpcy5nZXRQbHVnaW4uYmluZCh0aGlzKVxuICAgIHRoaXMuc2V0RmlsZU1ldGEgPSB0aGlzLnNldEZpbGVNZXRhLmJpbmQodGhpcylcbiAgICB0aGlzLnNldEZpbGVTdGF0ZSA9IHRoaXMuc2V0RmlsZVN0YXRlLmJpbmQodGhpcylcbiAgICB0aGlzLmxvZyA9IHRoaXMubG9nLmJpbmQodGhpcylcbiAgICB0aGlzLmluZm8gPSB0aGlzLmluZm8uYmluZCh0aGlzKVxuICAgIHRoaXMuaGlkZUluZm8gPSB0aGlzLmhpZGVJbmZvLmJpbmQodGhpcylcbiAgICB0aGlzLmFkZEZpbGUgPSB0aGlzLmFkZEZpbGUuYmluZCh0aGlzKVxuICAgIHRoaXMucmVtb3ZlRmlsZSA9IHRoaXMucmVtb3ZlRmlsZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5wYXVzZVJlc3VtZSA9IHRoaXMucGF1c2VSZXN1bWUuYmluZCh0aGlzKVxuXG4gICAgLy8gX19fV2h5IHRocm90dGxlIGF0IDUwMG1zP1xuICAgIC8vICAgIC0gV2UgbXVzdCB0aHJvdHRsZSBhdCA+MjUwbXMgZm9yIHN1cGVyZm9jdXMgaW4gRGFzaGJvYXJkIHRvIHdvcmsgd2VsbCAoYmVjYXVzZSBhbmltYXRpb24gdGFrZXMgMC4yNXMsIGFuZCB3ZSB3YW50IHRvIHdhaXQgZm9yIGFsbCBhbmltYXRpb25zIHRvIGJlIG92ZXIgYmVmb3JlIHJlZm9jdXNpbmcpLlxuICAgIC8vICAgIFtQcmFjdGljYWwgQ2hlY2tdOiBpZiB0aG90dGxlIGlzIGF0IDEwMG1zLCB0aGVuIGlmIHlvdSBhcmUgdXBsb2FkaW5nIGEgZmlsZSwgYW5kIGNsaWNrICdBREQgTU9SRSBGSUxFUycsIC0gZm9jdXMgd29uJ3QgYWN0aXZhdGUgaW4gRmlyZWZveC5cbiAgICAvLyAgICAtIFdlIG11c3QgdGhyb3R0bGUgYXQgYXJvdW5kID41MDBtcyB0byBhdm9pZCBwZXJmb3JtYW5jZSBsYWdzLlxuICAgIC8vICAgIFtQcmFjdGljYWwgQ2hlY2tdIEZpcmVmb3gsIHRyeSB0byB1cGxvYWQgYSBiaWcgZmlsZSBmb3IgYSBwcm9sb25nZWQgcGVyaW9kIG9mIHRpbWUuIExhcHRvcCB3aWxsIHN0YXJ0IHRvIGhlYXQgdXAuXG4gICAgdGhpcy5fY2FsY3VsYXRlUHJvZ3Jlc3MgPSB0aHJvdHRsZSh0aGlzLl9jYWxjdWxhdGVQcm9ncmVzcy5iaW5kKHRoaXMpLCA1MDAsIHsgbGVhZGluZzogdHJ1ZSwgdHJhaWxpbmc6IHRydWUgfSlcblxuICAgIHRoaXMudXBkYXRlT25saW5lU3RhdHVzID0gdGhpcy51cGRhdGVPbmxpbmVTdGF0dXMuYmluZCh0aGlzKVxuICAgIHRoaXMucmVzZXRQcm9ncmVzcyA9IHRoaXMucmVzZXRQcm9ncmVzcy5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLnBhdXNlQWxsID0gdGhpcy5wYXVzZUFsbC5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZXN1bWVBbGwgPSB0aGlzLnJlc3VtZUFsbC5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZXRyeUFsbCA9IHRoaXMucmV0cnlBbGwuYmluZCh0aGlzKVxuICAgIHRoaXMuY2FuY2VsQWxsID0gdGhpcy5jYW5jZWxBbGwuYmluZCh0aGlzKVxuICAgIHRoaXMucmV0cnlVcGxvYWQgPSB0aGlzLnJldHJ5VXBsb2FkLmJpbmQodGhpcylcbiAgICB0aGlzLnVwbG9hZCA9IHRoaXMudXBsb2FkLmJpbmQodGhpcylcblxuICAgIHRoaXMuZW1pdHRlciA9IGVlKClcbiAgICB0aGlzLm9uID0gdGhpcy5vbi5iaW5kKHRoaXMpXG4gICAgdGhpcy5vZmYgPSB0aGlzLm9mZi5iaW5kKHRoaXMpXG4gICAgdGhpcy5vbmNlID0gdGhpcy5lbWl0dGVyLm9uY2UuYmluZCh0aGlzLmVtaXR0ZXIpXG4gICAgdGhpcy5lbWl0ID0gdGhpcy5lbWl0dGVyLmVtaXQuYmluZCh0aGlzLmVtaXR0ZXIpXG5cbiAgICB0aGlzLnByZVByb2Nlc3NvcnMgPSBbXVxuICAgIHRoaXMudXBsb2FkZXJzID0gW11cbiAgICB0aGlzLnBvc3RQcm9jZXNzb3JzID0gW11cblxuICAgIHRoaXMuc3RvcmUgPSB0aGlzLm9wdHMuc3RvcmVcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHBsdWdpbnM6IHt9LFxuICAgICAgZmlsZXM6IHt9LFxuICAgICAgY3VycmVudFVwbG9hZHM6IHt9LFxuICAgICAgYWxsb3dOZXdVcGxvYWQ6IHRydWUsXG4gICAgICBjYXBhYmlsaXRpZXM6IHtcbiAgICAgICAgdXBsb2FkUHJvZ3Jlc3M6IHN1cHBvcnRzVXBsb2FkUHJvZ3Jlc3MoKSxcbiAgICAgICAgaW5kaXZpZHVhbENhbmNlbGxhdGlvbjogdHJ1ZSxcbiAgICAgICAgcmVzdW1hYmxlVXBsb2FkczogZmFsc2VcbiAgICAgIH0sXG4gICAgICB0b3RhbFByb2dyZXNzOiAwLFxuICAgICAgbWV0YTogeyAuLi50aGlzLm9wdHMubWV0YSB9LFxuICAgICAgaW5mbzoge1xuICAgICAgICBpc0hpZGRlbjogdHJ1ZSxcbiAgICAgICAgdHlwZTogJ2luZm8nLFxuICAgICAgICBtZXNzYWdlOiAnJ1xuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLl9zdG9yZVVuc3Vic2NyaWJlID0gdGhpcy5zdG9yZS5zdWJzY3JpYmUoKHByZXZTdGF0ZSwgbmV4dFN0YXRlLCBwYXRjaCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdzdGF0ZS11cGRhdGUnLCBwcmV2U3RhdGUsIG5leHRTdGF0ZSwgcGF0Y2gpXG4gICAgICB0aGlzLnVwZGF0ZUFsbChuZXh0U3RhdGUpXG4gICAgfSlcblxuICAgIC8vIEV4cG9zaW5nIHVwcHkgb2JqZWN0IG9uIHdpbmRvdyBmb3IgZGVidWdnaW5nIGFuZCB0ZXN0aW5nXG4gICAgaWYgKHRoaXMub3B0cy5kZWJ1ZyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2luZG93W3RoaXMub3B0cy5pZF0gPSB0aGlzXG4gICAgfVxuXG4gICAgdGhpcy5fYWRkTGlzdGVuZXJzKClcbiAgfVxuXG4gIG9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmVtaXR0ZXIub24oZXZlbnQsIGNhbGxiYWNrKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBvZmYgKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlci5vZmYoZXZlbnQsIGNhbGxiYWNrKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSBvbiBhbGwgcGx1Z2lucyBhbmQgcnVuIGB1cGRhdGVgIG9uIHRoZW0uXG4gICAqIENhbGxlZCBlYWNoIHRpbWUgc3RhdGUgY2hhbmdlcy5cbiAgICpcbiAgICovXG4gIHVwZGF0ZUFsbCAoc3RhdGUpIHtcbiAgICB0aGlzLml0ZXJhdGVQbHVnaW5zKHBsdWdpbiA9PiB7XG4gICAgICBwbHVnaW4udXBkYXRlKHN0YXRlKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBzdGF0ZSB3aXRoIGEgcGF0Y2hcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhdGNoIHtmb286ICdiYXInfVxuICAgKi9cbiAgc2V0U3RhdGUgKHBhdGNoKSB7XG4gICAgdGhpcy5zdG9yZS5zZXRTdGF0ZShwYXRjaClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGN1cnJlbnQgc3RhdGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICBnZXRTdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEJhY2sgY29tcGF0IGZvciB3aGVuIHVwcHkuc3RhdGUgaXMgdXNlZCBpbnN0ZWFkIG9mIHVwcHkuZ2V0U3RhdGUoKS5cbiAgICovXG4gIGdldCBzdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3J0aGFuZCB0byBzZXQgc3RhdGUgZm9yIGEgc3BlY2lmaWMgZmlsZS5cbiAgICovXG4gIHNldEZpbGVTdGF0ZSAoZmlsZUlELCBzdGF0ZSkge1xuICAgIGlmICghdGhpcy5nZXRTdGF0ZSgpLmZpbGVzW2ZpbGVJRF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fu4oCZdCBzZXQgc3RhdGUgZm9yICR7ZmlsZUlEfSAodGhlIGZpbGUgY291bGQgaGF2ZSBiZWVuIHJlbW92ZWQpYClcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGZpbGVzOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldFN0YXRlKCkuZmlsZXMsIHtcbiAgICAgICAgW2ZpbGVJRF06IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0U3RhdGUoKS5maWxlc1tmaWxlSURdLCBzdGF0ZSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGkxOG5Jbml0ICgpIHtcbiAgICB0aGlzLnRyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcihbdGhpcy5kZWZhdWx0TG9jYWxlLCB0aGlzLm9wdHMubG9jYWxlXSlcbiAgICB0aGlzLmxvY2FsZSA9IHRoaXMudHJhbnNsYXRvci5sb2NhbGVcbiAgICB0aGlzLmkxOG4gPSB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlLmJpbmQodGhpcy50cmFuc2xhdG9yKVxuICAgIHRoaXMuaTE4bkFycmF5ID0gdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZUFycmF5LmJpbmQodGhpcy50cmFuc2xhdG9yKVxuICB9XG5cbiAgc2V0T3B0aW9ucyAobmV3T3B0cykge1xuICAgIHRoaXMub3B0cyA9IHtcbiAgICAgIC4uLnRoaXMub3B0cyxcbiAgICAgIC4uLm5ld09wdHMsXG4gICAgICByZXN0cmljdGlvbnM6IHtcbiAgICAgICAgLi4udGhpcy5vcHRzLnJlc3RyaWN0aW9ucyxcbiAgICAgICAgLi4uKG5ld09wdHMgJiYgbmV3T3B0cy5yZXN0cmljdGlvbnMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5ld09wdHMubWV0YSkge1xuICAgICAgdGhpcy5zZXRNZXRhKG5ld09wdHMubWV0YSlcbiAgICB9XG5cbiAgICB0aGlzLmkxOG5Jbml0KClcblxuICAgIGlmIChuZXdPcHRzLmxvY2FsZSkge1xuICAgICAgdGhpcy5pdGVyYXRlUGx1Z2lucygocGx1Z2luKSA9PiB7XG4gICAgICAgIHBsdWdpbi5zZXRPcHRpb25zKClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSgpIC8vIHNvIHRoYXQgVUkgcmUtcmVuZGVycyB3aXRoIG5ldyBvcHRpb25zXG4gIH1cblxuICByZXNldFByb2dyZXNzICgpIHtcbiAgICBjb25zdCBkZWZhdWx0UHJvZ3Jlc3MgPSB7XG4gICAgICBwZXJjZW50YWdlOiAwLFxuICAgICAgYnl0ZXNVcGxvYWRlZDogMCxcbiAgICAgIHVwbG9hZENvbXBsZXRlOiBmYWxzZSxcbiAgICAgIHVwbG9hZFN0YXJ0ZWQ6IG51bGxcbiAgICB9XG4gICAgY29uc3QgZmlsZXMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldFN0YXRlKCkuZmlsZXMpXG4gICAgY29uc3QgdXBkYXRlZEZpbGVzID0ge31cbiAgICBPYmplY3Qua2V5cyhmaWxlcykuZm9yRWFjaChmaWxlSUQgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZEZpbGUgPSBPYmplY3QuYXNzaWduKHt9LCBmaWxlc1tmaWxlSURdKVxuICAgICAgdXBkYXRlZEZpbGUucHJvZ3Jlc3MgPSBPYmplY3QuYXNzaWduKHt9LCB1cGRhdGVkRmlsZS5wcm9ncmVzcywgZGVmYXVsdFByb2dyZXNzKVxuICAgICAgdXBkYXRlZEZpbGVzW2ZpbGVJRF0gPSB1cGRhdGVkRmlsZVxuICAgIH0pXG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGZpbGVzOiB1cGRhdGVkRmlsZXMsXG4gICAgICB0b3RhbFByb2dyZXNzOiAwXG4gICAgfSlcblxuICAgIHRoaXMuZW1pdCgncmVzZXQtcHJvZ3Jlc3MnKVxuICB9XG5cbiAgYWRkUHJlUHJvY2Vzc29yIChmbikge1xuICAgIHRoaXMucHJlUHJvY2Vzc29ycy5wdXNoKGZuKVxuICB9XG5cbiAgcmVtb3ZlUHJlUHJvY2Vzc29yIChmbikge1xuICAgIGNvbnN0IGkgPSB0aGlzLnByZVByb2Nlc3NvcnMuaW5kZXhPZihmbilcbiAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgIHRoaXMucHJlUHJvY2Vzc29ycy5zcGxpY2UoaSwgMSlcbiAgICB9XG4gIH1cblxuICBhZGRQb3N0UHJvY2Vzc29yIChmbikge1xuICAgIHRoaXMucG9zdFByb2Nlc3NvcnMucHVzaChmbilcbiAgfVxuXG4gIHJlbW92ZVBvc3RQcm9jZXNzb3IgKGZuKSB7XG4gICAgY29uc3QgaSA9IHRoaXMucG9zdFByb2Nlc3NvcnMuaW5kZXhPZihmbilcbiAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgIHRoaXMucG9zdFByb2Nlc3NvcnMuc3BsaWNlKGksIDEpXG4gICAgfVxuICB9XG5cbiAgYWRkVXBsb2FkZXIgKGZuKSB7XG4gICAgdGhpcy51cGxvYWRlcnMucHVzaChmbilcbiAgfVxuXG4gIHJlbW92ZVVwbG9hZGVyIChmbikge1xuICAgIGNvbnN0IGkgPSB0aGlzLnVwbG9hZGVycy5pbmRleE9mKGZuKVxuICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgdGhpcy51cGxvYWRlcnMuc3BsaWNlKGksIDEpXG4gICAgfVxuICB9XG5cbiAgc2V0TWV0YSAoZGF0YSkge1xuICAgIGNvbnN0IHVwZGF0ZWRNZXRhID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRTdGF0ZSgpLm1ldGEsIGRhdGEpXG4gICAgY29uc3QgdXBkYXRlZEZpbGVzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRTdGF0ZSgpLmZpbGVzKVxuXG4gICAgT2JqZWN0LmtleXModXBkYXRlZEZpbGVzKS5mb3JFYWNoKChmaWxlSUQpID0+IHtcbiAgICAgIHVwZGF0ZWRGaWxlc1tmaWxlSURdID0gT2JqZWN0LmFzc2lnbih7fSwgdXBkYXRlZEZpbGVzW2ZpbGVJRF0sIHtcbiAgICAgICAgbWV0YTogT2JqZWN0LmFzc2lnbih7fSwgdXBkYXRlZEZpbGVzW2ZpbGVJRF0ubWV0YSwgZGF0YSlcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRoaXMubG9nKCdBZGRpbmcgbWV0YWRhdGE6JylcbiAgICB0aGlzLmxvZyhkYXRhKVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBtZXRhOiB1cGRhdGVkTWV0YSxcbiAgICAgIGZpbGVzOiB1cGRhdGVkRmlsZXNcbiAgICB9KVxuICB9XG5cbiAgc2V0RmlsZU1ldGEgKGZpbGVJRCwgZGF0YSkge1xuICAgIGNvbnN0IHVwZGF0ZWRGaWxlcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0U3RhdGUoKS5maWxlcylcbiAgICBpZiAoIXVwZGF0ZWRGaWxlc1tmaWxlSURdKSB7XG4gICAgICB0aGlzLmxvZygnV2FzIHRyeWluZyB0byBzZXQgbWV0YWRhdGEgZm9yIGEgZmlsZSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQ6ICcsIGZpbGVJRClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBuZXdNZXRhID0gT2JqZWN0LmFzc2lnbih7fSwgdXBkYXRlZEZpbGVzW2ZpbGVJRF0ubWV0YSwgZGF0YSlcbiAgICB1cGRhdGVkRmlsZXNbZmlsZUlEXSA9IE9iamVjdC5hc3NpZ24oe30sIHVwZGF0ZWRGaWxlc1tmaWxlSURdLCB7XG4gICAgICBtZXRhOiBuZXdNZXRhXG4gICAgfSlcbiAgICB0aGlzLnNldFN0YXRlKHsgZmlsZXM6IHVwZGF0ZWRGaWxlcyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGZpbGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEIFRoZSBJRCBvZiB0aGUgZmlsZSBvYmplY3QgdG8gcmV0dXJuLlxuICAgKi9cbiAgZ2V0RmlsZSAoZmlsZUlEKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKS5maWxlc1tmaWxlSURdXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBmaWxlcyBpbiBhbiBhcnJheS5cbiAgICovXG4gIGdldEZpbGVzICgpIHtcbiAgICBjb25zdCB7IGZpbGVzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZmlsZXMpLm1hcCgoZmlsZUlEKSA9PiBmaWxlc1tmaWxlSURdKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIG1pbk51bWJlck9mRmlsZXMgcmVzdHJpY3Rpb24gaXMgcmVhY2hlZCBiZWZvcmUgdXBsb2FkaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrTWluTnVtYmVyT2ZGaWxlcyAoZmlsZXMpIHtcbiAgICBjb25zdCB7IG1pbk51bWJlck9mRmlsZXMgfSA9IHRoaXMub3B0cy5yZXN0cmljdGlvbnNcbiAgICBpZiAoT2JqZWN0LmtleXMoZmlsZXMpLmxlbmd0aCA8IG1pbk51bWJlck9mRmlsZXMpIHtcbiAgICAgIHRocm93IG5ldyBSZXN0cmljdGlvbkVycm9yKGAke3RoaXMuaTE4bigneW91SGF2ZVRvQXRMZWFzdFNlbGVjdFgnLCB7IHNtYXJ0X2NvdW50OiBtaW5OdW1iZXJPZkZpbGVzIH0pfWApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGZpbGUgcGFzc2VzIGEgc2V0IG9mIHJlc3RyaWN0aW9ucyBzZXQgaW4gb3B0aW9uczogbWF4RmlsZVNpemUsXG4gICAqIG1heE51bWJlck9mRmlsZXMgYW5kIGFsbG93ZWRGaWxlVHlwZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmaWxlcyBPYmplY3Qgb2YgSURzIOKGkiBmaWxlcyBhbHJlYWR5IGFkZGVkXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmaWxlIG9iamVjdCB0byBjaGVja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrUmVzdHJpY3Rpb25zIChmaWxlcywgZmlsZSkge1xuICAgIGNvbnN0IHsgbWF4RmlsZVNpemUsIG1heE51bWJlck9mRmlsZXMsIGFsbG93ZWRGaWxlVHlwZXMgfSA9IHRoaXMub3B0cy5yZXN0cmljdGlvbnNcblxuICAgIGlmIChtYXhOdW1iZXJPZkZpbGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoZmlsZXMpLmxlbmd0aCArIDEgPiBtYXhOdW1iZXJPZkZpbGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBSZXN0cmljdGlvbkVycm9yKGAke3RoaXMuaTE4bigneW91Q2FuT25seVVwbG9hZFgnLCB7IHNtYXJ0X2NvdW50OiBtYXhOdW1iZXJPZkZpbGVzIH0pfWApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFsbG93ZWRGaWxlVHlwZXMpIHtcbiAgICAgIGNvbnN0IGlzQ29ycmVjdEZpbGVUeXBlID0gYWxsb3dlZEZpbGVUeXBlcy5zb21lKCh0eXBlKSA9PiB7XG4gICAgICAgIC8vIGlzIHRoaXMgaXMgYSBtaW1lLXR5cGVcbiAgICAgICAgaWYgKHR5cGUuaW5kZXhPZignLycpID4gLTEpIHtcbiAgICAgICAgICBpZiAoIWZpbGUudHlwZSkgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgcmV0dXJuIG1hdGNoKGZpbGUudHlwZSwgdHlwZSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSB0aGlzIGlzIGxpa2VseSBhbiBleHRlbnNpb25cbiAgICAgICAgaWYgKHR5cGVbMF0gPT09ICcuJykge1xuICAgICAgICAgIHJldHVybiBmaWxlLmV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpID09PSB0eXBlLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9KVxuXG4gICAgICBpZiAoIWlzQ29ycmVjdEZpbGVUeXBlKSB7XG4gICAgICAgIGNvbnN0IGFsbG93ZWRGaWxlVHlwZXNTdHJpbmcgPSBhbGxvd2VkRmlsZVR5cGVzLmpvaW4oJywgJylcbiAgICAgICAgdGhyb3cgbmV3IFJlc3RyaWN0aW9uRXJyb3IodGhpcy5pMThuKCd5b3VDYW5Pbmx5VXBsb2FkRmlsZVR5cGVzJywgeyB0eXBlczogYWxsb3dlZEZpbGVUeXBlc1N0cmluZyB9KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZSBjYW4ndCBjaGVjayBtYXhGaWxlU2l6ZSBpZiB0aGUgc2l6ZSBpcyB1bmtub3duLlxuICAgIGlmIChtYXhGaWxlU2l6ZSAmJiBmaWxlLmRhdGEuc2l6ZSAhPSBudWxsKSB7XG4gICAgICBpZiAoZmlsZS5kYXRhLnNpemUgPiBtYXhGaWxlU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVzdHJpY3Rpb25FcnJvcihgJHt0aGlzLmkxOG4oJ2V4Y2VlZHNTaXplJyl9ICR7cHJldHR5Qnl0ZXMobWF4RmlsZVNpemUpfWApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3Nob3dPckxvZ0Vycm9yQW5kVGhyb3cgKGVyciwgeyBzaG93SW5mb3JtZXIgPSB0cnVlLCBmaWxlID0gbnVsbCB9ID0ge30pIHtcbiAgICBjb25zdCBtZXNzYWdlID0gdHlwZW9mIGVyciA9PT0gJ29iamVjdCcgPyBlcnIubWVzc2FnZSA6IGVyclxuICAgIGNvbnN0IGRldGFpbHMgPSAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcgJiYgZXJyLmRldGFpbHMpID8gZXJyLmRldGFpbHMgOiAnJ1xuXG4gICAgLy8gUmVzdHJpY3Rpb24gZXJyb3JzIHNob3VsZCBiZSBsb2dnZWQsIGJ1dCBub3QgYXMgZXJyb3JzLFxuICAgIC8vIGFzIHRoZXkgYXJlIGV4cGVjdGVkIGFuZCBzaG93biBpbiB0aGUgVUkuXG4gICAgaWYgKGVyci5pc1Jlc3RyaWN0aW9uKSB7XG4gICAgICB0aGlzLmxvZyhgJHttZXNzYWdlfSAke2RldGFpbHN9YClcbiAgICAgIHRoaXMuZW1pdCgncmVzdHJpY3Rpb24tZmFpbGVkJywgZmlsZSwgZXJyKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZyhgJHttZXNzYWdlfSAke2RldGFpbHN9YCwgJ2Vycm9yJylcbiAgICB9XG5cbiAgICAvLyBTb21ldGltZXMgaW5mb3JtZXIgaGFzIHRvIGJlIHNob3duIG1hbnVhbGx5IGJ5IHRoZSBkZXZlbG9wZXIsXG4gICAgLy8gZm9yIGV4YW1wbGUsIGluIGBvbkJlZm9yZUZpbGVBZGRlZGAuXG4gICAgaWYgKHNob3dJbmZvcm1lcikge1xuICAgICAgdGhpcy5pbmZvKHsgbWVzc2FnZTogbWVzc2FnZSwgZGV0YWlsczogZGV0YWlscyB9LCAnZXJyb3InLCA1MDAwKVxuICAgIH1cblxuICAgIHRocm93ICh0eXBlb2YgZXJyID09PSAnb2JqZWN0JyA/IGVyciA6IG5ldyBFcnJvcihlcnIpKVxuICB9XG5cbiAgX2Fzc2VydE5ld1VwbG9hZEFsbG93ZWQgKGZpbGUpIHtcbiAgICBjb25zdCB7IGFsbG93TmV3VXBsb2FkIH0gPSB0aGlzLmdldFN0YXRlKClcblxuICAgIGlmIChhbGxvd05ld1VwbG9hZCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX3Nob3dPckxvZ0Vycm9yQW5kVGhyb3cobmV3IFJlc3RyaWN0aW9uRXJyb3IoJ0Nhbm5vdCBhZGQgbmV3IGZpbGVzOiBhbHJlYWR5IHVwbG9hZGluZy4nKSwgeyBmaWxlIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGZpbGUgc3RhdGUgb2JqZWN0IGJhc2VkIG9uIHVzZXItcHJvdmlkZWQgYGFkZEZpbGUoKWAgb3B0aW9ucy5cbiAgICpcbiAgICogTm90ZSB0aGlzIGlzIGV4dHJlbWVseSBzaWRlLWVmZmVjdGZ1bCBhbmQgc2hvdWxkIG9ubHkgYmUgZG9uZSB3aGVuIGEgZmlsZSBzdGF0ZSBvYmplY3Qgd2lsbCBiZSBhZGRlZCB0byBzdGF0ZSBpbW1lZGlhdGVseSBhZnRlcndhcmQhXG4gICAqXG4gICAqIFRoZSBgZmlsZXNgIHZhbHVlIGlzIHBhc3NlZCBpbiBiZWNhdXNlIGl0IG1heSBiZSB1cGRhdGVkIGJ5IHRoZSBjYWxsZXIgd2l0aG91dCB1cGRhdGluZyB0aGUgc3RvcmUuXG4gICAqL1xuICBfY2hlY2tBbmRDcmVhdGVGaWxlU3RhdGVPYmplY3QgKGZpbGVzLCBmaWxlKSB7XG4gICAgY29uc3QgZmlsZVR5cGUgPSBnZXRGaWxlVHlwZShmaWxlKVxuICAgIGZpbGUudHlwZSA9IGZpbGVUeXBlXG5cbiAgICBjb25zdCBvbkJlZm9yZUZpbGVBZGRlZFJlc3VsdCA9IHRoaXMub3B0cy5vbkJlZm9yZUZpbGVBZGRlZChmaWxlLCBmaWxlcylcblxuICAgIGlmIChvbkJlZm9yZUZpbGVBZGRlZFJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIERvbuKAmXQgc2hvdyBVSSBpbmZvIGZvciB0aGlzIGVycm9yLCBhcyBpdCBzaG91bGQgYmUgZG9uZSBieSB0aGUgZGV2ZWxvcGVyXG4gICAgICB0aGlzLl9zaG93T3JMb2dFcnJvckFuZFRocm93KG5ldyBSZXN0cmljdGlvbkVycm9yKCdDYW5ub3QgYWRkIHRoZSBmaWxlIGJlY2F1c2Ugb25CZWZvcmVGaWxlQWRkZWQgcmV0dXJuZWQgZmFsc2UuJyksIHsgc2hvd0luZm9ybWVyOiBmYWxzZSwgZmlsZSB9KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb25CZWZvcmVGaWxlQWRkZWRSZXN1bHQgPT09ICdvYmplY3QnICYmIG9uQmVmb3JlRmlsZUFkZGVkUmVzdWx0KSB7XG4gICAgICBmaWxlID0gb25CZWZvcmVGaWxlQWRkZWRSZXN1bHRcbiAgICB9XG5cbiAgICBsZXQgZmlsZU5hbWVcbiAgICBpZiAoZmlsZS5uYW1lKSB7XG4gICAgICBmaWxlTmFtZSA9IGZpbGUubmFtZVxuICAgIH0gZWxzZSBpZiAoZmlsZVR5cGUuc3BsaXQoJy8nKVswXSA9PT0gJ2ltYWdlJykge1xuICAgICAgZmlsZU5hbWUgPSBmaWxlVHlwZS5zcGxpdCgnLycpWzBdICsgJy4nICsgZmlsZVR5cGUuc3BsaXQoJy8nKVsxXVxuICAgIH0gZWxzZSB7XG4gICAgICBmaWxlTmFtZSA9ICdub25hbWUnXG4gICAgfVxuICAgIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBnZXRGaWxlTmFtZUFuZEV4dGVuc2lvbihmaWxlTmFtZSkuZXh0ZW5zaW9uXG4gICAgY29uc3QgaXNSZW1vdGUgPSBmaWxlLmlzUmVtb3RlIHx8IGZhbHNlXG5cbiAgICBjb25zdCBmaWxlSUQgPSBnZW5lcmF0ZUZpbGVJRChmaWxlKVxuXG4gICAgaWYgKGZpbGVzW2ZpbGVJRF0pIHtcbiAgICAgIHRoaXMuX3Nob3dPckxvZ0Vycm9yQW5kVGhyb3cobmV3IFJlc3RyaWN0aW9uRXJyb3IoYENhbm5vdCBhZGQgdGhlIGR1cGxpY2F0ZSBmaWxlICcke2ZpbGVOYW1lfScsIGl0IGFscmVhZHkgZXhpc3RzLmApLCB7IGZpbGUgfSlcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhID0gZmlsZS5tZXRhIHx8IHt9XG4gICAgbWV0YS5uYW1lID0gZmlsZU5hbWVcbiAgICBtZXRhLnR5cGUgPSBmaWxlVHlwZVxuXG4gICAgLy8gYG51bGxgIG1lYW5zIHRoZSBzaXplIGlzIHVua25vd24uXG4gICAgY29uc3Qgc2l6ZSA9IGlzRmluaXRlKGZpbGUuZGF0YS5zaXplKSA/IGZpbGUuZGF0YS5zaXplIDogbnVsbFxuICAgIGNvbnN0IG5ld0ZpbGUgPSB7XG4gICAgICBzb3VyY2U6IGZpbGUuc291cmNlIHx8ICcnLFxuICAgICAgaWQ6IGZpbGVJRCxcbiAgICAgIG5hbWU6IGZpbGVOYW1lLFxuICAgICAgZXh0ZW5zaW9uOiBmaWxlRXh0ZW5zaW9uIHx8ICcnLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi50aGlzLmdldFN0YXRlKCkubWV0YSxcbiAgICAgICAgLi4ubWV0YVxuICAgICAgfSxcbiAgICAgIHR5cGU6IGZpbGVUeXBlLFxuICAgICAgZGF0YTogZmlsZS5kYXRhLFxuICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgcGVyY2VudGFnZTogMCxcbiAgICAgICAgYnl0ZXNVcGxvYWRlZDogMCxcbiAgICAgICAgYnl0ZXNUb3RhbDogc2l6ZSxcbiAgICAgICAgdXBsb2FkQ29tcGxldGU6IGZhbHNlLFxuICAgICAgICB1cGxvYWRTdGFydGVkOiBudWxsXG4gICAgICB9LFxuICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgIGlzUmVtb3RlOiBpc1JlbW90ZSxcbiAgICAgIHJlbW90ZTogZmlsZS5yZW1vdGUgfHwgJycsXG4gICAgICBwcmV2aWV3OiBmaWxlLnByZXZpZXdcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fY2hlY2tSZXN0cmljdGlvbnMoZmlsZXMsIG5ld0ZpbGUpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9zaG93T3JMb2dFcnJvckFuZFRocm93KGVyciwgeyBmaWxlOiBuZXdGaWxlIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0ZpbGVcbiAgfVxuXG4gIC8vIFNjaGVkdWxlIGFuIHVwbG9hZCBpZiBgYXV0b1Byb2NlZWRgIGlzIGVuYWJsZWQuXG4gIF9zdGFydElmQXV0b1Byb2NlZWQgKCkge1xuICAgIGlmICh0aGlzLm9wdHMuYXV0b1Byb2NlZWQgJiYgIXRoaXMuc2NoZWR1bGVkQXV0b1Byb2NlZWQpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVkQXV0b1Byb2NlZWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZWRBdXRvUHJvY2VlZCA9IG51bGxcbiAgICAgICAgdGhpcy51cGxvYWQoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKCFlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgICAgICAgdGhpcy5sb2coZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlIHx8IGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9LCA0KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgZmlsZSB0byBgc3RhdGUuZmlsZXNgLiBUaGlzIHdpbGwgcnVuIGBvbkJlZm9yZUZpbGVBZGRlZGAsXG4gICAqIHRyeSB0byBndWVzcyBmaWxlIHR5cGUgaW4gYSBjbGV2ZXIgd2F5LCBjaGVjayBmaWxlIGFnYWluc3QgcmVzdHJpY3Rpb25zLFxuICAgKiBhbmQgc3RhcnQgYW4gdXBsb2FkIGlmIGBhdXRvUHJvY2VlZCA9PT0gdHJ1ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBmaWxlIG9iamVjdCB0byBhZGRcbiAgICogQHJldHVybnMge3N0cmluZ30gaWQgZm9yIHRoZSBhZGRlZCBmaWxlXG4gICAqL1xuICBhZGRGaWxlIChmaWxlKSB7XG4gICAgdGhpcy5fYXNzZXJ0TmV3VXBsb2FkQWxsb3dlZChmaWxlKVxuXG4gICAgY29uc3QgeyBmaWxlcyB9ID0gdGhpcy5nZXRTdGF0ZSgpXG4gICAgY29uc3QgbmV3RmlsZSA9IHRoaXMuX2NoZWNrQW5kQ3JlYXRlRmlsZVN0YXRlT2JqZWN0KGZpbGVzLCBmaWxlKVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBmaWxlczoge1xuICAgICAgICAuLi5maWxlcyxcbiAgICAgICAgW25ld0ZpbGUuaWRdOiBuZXdGaWxlXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuZW1pdCgnZmlsZS1hZGRlZCcsIG5ld0ZpbGUpXG4gICAgdGhpcy5sb2coYEFkZGVkIGZpbGU6ICR7bmV3RmlsZS5uYW1lfSwgJHtuZXdGaWxlLmlkfSwgbWltZSB0eXBlOiAke25ld0ZpbGUudHlwZX1gKVxuXG4gICAgdGhpcy5fc3RhcnRJZkF1dG9Qcm9jZWVkKClcblxuICAgIHJldHVybiBuZXdGaWxlLmlkXG4gIH1cblxuICAvKipcbiAgICogQWRkIG11bHRpcGxlIGZpbGVzIHRvIGBzdGF0ZS5maWxlc2AuIFNlZSB0aGUgYGFkZEZpbGUoKWAgZG9jdW1lbnRhdGlvbi5cbiAgICpcbiAgICogVGhpcyBjdXRzIHNvbWUgY29ybmVycyBmb3IgcGVyZm9ybWFuY2UsIHNvIHNob3VsZCB0eXBpY2FsbHkgb25seSBiZSB1c2VkIGluIGNhc2VzIHdoZXJlIHRoZXJlIG1heSBiZSBhIGxvdCBvZiBmaWxlcy5cbiAgICpcbiAgICogSWYgYW4gZXJyb3Igb2NjdXJzIHdoaWxlIGFkZGluZyBhIGZpbGUsIGl0IGlzIGxvZ2dlZCBhbmQgdGhlIHVzZXIgaXMgbm90aWZpZWQuIFRoaXMgaXMgZ29vZCBmb3IgVUkgcGx1Z2lucywgYnV0IG5vdCBmb3IgcHJvZ3JhbW1hdGljIHVzZS4gUHJvZ3JhbW1hdGljIHVzZXJzIHNob3VsZCB1c3VhbGx5IHN0aWxsIHVzZSBgYWRkRmlsZSgpYCBvbiBpbmRpdmlkdWFsIGZpbGVzLlxuICAgKi9cbiAgYWRkRmlsZXMgKGZpbGVEZXNjcmlwdG9ycykge1xuICAgIHRoaXMuX2Fzc2VydE5ld1VwbG9hZEFsbG93ZWQoKVxuXG4gICAgLy8gY3JlYXRlIGEgY29weSBvZiB0aGUgZmlsZXMgb2JqZWN0IG9ubHkgb25jZVxuICAgIGNvbnN0IGZpbGVzID0geyAuLi50aGlzLmdldFN0YXRlKCkuZmlsZXMgfVxuICAgIGNvbnN0IG5ld0ZpbGVzID0gW11cbiAgICBjb25zdCBlcnJvcnMgPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZURlc2NyaXB0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBuZXdGaWxlID0gdGhpcy5fY2hlY2tBbmRDcmVhdGVGaWxlU3RhdGVPYmplY3QoZmlsZXMsIGZpbGVEZXNjcmlwdG9yc1tpXSlcbiAgICAgICAgbmV3RmlsZXMucHVzaChuZXdGaWxlKVxuICAgICAgICBmaWxlc1tuZXdGaWxlLmlkXSA9IG5ld0ZpbGVcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIWVyci5pc1Jlc3RyaWN0aW9uKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZpbGVzIH0pXG5cbiAgICBuZXdGaWxlcy5mb3JFYWNoKChuZXdGaWxlKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ2ZpbGUtYWRkZWQnLCBuZXdGaWxlKVxuICAgIH0pXG4gICAgdGhpcy5sb2coYEFkZGVkIGJhdGNoIG9mICR7bmV3RmlsZXMubGVuZ3RofSBmaWxlc2ApXG5cbiAgICB0aGlzLl9zdGFydElmQXV0b1Byb2NlZWQoKVxuXG4gICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICBsZXQgbWVzc2FnZSA9ICdNdWx0aXBsZSBlcnJvcnMgb2NjdXJyZWQgd2hpbGUgYWRkaW5nIGZpbGVzOlxcbidcbiAgICAgIGVycm9ycy5mb3JFYWNoKChzdWJFcnJvcikgPT4ge1xuICAgICAgICBtZXNzYWdlICs9IGBcXG4gKiAke3N1YkVycm9yLm1lc3NhZ2V9YFxuICAgICAgfSlcblxuICAgICAgdGhpcy5pbmZvKHtcbiAgICAgICAgbWVzc2FnZTogdGhpcy5pMThuKCdhZGRCdWxrRmlsZXNGYWlsZWQnLCB7IHNtYXJ0X2NvdW50OiBlcnJvcnMubGVuZ3RoIH0pLFxuICAgICAgICBkZXRhaWxzOiBtZXNzYWdlXG4gICAgICB9LCAnZXJyb3InLCA1MDAwKVxuXG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICAgIGVyci5lcnJvcnMgPSBlcnJvcnNcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUZpbGVzIChmaWxlSURzKSB7XG4gICAgY29uc3QgeyBmaWxlcywgY3VycmVudFVwbG9hZHMgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuICAgIGNvbnN0IHVwZGF0ZWRGaWxlcyA9IHsgLi4uZmlsZXMgfVxuICAgIGNvbnN0IHVwZGF0ZWRVcGxvYWRzID0geyAuLi5jdXJyZW50VXBsb2FkcyB9XG5cbiAgICBjb25zdCByZW1vdmVkRmlsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgZmlsZUlEcy5mb3JFYWNoKChmaWxlSUQpID0+IHtcbiAgICAgIGlmIChmaWxlc1tmaWxlSURdKSB7XG4gICAgICAgIHJlbW92ZWRGaWxlc1tmaWxlSURdID0gZmlsZXNbZmlsZUlEXVxuICAgICAgICBkZWxldGUgdXBkYXRlZEZpbGVzW2ZpbGVJRF1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gUmVtb3ZlIGZpbGVzIGZyb20gdGhlIGBmaWxlSURzYCBsaXN0IGluIGVhY2ggdXBsb2FkLlxuICAgIGZ1bmN0aW9uIGZpbGVJc05vdFJlbW92ZWQgKHVwbG9hZEZpbGVJRCkge1xuICAgICAgcmV0dXJuIHJlbW92ZWRGaWxlc1t1cGxvYWRGaWxlSURdID09PSB1bmRlZmluZWRcbiAgICB9XG4gICAgY29uc3QgdXBsb2Fkc1RvUmVtb3ZlID0gW11cbiAgICBPYmplY3Qua2V5cyh1cGRhdGVkVXBsb2FkcykuZm9yRWFjaCgodXBsb2FkSUQpID0+IHtcbiAgICAgIGNvbnN0IG5ld0ZpbGVJRHMgPSBjdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF0uZmlsZUlEcy5maWx0ZXIoZmlsZUlzTm90UmVtb3ZlZClcblxuICAgICAgLy8gUmVtb3ZlIHRoZSB1cGxvYWQgaWYgbm8gZmlsZXMgYXJlIGFzc29jaWF0ZWQgd2l0aCBpdCBhbnltb3JlLlxuICAgICAgaWYgKG5ld0ZpbGVJRHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHVwbG9hZHNUb1JlbW92ZS5wdXNoKHVwbG9hZElEKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdXBkYXRlZFVwbG9hZHNbdXBsb2FkSURdID0ge1xuICAgICAgICAuLi5jdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF0sXG4gICAgICAgIGZpbGVJRHM6IG5ld0ZpbGVJRHNcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdXBsb2Fkc1RvUmVtb3ZlLmZvckVhY2goKHVwbG9hZElEKSA9PiB7XG4gICAgICBkZWxldGUgdXBkYXRlZFVwbG9hZHNbdXBsb2FkSURdXG4gICAgfSlcblxuICAgIGNvbnN0IHN0YXRlVXBkYXRlID0ge1xuICAgICAgY3VycmVudFVwbG9hZHM6IHVwZGF0ZWRVcGxvYWRzLFxuICAgICAgZmlsZXM6IHVwZGF0ZWRGaWxlc1xuICAgIH1cblxuICAgIC8vIElmIGFsbCBmaWxlcyB3ZXJlIHJlbW92ZWQgLSBhbGxvdyBuZXcgdXBsb2FkcyFcbiAgICBpZiAoT2JqZWN0LmtleXModXBkYXRlZEZpbGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHN0YXRlVXBkYXRlLmFsbG93TmV3VXBsb2FkID0gdHJ1ZVxuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoc3RhdGVVcGRhdGUpXG5cbiAgICB0aGlzLl9jYWxjdWxhdGVUb3RhbFByb2dyZXNzKClcblxuICAgIGNvbnN0IHJlbW92ZWRGaWxlSURzID0gT2JqZWN0LmtleXMocmVtb3ZlZEZpbGVzKVxuICAgIHJlbW92ZWRGaWxlSURzLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdmaWxlLXJlbW92ZWQnLCByZW1vdmVkRmlsZXNbZmlsZUlEXSlcbiAgICB9KVxuICAgIGlmIChyZW1vdmVkRmlsZUlEcy5sZW5ndGggPiA1KSB7XG4gICAgICB0aGlzLmxvZyhgUmVtb3ZlZCAke3JlbW92ZWRGaWxlSURzLmxlbmd0aH0gZmlsZXNgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZyhgUmVtb3ZlZCBmaWxlczogJHtyZW1vdmVkRmlsZUlEcy5qb2luKCcsICcpfWApXG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlRmlsZSAoZmlsZUlEKSB7XG4gICAgdGhpcy5yZW1vdmVGaWxlcyhbZmlsZUlEXSlcbiAgfVxuXG4gIHBhdXNlUmVzdW1lIChmaWxlSUQpIHtcbiAgICBpZiAoIXRoaXMuZ2V0U3RhdGUoKS5jYXBhYmlsaXRpZXMucmVzdW1hYmxlVXBsb2FkcyB8fFxuICAgICAgICAgdGhpcy5nZXRGaWxlKGZpbGVJRCkudXBsb2FkQ29tcGxldGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHdhc1BhdXNlZCA9IHRoaXMuZ2V0RmlsZShmaWxlSUQpLmlzUGF1c2VkIHx8IGZhbHNlXG4gICAgY29uc3QgaXNQYXVzZWQgPSAhd2FzUGF1c2VkXG5cbiAgICB0aGlzLnNldEZpbGVTdGF0ZShmaWxlSUQsIHtcbiAgICAgIGlzUGF1c2VkOiBpc1BhdXNlZFxuICAgIH0pXG5cbiAgICB0aGlzLmVtaXQoJ3VwbG9hZC1wYXVzZScsIGZpbGVJRCwgaXNQYXVzZWQpXG5cbiAgICByZXR1cm4gaXNQYXVzZWRcbiAgfVxuXG4gIHBhdXNlQWxsICgpIHtcbiAgICBjb25zdCB1cGRhdGVkRmlsZXMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldFN0YXRlKCkuZmlsZXMpXG4gICAgY29uc3QgaW5Qcm9ncmVzc1VwZGF0ZWRGaWxlcyA9IE9iamVjdC5rZXlzKHVwZGF0ZWRGaWxlcykuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gIXVwZGF0ZWRGaWxlc1tmaWxlXS5wcm9ncmVzcy51cGxvYWRDb21wbGV0ZSAmJlxuICAgICAgICAgICAgIHVwZGF0ZWRGaWxlc1tmaWxlXS5wcm9ncmVzcy51cGxvYWRTdGFydGVkXG4gICAgfSlcblxuICAgIGluUHJvZ3Jlc3NVcGRhdGVkRmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZEZpbGUgPSBPYmplY3QuYXNzaWduKHt9LCB1cGRhdGVkRmlsZXNbZmlsZV0sIHtcbiAgICAgICAgaXNQYXVzZWQ6IHRydWVcbiAgICAgIH0pXG4gICAgICB1cGRhdGVkRmlsZXNbZmlsZV0gPSB1cGRhdGVkRmlsZVxuICAgIH0pXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZpbGVzOiB1cGRhdGVkRmlsZXMgfSlcblxuICAgIHRoaXMuZW1pdCgncGF1c2UtYWxsJylcbiAgfVxuXG4gIHJlc3VtZUFsbCAoKSB7XG4gICAgY29uc3QgdXBkYXRlZEZpbGVzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRTdGF0ZSgpLmZpbGVzKVxuICAgIGNvbnN0IGluUHJvZ3Jlc3NVcGRhdGVkRmlsZXMgPSBPYmplY3Qua2V5cyh1cGRhdGVkRmlsZXMpLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuICF1cGRhdGVkRmlsZXNbZmlsZV0ucHJvZ3Jlc3MudXBsb2FkQ29tcGxldGUgJiZcbiAgICAgICAgICAgICB1cGRhdGVkRmlsZXNbZmlsZV0ucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZFxuICAgIH0pXG5cbiAgICBpblByb2dyZXNzVXBkYXRlZEZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRGaWxlID0gT2JqZWN0LmFzc2lnbih7fSwgdXBkYXRlZEZpbGVzW2ZpbGVdLCB7XG4gICAgICAgIGlzUGF1c2VkOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgIH0pXG4gICAgICB1cGRhdGVkRmlsZXNbZmlsZV0gPSB1cGRhdGVkRmlsZVxuICAgIH0pXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZpbGVzOiB1cGRhdGVkRmlsZXMgfSlcblxuICAgIHRoaXMuZW1pdCgncmVzdW1lLWFsbCcpXG4gIH1cblxuICByZXRyeUFsbCAoKSB7XG4gICAgY29uc3QgdXBkYXRlZEZpbGVzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRTdGF0ZSgpLmZpbGVzKVxuICAgIGNvbnN0IGZpbGVzVG9SZXRyeSA9IE9iamVjdC5rZXlzKHVwZGF0ZWRGaWxlcykuZmlsdGVyKGZpbGUgPT4ge1xuICAgICAgcmV0dXJuIHVwZGF0ZWRGaWxlc1tmaWxlXS5lcnJvclxuICAgIH0pXG5cbiAgICBmaWxlc1RvUmV0cnkuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZEZpbGUgPSBPYmplY3QuYXNzaWduKHt9LCB1cGRhdGVkRmlsZXNbZmlsZV0sIHtcbiAgICAgICAgaXNQYXVzZWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgfSlcbiAgICAgIHVwZGF0ZWRGaWxlc1tmaWxlXSA9IHVwZGF0ZWRGaWxlXG4gICAgfSlcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGZpbGVzOiB1cGRhdGVkRmlsZXMsXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH0pXG5cbiAgICB0aGlzLmVtaXQoJ3JldHJ5LWFsbCcsIGZpbGVzVG9SZXRyeSlcblxuICAgIGNvbnN0IHVwbG9hZElEID0gdGhpcy5fY3JlYXRlVXBsb2FkKGZpbGVzVG9SZXRyeSlcbiAgICByZXR1cm4gdGhpcy5fcnVuVXBsb2FkKHVwbG9hZElEKVxuICB9XG5cbiAgY2FuY2VsQWxsICgpIHtcbiAgICB0aGlzLmVtaXQoJ2NhbmNlbC1hbGwnKVxuXG4gICAgY29uc3QgeyBmaWxlcyB9ID0gdGhpcy5nZXRTdGF0ZSgpXG5cbiAgICBjb25zdCBmaWxlSURzID0gT2JqZWN0LmtleXMoZmlsZXMpXG4gICAgaWYgKGZpbGVJRHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJlbW92ZUZpbGVzKGZpbGVJRHMpXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB0b3RhbFByb2dyZXNzOiAwLFxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9KVxuICB9XG5cbiAgcmV0cnlVcGxvYWQgKGZpbGVJRCkge1xuICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGVJRCwge1xuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBpc1BhdXNlZDogZmFsc2VcbiAgICB9KVxuXG4gICAgdGhpcy5lbWl0KCd1cGxvYWQtcmV0cnknLCBmaWxlSUQpXG5cbiAgICBjb25zdCB1cGxvYWRJRCA9IHRoaXMuX2NyZWF0ZVVwbG9hZChbZmlsZUlEXSlcbiAgICByZXR1cm4gdGhpcy5fcnVuVXBsb2FkKHVwbG9hZElEKVxuICB9XG5cbiAgcmVzZXQgKCkge1xuICAgIHRoaXMuY2FuY2VsQWxsKClcbiAgfVxuXG4gIF9jYWxjdWxhdGVQcm9ncmVzcyAoZmlsZSwgZGF0YSkge1xuICAgIGlmICghdGhpcy5nZXRGaWxlKGZpbGUuaWQpKSB7XG4gICAgICB0aGlzLmxvZyhgTm90IHNldHRpbmcgcHJvZ3Jlc3MgZm9yIGEgZmlsZSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQ6ICR7ZmlsZS5pZH1gKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gYnl0ZXNUb3RhbCBtYXkgYmUgbnVsbCBvciB6ZXJvOyBpbiB0aGF0IGNhc2Ugd2UgY2FuJ3QgZGl2aWRlIGJ5IGl0XG4gICAgY29uc3QgY2FuSGF2ZVBlcmNlbnRhZ2UgPSBpc0Zpbml0ZShkYXRhLmJ5dGVzVG90YWwpICYmIGRhdGEuYnl0ZXNUb3RhbCA+IDBcbiAgICB0aGlzLnNldEZpbGVTdGF0ZShmaWxlLmlkLCB7XG4gICAgICBwcm9ncmVzczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRGaWxlKGZpbGUuaWQpLnByb2dyZXNzLCB7XG4gICAgICAgIGJ5dGVzVXBsb2FkZWQ6IGRhdGEuYnl0ZXNVcGxvYWRlZCxcbiAgICAgICAgYnl0ZXNUb3RhbDogZGF0YS5ieXRlc1RvdGFsLFxuICAgICAgICBwZXJjZW50YWdlOiBjYW5IYXZlUGVyY2VudGFnZVxuICAgICAgICAgIC8vIFRPRE8oZ290by1idXMtc3RvcCkgZmxvb3JpbmcgdGhpcyBzaG91bGQgcHJvYmFibHkgYmUgdGhlIGNob2ljZSBvZiB0aGUgVUk/XG4gICAgICAgICAgLy8gd2UgZ2V0IG1vcmUgYWNjdXJhdGUgY2FsY3VsYXRpb25zIGlmIHdlIGRvbid0IHJvdW5kIHRoaXMgYXQgYWxsLlxuICAgICAgICAgID8gTWF0aC5yb3VuZChkYXRhLmJ5dGVzVXBsb2FkZWQgLyBkYXRhLmJ5dGVzVG90YWwgKiAxMDApXG4gICAgICAgICAgOiAwXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLl9jYWxjdWxhdGVUb3RhbFByb2dyZXNzKClcbiAgfVxuXG4gIF9jYWxjdWxhdGVUb3RhbFByb2dyZXNzICgpIHtcbiAgICAvLyBjYWxjdWxhdGUgdG90YWwgcHJvZ3Jlc3MsIHVzaW5nIHRoZSBudW1iZXIgb2YgZmlsZXMgY3VycmVudGx5IHVwbG9hZGluZyxcbiAgICAvLyBtdWx0aXBsaWVkIGJ5IDEwMCBhbmQgdGhlIHN1bW0gb2YgaW5kaXZpZHVhbCBwcm9ncmVzcyBvZiBlYWNoIGZpbGVcbiAgICBjb25zdCBmaWxlcyA9IHRoaXMuZ2V0RmlsZXMoKVxuXG4gICAgY29uc3QgaW5Qcm9ncmVzcyA9IGZpbGVzLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIGZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZFxuICAgIH0pXG5cbiAgICBpZiAoaW5Qcm9ncmVzcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCAwKVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHRvdGFsUHJvZ3Jlc3M6IDAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHNpemVkRmlsZXMgPSBpblByb2dyZXNzLmZpbHRlcigoZmlsZSkgPT4gZmlsZS5wcm9ncmVzcy5ieXRlc1RvdGFsICE9IG51bGwpXG4gICAgY29uc3QgdW5zaXplZEZpbGVzID0gaW5Qcm9ncmVzcy5maWx0ZXIoKGZpbGUpID0+IGZpbGUucHJvZ3Jlc3MuYnl0ZXNUb3RhbCA9PSBudWxsKVxuXG4gICAgaWYgKHNpemVkRmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCBwcm9ncmVzc01heCA9IGluUHJvZ3Jlc3MubGVuZ3RoICogMTAwXG4gICAgICBjb25zdCBjdXJyZW50UHJvZ3Jlc3MgPSB1bnNpemVkRmlsZXMucmVkdWNlKChhY2MsIGZpbGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGFjYyArIGZpbGUucHJvZ3Jlc3MucGVyY2VudGFnZVxuICAgICAgfSwgMClcbiAgICAgIGNvbnN0IHRvdGFsUHJvZ3Jlc3MgPSBNYXRoLnJvdW5kKGN1cnJlbnRQcm9ncmVzcyAvIHByb2dyZXNzTWF4ICogMTAwKVxuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHRvdGFsUHJvZ3Jlc3MgfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCB0b3RhbFNpemUgPSBzaXplZEZpbGVzLnJlZHVjZSgoYWNjLCBmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gYWNjICsgZmlsZS5wcm9ncmVzcy5ieXRlc1RvdGFsXG4gICAgfSwgMClcbiAgICBjb25zdCBhdmVyYWdlU2l6ZSA9IHRvdGFsU2l6ZSAvIHNpemVkRmlsZXMubGVuZ3RoXG4gICAgdG90YWxTaXplICs9IGF2ZXJhZ2VTaXplICogdW5zaXplZEZpbGVzLmxlbmd0aFxuXG4gICAgbGV0IHVwbG9hZGVkU2l6ZSA9IDBcbiAgICBzaXplZEZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIHVwbG9hZGVkU2l6ZSArPSBmaWxlLnByb2dyZXNzLmJ5dGVzVXBsb2FkZWRcbiAgICB9KVxuICAgIHVuc2l6ZWRGaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICB1cGxvYWRlZFNpemUgKz0gYXZlcmFnZVNpemUgKiAoZmlsZS5wcm9ncmVzcy5wZXJjZW50YWdlIHx8IDApIC8gMTAwXG4gICAgfSlcblxuICAgIGxldCB0b3RhbFByb2dyZXNzID0gdG90YWxTaXplID09PSAwXG4gICAgICA/IDBcbiAgICAgIDogTWF0aC5yb3VuZCh1cGxvYWRlZFNpemUgLyB0b3RhbFNpemUgKiAxMDApXG5cbiAgICAvLyBob3QgZml4LCBiZWNhdXNlOlxuICAgIC8vIHVwbG9hZGVkU2l6ZSBlbmRlZCB1cCBsYXJnZXIgdGhhbiB0b3RhbFNpemUsIHJlc3VsdGluZyBpbiAxMzI1JSB0b3RhbFxuICAgIGlmICh0b3RhbFByb2dyZXNzID4gMTAwKSB7XG4gICAgICB0b3RhbFByb2dyZXNzID0gMTAwXG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7IHRvdGFsUHJvZ3Jlc3MgfSlcbiAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgdG90YWxQcm9ncmVzcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgbGlzdGVuZXJzIGZvciBhbGwgZ2xvYmFsIGFjdGlvbnMsIGxpa2U6XG4gICAqIGBlcnJvcmAsIGBmaWxlLXJlbW92ZWRgLCBgdXBsb2FkLXByb2dyZXNzYFxuICAgKi9cbiAgX2FkZExpc3RlbmVycyAoKSB7XG4gICAgdGhpcy5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcicgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5vbigndXBsb2FkLWVycm9yJywgKGZpbGUsIGVycm9yLCByZXNwb25zZSkgPT4ge1xuICAgICAgdGhpcy5zZXRGaWxlU3RhdGUoZmlsZS5pZCwge1xuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcicsXG4gICAgICAgIHJlc3BvbnNlXG4gICAgICB9KVxuXG4gICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSlcblxuICAgICAgbGV0IG1lc3NhZ2UgPSB0aGlzLmkxOG4oJ2ZhaWxlZFRvVXBsb2FkJywgeyBmaWxlOiBmaWxlLm5hbWUgfSlcbiAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yLm1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZSA9IHsgbWVzc2FnZTogbWVzc2FnZSwgZGV0YWlsczogZXJyb3IubWVzc2FnZSB9XG4gICAgICB9XG4gICAgICB0aGlzLmluZm8obWVzc2FnZSwgJ2Vycm9yJywgNTAwMClcbiAgICB9KVxuXG4gICAgdGhpcy5vbigndXBsb2FkJywgKCkgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9yOiBudWxsIH0pXG4gICAgfSlcblxuICAgIHRoaXMub24oJ3VwbG9hZC1zdGFydGVkJywgKGZpbGUsIHVwbG9hZCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmdldEZpbGUoZmlsZS5pZCkpIHtcbiAgICAgICAgdGhpcy5sb2coYE5vdCBzZXR0aW5nIHByb2dyZXNzIGZvciBhIGZpbGUgdGhhdCBoYXMgYmVlbiByZW1vdmVkOiAke2ZpbGUuaWR9YClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzLnNldEZpbGVTdGF0ZShmaWxlLmlkLCB7XG4gICAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgICAgdXBsb2FkU3RhcnRlZDogRGF0ZS5ub3coKSxcbiAgICAgICAgICB1cGxvYWRDb21wbGV0ZTogZmFsc2UsXG4gICAgICAgICAgcGVyY2VudGFnZTogMCxcbiAgICAgICAgICBieXRlc1VwbG9hZGVkOiAwLFxuICAgICAgICAgIGJ5dGVzVG90YWw6IGZpbGUuc2l6ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uKCd1cGxvYWQtcHJvZ3Jlc3MnLCB0aGlzLl9jYWxjdWxhdGVQcm9ncmVzcylcblxuICAgIHRoaXMub24oJ3VwbG9hZC1zdWNjZXNzJywgKGZpbGUsIHVwbG9hZFJlc3ApID0+IHtcbiAgICAgIGlmICghdGhpcy5nZXRGaWxlKGZpbGUuaWQpKSB7XG4gICAgICAgIHRoaXMubG9nKGBOb3Qgc2V0dGluZyBwcm9ncmVzcyBmb3IgYSBmaWxlIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZDogJHtmaWxlLmlkfWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBjdXJyZW50UHJvZ3Jlc3MgPSB0aGlzLmdldEZpbGUoZmlsZS5pZCkucHJvZ3Jlc3NcbiAgICAgIHRoaXMuc2V0RmlsZVN0YXRlKGZpbGUuaWQsIHtcbiAgICAgICAgcHJvZ3Jlc3M6IE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnRQcm9ncmVzcywge1xuICAgICAgICAgIHVwbG9hZENvbXBsZXRlOiB0cnVlLFxuICAgICAgICAgIHBlcmNlbnRhZ2U6IDEwMCxcbiAgICAgICAgICBieXRlc1VwbG9hZGVkOiBjdXJyZW50UHJvZ3Jlc3MuYnl0ZXNUb3RhbFxuICAgICAgICB9KSxcbiAgICAgICAgcmVzcG9uc2U6IHVwbG9hZFJlc3AsXG4gICAgICAgIHVwbG9hZFVSTDogdXBsb2FkUmVzcC51cGxvYWRVUkwsXG4gICAgICAgIGlzUGF1c2VkOiBmYWxzZVxuICAgICAgfSlcblxuICAgICAgdGhpcy5fY2FsY3VsYXRlVG90YWxQcm9ncmVzcygpXG4gICAgfSlcblxuICAgIHRoaXMub24oJ3ByZXByb2Nlc3MtcHJvZ3Jlc3MnLCAoZmlsZSwgcHJvZ3Jlc3MpID0+IHtcbiAgICAgIGlmICghdGhpcy5nZXRGaWxlKGZpbGUuaWQpKSB7XG4gICAgICAgIHRoaXMubG9nKGBOb3Qgc2V0dGluZyBwcm9ncmVzcyBmb3IgYSBmaWxlIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZDogJHtmaWxlLmlkfWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcy5zZXRGaWxlU3RhdGUoZmlsZS5pZCwge1xuICAgICAgICBwcm9ncmVzczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRGaWxlKGZpbGUuaWQpLnByb2dyZXNzLCB7XG4gICAgICAgICAgcHJlcHJvY2VzczogcHJvZ3Jlc3NcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRoaXMub24oJ3ByZXByb2Nlc3MtY29tcGxldGUnLCAoZmlsZSkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmdldEZpbGUoZmlsZS5pZCkpIHtcbiAgICAgICAgdGhpcy5sb2coYE5vdCBzZXR0aW5nIHByb2dyZXNzIGZvciBhIGZpbGUgdGhhdCBoYXMgYmVlbiByZW1vdmVkOiAke2ZpbGUuaWR9YClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBmaWxlcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0U3RhdGUoKS5maWxlcylcbiAgICAgIGZpbGVzW2ZpbGUuaWRdID0gT2JqZWN0LmFzc2lnbih7fSwgZmlsZXNbZmlsZS5pZF0sIHtcbiAgICAgICAgcHJvZ3Jlc3M6IE9iamVjdC5hc3NpZ24oe30sIGZpbGVzW2ZpbGUuaWRdLnByb2dyZXNzKVxuICAgICAgfSlcbiAgICAgIGRlbGV0ZSBmaWxlc1tmaWxlLmlkXS5wcm9ncmVzcy5wcmVwcm9jZXNzXG5cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBmaWxlczogZmlsZXMgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5vbigncG9zdHByb2Nlc3MtcHJvZ3Jlc3MnLCAoZmlsZSwgcHJvZ3Jlc3MpID0+IHtcbiAgICAgIGlmICghdGhpcy5nZXRGaWxlKGZpbGUuaWQpKSB7XG4gICAgICAgIHRoaXMubG9nKGBOb3Qgc2V0dGluZyBwcm9ncmVzcyBmb3IgYSBmaWxlIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZDogJHtmaWxlLmlkfWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcy5zZXRGaWxlU3RhdGUoZmlsZS5pZCwge1xuICAgICAgICBwcm9ncmVzczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRTdGF0ZSgpLmZpbGVzW2ZpbGUuaWRdLnByb2dyZXNzLCB7XG4gICAgICAgICAgcG9zdHByb2Nlc3M6IHByb2dyZXNzXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uKCdwb3N0cHJvY2Vzcy1jb21wbGV0ZScsIChmaWxlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZ2V0RmlsZShmaWxlLmlkKSkge1xuICAgICAgICB0aGlzLmxvZyhgTm90IHNldHRpbmcgcHJvZ3Jlc3MgZm9yIGEgZmlsZSB0aGF0IGhhcyBiZWVuIHJlbW92ZWQ6ICR7ZmlsZS5pZH1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbGVzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRTdGF0ZSgpLmZpbGVzKVxuICAgICAgZmlsZXNbZmlsZS5pZF0gPSBPYmplY3QuYXNzaWduKHt9LCBmaWxlc1tmaWxlLmlkXSwge1xuICAgICAgICBwcm9ncmVzczogT2JqZWN0LmFzc2lnbih7fSwgZmlsZXNbZmlsZS5pZF0ucHJvZ3Jlc3MpXG4gICAgICB9KVxuICAgICAgZGVsZXRlIGZpbGVzW2ZpbGUuaWRdLnByb2dyZXNzLnBvc3Rwcm9jZXNzXG4gICAgICAvLyBUT0RPIHNob3VsZCB3ZSBzZXQgc29tZSBraW5kIG9mIGBmdWxseUNvbXBsZXRlYCBwcm9wZXJ0eSBvbiB0aGUgZmlsZSBvYmplY3RcbiAgICAgIC8vIHNvIGl0J3MgZWFzaWVyIHRvIHNlZSB0aGF0IHRoZSBmaWxlIGlzIHVwbG9hZOKApmZ1bGx5IGNvbXBsZXRl4oCmcmF0aGVyIHRoYW5cbiAgICAgIC8vIHdoYXQgd2UgaGF2ZSB0byBkbyBub3cgKGB1cGxvYWRDb21wbGV0ZSAmJiAhcG9zdHByb2Nlc3NgKVxuXG4gICAgICB0aGlzLnNldFN0YXRlKHsgZmlsZXM6IGZpbGVzIH0pXG4gICAgfSlcblxuICAgIHRoaXMub24oJ3Jlc3RvcmVkJywgKCkgPT4ge1xuICAgICAgLy8gRmlsZXMgbWF5IGhhdmUgY2hhbmdlZC0tZW5zdXJlIHByb2dyZXNzIGlzIHN0aWxsIGFjY3VyYXRlLlxuICAgICAgdGhpcy5fY2FsY3VsYXRlVG90YWxQcm9ncmVzcygpXG4gICAgfSlcblxuICAgIC8vIHNob3cgaW5mb3JtZXIgaWYgb2ZmbGluZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsICgpID0+IHRoaXMudXBkYXRlT25saW5lU3RhdHVzKCkpXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsICgpID0+IHRoaXMudXBkYXRlT25saW5lU3RhdHVzKCkpXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudXBkYXRlT25saW5lU3RhdHVzKCksIDMwMDApXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlT25saW5lU3RhdHVzICgpIHtcbiAgICBjb25zdCBvbmxpbmUgPVxuICAgICAgdHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3Iub25MaW5lICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IHdpbmRvdy5uYXZpZ2F0b3Iub25MaW5lXG4gICAgICAgIDogdHJ1ZVxuICAgIGlmICghb25saW5lKSB7XG4gICAgICB0aGlzLmVtaXQoJ2lzLW9mZmxpbmUnKVxuICAgICAgdGhpcy5pbmZvKHRoaXMuaTE4bignbm9JbnRlcm5ldENvbm5lY3Rpb24nKSwgJ2Vycm9yJywgMClcbiAgICAgIHRoaXMud2FzT2ZmbGluZSA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdpcy1vbmxpbmUnKVxuICAgICAgaWYgKHRoaXMud2FzT2ZmbGluZSkge1xuICAgICAgICB0aGlzLmVtaXQoJ2JhY2stb25saW5lJylcbiAgICAgICAgdGhpcy5pbmZvKHRoaXMuaTE4bignY29ubmVjdGVkVG9JbnRlcm5ldCcpLCAnc3VjY2VzcycsIDMwMDApXG4gICAgICAgIHRoaXMud2FzT2ZmbGluZSA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0SUQgKCkge1xuICAgIHJldHVybiB0aGlzLm9wdHMuaWRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBwbHVnaW4gd2l0aCBDb3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luIG9iamVjdFxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdHNdIG9iamVjdCB3aXRoIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIFBsdWdpblxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBzZWxmIGZvciBjaGFpbmluZ1xuICAgKi9cbiAgdXNlIChQbHVnaW4sIG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIFBsdWdpbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgbXNnID0gYEV4cGVjdGVkIGEgcGx1Z2luIGNsYXNzLCBidXQgZ290ICR7UGx1Z2luID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIFBsdWdpbn0uYCArXG4gICAgICAgICcgUGxlYXNlIHZlcmlmeSB0aGF0IHRoZSBwbHVnaW4gd2FzIGltcG9ydGVkIGFuZCBzcGVsbGVkIGNvcnJlY3RseS4nXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG1zZylcbiAgICB9XG5cbiAgICAvLyBJbnN0YW50aWF0ZVxuICAgIGNvbnN0IHBsdWdpbiA9IG5ldyBQbHVnaW4odGhpcywgb3B0cylcbiAgICBjb25zdCBwbHVnaW5JZCA9IHBsdWdpbi5pZFxuICAgIHRoaXMucGx1Z2luc1twbHVnaW4udHlwZV0gPSB0aGlzLnBsdWdpbnNbcGx1Z2luLnR5cGVdIHx8IFtdXG5cbiAgICBpZiAoIXBsdWdpbklkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdXIgcGx1Z2luIG11c3QgaGF2ZSBhbiBpZCcpXG4gICAgfVxuXG4gICAgaWYgKCFwbHVnaW4udHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3VyIHBsdWdpbiBtdXN0IGhhdmUgYSB0eXBlJylcbiAgICB9XG5cbiAgICBjb25zdCBleGlzdHNQbHVnaW5BbHJlYWR5ID0gdGhpcy5nZXRQbHVnaW4ocGx1Z2luSWQpXG4gICAgaWYgKGV4aXN0c1BsdWdpbkFscmVhZHkpIHtcbiAgICAgIGNvbnN0IG1zZyA9IGBBbHJlYWR5IGZvdW5kIGEgcGx1Z2luIG5hbWVkICcke2V4aXN0c1BsdWdpbkFscmVhZHkuaWR9Jy4gYCArXG4gICAgICAgIGBUcmllZCB0byB1c2U6ICcke3BsdWdpbklkfScuXFxuYCArXG4gICAgICAgICdVcHB5IHBsdWdpbnMgbXVzdCBoYXZlIHVuaXF1ZSBgaWRgIG9wdGlvbnMuIFNlZSBodHRwczovL3VwcHkuaW8vZG9jcy9wbHVnaW5zLyNpZC4nXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKVxuICAgIH1cblxuICAgIGlmIChQbHVnaW4uVkVSU0lPTikge1xuICAgICAgdGhpcy5sb2coYFVzaW5nICR7cGx1Z2luSWR9IHYke1BsdWdpbi5WRVJTSU9OfWApXG4gICAgfVxuXG4gICAgdGhpcy5wbHVnaW5zW3BsdWdpbi50eXBlXS5wdXNoKHBsdWdpbilcbiAgICBwbHVnaW4uaW5zdGFsbCgpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgb25lIFBsdWdpbiBieSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgcGx1Z2luIGlkXG4gICAqIEByZXR1cm5zIHtvYmplY3R8Ym9vbGVhbn1cbiAgICovXG4gIGdldFBsdWdpbiAoaWQpIHtcbiAgICBsZXQgZm91bmRQbHVnaW4gPSBudWxsXG4gICAgdGhpcy5pdGVyYXRlUGx1Z2lucygocGx1Z2luKSA9PiB7XG4gICAgICBpZiAocGx1Z2luLmlkID09PSBpZCkge1xuICAgICAgICBmb3VuZFBsdWdpbiA9IHBsdWdpblxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBmb3VuZFBsdWdpblxuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgYHVzZWBkIHBsdWdpbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCB0aGF0IHdpbGwgYmUgcnVuIG9uIGVhY2ggcGx1Z2luXG4gICAqL1xuICBpdGVyYXRlUGx1Z2lucyAobWV0aG9kKSB7XG4gICAgT2JqZWN0LmtleXModGhpcy5wbHVnaW5zKS5mb3JFYWNoKHBsdWdpblR5cGUgPT4ge1xuICAgICAgdGhpcy5wbHVnaW5zW3BsdWdpblR5cGVdLmZvckVhY2gobWV0aG9kKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVW5pbnN0YWxsIGFuZCByZW1vdmUgYSBwbHVnaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0YW5jZSBUaGUgcGx1Z2luIGluc3RhbmNlIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZVBsdWdpbiAoaW5zdGFuY2UpIHtcbiAgICB0aGlzLmxvZyhgUmVtb3ZpbmcgcGx1Z2luICR7aW5zdGFuY2UuaWR9YClcbiAgICB0aGlzLmVtaXQoJ3BsdWdpbi1yZW1vdmUnLCBpbnN0YW5jZSlcblxuICAgIGlmIChpbnN0YW5jZS51bmluc3RhbGwpIHtcbiAgICAgIGluc3RhbmNlLnVuaW5zdGFsbCgpXG4gICAgfVxuXG4gICAgY29uc3QgbGlzdCA9IHRoaXMucGx1Z2luc1tpbnN0YW5jZS50eXBlXS5zbGljZSgpXG4gICAgY29uc3QgaW5kZXggPSBsaXN0LmluZGV4T2YoaW5zdGFuY2UpXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICB0aGlzLnBsdWdpbnNbaW5zdGFuY2UudHlwZV0gPSBsaXN0XG4gICAgfVxuXG4gICAgY29uc3QgdXBkYXRlZFN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpXG4gICAgZGVsZXRlIHVwZGF0ZWRTdGF0ZS5wbHVnaW5zW2luc3RhbmNlLmlkXVxuICAgIHRoaXMuc2V0U3RhdGUodXBkYXRlZFN0YXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIFVuaW5zdGFsbCBhbGwgcGx1Z2lucyBhbmQgY2xvc2UgZG93biB0aGlzIFVwcHkgaW5zdGFuY2UuXG4gICAqL1xuICBjbG9zZSAoKSB7XG4gICAgdGhpcy5sb2coYENsb3NpbmcgVXBweSBpbnN0YW5jZSAke3RoaXMub3B0cy5pZH06IHJlbW92aW5nIGFsbCBmaWxlcyBhbmQgdW5pbnN0YWxsaW5nIHBsdWdpbnNgKVxuXG4gICAgdGhpcy5yZXNldCgpXG5cbiAgICB0aGlzLl9zdG9yZVVuc3Vic2NyaWJlKClcblxuICAgIHRoaXMuaXRlcmF0ZVBsdWdpbnMoKHBsdWdpbikgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVQbHVnaW4ocGx1Z2luKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU2V0IGluZm8gbWVzc2FnZSBpbiBgc3RhdGUuaW5mb2AsIHNvIHRoYXQgVUkgcGx1Z2lucyBsaWtlIGBJbmZvcm1lcmBcbiAgICogY2FuIGRpc3BsYXkgdGhlIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgb2JqZWN0fSBtZXNzYWdlIE1lc3NhZ2UgdG8gYmUgZGlzcGxheWVkIGJ5IHRoZSBpbmZvcm1lclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb25dXG4gICAqL1xuXG4gIGluZm8gKG1lc3NhZ2UsIHR5cGUgPSAnaW5mbycsIGR1cmF0aW9uID0gMzAwMCkge1xuICAgIGNvbnN0IGlzQ29tcGxleE1lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCdcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgaW5mbzoge1xuICAgICAgICBpc0hpZGRlbjogZmFsc2UsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIG1lc3NhZ2U6IGlzQ29tcGxleE1lc3NhZ2UgPyBtZXNzYWdlLm1lc3NhZ2UgOiBtZXNzYWdlLFxuICAgICAgICBkZXRhaWxzOiBpc0NvbXBsZXhNZXNzYWdlID8gbWVzc2FnZS5kZXRhaWxzIDogbnVsbFxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmVtaXQoJ2luZm8tdmlzaWJsZScpXG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5pbmZvVGltZW91dElEKVxuICAgIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgdGhpcy5pbmZvVGltZW91dElEID0gdW5kZWZpbmVkXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBoaWRlIHRoZSBpbmZvcm1lciBhZnRlciBgZHVyYXRpb25gIG1pbGxpc2Vjb25kc1xuICAgIHRoaXMuaW5mb1RpbWVvdXRJRCA9IHNldFRpbWVvdXQodGhpcy5oaWRlSW5mbywgZHVyYXRpb24pXG4gIH1cblxuICBoaWRlSW5mbyAoKSB7XG4gICAgY29uc3QgbmV3SW5mbyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0U3RhdGUoKS5pbmZvLCB7XG4gICAgICBpc0hpZGRlbjogdHJ1ZVxuICAgIH0pXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBpbmZvOiBuZXdJbmZvXG4gICAgfSlcbiAgICB0aGlzLmVtaXQoJ2luZm8taGlkZGVuJylcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXNzZXMgbWVzc2FnZXMgdG8gYSBmdW5jdGlvbiwgcHJvdmlkZWQgaW4gYG9wdHMubG9nZ2VyYC5cbiAgICogSWYgYG9wdHMubG9nZ2VyOiBVcHB5LmRlYnVnTG9nZ2VyYCBvciBgb3B0cy5kZWJ1ZzogdHJ1ZWAsIGxvZ3MgdG8gdGhlIGJyb3dzZXIgY29uc29sZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBtZXNzYWdlIHRvIGxvZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIG9wdGlvbmFsIGBlcnJvcmAgb3IgYHdhcm5pbmdgXG4gICAqL1xuICBsb2cgKG1lc3NhZ2UsIHR5cGUpIHtcbiAgICBjb25zdCB7IGxvZ2dlciB9ID0gdGhpcy5vcHRzXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdlcnJvcic6IGxvZ2dlci5lcnJvcihtZXNzYWdlKTsgYnJlYWtcbiAgICAgIGNhc2UgJ3dhcm5pbmcnOiBsb2dnZXIud2FybihtZXNzYWdlKTsgYnJlYWtcbiAgICAgIGRlZmF1bHQ6IGxvZ2dlci5kZWJ1ZyhtZXNzYWdlKTsgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2Jzb2xldGUsIGV2ZW50IGxpc3RlbmVycyBhcmUgbm93IGFkZGVkIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICovXG4gIHJ1biAoKSB7XG4gICAgdGhpcy5sb2coJ0NhbGxpbmcgcnVuKCkgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeS4nLCAnd2FybmluZycpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN0b3JlIGFuIHVwbG9hZCBieSBpdHMgSUQuXG4gICAqL1xuICByZXN0b3JlICh1cGxvYWRJRCkge1xuICAgIHRoaXMubG9nKGBDb3JlOiBhdHRlbXB0aW5nIHRvIHJlc3RvcmUgdXBsb2FkIFwiJHt1cGxvYWRJRH1cImApXG5cbiAgICBpZiAoIXRoaXMuZ2V0U3RhdGUoKS5jdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF0pIHtcbiAgICAgIHRoaXMuX3JlbW92ZVVwbG9hZCh1cGxvYWRJRClcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ05vbmV4aXN0ZW50IHVwbG9hZCcpKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9ydW5VcGxvYWQodXBsb2FkSUQpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIHVwbG9hZCBmb3IgYSBidW5jaCBvZiBmaWxlcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBmaWxlSURzIEZpbGUgSURzIHRvIGluY2x1ZGUgaW4gdGhpcyB1cGxvYWQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IElEIG9mIHRoaXMgdXBsb2FkLlxuICAgKi9cbiAgX2NyZWF0ZVVwbG9hZCAoZmlsZUlEcykge1xuICAgIGNvbnN0IHsgYWxsb3dOZXdVcGxvYWQsIGN1cnJlbnRVcGxvYWRzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICBpZiAoIWFsbG93TmV3VXBsb2FkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgYSBuZXcgdXBsb2FkOiBhbHJlYWR5IHVwbG9hZGluZy4nKVxuICAgIH1cblxuICAgIGNvbnN0IHVwbG9hZElEID0gY3VpZCgpXG5cbiAgICB0aGlzLmVtaXQoJ3VwbG9hZCcsIHtcbiAgICAgIGlkOiB1cGxvYWRJRCxcbiAgICAgIGZpbGVJRHM6IGZpbGVJRHNcbiAgICB9KVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBhbGxvd05ld1VwbG9hZDogdGhpcy5vcHRzLmFsbG93TXVsdGlwbGVVcGxvYWRzICE9PSBmYWxzZSxcblxuICAgICAgY3VycmVudFVwbG9hZHM6IHtcbiAgICAgICAgLi4uY3VycmVudFVwbG9hZHMsXG4gICAgICAgIFt1cGxvYWRJRF06IHtcbiAgICAgICAgICBmaWxlSURzOiBmaWxlSURzLFxuICAgICAgICAgIHN0ZXA6IDAsXG4gICAgICAgICAgcmVzdWx0OiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiB1cGxvYWRJRFxuICB9XG5cbiAgX2dldFVwbG9hZCAodXBsb2FkSUQpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRVcGxvYWRzIH0gPSB0aGlzLmdldFN0YXRlKClcblxuICAgIHJldHVybiBjdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgZGF0YSB0byBhbiB1cGxvYWQncyByZXN1bHQgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXBsb2FkSUQgVGhlIElEIG9mIHRoZSB1cGxvYWQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIERhdGEgcHJvcGVydGllcyB0byBhZGQgdG8gdGhlIHJlc3VsdCBvYmplY3QuXG4gICAqL1xuICBhZGRSZXN1bHREYXRhICh1cGxvYWRJRCwgZGF0YSkge1xuICAgIGlmICghdGhpcy5fZ2V0VXBsb2FkKHVwbG9hZElEKSkge1xuICAgICAgdGhpcy5sb2coYE5vdCBzZXR0aW5nIHJlc3VsdCBmb3IgYW4gdXBsb2FkIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZDogJHt1cGxvYWRJRH1gKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRVcGxvYWRzID0gdGhpcy5nZXRTdGF0ZSgpLmN1cnJlbnRVcGxvYWRzXG4gICAgY29uc3QgY3VycmVudFVwbG9hZCA9IE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnRVcGxvYWRzW3VwbG9hZElEXSwge1xuICAgICAgcmVzdWx0OiBPYmplY3QuYXNzaWduKHt9LCBjdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF0ucmVzdWx0LCBkYXRhKVxuICAgIH0pXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjdXJyZW50VXBsb2FkczogT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudFVwbG9hZHMsIHtcbiAgICAgICAgW3VwbG9hZElEXTogY3VycmVudFVwbG9hZFxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiB1cGxvYWQsIGVnLiBpZiBpdCBoYXMgYmVlbiBjYW5jZWxlZCBvciBjb21wbGV0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cGxvYWRJRCBUaGUgSUQgb2YgdGhlIHVwbG9hZC5cbiAgICovXG4gIF9yZW1vdmVVcGxvYWQgKHVwbG9hZElEKSB7XG4gICAgY29uc3QgY3VycmVudFVwbG9hZHMgPSB7IC4uLnRoaXMuZ2V0U3RhdGUoKS5jdXJyZW50VXBsb2FkcyB9XG4gICAgZGVsZXRlIGN1cnJlbnRVcGxvYWRzW3VwbG9hZElEXVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBjdXJyZW50VXBsb2FkczogY3VycmVudFVwbG9hZHNcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBhbiB1cGxvYWQuIFRoaXMgcGlja3MgdXAgd2hlcmUgaXQgbGVmdCBvZmYgaW4gY2FzZSB0aGUgdXBsb2FkIGlzIGJlaW5nIHJlc3RvcmVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3J1blVwbG9hZCAodXBsb2FkSUQpIHtcbiAgICBjb25zdCB1cGxvYWREYXRhID0gdGhpcy5nZXRTdGF0ZSgpLmN1cnJlbnRVcGxvYWRzW3VwbG9hZElEXVxuICAgIGNvbnN0IHJlc3RvcmVTdGVwID0gdXBsb2FkRGF0YS5zdGVwXG5cbiAgICBjb25zdCBzdGVwcyA9IFtcbiAgICAgIC4uLnRoaXMucHJlUHJvY2Vzc29ycyxcbiAgICAgIC4uLnRoaXMudXBsb2FkZXJzLFxuICAgICAgLi4udGhpcy5wb3N0UHJvY2Vzc29yc1xuICAgIF1cbiAgICBsZXQgbGFzdFN0ZXAgPSBQcm9taXNlLnJlc29sdmUoKVxuICAgIHN0ZXBzLmZvckVhY2goKGZuLCBzdGVwKSA9PiB7XG4gICAgICAvLyBTa2lwIHRoaXMgc3RlcCBpZiB3ZSBhcmUgcmVzdG9yaW5nIGFuZCBoYXZlIGFscmVhZHkgY29tcGxldGVkIHRoaXMgc3RlcCBiZWZvcmUuXG4gICAgICBpZiAoc3RlcCA8IHJlc3RvcmVTdGVwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBsYXN0U3RlcCA9IGxhc3RTdGVwLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRVcGxvYWRzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICAgICAgY29uc3QgY3VycmVudFVwbG9hZCA9IGN1cnJlbnRVcGxvYWRzW3VwbG9hZElEXVxuICAgICAgICBpZiAoIWN1cnJlbnRVcGxvYWQpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRVcGxvYWQgPSBPYmplY3QuYXNzaWduKHt9LCBjdXJyZW50VXBsb2FkLCB7XG4gICAgICAgICAgc3RlcDogc3RlcFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBjdXJyZW50VXBsb2FkczogT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudFVwbG9hZHMsIHtcbiAgICAgICAgICAgIFt1cGxvYWRJRF06IHVwZGF0ZWRVcGxvYWRcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIFRPRE8gZ2l2ZSB0aGlzIHRoZSBgdXBkYXRlZFVwbG9hZGAgb2JqZWN0IGFzIGl0cyBvbmx5IHBhcmFtZXRlciBtYXliZT9cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdoZW4gbW9yZSBtZXRhZGF0YSBtYXkgYmUgYWRkZWQgdG8gdGhlIHVwbG9hZCB0aGlzIHdvdWxkIGtlZXAgZ2V0dGluZyBtb3JlIHBhcmFtZXRlcnNcbiAgICAgICAgcmV0dXJuIGZuKHVwZGF0ZWRVcGxvYWQuZmlsZUlEcywgdXBsb2FkSUQpXG4gICAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIC8vIE5vdCByZXR1cm5pbmcgdGhlIGBjYXRjaGBlZCBwcm9taXNlLCBiZWNhdXNlIHdlIHN0aWxsIHdhbnQgdG8gcmV0dXJuIGEgcmVqZWN0ZWRcbiAgICAvLyBwcm9taXNlIGZyb20gdGhpcyBtZXRob2QgaWYgdGhlIHVwbG9hZCBmYWlsZWQuXG4gICAgbGFzdFN0ZXAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyciwgdXBsb2FkSUQpXG4gICAgICB0aGlzLl9yZW1vdmVVcGxvYWQodXBsb2FkSUQpXG4gICAgfSlcblxuICAgIHJldHVybiBsYXN0U3RlcC50aGVuKCgpID0+IHtcbiAgICAgIC8vIFNldCByZXN1bHQgZGF0YS5cbiAgICAgIGNvbnN0IHsgY3VycmVudFVwbG9hZHMgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuICAgICAgY29uc3QgY3VycmVudFVwbG9hZCA9IGN1cnJlbnRVcGxvYWRzW3VwbG9hZElEXVxuICAgICAgaWYgKCFjdXJyZW50VXBsb2FkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWxlcyA9IGN1cnJlbnRVcGxvYWQuZmlsZUlEc1xuICAgICAgICAubWFwKChmaWxlSUQpID0+IHRoaXMuZ2V0RmlsZShmaWxlSUQpKVxuICAgICAgY29uc3Qgc3VjY2Vzc2Z1bCA9IGZpbGVzLmZpbHRlcigoZmlsZSkgPT4gIWZpbGUuZXJyb3IpXG4gICAgICBjb25zdCBmYWlsZWQgPSBmaWxlcy5maWx0ZXIoKGZpbGUpID0+IGZpbGUuZXJyb3IpXG4gICAgICB0aGlzLmFkZFJlc3VsdERhdGEodXBsb2FkSUQsIHsgc3VjY2Vzc2Z1bCwgZmFpbGVkLCB1cGxvYWRJRCB9KVxuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgLy8gRW1pdCBjb21wbGV0aW9uIGV2ZW50cy5cbiAgICAgIC8vIFRoaXMgaXMgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBgY3VycmVudFVwbG9hZHNgIHZhcmlhYmxlXG4gICAgICAvLyBhbHdheXMgcmVmZXJzIHRvIHRoZSBsYXRlc3Qgc3RhdGUuIEluIHRoZSBoYW5kbGVyIHJpZ2h0IGFib3ZlIGl0IHJlZmVyc1xuICAgICAgLy8gdG8gYW4gb3V0ZGF0ZWQgb2JqZWN0IHdpdGhvdXQgdGhlIGAucmVzdWx0YCBwcm9wZXJ0eS5cbiAgICAgIGNvbnN0IHsgY3VycmVudFVwbG9hZHMgfSA9IHRoaXMuZ2V0U3RhdGUoKVxuICAgICAgaWYgKCFjdXJyZW50VXBsb2Fkc1t1cGxvYWRJRF0pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50VXBsb2FkID0gY3VycmVudFVwbG9hZHNbdXBsb2FkSURdXG4gICAgICBjb25zdCByZXN1bHQgPSBjdXJyZW50VXBsb2FkLnJlc3VsdFxuICAgICAgdGhpcy5lbWl0KCdjb21wbGV0ZScsIHJlc3VsdClcblxuICAgICAgdGhpcy5fcmVtb3ZlVXBsb2FkKHVwbG9hZElEKVxuXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5sb2coYE5vdCBzZXR0aW5nIHJlc3VsdCBmb3IgYW4gdXBsb2FkIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZDogJHt1cGxvYWRJRH1gKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYW4gdXBsb2FkIGZvciBhbGwgdGhlIGZpbGVzIHRoYXQgYXJlIG5vdCBjdXJyZW50bHkgYmVpbmcgdXBsb2FkZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgdXBsb2FkICgpIHtcbiAgICBpZiAoIXRoaXMucGx1Z2lucy51cGxvYWRlcikge1xuICAgICAgdGhpcy5sb2coJ05vIHVwbG9hZGVyIHR5cGUgcGx1Z2lucyBhcmUgdXNlZCcsICd3YXJuaW5nJylcbiAgICB9XG5cbiAgICBsZXQgZmlsZXMgPSB0aGlzLmdldFN0YXRlKCkuZmlsZXNcblxuICAgIGNvbnN0IG9uQmVmb3JlVXBsb2FkUmVzdWx0ID0gdGhpcy5vcHRzLm9uQmVmb3JlVXBsb2FkKGZpbGVzKVxuXG4gICAgaWYgKG9uQmVmb3JlVXBsb2FkUmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTm90IHN0YXJ0aW5nIHRoZSB1cGxvYWQgYmVjYXVzZSBvbkJlZm9yZVVwbG9hZCByZXR1cm5lZCBmYWxzZScpKVxuICAgIH1cblxuICAgIGlmIChvbkJlZm9yZVVwbG9hZFJlc3VsdCAmJiB0eXBlb2Ygb25CZWZvcmVVcGxvYWRSZXN1bHQgPT09ICdvYmplY3QnKSB7XG4gICAgICBmaWxlcyA9IG9uQmVmb3JlVXBsb2FkUmVzdWx0XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLl9jaGVja01pbk51bWJlck9mRmlsZXMoZmlsZXMpKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRVcGxvYWRzIH0gPSB0aGlzLmdldFN0YXRlKClcbiAgICAgICAgLy8gZ2V0IGEgbGlzdCBvZiBmaWxlcyB0aGF0IGFyZSBjdXJyZW50bHkgYXNzaWduZWQgdG8gdXBsb2Fkc1xuICAgICAgICBjb25zdCBjdXJyZW50bHlVcGxvYWRpbmdGaWxlcyA9IE9iamVjdC5rZXlzKGN1cnJlbnRVcGxvYWRzKS5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHByZXYuY29uY2F0KGN1cnJlbnRVcGxvYWRzW2N1cnJdLmZpbGVJRHMpLCBbXSlcblxuICAgICAgICBjb25zdCB3YWl0aW5nRmlsZUlEcyA9IFtdXG4gICAgICAgIE9iamVjdC5rZXlzKGZpbGVzKS5mb3JFYWNoKChmaWxlSUQpID0+IHtcbiAgICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5nZXRGaWxlKGZpbGVJRClcbiAgICAgICAgICAvLyBpZiB0aGUgZmlsZSBoYXNuJ3Qgc3RhcnRlZCB1cGxvYWRpbmcgYW5kIGhhc24ndCBhbHJlYWR5IGJlZW4gYXNzaWduZWQgdG8gYW4gdXBsb2FkLi5cbiAgICAgICAgICBpZiAoKCFmaWxlLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWQpICYmIChjdXJyZW50bHlVcGxvYWRpbmdGaWxlcy5pbmRleE9mKGZpbGVJRCkgPT09IC0xKSkge1xuICAgICAgICAgICAgd2FpdGluZ0ZpbGVJRHMucHVzaChmaWxlLmlkKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCB1cGxvYWRJRCA9IHRoaXMuX2NyZWF0ZVVwbG9hZCh3YWl0aW5nRmlsZUlEcylcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blVwbG9hZCh1cGxvYWRJRClcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICB0aGlzLl9zaG93T3JMb2dFcnJvckFuZFRocm93KGVycilcbiAgICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICByZXR1cm4gbmV3IFVwcHkob3B0cylcbn1cblxuLy8gRXhwb3NlIGNsYXNzIGNvbnN0cnVjdG9yLlxubW9kdWxlLmV4cG9ydHMuVXBweSA9IFVwcHlcbm1vZHVsZS5leHBvcnRzLlBsdWdpbiA9IFBsdWdpblxubW9kdWxlLmV4cG9ydHMuZGVidWdMb2dnZXIgPSBkZWJ1Z0xvZ2dlclxuIiwiY29uc3QgZ2V0VGltZVN0YW1wID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldFRpbWVTdGFtcCcpXG5cbi8vIFN3YWxsb3cgbG9ncywgZGVmYXVsdCBpZiBsb2dnZXIgaXMgbm90IHNldCBvciBkZWJ1ZzogZmFsc2VcbmNvbnN0IG51bGxMb2dnZXIgPSB7XG4gIGRlYnVnOiAoLi4uYXJncykgPT4ge30sXG4gIHdhcm46ICguLi5hcmdzKSA9PiB7fSxcbiAgZXJyb3I6ICguLi5hcmdzKSA9PiB7fVxufVxuXG4vLyBQcmludCBsb2dzIHRvIGNvbnNvbGUgd2l0aCBuYW1lc3BhY2UgKyB0aW1lc3RhbXAsXG4vLyBzZXQgYnkgbG9nZ2VyOiBVcHB5LmRlYnVnTG9nZ2VyIG9yIGRlYnVnOiB0cnVlXG5jb25zdCBkZWJ1Z0xvZ2dlciA9IHtcbiAgZGVidWc6ICguLi5hcmdzKSA9PiB7XG4gICAgLy8gSUUgMTAgZG9lc27igJl0IHN1cHBvcnQgY29uc29sZS5kZWJ1Z1xuICAgIGNvbnN0IGRlYnVnID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZ1xuICAgIGRlYnVnLmNhbGwoY29uc29sZSwgYFtVcHB5XSBbJHtnZXRUaW1lU3RhbXAoKX1dYCwgLi4uYXJncylcbiAgfSxcbiAgd2FybjogKC4uLmFyZ3MpID0+IGNvbnNvbGUud2FybihgW1VwcHldIFske2dldFRpbWVTdGFtcCgpfV1gLCAuLi5hcmdzKSxcbiAgZXJyb3I6ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKGBbVXBweV0gWyR7Z2V0VGltZVN0YW1wKCl9XWAsIC4uLmFyZ3MpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBudWxsTG9nZ2VyLFxuICBkZWJ1Z0xvZ2dlclxufVxuIiwiLy8gRWRnZSAxNS54IGRvZXMgbm90IGZpcmUgJ3Byb2dyZXNzJyBldmVudHMgb24gdXBsb2Fkcy5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXMvOTQ1XG4vLyBBbmQgaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTIyMjQ1MTAvXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN1cHBvcnRzVXBsb2FkUHJvZ3Jlc3MgKHVzZXJBZ2VudCkge1xuICAvLyBBbGxvdyBwYXNzaW5nIGluIHVzZXJBZ2VudCBmb3IgdGVzdHNcbiAgaWYgKHVzZXJBZ2VudCA9PSBudWxsKSB7XG4gICAgdXNlckFnZW50ID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3IudXNlckFnZW50IDogbnVsbFxuICB9XG4gIC8vIEFzc3VtZSBpdCB3b3JrcyBiZWNhdXNlIGJhc2ljYWxseSBldmVyeXRoaW5nIHN1cHBvcnRzIHByb2dyZXNzIGV2ZW50cy5cbiAgaWYgKCF1c2VyQWdlbnQpIHJldHVybiB0cnVlXG5cbiAgY29uc3QgbSA9IC9FZGdlXFwvKFxcZCtcXC5cXGQrKS8uZXhlYyh1c2VyQWdlbnQpXG4gIGlmICghbSkgcmV0dXJuIHRydWVcblxuICBjb25zdCBlZGdlVmVyc2lvbiA9IG1bMV1cbiAgbGV0IFttYWpvciwgbWlub3JdID0gZWRnZVZlcnNpb24uc3BsaXQoJy4nKVxuICBtYWpvciA9IHBhcnNlSW50KG1ham9yLCAxMClcbiAgbWlub3IgPSBwYXJzZUludChtaW5vciwgMTApXG5cbiAgLy8gV29ya2VkIGJlZm9yZTpcbiAgLy8gRWRnZSA0MC4xNTA2My4wLjBcbiAgLy8gTWljcm9zb2Z0IEVkZ2VIVE1MIDE1LjE1MDYzXG4gIGlmIChtYWpvciA8IDE1IHx8IChtYWpvciA9PT0gMTUgJiYgbWlub3IgPCAxNTA2MykpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gRml4ZWQgaW46XG4gIC8vIE1pY3Jvc29mdCBFZGdlSFRNTCAxOC4xODIxOFxuICBpZiAobWFqb3IgPiAxOCB8fCAobWFqb3IgPT09IDE4ICYmIG1pbm9yID49IDE4MjE4KSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBvdGhlciB2ZXJzaW9ucyBkb24ndCB3b3JrLlxuICByZXR1cm4gZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvZGFzaGJvYXJkXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJVbml2ZXJzYWwgVUkgcGx1Z2luIGZvciBVcHB5LlwiLFxuICBcInZlcnNpb25cIjogXCIxLjUuMlwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwic3R5bGVcIjogXCJkaXN0L3N0eWxlLm1pbi5jc3NcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiLFxuICAgIFwiZGFzaGJvYXJkXCIsXG4gICAgXCJ1aVwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvaW5mb3JtZXJcIjogXCJmaWxlOi4uL2luZm9ybWVyXCIsXG4gICAgXCJAdXBweS9wcm92aWRlci12aWV3c1wiOiBcImZpbGU6Li4vcHJvdmlkZXItdmlld3NcIixcbiAgICBcIkB1cHB5L3N0YXR1cy1iYXJcIjogXCJmaWxlOi4uL3N0YXR1cy1iYXJcIixcbiAgICBcIkB1cHB5L3RodW1ibmFpbC1nZW5lcmF0b3JcIjogXCJmaWxlOi4uL3RodW1ibmFpbC1nZW5lcmF0b3JcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwiY2xhc3NuYW1lc1wiOiBcIl4yLjIuNlwiLFxuICAgIFwiY3VpZFwiOiBcIl4yLjEuMVwiLFxuICAgIFwiaXMtc2hhbGxvdy1lcXVhbFwiOiBcIl4xLjAuMVwiLFxuICAgIFwibG9kYXNoLmRlYm91bmNlXCI6IFwiXjQuMC44XCIsXG4gICAgXCJsb2Rhc2gudGhyb3R0bGVcIjogXCJeNC4xLjFcIixcbiAgICBcIm1lbW9pemUtb25lXCI6IFwiXjUuMC40XCIsXG4gICAgXCJwcmVhY3RcIjogXCI4LjIuOVwiLFxuICAgIFwicHJlYWN0LWNzcy10cmFuc2l0aW9uLWdyb3VwXCI6IFwiXjEuMy4wXCIsXG4gICAgXCJyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGxcIjogXCJeMS41LjBcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgbG9jYWxJY29uIH0gPSByZXF1aXJlKCcuL2ljb25zJylcbmNvbnN0IHsgaCwgQ29tcG9uZW50IH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5jbGFzcyBBZGRGaWxlcyBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuXG4gICAgdGhpcy50cmlnZ2VyRmlsZUlucHV0Q2xpY2sgPSB0aGlzLnRyaWdnZXJGaWxlSW5wdXRDbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5vbkZpbGVJbnB1dENoYW5nZSA9IHRoaXMub25GaWxlSW5wdXRDaGFuZ2UuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5yZW5kZXJQb3dlcmVkQnlVcHB5ID0gdGhpcy5yZW5kZXJQb3dlcmVkQnlVcHB5LmJpbmQodGhpcylcbiAgICB0aGlzLnJlbmRlckhpZGRlbkZpbGVJbnB1dCA9IHRoaXMucmVuZGVySGlkZGVuRmlsZUlucHV0LmJpbmQodGhpcylcbiAgICB0aGlzLnJlbmRlckRyb3BQYXN0ZUJyb3dzZVRhZ2xpbmUgPSB0aGlzLnJlbmRlckRyb3BQYXN0ZUJyb3dzZVRhZ2xpbmUuYmluZCh0aGlzKVxuICAgIHRoaXMucmVuZGVyTXlEZXZpY2VBY3F1aXJlciA9IHRoaXMucmVuZGVyTXlEZXZpY2VBY3F1aXJlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZW5kZXJBY3F1aXJlciA9IHRoaXMucmVuZGVyQWNxdWlyZXIuYmluZCh0aGlzKVxuICB9XG5cbiAgdHJpZ2dlckZpbGVJbnB1dENsaWNrICgpIHtcbiAgICB0aGlzLmZpbGVJbnB1dC5jbGljaygpXG4gIH1cblxuICBvbkZpbGVJbnB1dENoYW5nZSAoZXZlbnQpIHtcbiAgICB0aGlzLnByb3BzLmhhbmRsZUlucHV0Q2hhbmdlKGV2ZW50KVxuXG4gICAgLy8gV2UgY2xlYXIgdGhlIGlucHV0IGFmdGVyIGEgZmlsZSBpcyBzZWxlY3RlZCwgYmVjYXVzZSBvdGhlcndpc2VcbiAgICAvLyBjaGFuZ2UgZXZlbnQgaXMgbm90IGZpcmVkIGluIENocm9tZSBhbmQgU2FmYXJpIHdoZW4gYSBmaWxlXG4gICAgLy8gd2l0aCB0aGUgc2FtZSBuYW1lIGlzIHNlbGVjdGVkLlxuICAgIC8vIF9fX1doeSBub3QgdXNlIHZhbHVlPVwiXCIgb24gPGlucHV0Lz4gaW5zdGVhZD9cbiAgICAvLyAgICBCZWNhdXNlIGlmIHdlIHVzZSB0aGF0IG1ldGhvZCBvZiBjbGVhcmluZyB0aGUgaW5wdXQsXG4gICAgLy8gICAgQ2hyb21lIHdpbGwgbm90IHRyaWdnZXIgY2hhbmdlIGlmIHdlIGRyb3AgdGhlIHNhbWUgZmlsZSB0d2ljZSAoSXNzdWUgIzc2OCkuXG4gICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gbnVsbFxuICB9XG5cbiAgcmVuZGVyUG93ZXJlZEJ5VXBweSAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxhXG4gICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICBocmVmPVwiaHR0cHM6Ly91cHB5LmlvXCJcbiAgICAgICAgcmVsPVwibm9yZWZlcnJlciBub29wZW5lclwiXG4gICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgIGNsYXNzPVwidXBweS1EYXNoYm9hcmQtcG93ZXJlZEJ5XCJcbiAgICAgID5cbiAgICAgICAge3RoaXMucHJvcHMuaTE4bigncG93ZXJlZEJ5JykgKyAnICd9XG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzcz1cIlVwcHlJY29uIHVwcHktRGFzaGJvYXJkLXBvd2VyZWRCeUljb25cIiB3aWR0aD1cIjExXCIgaGVpZ2h0PVwiMTFcIiB2aWV3Qm94PVwiMCAwIDExIDExXCI+XG4gICAgICAgICAgPHBhdGggZD1cIk03LjM2NSAxMC41bC0uMDEtNC4wNDVoMi42MTJMNS41LjgwNmwtNC40NjcgNS42NWgyLjYwNGwuMDEgNC4wNDRoMy43MTh6XCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgICA8c3BhbiBjbGFzcz1cInVwcHktRGFzaGJvYXJkLXBvd2VyZWRCeVVwcHlcIj5VcHB5PC9zcGFuPlxuICAgICAgPC9hPlxuICAgIClcbiAgfVxuXG4gIHJlbmRlckhpZGRlbkZpbGVJbnB1dCAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxpbnB1dFxuICAgICAgICBjbGFzcz1cInVwcHktRGFzaGJvYXJkLWlucHV0XCJcbiAgICAgICAgaGlkZGVuXG4gICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICAgIHRhYmluZGV4PXstMX1cbiAgICAgICAgdHlwZT1cImZpbGVcIlxuICAgICAgICBuYW1lPVwiZmlsZXNbXVwiXG4gICAgICAgIG11bHRpcGxlPXt0aGlzLnByb3BzLm1heE51bWJlck9mRmlsZXMgIT09IDF9XG4gICAgICAgIG9uY2hhbmdlPXt0aGlzLm9uRmlsZUlucHV0Q2hhbmdlfVxuICAgICAgICBhY2NlcHQ9e3RoaXMucHJvcHMuYWxsb3dlZEZpbGVUeXBlc31cbiAgICAgICAgcmVmPXsocmVmKSA9PiB7IHRoaXMuZmlsZUlucHV0ID0gcmVmIH19XG4gICAgICAvPlxuICAgIClcbiAgfVxuXG4gIHJlbmRlckRyb3BQYXN0ZUJyb3dzZVRhZ2xpbmUgKCkge1xuICAgIGNvbnN0IGJyb3dzZSA9XG4gICAgICA8YnV0dG9uXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBjbGFzcz1cInVwcHktdS1yZXNldCB1cHB5LURhc2hib2FyZC1icm93c2VcIlxuICAgICAgICBvbmNsaWNrPXt0aGlzLnRyaWdnZXJGaWxlSW5wdXRDbGlja31cbiAgICAgID5cbiAgICAgICAge3RoaXMucHJvcHMuaTE4bignYnJvd3NlJyl9XG4gICAgICA8L2J1dHRvbj5cblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzPVwidXBweS1EYXNoYm9hcmQtZHJvcEZpbGVzVGl0bGVcIj5cbiAgICAgICAgPHNwYW4+XG4gICAgICAgICAge3RoaXMucHJvcHMuYWNxdWlyZXJzLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgPyB0aGlzLnByb3BzLmkxOG5BcnJheSgnZHJvcFBhc3RlJywgeyBicm93c2UgfSlcbiAgICAgICAgICAgIDogdGhpcy5wcm9wcy5pMThuQXJyYXkoJ2Ryb3BQYXN0ZUltcG9ydCcsIHsgYnJvd3NlIH0pfVxuICAgICAgICA8L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICByZW5kZXJNeURldmljZUFjcXVpcmVyICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzcz1cInVwcHktRGFzaGJvYXJkVGFiXCIgcm9sZT1cInByZXNlbnRhdGlvblwiPlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgY2xhc3M9XCJ1cHB5LURhc2hib2FyZFRhYi1idG5cIlxuICAgICAgICAgIHJvbGU9XCJ0YWJcIlxuICAgICAgICAgIHRhYmluZGV4PXswfVxuICAgICAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICAgICAgICBvbmNsaWNrPXt0aGlzLnRyaWdnZXJGaWxlSW5wdXRDbGlja31cbiAgICAgICAgPlxuICAgICAgICAgIHtsb2NhbEljb24oKX1cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwidXBweS1EYXNoYm9hcmRUYWItbmFtZVwiPnt0aGlzLnByb3BzLmkxOG4oJ215RGV2aWNlJyl9PC9kaXY+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG5cbiAgcmVuZGVyQWNxdWlyZXIgKGFjcXVpcmVyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LURhc2hib2FyZFRhYlwiIHJvbGU9XCJwcmVzZW50YXRpb25cIj5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIGNsYXNzPVwidXBweS1EYXNoYm9hcmRUYWItYnRuXCJcbiAgICAgICAgICByb2xlPVwidGFiXCJcbiAgICAgICAgICB0YWJpbmRleD17MH1cbiAgICAgICAgICBhcmlhLWNvbnRyb2xzPXtgdXBweS1EYXNoYm9hcmRDb250ZW50LXBhbmVsLS0ke2FjcXVpcmVyLmlkfWB9XG4gICAgICAgICAgYXJpYS1zZWxlY3RlZD17dGhpcy5wcm9wcy5hY3RpdmVQaWNrZXJQYW5lbC5pZCA9PT0gYWNxdWlyZXIuaWR9XG4gICAgICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgICAgICAgIG9uY2xpY2s9eygpID0+IHRoaXMucHJvcHMuc2hvd1BhbmVsKGFjcXVpcmVyLmlkKX1cbiAgICAgICAgPlxuICAgICAgICAgIHthY3F1aXJlci5pY29uKCl9XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInVwcHktRGFzaGJvYXJkVGFiLW5hbWVcIj57YWNxdWlyZXIubmFtZX08L2Rpdj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzPVwidXBweS1EYXNoYm9hcmRBZGRGaWxlc1wiPlxuICAgICAgICB7dGhpcy5yZW5kZXJIaWRkZW5GaWxlSW5wdXQoKX1cbiAgICAgICAgPGRpdiBjbGFzcz1cInVwcHktRGFzaGJvYXJkVGFic1wiPlxuICAgICAgICAgIHt0aGlzLnJlbmRlckRyb3BQYXN0ZUJyb3dzZVRhZ2xpbmUoKX1cbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLmFjcXVpcmVycy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LURhc2hib2FyZFRhYnMtbGlzdFwiIHJvbGU9XCJ0YWJsaXN0XCI+XG4gICAgICAgICAgICAgICAge3RoaXMucmVuZGVyTXlEZXZpY2VBY3F1aXJlcigpfVxuICAgICAgICAgICAgICAgIHt0aGlzLnByb3BzLmFjcXVpcmVycy5tYXAoKGFjcXVpcmVyKSA9PlxuICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJBY3F1aXJlcihhY3F1aXJlcilcbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICB9XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInVwcHktRGFzaGJvYXJkQWRkRmlsZXMtaW5mb1wiPlxuICAgICAgICAgICAge3RoaXMucHJvcHMubm90ZSAmJiA8ZGl2IGNsYXNzPVwidXBweS1EYXNoYm9hcmQtbm90ZVwiPnt0aGlzLnByb3BzLm5vdGV9PC9kaXY+fVxuICAgICAgICAgICAge3RoaXMucHJvcHMucHJvdWRseURpc3BsYXlQb3dlcmVkQnlVcHB5ICYmIHRoaXMucmVuZGVyUG93ZXJlZEJ5VXBweSh0aGlzLnByb3BzKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBZGRGaWxlc1xuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgQWRkRmlsZXMgPSByZXF1aXJlKCcuL0FkZEZpbGVzJylcblxuY29uc3QgQWRkRmlsZXNQYW5lbCA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzPVwidXBweS1EYXNoYm9hcmQtQWRkRmlsZXNQYW5lbFwiXG4gICAgICBkYXRhLXVwcHktcGFuZWxUeXBlPVwiQWRkRmlsZXNcIlxuICAgICAgYXJpYS1oaWRkZW49e3Byb3BzLnNob3dBZGRGaWxlc1BhbmVsfVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYmFyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtdGl0bGVcIiByb2xlPVwiaGVhZGluZ1wiIGFyaWEtbGV2ZWw9XCJoMVwiPlxuICAgICAgICAgIHtwcm9wcy5pMThuKCdhZGRpbmdNb3JlRmlsZXMnKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBjbGFzcz1cInVwcHktRGFzaGJvYXJkQ29udGVudC1iYWNrXCJcbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBvbmNsaWNrPXsoZXYpID0+IHByb3BzLnRvZ2dsZUFkZEZpbGVzUGFuZWwoZmFsc2UpfVxuICAgICAgICA+e3Byb3BzLmkxOG4oJ2JhY2snKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxBZGRGaWxlcyB7Li4ucHJvcHN9IC8+XG4gICAgPC9kaXY+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBZGRGaWxlc1BhbmVsXG4iLCJjb25zdCBGaWxlTGlzdCA9IHJlcXVpcmUoJy4vRmlsZUxpc3QnKVxuY29uc3QgQWRkRmlsZXMgPSByZXF1aXJlKCcuL0FkZEZpbGVzJylcbmNvbnN0IEFkZEZpbGVzUGFuZWwgPSByZXF1aXJlKCcuL0FkZEZpbGVzUGFuZWwnKVxuY29uc3QgUGlja2VyUGFuZWxDb250ZW50ID0gcmVxdWlyZSgnLi9QaWNrZXJQYW5lbENvbnRlbnQnKVxuY29uc3QgUGFuZWxUb3BCYXIgPSByZXF1aXJlKCcuL1BpY2tlclBhbmVsVG9wQmFyJylcbmNvbnN0IEZpbGVDYXJkID0gcmVxdWlyZSgnLi9GaWxlQ2FyZCcpXG5jb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5jb25zdCBpc1RvdWNoRGV2aWNlID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2lzVG91Y2hEZXZpY2UnKVxuY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgUHJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwID0gcmVxdWlyZSgncHJlYWN0LWNzcy10cmFuc2l0aW9uLWdyb3VwJylcblxuLy8gaHR0cDovL2Rldi5lZGVuc3BpZWtlcm1hbm4uY29tLzIwMTYvMDIvMTEvaW50cm9kdWNpbmctYWNjZXNzaWJsZS1tb2RhbC1kaWFsb2dcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naG9zaC9taWNyb21vZGFsXG5cbmZ1bmN0aW9uIFRyYW5zaXRpb25XcmFwcGVyIChwcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxQcmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBcbiAgICAgIHRyYW5zaXRpb25OYW1lPVwidXBweS10cmFuc2l0aW9uLXNsaWRlRG93blVwXCJcbiAgICAgIHRyYW5zaXRpb25FbnRlclRpbWVvdXQ9ezI1MH1cbiAgICAgIHRyYW5zaXRpb25MZWF2ZVRpbWVvdXQ9ezI1MH1cbiAgICA+XG4gICAgICB7cHJvcHMuY2hpbGRyZW59XG4gICAgPC9QcmVhY3RDU1NUcmFuc2l0aW9uR3JvdXA+XG4gIClcbn1cblxuY29uc3QgV0lEVEhfWEwgPSA5MDBcbmNvbnN0IFdJRFRIX0xHID0gNzAwXG5jb25zdCBXSURUSF9NRCA9IDU3NlxuY29uc3QgSEVJR0hUX01EID0gNTc2XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gRGFzaGJvYXJkIChwcm9wcykge1xuICBjb25zdCBub0ZpbGVzID0gcHJvcHMudG90YWxGaWxlQ291bnQgPT09IDBcblxuICBjb25zdCBkYXNoYm9hcmRDbGFzc05hbWUgPSBjbGFzc05hbWVzKHtcbiAgICAndXBweS1Sb290JzogcHJvcHMuaXNUYXJnZXRET01FbCxcbiAgICAndXBweS1EYXNoYm9hcmQnOiB0cnVlLFxuICAgICdVcHB5LS1pc1RvdWNoRGV2aWNlJzogaXNUb3VjaERldmljZSgpLFxuICAgICd1cHB5LURhc2hib2FyZC0tYW5pbWF0ZU9wZW5DbG9zZSc6IHByb3BzLmFuaW1hdGVPcGVuQ2xvc2UsXG4gICAgJ3VwcHktRGFzaGJvYXJkLS1pc0Nsb3NpbmcnOiBwcm9wcy5pc0Nsb3NpbmcsXG4gICAgJ3VwcHktRGFzaGJvYXJkLS1pc0RyYWdnaW5nT3Zlcic6IHByb3BzLmlzRHJhZ2dpbmdPdmVyLFxuICAgICd1cHB5LURhc2hib2FyZC0tbW9kYWwnOiAhcHJvcHMuaW5saW5lLFxuICAgICd1cHB5LXNpemUtLW1kJzogcHJvcHMuY29udGFpbmVyV2lkdGggPiBXSURUSF9NRCxcbiAgICAndXBweS1zaXplLS1sZyc6IHByb3BzLmNvbnRhaW5lcldpZHRoID4gV0lEVEhfTEcsXG4gICAgJ3VwcHktc2l6ZS0teGwnOiBwcm9wcy5jb250YWluZXJXaWR0aCA+IFdJRFRIX1hMLFxuICAgICd1cHB5LXNpemUtLWhlaWdodC1tZCc6IHByb3BzLmNvbnRhaW5lckhlaWdodCA+IEhFSUdIVF9NRCxcbiAgICAndXBweS1EYXNoYm9hcmQtLWlzQWRkRmlsZXNQYW5lbFZpc2libGUnOiBwcm9wcy5zaG93QWRkRmlsZXNQYW5lbCxcbiAgICAndXBweS1EYXNoYm9hcmQtLWlzSW5uZXJXcmFwVmlzaWJsZSc6IHByb3BzLmFyZUluc2lkZXNSZWFkeVRvQmVWaXNpYmxlXG4gIH0pXG5cbiAgY29uc3Qgc2hvd0ZpbGVMaXN0ID0gcHJvcHMuc2hvd1NlbGVjdGVkRmlsZXMgJiYgIW5vRmlsZXNcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzPXtkYXNoYm9hcmRDbGFzc05hbWV9XG4gICAgICBhcmlhLWhpZGRlbj17cHJvcHMuaW5saW5lID8gJ2ZhbHNlJyA6IHByb3BzLmlzSGlkZGVufVxuICAgICAgYXJpYS1sYWJlbD17IXByb3BzLmlubGluZSA/IHByb3BzLmkxOG4oJ2Rhc2hib2FyZFdpbmRvd1RpdGxlJykgOiBwcm9wcy5pMThuKCdkYXNoYm9hcmRUaXRsZScpfVxuICAgICAgb25wYXN0ZT17cHJvcHMuaGFuZGxlUGFzdGV9XG5cbiAgICAgIG9uRHJhZ092ZXI9e3Byb3BzLmhhbmRsZURyYWdPdmVyfVxuICAgICAgb25EcmFnTGVhdmU9e3Byb3BzLmhhbmRsZURyYWdMZWF2ZX1cbiAgICAgIG9uRHJvcD17cHJvcHMuaGFuZGxlRHJvcH1cbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzPVwidXBweS1EYXNoYm9hcmQtb3ZlcmxheVwiIHRhYmluZGV4PXstMX0gb25jbGljaz17cHJvcHMuaGFuZGxlQ2xpY2tPdXRzaWRlfSAvPlxuXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwidXBweS1EYXNoYm9hcmQtaW5uZXJcIlxuICAgICAgICBhcmlhLW1vZGFsPXshcHJvcHMuaW5saW5lICYmICd0cnVlJ31cbiAgICAgICAgcm9sZT17IXByb3BzLmlubGluZSAmJiAnZGlhbG9nJ31cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICB3aWR0aDogcHJvcHMuaW5saW5lICYmIHByb3BzLndpZHRoID8gcHJvcHMud2lkdGggOiAnJyxcbiAgICAgICAgICBoZWlnaHQ6IHByb3BzLmlubGluZSAmJiBwcm9wcy5oZWlnaHQgPyBwcm9wcy5oZWlnaHQgOiAnJ1xuICAgICAgICB9fVxuICAgICAgPlxuXG4gICAgICAgIHshcHJvcHMuaW5saW5lID8gKFxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIGNsYXNzPVwidXBweS11LXJlc2V0IHVwcHktRGFzaGJvYXJkLWNsb3NlXCJcbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgYXJpYS1sYWJlbD17cHJvcHMuaTE4bignY2xvc2VNb2RhbCcpfVxuICAgICAgICAgICAgdGl0bGU9e3Byb3BzLmkxOG4oJ2Nsb3NlTW9kYWwnKX1cbiAgICAgICAgICAgIG9uY2xpY2s9e3Byb3BzLmNsb3NlTW9kYWx9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvc3Bhbj5cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKSA6IG51bGx9XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVwcHktRGFzaGJvYXJkLWlubmVyV3JhcFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LURhc2hib2FyZC1kcm9wRmlsZXNIZXJlSGludFwiPlxuICAgICAgICAgICAge3Byb3BzLmkxOG4oJ2Ryb3BIaW50Jyl9XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICB7c2hvd0ZpbGVMaXN0ICYmIDxQYW5lbFRvcEJhciB7Li4ucHJvcHN9IC8+fVxuXG4gICAgICAgICAge3Nob3dGaWxlTGlzdCA/IChcbiAgICAgICAgICAgIDxGaWxlTGlzdCB7Li4ucHJvcHN9IC8+XG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIDxBZGRGaWxlcyB7Li4ucHJvcHN9IC8+XG4gICAgICAgICAgKX1cblxuICAgICAgICAgIDxUcmFuc2l0aW9uV3JhcHBlcj5cbiAgICAgICAgICAgIHtwcm9wcy5zaG93QWRkRmlsZXNQYW5lbCA/IDxBZGRGaWxlc1BhbmVsIGtleT1cIkFkZEZpbGVzUGFuZWxcIiB7Li4ucHJvcHN9IC8+IDogbnVsbH1cbiAgICAgICAgICA8L1RyYW5zaXRpb25XcmFwcGVyPlxuXG4gICAgICAgICAgPFRyYW5zaXRpb25XcmFwcGVyPlxuICAgICAgICAgICAge3Byb3BzLmZpbGVDYXJkRm9yID8gPEZpbGVDYXJkIGtleT1cIkZpbGVDYXJkXCIgey4uLnByb3BzfSAvPiA6IG51bGx9XG4gICAgICAgICAgPC9UcmFuc2l0aW9uV3JhcHBlcj5cblxuICAgICAgICAgIDxUcmFuc2l0aW9uV3JhcHBlcj5cbiAgICAgICAgICAgIHtwcm9wcy5hY3RpdmVQaWNrZXJQYW5lbCA/IDxQaWNrZXJQYW5lbENvbnRlbnQga2V5PVwiUGlja2VyUGFuZWxDb250ZW50XCIgey4uLnByb3BzfSAvPiA6IG51bGx9XG4gICAgICAgICAgPC9UcmFuc2l0aW9uV3JhcHBlcj5cblxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LURhc2hib2FyZC1wcm9ncmVzc2luZGljYXRvcnNcIj5cbiAgICAgICAgICAgIHtwcm9wcy5wcm9ncmVzc2luZGljYXRvcnMubWFwKCh0YXJnZXQpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLmdldFBsdWdpbih0YXJnZXQuaWQpLnJlbmRlcihwcm9wcy5zdGF0ZSlcbiAgICAgICAgICAgIH0pfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGgsIENvbXBvbmVudCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IGdldEZpbGVUeXBlSWNvbiA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2dldEZpbGVUeXBlSWNvbicpXG5jb25zdCBpZ25vcmVFdmVudCA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lnbm9yZUV2ZW50LmpzJylcbmNvbnN0IEZpbGVQcmV2aWV3ID0gcmVxdWlyZSgnLi4vRmlsZVByZXZpZXcnKVxuXG5jbGFzcyBGaWxlQ2FyZCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuXG4gICAgY29uc3QgZmlsZSA9IHRoaXMucHJvcHMuZmlsZXNbdGhpcy5wcm9wcy5maWxlQ2FyZEZvcl1cbiAgICBjb25zdCBtZXRhRmllbGRzID0gdGhpcy5wcm9wcy5tZXRhRmllbGRzIHx8IFtdXG5cbiAgICBjb25zdCBzdG9yZWRNZXRhRGF0YSA9IHt9XG4gICAgbWV0YUZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgc3RvcmVkTWV0YURhdGFbZmllbGQuaWRdID0gZmlsZS5tZXRhW2ZpZWxkLmlkXSB8fCAnJ1xuICAgIH0pXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZm9ybVN0YXRlOiBzdG9yZWRNZXRhRGF0YVxuICAgIH1cbiAgfVxuXG4gIHNhdmVPbkVudGVyID0gKGV2KSA9PiB7XG4gICAgaWYgKGV2LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgZXYucHJldmVudERlZmF1bHQoKVxuICAgICAgY29uc3QgZmlsZSA9IHRoaXMucHJvcHMuZmlsZXNbdGhpcy5wcm9wcy5maWxlQ2FyZEZvcl1cbiAgICAgIHRoaXMucHJvcHMuc2F2ZUZpbGVDYXJkKHRoaXMuc3RhdGUuZm9ybVN0YXRlLCBmaWxlLmlkKVxuICAgIH1cbiAgfVxuXG4gIHRlbXBTdG9yZU1ldGEgPSAoZXYsIG5hbWUpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGZvcm1TdGF0ZToge1xuICAgICAgICAuLi50aGlzLnN0YXRlLmZvcm1TdGF0ZSxcbiAgICAgICAgW25hbWVdOiBldi50YXJnZXQudmFsdWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlU2F2ZSA9ICgpID0+IHtcbiAgICBjb25zdCBmaWxlSUQgPSB0aGlzLnByb3BzLmZpbGVDYXJkRm9yXG4gICAgdGhpcy5wcm9wcy5zYXZlRmlsZUNhcmQodGhpcy5zdGF0ZS5mb3JtU3RhdGUsIGZpbGVJRClcbiAgfVxuXG4gIGhhbmRsZUNhbmNlbCA9ICgpID0+IHtcbiAgICB0aGlzLnByb3BzLnRvZ2dsZUZpbGVDYXJkKClcbiAgfVxuXG4gIHJlbmRlck1ldGFGaWVsZHMgPSAoKSA9PiB7XG4gICAgY29uc3QgbWV0YUZpZWxkcyA9IHRoaXMucHJvcHMubWV0YUZpZWxkcyB8fCBbXVxuXG4gICAgcmV0dXJuIG1ldGFGaWVsZHMubWFwKChmaWVsZCkgPT4ge1xuICAgICAgY29uc3QgaWQgPSBgdXBweS1EYXNoYm9hcmQtRmlsZUNhcmQtaW5wdXQtJHtmaWVsZC5pZH1gXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8ZmllbGRzZXQga2V5PXtmaWVsZC5pZH0gY2xhc3M9XCJ1cHB5LURhc2hib2FyZC1GaWxlQ2FyZC1maWVsZHNldFwiPlxuICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLWxhYmVsXCIgZm9yPXtpZH0+e2ZpZWxkLm5hbWV9PC9sYWJlbD5cbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIGNsYXNzPVwidXBweS11LXJlc2V0IHVwcHktYy10ZXh0SW5wdXQgdXBweS1EYXNoYm9hcmQtRmlsZUNhcmQtaW5wdXRcIlxuICAgICAgICAgICAgaWQ9e2lkfVxuICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgdmFsdWU9e3RoaXMuc3RhdGUuZm9ybVN0YXRlW2ZpZWxkLmlkXX1cbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPXtmaWVsZC5wbGFjZWhvbGRlcn1cbiAgICAgICAgICAgIG9ua2V5dXA9e3RoaXMuc2F2ZU9uRW50ZXJ9XG4gICAgICAgICAgICBvbmtleWRvd249e3RoaXMuc2F2ZU9uRW50ZXJ9XG4gICAgICAgICAgICBvbmtleXByZXNzPXt0aGlzLnNhdmVPbkVudGVyfVxuICAgICAgICAgICAgb25pbnB1dD17ZXYgPT4gdGhpcy50ZW1wU3RvcmVNZXRhKGV2LCBmaWVsZC5pZCl9XG4gICAgICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICAgICAgLz5cbiAgICAgICAgPC9maWVsZHNldD5cbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICBjb25zdCBmaWxlID0gdGhpcy5wcm9wcy5maWxlc1t0aGlzLnByb3BzLmZpbGVDYXJkRm9yXVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJ1cHB5LURhc2hib2FyZC1GaWxlQ2FyZFwiXG4gICAgICAgIGRhdGEtdXBweS1wYW5lbFR5cGU9XCJGaWxlQ2FyZFwiXG4gICAgICAgIG9uRHJhZ092ZXI9e2lnbm9yZUV2ZW50fVxuICAgICAgICBvbkRyYWdMZWF2ZT17aWdub3JlRXZlbnR9XG4gICAgICAgIG9uRHJvcD17aWdub3JlRXZlbnR9XG4gICAgICAgIG9uUGFzdGU9e2lnbm9yZUV2ZW50fVxuICAgICAgPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtdGl0bGVcIiByb2xlPVwiaGVhZGluZ1wiIGFyaWEtbGV2ZWw9XCJoMVwiPlxuICAgICAgICAgICAge3RoaXMucHJvcHMuaTE4bkFycmF5KCdlZGl0aW5nJywge1xuICAgICAgICAgICAgICBmaWxlOiA8c3BhbiBjbGFzcz1cInVwcHktRGFzaGJvYXJkQ29udGVudC10aXRsZUZpbGVcIj57ZmlsZS5tZXRhID8gZmlsZS5tZXRhLm5hbWUgOiBmaWxlLm5hbWV9PC9zcGFuPlxuICAgICAgICAgICAgfSl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgY2xhc3M9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYmFja1wiIHR5cGU9XCJidXR0b25cIiB0aXRsZT17dGhpcy5wcm9wcy5pMThuKCdmaW5pc2hFZGl0aW5nRmlsZScpfVxuICAgICAgICAgICAgb25jbGljaz17dGhpcy5oYW5kbGVTYXZlfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHt0aGlzLnByb3BzLmkxOG4oJ2RvbmUnKX1cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLWlubmVyXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLXByZXZpZXdcIiBzdHlsZT17eyBiYWNrZ3JvdW5kQ29sb3I6IGdldEZpbGVUeXBlSWNvbihmaWxlLnR5cGUpLmNvbG9yIH19PlxuICAgICAgICAgICAgPEZpbGVQcmV2aWV3IGZpbGU9e2ZpbGV9IC8+XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwidXBweS1EYXNoYm9hcmQtRmlsZUNhcmQtaW5mb1wiPlxuICAgICAgICAgICAge3RoaXMucmVuZGVyTWV0YUZpZWxkcygpfVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPGRpdiBjbGFzcz1cInVwcHktRGFzaGJvYXJkLUZpbGVDYXJkLWFjdGlvbnNcIj5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgY2xhc3M9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LWMtYnRuLXByaW1hcnkgdXBweS1EYXNoYm9hcmQtRmlsZUNhcmQtYWN0aW9uc0J0blwiXG4gICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICBvbmNsaWNrPXt0aGlzLmhhbmRsZVNhdmV9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHt0aGlzLnByb3BzLmkxOG4oJ3NhdmVDaGFuZ2VzJyl9XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgY2xhc3M9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LWMtYnRuLWxpbmsgdXBweS1EYXNoYm9hcmQtRmlsZUNhcmQtYWN0aW9uc0J0blwiXG4gICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICBvbmNsaWNrPXt0aGlzLmhhbmRsZUNhbmNlbH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3RoaXMucHJvcHMuaTE4bignY2FuY2VsJyl9XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGaWxlQ2FyZFxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgY29weVRvQ2xpcGJvYXJkID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvY29weVRvQ2xpcGJvYXJkJylcblxuY29uc3QgeyBpY29uUGVuY2lsLCBpY29uQ3Jvc3MsIGljb25Db3B5TGluayB9ID0gcmVxdWlyZSgnLi4vLi4vaWNvbnMnKVxuXG5jb25zdCByZW5kZXJFZGl0QnV0dG9uID0gKHByb3BzKSA9PiAoXG4gICFwcm9wcy51cGxvYWRJblByb2dyZXNzT3JDb21wbGV0ZSAmJlxuICBwcm9wcy5tZXRhRmllbGRzICYmXG4gIHByb3BzLm1ldGFGaWVsZHMubGVuZ3RoID4gMCAmJlxuICAgIDxidXR0b25cbiAgICAgIGNsYXNzPVwidXBweS11LXJlc2V0IHVwcHktRGFzaGJvYXJkSXRlbS1hY3Rpb24gdXBweS1EYXNoYm9hcmRJdGVtLWFjdGlvbi0tZWRpdFwiXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmkxOG4oJ2VkaXRGaWxlJykgKyAnICcgKyBwcm9wcy5maWxlLm1ldGEubmFtZX1cbiAgICAgIHRpdGxlPXtwcm9wcy5pMThuKCdlZGl0RmlsZScpfVxuICAgICAgb25jbGljaz17KGUpID0+IHByb3BzLnRvZ2dsZUZpbGVDYXJkKHByb3BzLmZpbGUuaWQpfVxuICAgID5cbiAgICAgIHtpY29uUGVuY2lsKCl9XG4gICAgPC9idXR0b24+XG4pXG5cbmNvbnN0IHJlbmRlclJlbW92ZUJ1dHRvbiA9IChwcm9wcykgPT4gKFxuICBwcm9wcy5zaG93UmVtb3ZlQnV0dG9uICYmXG4gICAgPGJ1dHRvblxuICAgICAgY2xhc3M9XCJ1cHB5LXUtcmVzZXQgdXBweS1EYXNoYm9hcmRJdGVtLWFjdGlvbiB1cHB5LURhc2hib2FyZEl0ZW0tYWN0aW9uLS1yZW1vdmVcIlxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBhcmlhLWxhYmVsPXtwcm9wcy5pMThuKCdyZW1vdmVGaWxlJyl9XG4gICAgICB0aXRsZT17cHJvcHMuaTE4bigncmVtb3ZlRmlsZScpfVxuICAgICAgb25jbGljaz17KCkgPT4gcHJvcHMucmVtb3ZlRmlsZShwcm9wcy5maWxlLmlkKX1cbiAgICA+XG4gICAgICB7aWNvbkNyb3NzKCl9XG4gICAgPC9idXR0b24+XG4pXG5cbmNvbnN0IGNvcHlMaW5rVG9DbGlwYm9hcmQgPSAoZXZlbnQsIHByb3BzKSA9PlxuICBjb3B5VG9DbGlwYm9hcmQocHJvcHMuZmlsZS51cGxvYWRVUkwsIHByb3BzLmkxOG4oJ2NvcHlMaW5rVG9DbGlwYm9hcmRGYWxsYmFjaycpKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHByb3BzLmxvZygnTGluayBjb3BpZWQgdG8gY2xpcGJvYXJkLicpXG4gICAgICBwcm9wcy5pbmZvKHByb3BzLmkxOG4oJ2NvcHlMaW5rVG9DbGlwYm9hcmRTdWNjZXNzJyksICdpbmZvJywgMzAwMClcbiAgICB9KVxuICAgIC5jYXRjaChwcm9wcy5sb2cpXG4gICAgLy8gYXZvaWQgbG9zaW5nIGZvY3VzXG4gICAgLnRoZW4oKCkgPT4gZXZlbnQudGFyZ2V0LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KSlcblxuY29uc3QgcmVuZGVyQ29weUxpbmtCdXR0b24gPSAocHJvcHMpID0+IChcbiAgcHJvcHMuc2hvd0xpbmtUb0ZpbGVVcGxvYWRSZXN1bHQgJiZcbiAgcHJvcHMuZmlsZS51cGxvYWRVUkwgJiZcbiAgICA8YnV0dG9uXG4gICAgICBjbGFzcz1cInVwcHktdS1yZXNldCB1cHB5LURhc2hib2FyZEl0ZW0tYWN0aW9uIHVwcHktRGFzaGJvYXJkSXRlbS1hY3Rpb24tLWNvcHlMaW5rXCJcbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgYXJpYS1sYWJlbD17cHJvcHMuaTE4bignY29weUxpbmsnKX1cbiAgICAgIHRpdGxlPXtwcm9wcy5pMThuKCdjb3B5TGluaycpfVxuICAgICAgb25jbGljaz17KGV2ZW50KSA9PiBjb3B5TGlua1RvQ2xpcGJvYXJkKGV2ZW50LCBwcm9wcyl9XG4gICAgPlxuICAgICAge2ljb25Db3B5TGluaygpfVxuICAgIDwvYnV0dG9uPlxuKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEJ1dHRvbnMgKHByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ1cHB5LURhc2hib2FyZEl0ZW0tYWN0aW9uV3JhcHBlclwiPlxuICAgICAge3JlbmRlckVkaXRCdXR0b24ocHJvcHMpfVxuICAgICAge3JlbmRlckNvcHlMaW5rQnV0dG9uKHByb3BzKX1cbiAgICAgIHtyZW5kZXJSZW1vdmVCdXR0b24ocHJvcHMpfVxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBwcmV0dHlCeXRlcyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9wcmV0dHlCeXRlcycpXG5jb25zdCB0cnVuY2F0ZVN0cmluZyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWxzL3RydW5jYXRlU3RyaW5nJylcblxuY29uc3QgcmVuZGVyQWNxdWlyZXJJY29uID0gKGFjcXVpcmVyLCBwcm9wcykgPT5cbiAgPHNwYW4gdGl0bGU9e3Byb3BzLmkxOG4oJ2ZpbGVTb3VyY2UnLCB7IG5hbWU6IGFjcXVpcmVyLm5hbWUgfSl9PlxuICAgIHthY3F1aXJlci5pY29uKCl9XG4gIDwvc3Bhbj5cblxuY29uc3QgcmVuZGVyRmlsZVNvdXJjZSA9IChwcm9wcykgPT4gKFxuICBwcm9wcy5maWxlLnNvdXJjZSAmJlxuICBwcm9wcy5maWxlLnNvdXJjZSAhPT0gcHJvcHMuaWQgJiZcbiAgICA8ZGl2IGNsYXNzPVwidXBweS1EYXNoYm9hcmRJdGVtLXNvdXJjZUljb25cIj5cbiAgICAgIHtwcm9wcy5hY3F1aXJlcnMubWFwKGFjcXVpcmVyID0+IHtcbiAgICAgICAgaWYgKGFjcXVpcmVyLmlkID09PSBwcm9wcy5maWxlLnNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiByZW5kZXJBY3F1aXJlckljb24oYWNxdWlyZXIsIHByb3BzKVxuICAgICAgICB9XG4gICAgICB9KX1cbiAgICA8L2Rpdj5cbilcblxuY29uc3QgcmVuZGVyRmlsZU5hbWUgPSAocHJvcHMpID0+IHtcbiAgLy8gVGFrZSB1cCBhdCBtb3N0IDIgbGluZXMgb24gYW55IHNjcmVlblxuICBsZXQgbWF4TmFtZUxlbmd0aFxuICAvLyBGb3IgdmVyeSBzbWFsbCBtb2JpbGUgc2NyZWVuc1xuICBpZiAocHJvcHMuY29udGFpbmVyV2lkdGggPD0gMzUyKSB7XG4gICAgbWF4TmFtZUxlbmd0aCA9IDM1XG4gIC8vIEZvciByZWd1bGFyIG1vYmlsZSBzY3JlZW5zXG4gIH0gZWxzZSBpZiAocHJvcHMuY29udGFpbmVyV2lkdGggPD0gNTc2KSB7XG4gICAgbWF4TmFtZUxlbmd0aCA9IDYwXG4gIC8vIEZvciBkZXNrdG9wc1xuICB9IGVsc2Uge1xuICAgIG1heE5hbWVMZW5ndGggPSAzMFxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzPVwidXBweS1EYXNoYm9hcmRJdGVtLW5hbWVcIiB0aXRsZT17cHJvcHMuZmlsZS5tZXRhLm5hbWV9PlxuICAgICAge3RydW5jYXRlU3RyaW5nKHByb3BzLmZpbGUubWV0YS5uYW1lLCBtYXhOYW1lTGVuZ3RoKX1cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5jb25zdCByZW5kZXJGaWxlU2l6ZSA9IChwcm9wcykgPT4gKFxuICBwcm9wcy5maWxlLmRhdGEuc2l6ZSAmJlxuICAgIDxkaXYgY2xhc3M9XCJ1cHB5LURhc2hib2FyZEl0ZW0tc3RhdHVzU2l6ZVwiPlxuICAgICAge3ByZXR0eUJ5dGVzKHByb3BzLmZpbGUuZGF0YS5zaXplKX1cbiAgICA8L2Rpdj5cbilcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBGaWxlSW5mbyAocHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzPVwidXBweS1EYXNoYm9hcmRJdGVtLWZpbGVJbmZvXCIgZGF0YS11cHB5LWZpbGUtc291cmNlPXtwcm9wcy5maWxlLnNvdXJjZX0+XG4gICAgICB7cmVuZGVyRmlsZU5hbWUocHJvcHMpfVxuICAgICAgPGRpdiBjbGFzcz1cInVwcHktRGFzaGJvYXJkSXRlbS1zdGF0dXNcIj5cbiAgICAgICAge3JlbmRlckZpbGVTaXplKHByb3BzKX1cbiAgICAgICAge3JlbmRlckZpbGVTb3VyY2UocHJvcHMpfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IEZpbGVQcmV2aWV3ID0gcmVxdWlyZSgnLi4vLi4vRmlsZVByZXZpZXcnKVxuY29uc3QgZ2V0RmlsZVR5cGVJY29uID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMvZ2V0RmlsZVR5cGVJY29uJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBGaWxlUHJldmlld0FuZExpbmsgKHByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY2xhc3M9XCJ1cHB5LURhc2hib2FyZEl0ZW0tcHJldmlld0lubmVyV3JhcFwiXG4gICAgICBzdHlsZT17eyBiYWNrZ3JvdW5kQ29sb3I6IGdldEZpbGVUeXBlSWNvbihwcm9wcy5maWxlLnR5cGUpLmNvbG9yIH19XG4gICAgPlxuICAgICAge1xuICAgICAgICBwcm9wcy5zaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdCAmJlxuICAgICAgICBwcm9wcy5maWxlLnVwbG9hZFVSTCAmJlxuICAgICAgICAgIDxhXG4gICAgICAgICAgICBjbGFzcz1cInVwcHktRGFzaGJvYXJkSXRlbS1wcmV2aWV3TGlua1wiXG4gICAgICAgICAgICBocmVmPXtwcm9wcy5maWxlLnVwbG9hZFVSTH1cbiAgICAgICAgICAgIHJlbD1cIm5vcmVmZXJyZXIgbm9vcGVuZXJcIlxuICAgICAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmZpbGUubWV0YS5uYW1lfVxuICAgICAgICAgIC8+XG4gICAgICB9XG4gICAgICA8RmlsZVByZXZpZXcgZmlsZT17cHJvcHMuZmlsZX0gLz5cbiAgICA8L2Rpdj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG4vLyBodHRwOi8vY29kZXBlbi5pby9IYXJra28vcGVuL3JWeHZOTVxuLy8gaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9zdmctbGluZS1hbmltYXRpb24td29ya3MvXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9lc3dhay9hZDRlYTU3YmNkNWZmN2FhNWQ0MlxuXG4vLyBjaXJjbGUgbGVuZ3RoIGVxdWFscyAyICogUEkgKiBSXG5jb25zdCBjaXJjbGVMZW5ndGggPSAyICogTWF0aC5QSSAqIDE1XG5cbi8vIHN0cm9rZS1kYXNob2Zmc2V0IGlzIGEgcGVyY2VudGFnZSBvZiB0aGUgcHJvZ3Jlc3MgZnJvbSBjaXJjbGVMZW5ndGgsXG4vLyBzdWJzdHJhY3RlZCBmcm9tIGNpcmNsZUxlbmd0aCwgYmVjYXVzZSBpdHMgYW4gb2Zmc2V0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFBhdXNlUmVzdW1lQ2FuY2VsSWNvbiAocHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCI3MFwiIGhlaWdodD1cIjcwXCIgdmlld0JveD1cIjAgMCAzNiAzNlwiIGNsYXNzPVwiVXBweUljb24gVXBweUljb24tcHJvZ3Jlc3NDaXJjbGVcIj5cbiAgICAgIDxnIGNsYXNzPVwicHJvZ3Jlc3MtZ3JvdXBcIj5cbiAgICAgICAgPGNpcmNsZSBjbGFzcz1cImJnXCIgcj1cIjE1XCIgY3g9XCIxOFwiIGN5PVwiMThcIiBzdHJva2Utd2lkdGg9XCIyXCIgZmlsbD1cIm5vbmVcIiAvPlxuICAgICAgICA8Y2lyY2xlXG4gICAgICAgICAgY2xhc3M9XCJwcm9ncmVzc1wiIHI9XCIxNVwiIGN4PVwiMThcIiBjeT1cIjE4XCIgdHJhbnNmb3JtPVwicm90YXRlKC05MCwgMTgsIDE4KVwiIHN0cm9rZS13aWR0aD1cIjJcIiBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgc3Ryb2tlLWRhc2hhcnJheT17Y2lyY2xlTGVuZ3RofVxuICAgICAgICAgIHN0cm9rZS1kYXNob2Zmc2V0PXtjaXJjbGVMZW5ndGggLSAoY2lyY2xlTGVuZ3RoIC8gMTAwICogcHJvcHMucHJvZ3Jlc3MpfVxuICAgICAgICAvPlxuICAgICAgPC9nPlxuICAgICAge1xuICAgICAgICAhcHJvcHMuaGlkZVBhdXNlUmVzdW1lQ2FuY2VsQnV0dG9ucyAmJlxuICAgICAgICAgIDxnPlxuICAgICAgICAgICAgPHBvbHlnb24gY2xhc3M9XCJwbGF5XCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDMsIDMpXCIgcG9pbnRzPVwiMTIgMjAgMTIgMTAgMjAgMTVcIiAvPlxuICAgICAgICAgICAgPGcgY2xhc3M9XCJwYXVzZVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxNC41LCAxMylcIj5cbiAgICAgICAgICAgICAgPHJlY3QgeD1cIjBcIiB5PVwiMFwiIHdpZHRoPVwiMlwiIGhlaWdodD1cIjEwXCIgcng9XCIwXCIgLz5cbiAgICAgICAgICAgICAgPHJlY3QgeD1cIjVcIiB5PVwiMFwiIHdpZHRoPVwiMlwiIGhlaWdodD1cIjEwXCIgcng9XCIwXCIgLz5cbiAgICAgICAgICAgIDwvZz5cbiAgICAgICAgICAgIDxwb2x5Z29uIGNsYXNzPVwiY2FuY2VsXCIgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDIsIDIpXCIgcG9pbnRzPVwiMTkuODg1NjUxNiAxMS4wNjI1IDE2IDE0Ljk0ODE1MTYgMTIuMTAxOTczNyAxMS4wNjI1IDExLjA2MjUgMTIuMTE0MzQ4NCAxNC45NDgxNTE2IDE2IDExLjA2MjUgMTkuODk4MDI2MyAxMi4xMDE5NzM3IDIwLjkzNzUgMTYgMTcuMDUxODQ4NCAxOS44ODU2NTE2IDIwLjkzNzUgMjAuOTM3NSAxOS44OTgwMjYzIDE3LjA1MTg0ODQgMTYgMjAuOTM3NSAxMlwiIC8+XG4gICAgICAgICAgPC9nPlxuICAgICAgfVxuICAgICAgPHBvbHlnb24gY2xhc3M9XCJjaGVja1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgyLCAzKVwiIHBvaW50cz1cIjE0IDIyLjUgNyAxNS4yNDU3MDY1IDguOTk5ODU4NTcgMTMuMTczMjgxNSAxNCAxOC4zNTQ3MTA0IDIyLjk3Mjk4ODMgOSAyNSAxMS4xMDA1NjM0XCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgeyBpY29uUmV0cnkgfSA9IHJlcXVpcmUoJy4uLy4uL2ljb25zJylcbmNvbnN0IFBhdXNlUmVzdW1lQ2FuY2VsSWNvbiA9IHJlcXVpcmUoJy4vUGF1c2VSZXN1bWVDYW5jZWxJY29uJylcblxuZnVuY3Rpb24gb25QYXVzZVJlc3VtZUNhbmNlbFJldHJ5IChwcm9wcykge1xuICBpZiAocHJvcHMuaXNVcGxvYWRlZCkgcmV0dXJuXG5cbiAgaWYgKHByb3BzLmVycm9yICYmICFwcm9wcy5oaWRlUmV0cnlCdXR0b24pIHtcbiAgICBwcm9wcy5yZXRyeVVwbG9hZChwcm9wcy5maWxlLmlkKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHByb3BzLmhpZGVQYXVzZVJlc3VtZUNhbmNlbEJ1dHRvbnMpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChwcm9wcy5yZXN1bWFibGVVcGxvYWRzKSB7XG4gICAgcHJvcHMucGF1c2VVcGxvYWQocHJvcHMuZmlsZS5pZClcbiAgfSBlbHNlIGlmIChwcm9wcy5pbmRpdmlkdWFsQ2FuY2VsbGF0aW9uKSB7XG4gICAgcHJvcHMuY2FuY2VsVXBsb2FkKHByb3BzLmZpbGUuaWQpXG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvZ3Jlc3NJbmRpY2F0b3JUaXRsZSAocHJvcHMpIHtcbiAgaWYgKHByb3BzLmlzVXBsb2FkZWQpIHtcbiAgICByZXR1cm4gcHJvcHMuaTE4bigndXBsb2FkQ29tcGxldGUnKVxuICB9XG5cbiAgaWYgKHByb3BzLmVycm9yKSB7XG4gICAgcmV0dXJuIHByb3BzLmkxOG4oJ3JldHJ5VXBsb2FkJylcbiAgfVxuXG4gIGlmIChwcm9wcy5yZXN1bWFibGVVcGxvYWRzKSB7XG4gICAgaWYgKHByb3BzLmZpbGUuaXNQYXVzZWQpIHtcbiAgICAgIHJldHVybiBwcm9wcy5pMThuKCdyZXN1bWVVcGxvYWQnKVxuICAgIH1cbiAgICByZXR1cm4gcHJvcHMuaTE4bigncGF1c2VVcGxvYWQnKVxuICB9IGVsc2UgaWYgKHByb3BzLmluZGl2aWR1YWxDYW5jZWxsYXRpb24pIHtcbiAgICByZXR1cm4gcHJvcHMuaTE4bignY2FuY2VsVXBsb2FkJylcbiAgfVxuXG4gIHJldHVybiAnJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEZpbGVQcm9ncmVzcyAocHJvcHMpIHtcbiAgaWYgKHByb3BzLmhpZGVSZXRyeUJ1dHRvbiAmJiBwcm9wcy5lcnJvcikge1xuICAgIHJldHVybiA8ZGl2IGNsYXNzPVwidXBweS1EYXNoYm9hcmRJdGVtLXByb2dyZXNzXCIgLz5cbiAgfSBlbHNlIGlmIChcbiAgICBwcm9wcy5pc1VwbG9hZGVkIHx8XG4gICAgKHByb3BzLmhpZGVQYXVzZVJlc3VtZUNhbmNlbEJ1dHRvbnMgJiYgIXByb3BzLmVycm9yKVxuICApIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzcz1cInVwcHktRGFzaGJvYXJkSXRlbS1wcm9ncmVzc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidXBweS1EYXNoYm9hcmRJdGVtLXByb2dyZXNzSW5kaWNhdG9yXCI+XG4gICAgICAgICAgPFBhdXNlUmVzdW1lQ2FuY2VsSWNvblxuICAgICAgICAgICAgcHJvZ3Jlc3M9e3Byb3BzLmZpbGUucHJvZ3Jlc3MucGVyY2VudGFnZX1cbiAgICAgICAgICAgIGhpZGVQYXVzZVJlc3VtZUNhbmNlbEJ1dHRvbnM9e3Byb3BzLmhpZGVQYXVzZVJlc3VtZUNhbmNlbEJ1dHRvbnN9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LURhc2hib2FyZEl0ZW0tcHJvZ3Jlc3NcIj5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGNsYXNzPVwidXBweS11LXJlc2V0IHVwcHktRGFzaGJvYXJkSXRlbS1wcm9ncmVzc0luZGljYXRvclwiXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgYXJpYS1sYWJlbD17cHJvZ3Jlc3NJbmRpY2F0b3JUaXRsZShwcm9wcyl9XG4gICAgICAgICAgdGl0bGU9e3Byb2dyZXNzSW5kaWNhdG9yVGl0bGUocHJvcHMpfVxuICAgICAgICAgIG9uY2xpY2s9eygpID0+IG9uUGF1c2VSZXN1bWVDYW5jZWxSZXRyeShwcm9wcyl9XG4gICAgICAgID5cbiAgICAgICAgICB7cHJvcHMuZXJyb3IgPyAoXG4gICAgICAgICAgICBwcm9wcy5oaWRlUmV0cnlCdXR0b24gPyBudWxsIDogaWNvblJldHJ5KClcbiAgICAgICAgICApIDogKFxuICAgICAgICAgICAgPFBhdXNlUmVzdW1lQ2FuY2VsSWNvblxuICAgICAgICAgICAgICBwcm9ncmVzcz17cHJvcHMuZmlsZS5wcm9ncmVzcy5wZXJjZW50YWdlfVxuICAgICAgICAgICAgICBoaWRlUGF1c2VSZXN1bWVDYW5jZWxCdXR0b25zPXtwcm9wcy5oaWRlUGF1c2VSZXN1bWVDYW5jZWxCdXR0b25zfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApfVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuIiwiY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpXG5jb25zdCBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdpcy1zaGFsbG93LWVxdWFsJylcbmNvbnN0IEZpbGVQcmV2aWV3QW5kTGluayA9IHJlcXVpcmUoJy4vRmlsZVByZXZpZXdBbmRMaW5rJylcbmNvbnN0IEZpbGVQcm9ncmVzcyA9IHJlcXVpcmUoJy4vRmlsZVByb2dyZXNzJylcbmNvbnN0IEZpbGVJbmZvID0gcmVxdWlyZSgnLi9GaWxlSW5mbycpXG5jb25zdCBCdXR0b25zID0gcmVxdWlyZSgnLi9CdXR0b25zJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBGaWxlSXRlbSBleHRlbmRzIENvbXBvbmVudCB7XG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZSAobmV4dFByb3BzKSB7XG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwodGhpcy5wcm9wcywgbmV4dFByb3BzKVxuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICBjb25zdCBmaWxlID0gdGhpcy5wcm9wcy5maWxlXG5cbiAgICBjb25zdCBpc1Byb2Nlc3NpbmcgPSBmaWxlLnByb2dyZXNzLnByZXByb2Nlc3MgfHwgZmlsZS5wcm9ncmVzcy5wb3N0cHJvY2Vzc1xuICAgIGNvbnN0IGlzVXBsb2FkZWQgPSBmaWxlLnByb2dyZXNzLnVwbG9hZENvbXBsZXRlICYmICFpc1Byb2Nlc3NpbmcgJiYgIWZpbGUuZXJyb3JcbiAgICBjb25zdCB1cGxvYWRJblByb2dyZXNzT3JDb21wbGV0ZSA9IGZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZCB8fCBpc1Byb2Nlc3NpbmdcbiAgICBjb25zdCB1cGxvYWRJblByb2dyZXNzID0gKGZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZCAmJiAhZmlsZS5wcm9ncmVzcy51cGxvYWRDb21wbGV0ZSkgfHwgaXNQcm9jZXNzaW5nXG4gICAgY29uc3QgaXNQYXVzZWQgPSBmaWxlLmlzUGF1c2VkIHx8IGZhbHNlXG4gICAgY29uc3QgZXJyb3IgPSBmaWxlLmVycm9yIHx8IGZhbHNlXG5cbiAgICBjb25zdCBzaG93UmVtb3ZlQnV0dG9uID0gdGhpcy5wcm9wcy5pbmRpdmlkdWFsQ2FuY2VsbGF0aW9uXG4gICAgICA/ICFpc1VwbG9hZGVkXG4gICAgICA6ICF1cGxvYWRJblByb2dyZXNzICYmICFpc1VwbG9hZGVkXG5cbiAgICBjb25zdCBkYXNoYm9hcmRJdGVtQ2xhc3MgPSBjbGFzc05hbWVzKHtcbiAgICAgICd1cHB5LXUtcmVzZXQnOiB0cnVlLFxuICAgICAgJ3VwcHktRGFzaGJvYXJkSXRlbSc6IHRydWUsXG4gICAgICAnaXMtaW5wcm9ncmVzcyc6IHVwbG9hZEluUHJvZ3Jlc3MsXG4gICAgICAnaXMtcHJvY2Vzc2luZyc6IGlzUHJvY2Vzc2luZyxcbiAgICAgICdpcy1jb21wbGV0ZSc6IGlzVXBsb2FkZWQsXG4gICAgICAnaXMtcGF1c2VkJzogaXNQYXVzZWQsXG4gICAgICAnaXMtZXJyb3InOiAhIWVycm9yLFxuICAgICAgJ2lzLXJlc3VtYWJsZSc6IHRoaXMucHJvcHMucmVzdW1hYmxlVXBsb2FkcyxcbiAgICAgICdpcy1ub0luZGl2aWR1YWxDYW5jZWxsYXRpb24nOiAhdGhpcy5wcm9wcy5pbmRpdmlkdWFsQ2FuY2VsbGF0aW9uXG4gICAgfSlcblxuICAgIHJldHVybiAoXG4gICAgICA8bGkgY2xhc3M9e2Rhc2hib2FyZEl0ZW1DbGFzc30gaWQ9e2B1cHB5XyR7ZmlsZS5pZH1gfT5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVwcHktRGFzaGJvYXJkSXRlbS1wcmV2aWV3XCI+XG4gICAgICAgICAgPEZpbGVQcmV2aWV3QW5kTGlua1xuICAgICAgICAgICAgZmlsZT17ZmlsZX1cbiAgICAgICAgICAgIHNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0PXt0aGlzLnByb3BzLnNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0fVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPEZpbGVQcm9ncmVzc1xuICAgICAgICAgICAgey4uLnRoaXMucHJvcHN9XG4gICAgICAgICAgICBmaWxlPXtmaWxlfVxuICAgICAgICAgICAgZXJyb3I9e2Vycm9yfVxuICAgICAgICAgICAgaXNVcGxvYWRlZD17aXNVcGxvYWRlZH1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwidXBweS1EYXNoYm9hcmRJdGVtLWZpbGVJbmZvQW5kQnV0dG9uc1wiPlxuICAgICAgICAgIDxGaWxlSW5mb1xuICAgICAgICAgICAgZmlsZT17ZmlsZX1cbiAgICAgICAgICAgIGlkPXt0aGlzLnByb3BzLmlkfVxuICAgICAgICAgICAgYWNxdWlyZXJzPXt0aGlzLnByb3BzLmFjcXVpcmVyc31cbiAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoPXt0aGlzLnByb3BzLmNvbnRhaW5lcldpZHRofVxuICAgICAgICAgICAgaTE4bj17dGhpcy5wcm9wcy5pMThufVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPEJ1dHRvbnNcbiAgICAgICAgICAgIGZpbGU9e2ZpbGV9XG4gICAgICAgICAgICBtZXRhRmllbGRzPXt0aGlzLnByb3BzLm1ldGFGaWVsZHN9XG5cbiAgICAgICAgICAgIHNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0PXt0aGlzLnByb3BzLnNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0fVxuICAgICAgICAgICAgc2hvd1JlbW92ZUJ1dHRvbj17c2hvd1JlbW92ZUJ1dHRvbn1cblxuICAgICAgICAgICAgdXBsb2FkSW5Qcm9ncmVzc09yQ29tcGxldGU9e3VwbG9hZEluUHJvZ3Jlc3NPckNvbXBsZXRlfVxuICAgICAgICAgICAgcmVtb3ZlRmlsZT17dGhpcy5wcm9wcy5yZW1vdmVGaWxlfVxuICAgICAgICAgICAgdG9nZ2xlRmlsZUNhcmQ9e3RoaXMucHJvcHMudG9nZ2xlRmlsZUNhcmR9XG5cbiAgICAgICAgICAgIGkxOG49e3RoaXMucHJvcHMuaTE4bn1cbiAgICAgICAgICAgIGxvZz17dGhpcy5wcm9wcy5sb2d9XG4gICAgICAgICAgICBpbmZvPXt0aGlzLnByb3BzLmluZm99XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2xpPlxuICAgIClcbiAgfVxufVxuIiwiY29uc3QgRmlsZUl0ZW0gPSByZXF1aXJlKCcuL0ZpbGVJdGVtL2luZGV4LmpzJylcbmNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgZGFzaGJvYXJkRmlsZXNDbGFzcyA9IGNsYXNzTmFtZXMoe1xuICAgICd1cHB5LURhc2hib2FyZC1maWxlcyc6IHRydWUsXG4gICAgJ3VwcHktRGFzaGJvYXJkLWZpbGVzLS1ub0ZpbGVzJzogcHJvcHMudG90YWxGaWxlQ291bnQgPT09IDBcbiAgfSlcblxuICBjb25zdCBmaWxlUHJvcHMgPSB7XG4gICAgLy8gRklYTUUgVGhpcyBpcyBjb25mdXNpbmcsIGl0J3MgYWN0dWFsbHkgdGhlIERhc2hib2FyZCdzIHBsdWdpbiBJRFxuICAgIGlkOiBwcm9wcy5pZCxcbiAgICBlcnJvcjogcHJvcHMuZXJyb3IsXG4gICAgLy8gVE9ETyBtb3ZlIHRoaXMgdG8gY29udGV4dFxuICAgIGkxOG46IHByb3BzLmkxOG4sXG4gICAgbG9nOiBwcm9wcy5sb2csXG4gICAgaW5mbzogcHJvcHMuaW5mbyxcbiAgICAvLyBmZWF0dXJlc1xuICAgIGFjcXVpcmVyczogcHJvcHMuYWNxdWlyZXJzLFxuICAgIHJlc3VtYWJsZVVwbG9hZHM6IHByb3BzLnJlc3VtYWJsZVVwbG9hZHMsXG4gICAgaW5kaXZpZHVhbENhbmNlbGxhdGlvbjogcHJvcHMuaW5kaXZpZHVhbENhbmNlbGxhdGlvbixcbiAgICAvLyB2aXN1YWwgb3B0aW9uc1xuICAgIGhpZGVSZXRyeUJ1dHRvbjogcHJvcHMuaGlkZVJldHJ5QnV0dG9uLFxuICAgIGhpZGVQYXVzZVJlc3VtZUNhbmNlbEJ1dHRvbnM6IHByb3BzLmhpZGVQYXVzZVJlc3VtZUNhbmNlbEJ1dHRvbnMsXG4gICAgc2hvd0xpbmtUb0ZpbGVVcGxvYWRSZXN1bHQ6IHByb3BzLnNob3dMaW5rVG9GaWxlVXBsb2FkUmVzdWx0LFxuICAgIGlzV2lkZTogcHJvcHMuaXNXaWRlLFxuICAgIG1ldGFGaWVsZHM6IHByb3BzLm1ldGFGaWVsZHMsXG4gICAgLy8gY2FsbGJhY2tzXG4gICAgcmV0cnlVcGxvYWQ6IHByb3BzLnJldHJ5VXBsb2FkLFxuICAgIHBhdXNlVXBsb2FkOiBwcm9wcy5wYXVzZVVwbG9hZCxcbiAgICBjYW5jZWxVcGxvYWQ6IHByb3BzLmNhbmNlbFVwbG9hZCxcbiAgICB0b2dnbGVGaWxlQ2FyZDogcHJvcHMudG9nZ2xlRmlsZUNhcmQsXG4gICAgcmVtb3ZlRmlsZTogcHJvcHMucmVtb3ZlRmlsZSxcbiAgICBoYW5kbGVSZXF1ZXN0VGh1bWJuYWlsOiBwcm9wcy5oYW5kbGVSZXF1ZXN0VGh1bWJuYWlsXG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJJdGVtIChmaWxlSUQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPEZpbGVJdGVtXG4gICAgICAgIGtleT17ZmlsZUlEfVxuICAgICAgICB7Li4uZmlsZVByb3BzfVxuICAgICAgICBmaWxlPXtwcm9wcy5maWxlc1tmaWxlSURdfVxuICAgICAgLz5cbiAgICApXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDx1bCBjbGFzcz17ZGFzaGJvYXJkRmlsZXNDbGFzc30+XG4gICAgICB7T2JqZWN0LmtleXMocHJvcHMuZmlsZXMpLm1hcChyZW5kZXJJdGVtKX1cbiAgICA8L3VsPlxuICApXG59XG4iLCJjb25zdCBnZXRGaWxlVHlwZUljb24gPSByZXF1aXJlKCcuLi91dGlscy9nZXRGaWxlVHlwZUljb24nKVxuY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEZpbGVQcmV2aWV3IChwcm9wcykge1xuICBjb25zdCBmaWxlID0gcHJvcHMuZmlsZVxuXG4gIGlmIChmaWxlLnByZXZpZXcpIHtcbiAgICByZXR1cm4gPGltZyBjbGFzcz1cInVwcHktRGFzaGJvYXJkSXRlbS1wcmV2aWV3SW1nXCIgYWx0PXtmaWxlLm5hbWV9IHNyYz17ZmlsZS5wcmV2aWV3fSAvPlxuICB9XG5cbiAgY29uc3QgeyBjb2xvciwgaWNvbiB9ID0gZ2V0RmlsZVR5cGVJY29uKGZpbGUudHlwZSlcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3M9XCJ1cHB5LURhc2hib2FyZEl0ZW0tcHJldmlld0ljb25XcmFwXCI+XG4gICAgICA8c3BhbiBjbGFzcz1cInVwcHktRGFzaGJvYXJkSXRlbS1wcmV2aWV3SWNvblwiIHN0eWxlPXt7IGNvbG9yOiBjb2xvciB9fT57aWNvbn08L3NwYW4+XG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3M9XCJ1cHB5LURhc2hib2FyZEl0ZW0tcHJldmlld0ljb25CZ1wiIHdpZHRoPVwiNThcIiBoZWlnaHQ9XCI3NlwiIHZpZXdCb3g9XCIwIDAgNTggNzZcIj48cmVjdCBmaWxsPVwiI0ZGRlwiIHdpZHRoPVwiNThcIiBoZWlnaHQ9XCI3NlwiIHJ4PVwiM1wiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiAvPjwvc3ZnPlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBpZ25vcmVFdmVudCA9IHJlcXVpcmUoJy4uL3V0aWxzL2lnbm9yZUV2ZW50LmpzJylcblxuZnVuY3Rpb24gUGlja2VyUGFuZWxDb250ZW50IChwcm9wcykge1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzPVwidXBweS1EYXNoYm9hcmRDb250ZW50LXBhbmVsXCJcbiAgICAgIHJvbGU9XCJ0YWJwYW5lbFwiXG4gICAgICBkYXRhLXVwcHktcGFuZWxUeXBlPVwiUGlja2VyUGFuZWxcIlxuICAgICAgaWQ9e2B1cHB5LURhc2hib2FyZENvbnRlbnQtcGFuZWwtLSR7cHJvcHMuYWN0aXZlUGlja2VyUGFuZWwuaWR9YH1cbiAgICAgIG9uRHJhZ092ZXI9e2lnbm9yZUV2ZW50fVxuICAgICAgb25EcmFnTGVhdmU9e2lnbm9yZUV2ZW50fVxuICAgICAgb25Ecm9wPXtpZ25vcmVFdmVudH1cbiAgICAgIG9uUGFzdGU9e2lnbm9yZUV2ZW50fVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYmFyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtdGl0bGVcIiByb2xlPVwiaGVhZGluZ1wiIGFyaWEtbGV2ZWw9XCJoMVwiPlxuICAgICAgICAgIHtwcm9wcy5pMThuKCdpbXBvcnRGcm9tJywgeyBuYW1lOiBwcm9wcy5hY3RpdmVQaWNrZXJQYW5lbC5uYW1lIH0pfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGNsYXNzPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhY2tcIlxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIG9uY2xpY2s9e3Byb3BzLmhpZGVBbGxQYW5lbHN9XG4gICAgICAgID57cHJvcHMuaTE4bignZG9uZScpfVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInVwcHktRGFzaGJvYXJkQ29udGVudC1wYW5lbEJvZHlcIj5cbiAgICAgICAge3Byb3BzLmdldFBsdWdpbihwcm9wcy5hY3RpdmVQaWNrZXJQYW5lbC5pZCkucmVuZGVyKHByb3BzLnN0YXRlKX1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGlja2VyUGFuZWxDb250ZW50XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCB7IGljb25QbHVzIH0gPSByZXF1aXJlKCcuL2ljb25zJylcblxuY29uc3QgdXBsb2FkU3RhdGVzID0ge1xuICBTVEFURV9FUlJPUjogJ2Vycm9yJyxcbiAgU1RBVEVfV0FJVElORzogJ3dhaXRpbmcnLFxuICBTVEFURV9QUkVQUk9DRVNTSU5HOiAncHJlcHJvY2Vzc2luZycsXG4gIFNUQVRFX1VQTE9BRElORzogJ3VwbG9hZGluZycsXG4gIFNUQVRFX1BPU1RQUk9DRVNTSU5HOiAncG9zdHByb2Nlc3NpbmcnLFxuICBTVEFURV9DT01QTEVURTogJ2NvbXBsZXRlJyxcbiAgU1RBVEVfUEFVU0VEOiAncGF1c2VkJ1xufVxuXG5mdW5jdGlvbiBnZXRVcGxvYWRpbmdTdGF0ZSAoaXNBbGxFcnJvcmVkLCBpc0FsbENvbXBsZXRlLCBpc0FsbFBhdXNlZCwgZmlsZXMgPSB7fSkge1xuICBpZiAoaXNBbGxFcnJvcmVkKSB7XG4gICAgcmV0dXJuIHVwbG9hZFN0YXRlcy5TVEFURV9FUlJPUlxuICB9XG5cbiAgaWYgKGlzQWxsQ29tcGxldGUpIHtcbiAgICByZXR1cm4gdXBsb2FkU3RhdGVzLlNUQVRFX0NPTVBMRVRFXG4gIH1cblxuICBpZiAoaXNBbGxQYXVzZWQpIHtcbiAgICByZXR1cm4gdXBsb2FkU3RhdGVzLlNUQVRFX1BBVVNFRFxuICB9XG5cbiAgbGV0IHN0YXRlID0gdXBsb2FkU3RhdGVzLlNUQVRFX1dBSVRJTkdcbiAgY29uc3QgZmlsZUlEcyA9IE9iamVjdC5rZXlzKGZpbGVzKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVJRHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcm9ncmVzcyA9IGZpbGVzW2ZpbGVJRHNbaV1dLnByb2dyZXNzXG4gICAgLy8gSWYgQU5ZIGZpbGVzIGFyZSBiZWluZyB1cGxvYWRlZCByaWdodCBub3csIHNob3cgdGhlIHVwbG9hZGluZyBzdGF0ZS5cbiAgICBpZiAocHJvZ3Jlc3MudXBsb2FkU3RhcnRlZCAmJiAhcHJvZ3Jlc3MudXBsb2FkQ29tcGxldGUpIHtcbiAgICAgIHJldHVybiB1cGxvYWRTdGF0ZXMuU1RBVEVfVVBMT0FESU5HXG4gICAgfVxuICAgIC8vIElmIGZpbGVzIGFyZSBiZWluZyBwcmVwcm9jZXNzZWQgQU5EIHBvc3Rwcm9jZXNzZWQgYXQgdGhpcyB0aW1lLCB3ZSBzaG93IHRoZVxuICAgIC8vIHByZXByb2Nlc3Mgc3RhdGUuIElmIGFueSBmaWxlcyBhcmUgYmVpbmcgdXBsb2FkZWQgd2Ugc2hvdyB1cGxvYWRpbmcuXG4gICAgaWYgKHByb2dyZXNzLnByZXByb2Nlc3MgJiYgc3RhdGUgIT09IHVwbG9hZFN0YXRlcy5TVEFURV9VUExPQURJTkcpIHtcbiAgICAgIHN0YXRlID0gdXBsb2FkU3RhdGVzLlNUQVRFX1BSRVBST0NFU1NJTkdcbiAgICB9XG4gICAgLy8gSWYgTk8gZmlsZXMgYXJlIGJlaW5nIHByZXByb2Nlc3NlZCBvciB1cGxvYWRlZCByaWdodCBub3csIGJ1dCBzb21lIGZpbGVzIGFyZVxuICAgIC8vIGJlaW5nIHBvc3Rwcm9jZXNzZWQsIHNob3cgdGhlIHBvc3Rwcm9jZXNzIHN0YXRlLlxuICAgIGlmIChwcm9ncmVzcy5wb3N0cHJvY2VzcyAmJiBzdGF0ZSAhPT0gdXBsb2FkU3RhdGVzLlNUQVRFX1VQTE9BRElORyAmJiBzdGF0ZSAhPT0gdXBsb2FkU3RhdGVzLlNUQVRFX1BSRVBST0NFU1NJTkcpIHtcbiAgICAgIHN0YXRlID0gdXBsb2FkU3RhdGVzLlNUQVRFX1BPU1RQUk9DRVNTSU5HXG4gICAgfVxuICB9XG4gIHJldHVybiBzdGF0ZVxufVxuXG5mdW5jdGlvbiBVcGxvYWRTdGF0dXMgKHByb3BzKSB7XG4gIGNvbnN0IHVwbG9hZGluZ1N0YXRlID0gZ2V0VXBsb2FkaW5nU3RhdGUoXG4gICAgcHJvcHMuaXNBbGxFcnJvcmVkLFxuICAgIHByb3BzLmlzQWxsQ29tcGxldGUsXG4gICAgcHJvcHMuaXNBbGxQYXVzZWQsXG4gICAgcHJvcHMuZmlsZXNcbiAgKVxuXG4gIHN3aXRjaCAodXBsb2FkaW5nU3RhdGUpIHtcbiAgICBjYXNlICd1cGxvYWRpbmcnOlxuICAgICAgcmV0dXJuIHByb3BzLmkxOG4oJ3VwbG9hZGluZ1hGaWxlcycsIHsgc21hcnRfY291bnQ6IHByb3BzLmluUHJvZ3Jlc3NOb3RQYXVzZWRGaWxlcy5sZW5ndGggfSlcbiAgICBjYXNlICdwcmVwcm9jZXNzaW5nJzpcbiAgICBjYXNlICdwb3N0cHJvY2Vzc2luZyc6XG4gICAgICByZXR1cm4gcHJvcHMuaTE4bigncHJvY2Vzc2luZ1hGaWxlcycsIHsgc21hcnRfY291bnQ6IHByb3BzLnByb2Nlc3NpbmdGaWxlcy5sZW5ndGggfSlcbiAgICBjYXNlICdwYXVzZWQnOlxuICAgICAgcmV0dXJuIHByb3BzLmkxOG4oJ3VwbG9hZFBhdXNlZCcpXG4gICAgY2FzZSAnd2FpdGluZyc6XG4gICAgICByZXR1cm4gcHJvcHMuaTE4bigneEZpbGVzU2VsZWN0ZWQnLCB7IHNtYXJ0X2NvdW50OiBwcm9wcy5uZXdGaWxlcy5sZW5ndGggfSlcbiAgICBjYXNlICdjb21wbGV0ZSc6XG4gICAgICByZXR1cm4gcHJvcHMuaTE4bigndXBsb2FkQ29tcGxldGUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIFBhbmVsVG9wQmFyIChwcm9wcykge1xuICBsZXQgYWxsb3dOZXdVcGxvYWQgPSBwcm9wcy5hbGxvd05ld1VwbG9hZFxuICAvLyBUT0RPIG1heWJlIHRoaXMgc2hvdWxkIGJlIGRvbmUgaW4gLi4vaW5kZXguanMsIHRoZW4ganVzdCBwYXNzIHRoYXQgZG93biBhcyBgYWxsb3dOZXdVcGxvYWRgXG4gIGlmIChhbGxvd05ld1VwbG9hZCAmJiBwcm9wcy5tYXhOdW1iZXJPZkZpbGVzKSB7XG4gICAgYWxsb3dOZXdVcGxvYWQgPSBwcm9wcy50b3RhbEZpbGVDb3VudCA8IHByb3BzLm1heE51bWJlck9mRmlsZXNcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzcz1cInVwcHktRGFzaGJvYXJkQ29udGVudC1iYXJcIj5cbiAgICAgIHshcHJvcHMuaXNBbGxDb21wbGV0ZSAmJiAhcHJvcHMuaGlkZUNhbmNlbEJ1dHRvbiA/IChcbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGNsYXNzPVwidXBweS1EYXNoYm9hcmRDb250ZW50LWJhY2tcIlxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIG9uY2xpY2s9e3Byb3BzLmNhbmNlbEFsbH1cbiAgICAgICAgPlxuICAgICAgICAgIHtwcm9wcy5pMThuKCdjYW5jZWwnKX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICApIDogKFxuICAgICAgICA8ZGl2IC8+XG4gICAgICApfVxuXG4gICAgICA8ZGl2IGNsYXNzPVwidXBweS1EYXNoYm9hcmRDb250ZW50LXRpdGxlXCIgcm9sZT1cImhlYWRpbmdcIiBhcmlhLWxldmVsPVwiaDFcIj5cbiAgICAgICAgPFVwbG9hZFN0YXR1cyB7Li4ucHJvcHN9IC8+XG4gICAgICA8L2Rpdj5cblxuICAgICAge2FsbG93TmV3VXBsb2FkID8gKFxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3M9XCJ1cHB5LURhc2hib2FyZENvbnRlbnQtYWRkTW9yZVwiXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgYXJpYS1sYWJlbD17cHJvcHMuaTE4bignYWRkTW9yZUZpbGVzJyl9XG4gICAgICAgICAgdGl0bGU9e3Byb3BzLmkxOG4oJ2FkZE1vcmVGaWxlcycpfVxuICAgICAgICAgIG9uY2xpY2s9eygpID0+IHByb3BzLnRvZ2dsZUFkZEZpbGVzUGFuZWwodHJ1ZSl9XG4gICAgICAgID5cbiAgICAgICAgICB7aWNvblBsdXMoKX1cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cInVwcHktRGFzaGJvYXJkQ29udGVudC1hZGRNb3JlQ2FwdGlvblwiPntwcm9wcy5pMThuKCdhZGRNb3JlJyl9PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICkgOiAoXG4gICAgICAgIDxkaXYgLz5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYW5lbFRvcEJhclxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG4vLyBodHRwczovL2Nzcy10cmlja3MuY29tL2NyZWF0aW5nLXN2Zy1pY29uLXN5c3RlbS1yZWFjdC9cblxuZnVuY3Rpb24gZGVmYXVsdFBpY2tlckljb24gKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjMwXCIgaGVpZ2h0PVwiMzBcIiB2aWV3Qm94PVwiMCAwIDMwIDMwXCI+XG4gICAgICA8cGF0aCBkPVwiTTE1IDMwYzguMjg0IDAgMTUtNi43MTYgMTUtMTUgMC04LjI4NC02LjcxNi0xNS0xNS0xNUM2LjcxNiAwIDAgNi43MTYgMCAxNWMwIDguMjg0IDYuNzE2IDE1IDE1IDE1em00LjI1OC0xMi42NzZ2Ni44NDZoLTguNDI2di02Ljg0Nkg1LjIwNGw5LjgyLTEyLjM2NCA5LjgyIDEyLjM2NEgxOS4yNnpcIiAvPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbmZ1bmN0aW9uIGljb25Db3B5ICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3M9XCJVcHB5SWNvblwiIHdpZHRoPVwiNTFcIiBoZWlnaHQ9XCI1MVwiIHZpZXdCb3g9XCIwIDAgNTEgNTFcIj5cbiAgICAgIDxwYXRoIGQ9XCJNMTcuMjEgNDUuNzY1YTUuMzk0IDUuMzk0IDAgMCAxLTcuNjIgMGwtNC4xMi00LjEyMmE1LjM5MyA1LjM5MyAwIDAgMSAwLTcuNjE4bDYuNzc0LTYuNzc1LTIuNDA0LTIuNDA0LTYuNzc1IDYuNzc2Yy0zLjQyNCAzLjQyNy0zLjQyNCA5IDAgMTIuNDI2bDQuMTIgNC4xMjNhOC43NjYgOC43NjYgMCAwIDAgNi4yMTYgMi41N2MyLjI1IDAgNC41LS44NTggNi4yMTQtMi41N2wxMy41NS0xMy41NTJhOC43MiA4LjcyIDAgMCAwIDIuNTc1LTYuMjEzIDguNzMgOC43MyAwIDAgMC0yLjU3NS02LjIxM2wtNC4xMjMtNC4xMi0yLjQwNCAyLjQwNCA0LjEyMyA0LjEyYTUuMzUyIDUuMzUyIDAgMCAxIDEuNTggMy44MWMwIDEuNDM4LS41NjIgMi43OS0xLjU4IDMuODA4bC0xMy41NSAxMy41NXpcIiAvPlxuICAgICAgPHBhdGggZD1cIk00NC4yNTYgMi44NThBOC43MjggOC43MjggMCAwIDAgMzguMDQzLjI4M2gtLjAwMmE4LjczIDguNzMgMCAwIDAtNi4yMTIgMi41NzRsLTEzLjU1IDEzLjU1YTguNzI1IDguNzI1IDAgMCAwLTIuNTc1IDYuMjE0IDguNzMgOC43MyAwIDAgMCAyLjU3NCA2LjIxNmw0LjEyIDQuMTIgMi40MDUtMi40MDMtNC4xMi00LjEyYTUuMzU3IDUuMzU3IDAgMCAxLTEuNTgtMy44MTJjMC0xLjQzNy41NjItMi43OSAxLjU4LTMuODA4bDEzLjU1LTEzLjU1YTUuMzQ4IDUuMzQ4IDAgMCAxIDMuODEtMS41OGMxLjQ0IDAgMi43OTIuNTYyIDMuODEgMS41OGw0LjEyIDQuMTJjMi4xIDIuMSAyLjEgNS41MTggMCA3LjYxN0wzOS4yIDIzLjc3NWwyLjQwNCAyLjQwNCA2Ljc3NS02Ljc3N2MzLjQyNi0zLjQyNyAzLjQyNi05IDAtMTIuNDI2bC00LjEyLTQuMTJ6XCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5mdW5jdGlvbiBpY29uUmVzdW1lICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3M9XCJVcHB5SWNvblwiIHdpZHRoPVwiMjVcIiBoZWlnaHQ9XCIyNVwiIHZpZXdCb3g9XCIwIDAgNDQgNDRcIj5cbiAgICAgIDxwb2x5Z29uIGNsYXNzPVwicGxheVwiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg2LCA1LjUpXCIgcG9pbnRzPVwiMTMgMjEuNjY2NjY2NyAxMyAxMSAyMSAxNi4zMzMzMzMzXCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5mdW5jdGlvbiBpY29uUGF1c2UgKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzcz1cIlVwcHlJY29uXCIgd2lkdGg9XCIyNXB4XCIgaGVpZ2h0PVwiMjVweFwiIHZpZXdCb3g9XCIwIDAgNDQgNDRcIj5cbiAgICAgIDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxOCwgMTcpXCIgY2xhc3M9XCJwYXVzZVwiPlxuICAgICAgICA8cmVjdCB4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCIyXCIgaGVpZ2h0PVwiMTBcIiByeD1cIjBcIiAvPlxuICAgICAgICA8cmVjdCB4PVwiNlwiIHk9XCIwXCIgd2lkdGg9XCIyXCIgaGVpZ2h0PVwiMTBcIiByeD1cIjBcIiAvPlxuICAgICAgPC9nPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbmZ1bmN0aW9uIGxvY2FsSWNvbiAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGZpbGw9XCIjNjA3ZDhiXCIgd2lkdGg9XCIyN1wiIGhlaWdodD1cIjI1XCIgdmlld0JveD1cIjAgMCAyNyAyNVwiPlxuICAgICAgPHBhdGggZD1cIk01LjU4NiA5LjI4OGEuMzEzLjMxMyAwIDAgMCAuMjgyLjE3Nmg0Ljg0djMuOTIyYzAgMS41MTQgMS4yNSAyLjI0IDIuNzkyIDIuMjQgMS41NCAwIDIuNzktLjcyNiAyLjc5LTIuMjRWOS40NjRoNC44NGMuMTIyIDAgLjIzLS4wNjguMjg0LS4xNzZhLjMwNC4zMDQgMCAwIDAtLjA0Ni0uMzI0TDEzLjczNS4xMDZhLjMxNi4zMTYgMCAwIDAtLjQ3MiAwbC03LjYzIDguODU3YS4zMDIuMzAyIDAgMCAwLS4wNDcuMzI1elwiIC8+XG4gICAgICA8cGF0aCBkPVwiTTI0LjMgNS4wOTNjLS4yMTgtLjc2LS41NC0xLjE4Ny0xLjIwOC0xLjE4N2gtNC44NTZsMS4wMTggMS4xOGgzLjk0OGwyLjA0MyAxMS4wMzhoLTcuMTkzdjIuNzI4SDkuMTE0di0yLjcyNWgtNy4zNmwyLjY2LTExLjA0aDMuMzNsMS4wMTgtMS4xOEgzLjkwN2MtLjY2OCAwLTEuMDYuNDYtMS4yMSAxLjE4NkwwIDE2LjQ1NnY3LjA2MkMwIDI0LjMzOC42NzYgMjUgMS41MSAyNWgyMy45OGMuODMzIDAgMS41MS0uNjYzIDEuNTEtMS40ODJ2LTcuMDYyTDI0LjMgNS4wOTN6XCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5mdW5jdGlvbiBpY29uUmV0cnkgKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzcz1cIlVwcHlJY29uIHJldHJ5XCIgd2lkdGg9XCIyOFwiIGhlaWdodD1cIjMxXCIgdmlld0JveD1cIjAgMCAxNiAxOVwiPlxuICAgICAgPHBhdGggZD1cIk0xNiAxMWE4IDggMCAxIDEtOC04djJhNiA2IDAgMSAwIDYgNmgyelwiIC8+XG4gICAgICA8cGF0aCBkPVwiTTcuOSAzSDEwdjJINy45elwiIC8+XG4gICAgICA8cGF0aCBkPVwiTTguNTM2LjVsMy41MzUgMy41MzYtMS40MTQgMS40MTRMNy4xMiAxLjkxNHpcIiAvPlxuICAgICAgPHBhdGggZD1cIk0xMC42NTcgMi42MjFsMS40MTQgMS40MTVMOC41MzYgNy41NyA3LjEyIDYuMTU3elwiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gY2hlY2tJY29uICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3M9XCJVcHB5SWNvbiBVcHB5SWNvbi1jaGVja1wiIHdpZHRoPVwiMTNcIiBoZWlnaHQ9XCI5XCIgdmlld0JveD1cIjAgMCAxMyA5XCI+XG4gICAgICA8cG9seWdvbiBwb2ludHM9XCI1IDcuMjkzIDEuMzU0IDMuNjQ3IDAuNjQ2IDQuMzU0IDUgOC43MDcgMTIuMzU0IDEuMzU0IDExLjY0NiAwLjY0N1wiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gaWNvbkF1ZGlvICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3M9XCJVcHB5SWNvblwiIHdpZHRoPVwiMjVcIiBoZWlnaHQ9XCIyNVwiIHZpZXdCb3g9XCIwIDAgMjUgMjVcIj5cbiAgICAgIDxwYXRoIGQ9XCJNOS41IDE4LjY0YzAgMS4xNC0xLjE0NSAyLTIuNSAycy0yLjUtLjg2LTIuNS0yYzAtMS4xNCAxLjE0NS0yIDIuNS0yIC41NTcgMCAxLjA3OS4xNDUgMS41LjM5NlY3LjI1YS41LjUgMCAwIDEgLjM3OS0uNDg1bDktMi4yNUEuNS41IDAgMCAxIDE4LjUgNXYxMS42NGMwIDEuMTQtMS4xNDUgMi0yLjUgMnMtMi41LS44Ni0yLjUtMmMwLTEuMTQgMS4xNDUtMiAyLjUtMiAuNTU3IDAgMS4wNzkuMTQ1IDEuNS4zOTZWOC42N2wtOCAydjcuOTd6bTgtMTF2LTJsLTggMnYybDgtMnpNNyAxOS42NGMuODU1IDAgMS41LS40ODQgMS41LTFzLS42NDUtMS0xLjUtMS0xLjUuNDg0LTEuNSAxIC42NDUgMSAxLjUgMXptOS0yYy44NTUgMCAxLjUtLjQ4NCAxLjUtMXMtLjY0NS0xLTEuNS0xLTEuNS40ODQtMS41IDEgLjY0NSAxIDEuNSAxelwiIGZpbGw9XCIjMDQ5QkNGXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gaWNvblZpZGVvICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3M9XCJVcHB5SWNvblwiIHdpZHRoPVwiMjVcIiBoZWlnaHQ9XCIyNVwiIHZpZXdCb3g9XCIwIDAgMjUgMjVcIj5cbiAgICAgIDxwYXRoIGQ9XCJNMTYgMTEuODM0bDQuNDg2LTIuNjkxQTEgMSAwIDAgMSAyMiAxMHY2YTEgMSAwIDAgMS0xLjUxNC44NTdMMTYgMTQuMTY3VjE3YTEgMSAwIDAgMS0xIDFINWExIDEgMCAwIDEtMS0xVjlhMSAxIDAgMCAxIDEtMWgxMGExIDEgMCAwIDEgMSAxdjIuODM0ek0xNSA5SDV2OGgxMFY5em0xIDRsNSAzdi02bC01IDN6XCIgZmlsbD1cIiMxOUFGNjdcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5mdW5jdGlvbiBpY29uUERGICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3M9XCJVcHB5SWNvblwiIHdpZHRoPVwiMjVcIiBoZWlnaHQ9XCIyNVwiIHZpZXdCb3g9XCIwIDAgMjUgMjVcIj5cbiAgICAgIDxwYXRoIGQ9XCJNOS43NjYgOC4yOTVjLS42OTEtMS44NDMtLjUzOS0zLjQwMS43NDctMy43MjYgMS42NDMtLjQxNCAyLjUwNS45MzggMi4zOSAzLjI5OS0uMDM5Ljc5LS4xOTQgMS42NjItLjUzNyAzLjE0OC4zMjQuNDkuNjYuOTY3IDEuMDU1IDEuNTEuMTcuMjMxLjM4Mi40ODguNjI5Ljc1NyAxLjg2Ni0uMTI4IDMuNjUzLjExNCA0LjkxOC42NTUgMS40ODcuNjM1IDIuMTkyIDEuNjg1IDEuNjE0IDIuODQtLjU2NiAxLjEzMy0xLjgzOSAxLjA4NC0zLjQxNi4yNDktMS4xNDEtLjYwNC0yLjQ1Ny0xLjYzNC0zLjUxLTIuNzA3YTEzLjQ2NyAxMy40NjcgMCAwIDAtMi4yMzguNDI2Yy0xLjM5MiA0LjA1MS00LjUzNCA2LjQ1My01LjcwNyA0LjU3Mi0uOTg2LTEuNTggMS4zOC00LjIwNiA0LjkxNC01LjM3NS4wOTctLjMyMi4xODUtLjY1Ni4yNjQtMS4wMDEuMDgtLjM1My4zMDYtMS4zMS40MDctMS43MzctLjY3OC0xLjA1OS0xLjItMi4wMzEtMS41My0yLjkxem0yLjA5OCA0Ljg3Yy0uMDMzLjE0NC0uMDY4LjI4Ny0uMTA0LjQyN2wuMDMzLS4wMS0uMDEyLjAzOGExNC4wNjUgMTQuMDY1IDAgMCAxIDEuMDItLjE5N2wtLjAzMi0uMDMzLjA1Mi0uMDA0YTcuOTAyIDcuOTAyIDAgMCAxLS4yMDgtLjI3MWMtLjE5Ny0uMjctLjM4LS41MjYtLjU1NS0uNzc1bC0uMDA2LjAyOC0uMDAyLS4wMDNjLS4wNzYuMzIzLS4xNDguNjMyLS4xODYuOHptNS43NyAyLjk3OGMxLjE0My42MDUgMS44MzIuNjMyIDIuMDU0LjE4Ny4yNi0uNTE5LS4wODctMS4wMzQtMS4xMTMtMS40NzMtLjkxMS0uMzktMi4xNzUtLjYwOC0zLjU1LS42MDguODQ1Ljc2NiAxLjc4NyAxLjQ1OSAyLjYwOSAxLjg5NHpNNi41NTkgMTguNzg5Yy4xNC4yMjMuNjkzLjE2IDEuNDI1LS40MTMuODI3LS42NDggMS42MS0xLjc0NyAyLjIwOC0zLjIwNi0yLjU2MyAxLjA2NC00LjEwMiAyLjg2Ny0zLjYzMyAzLjYyem01LjM0NS0xMC45N2MuMDg4LTEuNzkzLS4zNTEtMi40OC0xLjE0Ni0yLjI4LS40NzMuMTE5LS41NjQgMS4wNS0uMDU2IDIuNDA1LjIxMy41NjYuNTIgMS4xODguOTA4IDEuODU5LjE4LS44NTguMjY4LTEuNDUzLjI5NC0xLjk4NHpcIiBmaWxsPVwiI0UyNTE0QVwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIiAvPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbmZ1bmN0aW9uIGljb25GaWxlICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3M9XCJVcHB5SWNvblwiIHdpZHRoPVwiMjVcIiBoZWlnaHQ9XCIyNVwiIHZpZXdCb3g9XCIwIDAgMjUgMjVcIj5cbiAgICAgIDxnIGZpbGw9XCIjQTdBRkI3XCIgZmlsbC1ydWxlPVwibm9uemVyb1wiPlxuICAgICAgICA8cGF0aCBkPVwiTTUuNSAyMmEuNS41IDAgMCAxLS41LS41di0xOGEuNS41IDAgMCAxIC41LS41aDEwLjcxOWEuNS41IDAgMCAxIC4zNjcuMTZsMy4yODEgMy41NTZhLjUuNSAwIDAgMSAuMTMzLjMzOVYyMS41YS41LjUgMCAwIDEtLjUuNWgtMTR6bS41LTFoMTNWNy4yNUwxNiA0SDZ2MTd6XCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0xNSA0djNhMSAxIDAgMCAwIDEgMWgzVjdoLTNWNGgtMXpcIiAvPlxuICAgICAgPC9nPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbmZ1bmN0aW9uIGljb25UZXh0ICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3M9XCJVcHB5SWNvblwiIHdpZHRoPVwiMjVcIiBoZWlnaHQ9XCIyNVwiIHZpZXdCb3g9XCIwIDAgMjUgMjVcIj5cbiAgICAgIDxwYXRoIGQ9XCJNNC41IDdoMTNhLjUuNSAwIDEgMSAwIDFoLTEzYS41LjUgMCAwIDEgMC0xem0wIDNoMTVhLjUuNSAwIDEgMSAwIDFoLTE1YS41LjUgMCAxIDEgMC0xem0wIDNoMTVhLjUuNSAwIDEgMSAwIDFoLTE1YS41LjUgMCAxIDEgMC0xem0wIDNoMTBhLjUuNSAwIDEgMSAwIDFoLTEwYS41LjUgMCAxIDEgMC0xelwiIGZpbGw9XCIjNUE1RTY5XCIgZmlsbC1ydWxlPVwibm9uemVyb1wiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gaWNvbkNvcHlMaW5rICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3M9XCJVcHB5SWNvblwiIHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiIHZpZXdCb3g9XCIwIDAgMTQgMTJcIj5cbiAgICAgIDxwYXRoIGQ9XCJNNy45NCA3LjcwM2EyLjYxMyAyLjYxMyAwIDAgMS0uNjI2IDIuNjgxbC0uODUyLjg1MWEyLjU5NyAyLjU5NyAwIDAgMS0xLjg0OS43NjZBMi42MTYgMi42MTYgMCAwIDEgMi43NjQgNy41NGwuODUyLS44NTJhMi41OTYgMi41OTYgMCAwIDEgMi42OS0uNjI1TDUuMjY3IDcuMDk5YTEuNDQgMS40NCAwIDAgMC0uODMzLjQwN2wtLjg1Mi44NTFhMS40NTggMS40NTggMCAwIDAgMS4wMyAyLjQ4NmMuMzkgMCAuNzU1LS4xNTIgMS4wMy0uNDI2bC44NTItLjg1MmMuMjMxLS4yMzEuMzYzLS41MjIuNDA2LS44MjRsMS4wNC0xLjAzOHptNC4yOTUtNS45MzdBMi41OTYgMi41OTYgMCAwIDAgMTAuMzg3IDFjLS42OTggMC0xLjM1NS4yNzItMS44NDkuNzY2bC0uODUyLjg1MWEyLjYxNCAyLjYxNCAwIDAgMC0uNjI0IDIuNjg4bDEuMDM2LTEuMDM2Yy4wNDEtLjMwNC4xNzMtLjYuNDA3LS44MzNsLjg1Mi0uODUyYy4yNzUtLjI3NS42NC0uNDI2IDEuMDMtLjQyNmExLjQ1OCAxLjQ1OCAwIDAgMSAxLjAzIDIuNDg2bC0uODUyLjg1MWExLjQ0MiAxLjQ0MiAwIDAgMS0uODI0LjQwNmwtMS4wNCAxLjA0YTIuNTk2IDIuNTk2IDAgMCAwIDIuNjgzLS42MjhsLjg1MS0uODVhMi42MTYgMi42MTYgMCAwIDAgMC0zLjY5N3ptLTYuODggNi44ODNhLjU3Ny41NzcgMCAwIDAgLjgyIDBsMy40NzQtMy40NzRhLjU3OS41NzkgMCAxIDAtLjgxOS0uODJMNS4zNTUgNy44M2EuNTc5LjU3OSAwIDAgMCAwIC44MTl6XCIgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG5mdW5jdGlvbiBpY29uUGVuY2lsICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3M9XCJVcHB5SWNvblwiIHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiIHZpZXdCb3g9XCIwIDAgMTQgMTRcIj5cbiAgICAgIDxnIGZpbGwtcnVsZT1cImV2ZW5vZGRcIj48cGF0aCBkPVwiTTEuNSAxMC43OTNoMi43OTNBMSAxIDAgMCAwIDUgMTAuNUwxMS41IDRhMSAxIDAgMCAwIDAtMS40MTRMOS43MDcuNzkzYTEgMSAwIDAgMC0xLjQxNCAwbC02LjUgNi41QTEgMSAwIDAgMCAxLjUgOHYyLjc5M3ptMS0xVjhMOSAxLjVsMS43OTMgMS43OTMtNi41IDYuNUgyLjV6XCIgZmlsbC1ydWxlPVwibm9uemVyb1wiIC8+PHJlY3QgeD1cIjFcIiB5PVwiMTIuMjkzXCIgd2lkdGg9XCIxMVwiIGhlaWdodD1cIjFcIiByeD1cIi41XCIgLz48cGF0aCBmaWxsLXJ1bGU9XCJub256ZXJvXCIgZD1cIk02Ljc5MyAyLjVMOS41IDUuMjA3bC43MDctLjcwN0w3LjUgMS43OTN6XCIgLz48L2c+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gaWNvbkNyb3NzICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3M9XCJVcHB5SWNvblwiIHdpZHRoPVwiMThcIiBoZWlnaHQ9XCIxOFwiIHZpZXdCb3g9XCIwIDAgMTggMThcIj5cbiAgICAgIDxwYXRoIGQ9XCJNOSAwQzQuMDM0IDAgMCA0LjAzNCAwIDlzNC4wMzQgOSA5IDkgOS00LjAzNCA5LTktNC4wMzQtOS05LTl6XCIgLz5cbiAgICAgIDxwYXRoIGZpbGw9XCIjRkZGXCIgZD1cIk0xMyAxMi4yMjJsLS43NzguNzc4TDkgOS43NzggNS43NzggMTMgNSAxMi4yMjIgOC4yMjIgOSA1IDUuNzc4IDUuNzc4IDUgOSA4LjIyMiAxMi4yMjIgNWwuNzc4Ljc3OEw5Ljc3OCA5elwiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gaWNvblBsdXMgKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzcz1cIlVwcHlJY29uXCIgd2lkdGg9XCIxNVwiIGhlaWdodD1cIjE1XCIgdmlld0JveD1cIjAgMCAxNSAxNVwiPlxuICAgICAgPHBhdGggZD1cIk04IDYuNWg2YS41LjUgMCAwIDEgLjUuNXYuNWEuNS41IDAgMCAxLS41LjVIOHY2YS41LjUgMCAwIDEtLjUuNUg3YS41LjUgMCAwIDEtLjUtLjVWOGgtNmEuNS41IDAgMCAxLS41LS41VjdhLjUuNSAwIDAgMSAuNS0uNWg2di02QS41LjUgMCAwIDEgNyAwaC41YS41LjUgMCAwIDEgLjUuNXY2elwiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlZmF1bHRQaWNrZXJJY29uLFxuICBpY29uQ29weSxcbiAgaWNvblJlc3VtZSxcbiAgaWNvblBhdXNlLFxuICBpY29uUmV0cnksXG4gIGxvY2FsSWNvbixcbiAgY2hlY2tJY29uLFxuICBpY29uQXVkaW8sXG4gIGljb25WaWRlbyxcbiAgaWNvblBERixcbiAgaWNvbkZpbGUsXG4gIGljb25UZXh0LFxuICBpY29uQ29weUxpbmssXG4gIGljb25QZW5jaWwsXG4gIGljb25Dcm9zcyxcbiAgaWNvblBsdXNcbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IFRyYW5zbGF0b3IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvVHJhbnNsYXRvcicpXG5jb25zdCBEYXNoYm9hcmRVSSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9EYXNoYm9hcmQnKVxuY29uc3QgU3RhdHVzQmFyID0gcmVxdWlyZSgnQHVwcHkvc3RhdHVzLWJhcicpXG5jb25zdCBJbmZvcm1lciA9IHJlcXVpcmUoJ0B1cHB5L2luZm9ybWVyJylcbmNvbnN0IFRodW1ibmFpbEdlbmVyYXRvciA9IHJlcXVpcmUoJ0B1cHB5L3RodW1ibmFpbC1nZW5lcmF0b3InKVxuY29uc3QgZmluZEFsbERPTUVsZW1lbnRzID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2ZpbmRBbGxET01FbGVtZW50cycpXG5jb25zdCB0b0FycmF5ID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL3RvQXJyYXknKVxuY29uc3QgZ2V0RHJvcHBlZEZpbGVzID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldERyb3BwZWRGaWxlcycpXG5jb25zdCB0cmFwRm9jdXMgPSByZXF1aXJlKCcuL3V0aWxzL3RyYXBGb2N1cycpXG5jb25zdCBjdWlkID0gcmVxdWlyZSgnY3VpZCcpXG5jb25zdCBSZXNpemVPYnNlcnZlciA9IHJlcXVpcmUoJ3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbCcpLmRlZmF1bHQgfHwgcmVxdWlyZSgncmVzaXplLW9ic2VydmVyLXBvbHlmaWxsJylcbmNvbnN0IHsgZGVmYXVsdFBpY2tlckljb24gfSA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9pY29ucycpXG5jb25zdCBjcmVhdGVTdXBlckZvY3VzID0gcmVxdWlyZSgnLi91dGlscy9jcmVhdGVTdXBlckZvY3VzJylcbmNvbnN0IG1lbW9pemUgPSByZXF1aXJlKCdtZW1vaXplLW9uZScpLmRlZmF1bHQgfHwgcmVxdWlyZSgnbWVtb2l6ZS1vbmUnKVxuXG5jb25zdCBUQUJfS0VZID0gOVxuY29uc3QgRVNDX0tFWSA9IDI3XG5cbmZ1bmN0aW9uIGNyZWF0ZVByb21pc2UgKCkge1xuICBjb25zdCBvID0ge31cbiAgby5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG8ucmVzb2x2ZSA9IHJlc29sdmVcbiAgICBvLnJlamVjdCA9IHJlamVjdFxuICB9KVxuICByZXR1cm4gb1xufVxuXG4vKipcbiAqIERhc2hib2FyZCBVSSB3aXRoIHByZXZpZXdzLCBtZXRhZGF0YSBlZGl0aW5nLCB0YWJzIGZvciB2YXJpb3VzIHNlcnZpY2VzIGFuZCBtb3JlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRGFzaGJvYXJkIGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ0Rhc2hib2FyZCdcbiAgICB0aGlzLnRpdGxlID0gJ0Rhc2hib2FyZCdcbiAgICB0aGlzLnR5cGUgPSAnb3JjaGVzdHJhdG9yJ1xuICAgIHRoaXMubW9kYWxOYW1lID0gYHVwcHktRGFzaGJvYXJkLSR7Y3VpZCgpfWBcblxuICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IHtcbiAgICAgIHN0cmluZ3M6IHtcbiAgICAgICAgY2xvc2VNb2RhbDogJ0Nsb3NlIE1vZGFsJyxcbiAgICAgICAgaW1wb3J0RnJvbTogJ0ltcG9ydCBmcm9tICV7bmFtZX0nLFxuICAgICAgICBhZGRpbmdNb3JlRmlsZXM6ICdBZGRpbmcgbW9yZSBmaWxlcycsXG4gICAgICAgIGFkZE1vcmVGaWxlczogJ0FkZCBtb3JlIGZpbGVzJyxcbiAgICAgICAgZGFzaGJvYXJkV2luZG93VGl0bGU6ICdGaWxlIFVwbG9hZGVyIFdpbmRvdyAoUHJlc3MgZXNjYXBlIHRvIGNsb3NlKScsXG4gICAgICAgIGRhc2hib2FyZFRpdGxlOiAnRmlsZSBVcGxvYWRlcicsXG4gICAgICAgIGNvcHlMaW5rVG9DbGlwYm9hcmRTdWNjZXNzOiAnTGluayBjb3BpZWQgdG8gY2xpcGJvYXJkJyxcbiAgICAgICAgY29weUxpbmtUb0NsaXBib2FyZEZhbGxiYWNrOiAnQ29weSB0aGUgVVJMIGJlbG93JyxcbiAgICAgICAgY29weUxpbms6ICdDb3B5IGxpbmsnLFxuICAgICAgICBsaW5rOiAnTGluaycsXG4gICAgICAgIGZpbGVTb3VyY2U6ICdGaWxlIHNvdXJjZTogJXtuYW1lfScsXG4gICAgICAgIGRvbmU6ICdEb25lJyxcbiAgICAgICAgYmFjazogJ0JhY2snLFxuICAgICAgICBhZGRNb3JlOiAnQWRkIG1vcmUnLFxuICAgICAgICByZW1vdmVGaWxlOiAnUmVtb3ZlIGZpbGUnLFxuICAgICAgICBlZGl0RmlsZTogJ0VkaXQgZmlsZScsXG4gICAgICAgIGVkaXRpbmc6ICdFZGl0aW5nICV7ZmlsZX0nLFxuICAgICAgICBlZGl0OiAnRWRpdCcsXG4gICAgICAgIGZpbmlzaEVkaXRpbmdGaWxlOiAnRmluaXNoIGVkaXRpbmcgZmlsZScsXG4gICAgICAgIHNhdmVDaGFuZ2VzOiAnU2F2ZSBjaGFuZ2VzJyxcbiAgICAgICAgY2FuY2VsOiAnQ2FuY2VsJyxcbiAgICAgICAgbXlEZXZpY2U6ICdNeSBEZXZpY2UnLFxuICAgICAgICBkcm9wUGFzdGVJbXBvcnQ6ICdEcm9wIGZpbGVzIGhlcmUsIHBhc3RlLCAle2Jyb3dzZX0gb3IgaW1wb3J0IGZyb20nLFxuICAgICAgICBkcm9wUGFzdGU6ICdEcm9wIGZpbGVzIGhlcmUsIHBhc3RlIG9yICV7YnJvd3NlfScsXG4gICAgICAgIGRyb3BIaW50OiAnRHJvcCB5b3VyIGZpbGVzIGhlcmUnLFxuICAgICAgICBicm93c2U6ICdicm93c2UnLFxuICAgICAgICB1cGxvYWRDb21wbGV0ZTogJ1VwbG9hZCBjb21wbGV0ZScsXG4gICAgICAgIHVwbG9hZFBhdXNlZDogJ1VwbG9hZCBwYXVzZWQnLFxuICAgICAgICByZXN1bWVVcGxvYWQ6ICdSZXN1bWUgdXBsb2FkJyxcbiAgICAgICAgcGF1c2VVcGxvYWQ6ICdQYXVzZSB1cGxvYWQnLFxuICAgICAgICByZXRyeVVwbG9hZDogJ1JldHJ5IHVwbG9hZCcsXG4gICAgICAgIGNhbmNlbFVwbG9hZDogJ0NhbmNlbCB1cGxvYWQnLFxuICAgICAgICB4RmlsZXNTZWxlY3RlZDoge1xuICAgICAgICAgIDA6ICcle3NtYXJ0X2NvdW50fSBmaWxlIHNlbGVjdGVkJyxcbiAgICAgICAgICAxOiAnJXtzbWFydF9jb3VudH0gZmlsZXMgc2VsZWN0ZWQnLFxuICAgICAgICAgIDI6ICcle3NtYXJ0X2NvdW50fSBmaWxlcyBzZWxlY3RlZCdcbiAgICAgICAgfSxcbiAgICAgICAgdXBsb2FkaW5nWEZpbGVzOiB7XG4gICAgICAgICAgMDogJ1VwbG9hZGluZyAle3NtYXJ0X2NvdW50fSBmaWxlJyxcbiAgICAgICAgICAxOiAnVXBsb2FkaW5nICV7c21hcnRfY291bnR9IGZpbGVzJyxcbiAgICAgICAgICAyOiAnVXBsb2FkaW5nICV7c21hcnRfY291bnR9IGZpbGVzJ1xuICAgICAgICB9LFxuICAgICAgICBwcm9jZXNzaW5nWEZpbGVzOiB7XG4gICAgICAgICAgMDogJ1Byb2Nlc3NpbmcgJXtzbWFydF9jb3VudH0gZmlsZScsXG4gICAgICAgICAgMTogJ1Byb2Nlc3NpbmcgJXtzbWFydF9jb3VudH0gZmlsZXMnLFxuICAgICAgICAgIDI6ICdQcm9jZXNzaW5nICV7c21hcnRfY291bnR9IGZpbGVzJ1xuICAgICAgICB9LFxuICAgICAgICBwb3dlcmVkQnk6ICdQb3dlcmVkIGJ5J1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHRhcmdldDogJ2JvZHknLFxuICAgICAgbWV0YUZpZWxkczogW10sXG4gICAgICB0cmlnZ2VyOiAnI3VwcHktc2VsZWN0LWZpbGVzJyxcbiAgICAgIGlubGluZTogZmFsc2UsXG4gICAgICB3aWR0aDogNzUwLFxuICAgICAgaGVpZ2h0OiA1NTAsXG4gICAgICB0aHVtYm5haWxXaWR0aDogMjgwLFxuICAgICAgd2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWQ6IGZhbHNlLFxuICAgICAgZGVmYXVsdFBpY2tlckljb24sXG4gICAgICBzaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdDogdHJ1ZSxcbiAgICAgIHNob3dQcm9ncmVzc0RldGFpbHM6IGZhbHNlLFxuICAgICAgaGlkZVVwbG9hZEJ1dHRvbjogZmFsc2UsXG4gICAgICBoaWRlUmV0cnlCdXR0b246IGZhbHNlLFxuICAgICAgaGlkZVBhdXNlUmVzdW1lQ2FuY2VsQnV0dG9uczogZmFsc2UsXG4gICAgICBoaWRlUHJvZ3Jlc3NBZnRlckZpbmlzaDogZmFsc2UsXG4gICAgICBub3RlOiBudWxsLFxuICAgICAgY2xvc2VNb2RhbE9uQ2xpY2tPdXRzaWRlOiBmYWxzZSxcbiAgICAgIGNsb3NlQWZ0ZXJGaW5pc2g6IGZhbHNlLFxuICAgICAgZGlzYWJsZVN0YXR1c0JhcjogZmFsc2UsXG4gICAgICBkaXNhYmxlSW5mb3JtZXI6IGZhbHNlLFxuICAgICAgZGlzYWJsZVRodW1ibmFpbEdlbmVyYXRvcjogZmFsc2UsXG4gICAgICBkaXNhYmxlUGFnZVNjcm9sbFdoZW5Nb2RhbE9wZW46IHRydWUsXG4gICAgICBhbmltYXRlT3BlbkNsb3NlOiB0cnVlLFxuICAgICAgcHJvdWRseURpc3BsYXlQb3dlcmVkQnlVcHB5OiB0cnVlLFxuICAgICAgb25SZXF1ZXN0Q2xvc2VNb2RhbDogKCkgPT4gdGhpcy5jbG9zZU1vZGFsKCksXG4gICAgICBzaG93U2VsZWN0ZWRGaWxlczogdHJ1ZSxcbiAgICAgIGJyb3dzZXJCYWNrQnV0dG9uQ2xvc2U6IGZhbHNlXG4gICAgfVxuXG4gICAgLy8gbWVyZ2UgZGVmYXVsdCBvcHRpb25zIHdpdGggdGhlIG9uZXMgc2V0IGJ5IHVzZXJcbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRzIH1cblxuICAgIHRoaXMuaTE4bkluaXQoKVxuXG4gICAgdGhpcy5vcGVuTW9kYWwgPSB0aGlzLm9wZW5Nb2RhbC5iaW5kKHRoaXMpXG4gICAgdGhpcy5jbG9zZU1vZGFsID0gdGhpcy5jbG9zZU1vZGFsLmJpbmQodGhpcylcbiAgICB0aGlzLnJlcXVlc3RDbG9zZU1vZGFsID0gdGhpcy5yZXF1ZXN0Q2xvc2VNb2RhbC5iaW5kKHRoaXMpXG4gICAgdGhpcy5pc01vZGFsT3BlbiA9IHRoaXMuaXNNb2RhbE9wZW4uYmluZCh0aGlzKVxuXG4gICAgdGhpcy5hZGRUYXJnZXQgPSB0aGlzLmFkZFRhcmdldC5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZW1vdmVUYXJnZXQgPSB0aGlzLnJlbW92ZVRhcmdldC5iaW5kKHRoaXMpXG4gICAgdGhpcy5oaWRlQWxsUGFuZWxzID0gdGhpcy5oaWRlQWxsUGFuZWxzLmJpbmQodGhpcylcbiAgICB0aGlzLnNob3dQYW5lbCA9IHRoaXMuc2hvd1BhbmVsLmJpbmQodGhpcylcbiAgICB0aGlzLnRvZ2dsZUZpbGVDYXJkID0gdGhpcy50b2dnbGVGaWxlQ2FyZC5iaW5kKHRoaXMpXG4gICAgdGhpcy50b2dnbGVBZGRGaWxlc1BhbmVsID0gdGhpcy50b2dnbGVBZGRGaWxlc1BhbmVsLmJpbmQodGhpcylcblxuICAgIHRoaXMuaW5pdEV2ZW50cyA9IHRoaXMuaW5pdEV2ZW50cy5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVQb3BTdGF0ZSA9IHRoaXMuaGFuZGxlUG9wU3RhdGUuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlS2V5RG93bkluTW9kYWwgPSB0aGlzLmhhbmRsZUtleURvd25Jbk1vZGFsLmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZUtleURvd25JbklubGluZSA9IHRoaXMuaGFuZGxlS2V5RG93bkluSW5saW5lLmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZUNvbXBsZXRlID0gdGhpcy5oYW5kbGVDb21wbGV0ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVDbGlja091dHNpZGUgPSB0aGlzLmhhbmRsZUNsaWNrT3V0c2lkZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVQYXN0ZSA9IHRoaXMuaGFuZGxlUGFzdGUuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlUGFzdGVPbkJvZHkgPSB0aGlzLmhhbmRsZVBhc3RlT25Cb2R5LmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZUlucHV0Q2hhbmdlID0gdGhpcy5oYW5kbGVJbnB1dENoYW5nZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVEcmFnT3ZlciA9IHRoaXMuaGFuZGxlRHJhZ092ZXIuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlRHJhZ0xlYXZlID0gdGhpcy5oYW5kbGVEcmFnTGVhdmUuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlRHJvcCA9IHRoaXMuaGFuZGxlRHJvcC5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLnN1cGVyRm9jdXNPbkVhY2hVcGRhdGUgPSB0aGlzLnN1cGVyRm9jdXNPbkVhY2hVcGRhdGUuYmluZCh0aGlzKVxuICAgIHRoaXMucmVjb3JkSWZGb2N1c2VkT25VcHB5UmVjZW50bHkgPSB0aGlzLnJlY29yZElmRm9jdXNlZE9uVXBweVJlY2VudGx5LmJpbmQodGhpcylcblxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICAgIHRoaXMuaW5zdGFsbCA9IHRoaXMuaW5zdGFsbC5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLnN1cGVyRm9jdXMgPSBjcmVhdGVTdXBlckZvY3VzKClcbiAgICB0aGlzLmlmRm9jdXNlZE9uVXBweVJlY2VudGx5ID0gZmFsc2VcblxuICAgIC8vIFRpbWVvdXRzXG4gICAgdGhpcy5tYWtlRGFzaGJvYXJkSW5zaWRlc1Zpc2libGVBbnl3YXlUaW1lb3V0ID0gbnVsbFxuICAgIHRoaXMucmVtb3ZlRHJhZ092ZXJDbGFzc1RpbWVvdXQgPSBudWxsXG4gIH1cblxuICBzZXRPcHRpb25zIChuZXdPcHRzKSB7XG4gICAgc3VwZXIuc2V0T3B0aW9ucyhuZXdPcHRzKVxuICAgIHRoaXMuaTE4bkluaXQoKVxuICB9XG5cbiAgaTE4bkluaXQgKCkge1xuICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKFt0aGlzLmRlZmF1bHRMb2NhbGUsIHRoaXMudXBweS5sb2NhbGUsIHRoaXMub3B0cy5sb2NhbGVdKVxuICAgIHRoaXMuaTE4biA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgdGhpcy5pMThuQXJyYXkgPSB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlQXJyYXkuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSgpIC8vIHNvIHRoYXQgVUkgcmUtcmVuZGVycyBhbmQgd2Ugc2VlIHRoZSB1cGRhdGVkIGxvY2FsZVxuICB9XG5cbiAgcmVtb3ZlVGFyZ2V0IChwbHVnaW4pIHtcbiAgICBjb25zdCBwbHVnaW5TdGF0ZSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgIC8vIGZpbHRlciBvdXQgdGhlIG9uZSB3ZSB3YW50IHRvIHJlbW92ZVxuICAgIGNvbnN0IG5ld1RhcmdldHMgPSBwbHVnaW5TdGF0ZS50YXJnZXRzLmZpbHRlcih0YXJnZXQgPT4gdGFyZ2V0LmlkICE9PSBwbHVnaW4uaWQpXG5cbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIHRhcmdldHM6IG5ld1RhcmdldHNcbiAgICB9KVxuICB9XG5cbiAgYWRkVGFyZ2V0IChwbHVnaW4pIHtcbiAgICBjb25zdCBjYWxsZXJQbHVnaW5JZCA9IHBsdWdpbi5pZCB8fCBwbHVnaW4uY29uc3RydWN0b3IubmFtZVxuICAgIGNvbnN0IGNhbGxlclBsdWdpbk5hbWUgPSBwbHVnaW4udGl0bGUgfHwgY2FsbGVyUGx1Z2luSWRcbiAgICBjb25zdCBjYWxsZXJQbHVnaW5UeXBlID0gcGx1Z2luLnR5cGVcblxuICAgIGlmIChjYWxsZXJQbHVnaW5UeXBlICE9PSAnYWNxdWlyZXInICYmXG4gICAgICAgIGNhbGxlclBsdWdpblR5cGUgIT09ICdwcm9ncmVzc2luZGljYXRvcicgJiZcbiAgICAgICAgY2FsbGVyUGx1Z2luVHlwZSAhPT0gJ3ByZXNlbnRlcicpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdEYXNoYm9hcmQ6IE1vZGFsIGNhbiBvbmx5IGJlIHVzZWQgYnkgcGx1Z2lucyBvZiB0eXBlczogYWNxdWlyZXIsIHByb2dyZXNzaW5kaWNhdG9yLCBwcmVzZW50ZXInXG4gICAgICB0aGlzLnVwcHkubG9nKG1zZywgJ2Vycm9yJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IHtcbiAgICAgIGlkOiBjYWxsZXJQbHVnaW5JZCxcbiAgICAgIG5hbWU6IGNhbGxlclBsdWdpbk5hbWUsXG4gICAgICB0eXBlOiBjYWxsZXJQbHVnaW5UeXBlXG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCBuZXdUYXJnZXRzID0gc3RhdGUudGFyZ2V0cy5zbGljZSgpXG4gICAgbmV3VGFyZ2V0cy5wdXNoKHRhcmdldClcblxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgdGFyZ2V0czogbmV3VGFyZ2V0c1xuICAgIH0pXG5cbiAgICByZXR1cm4gdGhpcy5lbFxuICB9XG5cbiAgaGlkZUFsbFBhbmVscyAoKSB7XG4gICAgY29uc3QgdXBkYXRlID0ge1xuICAgICAgYWN0aXZlUGlja2VyUGFuZWw6IGZhbHNlLFxuICAgICAgc2hvd0FkZEZpbGVzUGFuZWw6IGZhbHNlLFxuICAgICAgYWN0aXZlT3ZlcmxheVR5cGU6IG51bGxcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgaWYgKGN1cnJlbnQuYWN0aXZlUGlja2VyUGFuZWwgPT09IHVwZGF0ZS5hY3RpdmVQaWNrZXJQYW5lbCAmJlxuICAgICAgICBjdXJyZW50LnNob3dBZGRGaWxlc1BhbmVsID09PSB1cGRhdGUuc2hvd0FkZEZpbGVzUGFuZWwgJiZcbiAgICAgICAgY3VycmVudC5hY3RpdmVPdmVybGF5VHlwZSA9PT0gdXBkYXRlLmFjdGl2ZU92ZXJsYXlUeXBlKSB7XG4gICAgICAvLyBhdm9pZCBkb2luZyBhIHN0YXRlIHVwZGF0ZSBpZiBub3RoaW5nIGNoYW5nZWRcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUodXBkYXRlKVxuICB9XG5cbiAgc2hvd1BhbmVsIChpZCkge1xuICAgIGNvbnN0IHsgdGFyZ2V0cyB9ID0gdGhpcy5nZXRQbHVnaW5TdGF0ZSgpXG5cbiAgICBjb25zdCBhY3RpdmVQaWNrZXJQYW5lbCA9IHRhcmdldHMuZmlsdGVyKCh0YXJnZXQpID0+IHtcbiAgICAgIHJldHVybiB0YXJnZXQudHlwZSA9PT0gJ2FjcXVpcmVyJyAmJiB0YXJnZXQuaWQgPT09IGlkXG4gICAgfSlbMF1cblxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgYWN0aXZlUGlja2VyUGFuZWw6IGFjdGl2ZVBpY2tlclBhbmVsLFxuICAgICAgYWN0aXZlT3ZlcmxheVR5cGU6ICdQaWNrZXJQYW5lbCdcbiAgICB9KVxuICB9XG5cbiAgb3Blbk1vZGFsICgpIHtcbiAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUgfSA9IGNyZWF0ZVByb21pc2UoKVxuICAgIC8vIHNhdmUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgdGhpcy5zYXZlZFNjcm9sbFBvc2l0aW9uID0gd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgLy8gc2F2ZSBhY3RpdmUgZWxlbWVudCwgc28gd2UgY2FuIHJlc3RvcmUgZm9jdXMgd2hlbiBtb2RhbCBpcyBjbG9zZWRcbiAgICB0aGlzLnNhdmVkQWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcblxuICAgIGlmICh0aGlzLm9wdHMuZGlzYWJsZVBhZ2VTY3JvbGxXaGVuTW9kYWxPcGVuKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ3VwcHktRGFzaGJvYXJkLWlzRml4ZWQnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdHMuYW5pbWF0ZU9wZW5DbG9zZSAmJiB0aGlzLmdldFBsdWdpblN0YXRlKCkuaXNDbG9zaW5nKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgICBpc0hpZGRlbjogZmFsc2VcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhbmltYXRpb25lbmQnLCBoYW5kbGVyLCBmYWxzZSlcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2FuaW1hdGlvbmVuZCcsIGhhbmRsZXIsIGZhbHNlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgaXNIaWRkZW46IGZhbHNlXG4gICAgICB9KVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0cy5icm93c2VyQmFja0J1dHRvbkNsb3NlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUJyb3dzZXJIaXN0b3J5KClcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgRVNDIGFuZCBUQUIga2V5cyBpbiBtb2RhbCBkaWFsb2dcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duSW5Nb2RhbClcblxuICAgIHRoaXMudXBweS5lbWl0KCdkYXNoYm9hcmQ6bW9kYWwtb3BlbicpXG5cbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgY2xvc2VNb2RhbCAob3B0cyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgbWFudWFsQ2xvc2UgPSB0cnVlIC8vIFdoZXRoZXIgdGhlIG1vZGFsIGlzIGJlaW5nIGNsb3NlZCBieSB0aGUgdXNlciAoYHRydWVgKSBvciBieSBvdGhlciBtZWFucyAoZS5nLiBicm93c2VyIGJhY2sgYnV0dG9uKVxuICAgIH0gPSBvcHRzXG5cbiAgICBjb25zdCB7IGlzSGlkZGVuLCBpc0Nsb3NpbmcgfSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGlmIChpc0hpZGRlbiB8fCBpc0Nsb3NpbmcpIHtcbiAgICAgIC8vIHNob3J0LWNpcmN1aXQgaWYgYW5pbWF0aW9uIGlzIG9uZ29pbmdcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSB9ID0gY3JlYXRlUHJvbWlzZSgpXG5cbiAgICBpZiAodGhpcy5vcHRzLmRpc2FibGVQYWdlU2Nyb2xsV2hlbk1vZGFsT3Blbikge1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCd1cHB5LURhc2hib2FyZC1pc0ZpeGVkJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRzLmFuaW1hdGVPcGVuQ2xvc2UpIHtcbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICBpc0Nsb3Npbmc6IHRydWVcbiAgICAgIH0pXG4gICAgICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgICBpc0hpZGRlbjogdHJ1ZSxcbiAgICAgICAgICBpc0Nsb3Npbmc6IGZhbHNlXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5zdXBlckZvY3VzLmNhbmNlbCgpXG4gICAgICAgIHRoaXMuc2F2ZWRBY3RpdmVFbGVtZW50LmZvY3VzKClcblxuICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FuaW1hdGlvbmVuZCcsIGhhbmRsZXIsIGZhbHNlKVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgaGFuZGxlciwgZmFsc2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICBpc0hpZGRlbjogdHJ1ZVxuICAgICAgfSlcblxuICAgICAgdGhpcy5zdXBlckZvY3VzLmNhbmNlbCgpXG4gICAgICB0aGlzLnNhdmVkQWN0aXZlRWxlbWVudC5mb2N1cygpXG5cbiAgICAgIHJlc29sdmUoKVxuICAgIH1cblxuICAgIC8vIGhhbmRsZSBFU0MgYW5kIFRBQiBrZXlzIGluIG1vZGFsIGRpYWxvZ1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd25Jbk1vZGFsKVxuXG4gICAgaWYgKG1hbnVhbENsb3NlKSB7XG4gICAgICBpZiAodGhpcy5vcHRzLmJyb3dzZXJCYWNrQnV0dG9uQ2xvc2UpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGxhdGVzdCBlbnRyeSBpbiB0aGUgaGlzdG9yeSBzdGF0ZSBpcyBvdXIgbW9kYWwgbmFtZVxuICAgICAgICBpZiAoaGlzdG9yeS5zdGF0ZSAmJiBoaXN0b3J5LnN0YXRlW3RoaXMubW9kYWxOYW1lXSkge1xuICAgICAgICAgIC8vIEdvIGJhY2sgaW4gaGlzdG9yeSB0byBjbGVhciBvdXQgdGhlIGVudHJ5IHdlIGNyZWF0ZWQgKHVsdGltYXRlbHkgY2xvc2luZyB0aGUgbW9kYWwpXG4gICAgICAgICAgaGlzdG9yeS5nbygtMSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBweS5lbWl0KCdkYXNoYm9hcmQ6bW9kYWwtY2xvc2VkJylcblxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBpc01vZGFsT3BlbiAoKSB7XG4gICAgcmV0dXJuICF0aGlzLmdldFBsdWdpblN0YXRlKCkuaXNIaWRkZW4gfHwgZmFsc2VcbiAgfVxuXG4gIHJlcXVlc3RDbG9zZU1vZGFsICgpIHtcbiAgICBpZiAodGhpcy5vcHRzLm9uUmVxdWVzdENsb3NlTW9kYWwpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdHMub25SZXF1ZXN0Q2xvc2VNb2RhbCgpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb3NlTW9kYWwoKVxuICB9XG5cbiAgdG9nZ2xlRmlsZUNhcmQgKGZpbGVJZCkge1xuICAgIGlmIChmaWxlSWQpIHtcbiAgICAgIHRoaXMudXBweS5lbWl0KCdkYXNoYm9hcmQ6ZmlsZS1lZGl0LXN0YXJ0JylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cHB5LmVtaXQoJ2Rhc2hib2FyZDpmaWxlLWVkaXQtY29tcGxldGUnKVxuICAgIH1cblxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgZmlsZUNhcmRGb3I6IGZpbGVJZCB8fCBudWxsLFxuICAgICAgYWN0aXZlT3ZlcmxheVR5cGU6IGZpbGVJZCA/ICdGaWxlQ2FyZCcgOiBudWxsXG4gICAgfSlcbiAgfVxuXG4gIHRvZ2dsZUFkZEZpbGVzUGFuZWwgKHNob3cpIHtcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIHNob3dBZGRGaWxlc1BhbmVsOiBzaG93LFxuICAgICAgYWN0aXZlT3ZlcmxheVR5cGU6IHNob3cgPyAnQWRkRmlsZXMnIDogbnVsbFxuICAgIH0pXG4gIH1cblxuICBhZGRGaWxlcyAoZmlsZXMpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IGZpbGVzLm1hcCgoZmlsZSkgPT4gKHtcbiAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgIHR5cGU6IGZpbGUudHlwZSxcbiAgICAgIGRhdGE6IGZpbGUsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC8vIHBhdGggb2YgdGhlIGZpbGUgcmVsYXRpdmUgdG8gdGhlIGFuY2VzdG9yIGRpcmVjdG9yeSB0aGUgdXNlciBzZWxlY3RlZC5cbiAgICAgICAgLy8gZS5nLiAnZG9jcy9PbGQgUHJhZ3VlL2FpcmJuYi5wZGYnXG4gICAgICAgIHJlbGF0aXZlUGF0aDogZmlsZS5yZWxhdGl2ZVBhdGggfHwgbnVsbFxuICAgICAgfVxuICAgIH0pKVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMudXBweS5hZGRGaWxlcyhkZXNjcmlwdG9ycylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgIH1cbiAgfVxuXG4gIC8vIF9fX1doeSBtYWtlIGluc2lkZXMgb2YgRGFzaGJvYXJkIGludmlzaWJsZSB1bnRpbCBmaXJzdCBSZXNpemVPYnNlcnZlciBldmVudCBpcyBlbWl0dGVkP1xuICAvLyAgICBSZXNpemVPYmVyc2VydmVyIGRvZXNuJ3QgZW1pdCB0aGUgZmlyc3QgcmVzaXplIGV2ZW50IGZhc3QgZW5vdWdoLCB1c2VycyBjYW4gc2VlIHRoZSBqdW1wIGZyb20gb25lIC51cHB5LXNpemUtLSB0byBhbm90aGVyIChlLmcuIGluIFNhZmFyaSlcbiAgLy8gX19fV2h5IG5vdCBhcHBseSB2aXNpYmlsaXR5IHByb3BlcnR5IHRvIC51cHB5LURhc2hib2FyZC1pbm5lcj9cbiAgLy8gICAgQmVjYXVzZSBpZGVhbGx5LCBhY2MgdG8gc3BlY3MsIFJlc2l6ZU9ic2VydmVyIHNob3VsZCBzZWUgaW52aXNpYmxlIGVsZW1lbnRzIGFzIG9mIHdpZHRoIDAuIFNvIGV2ZW4gdGhvdWdoIGFwcGx5aW5nIGludmlzaWJpbGl0eSB0byAudXBweS1EYXNoYm9hcmQtaW5uZXIgd29ya3Mgbm93LCBpdCBtYXkgbm90IHdvcmsgaW4gdGhlIGZ1dHVyZS5cbiAgc3RhcnRMaXN0ZW5pbmdUb1Jlc2l6ZSAoKSB7XG4gICAgLy8gV2F0Y2ggZm9yIERhc2hib2FyZCBjb250YWluZXIgKGAudXBweS1EYXNoYm9hcmQtaW5uZXJgKSByZXNpemVcbiAgICAvLyBhbmQgdXBkYXRlIGNvbnRhaW5lcldpZHRoL2NvbnRhaW5lckhlaWdodCBpbiBwbHVnaW4gc3RhdGUgYWNjb3JkaW5nbHkuXG4gICAgLy8gRW1pdHMgZmlyc3QgZXZlbnQgb24gaW5pdGlhbGl6YXRpb24uXG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcywgb2JzZXJ2ZXIpID0+IHtcbiAgICAgIGNvbnN0IHVwcHlEYXNoYm9hcmRJbm5lckVsID0gZW50cmllc1swXVxuXG4gICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHVwcHlEYXNoYm9hcmRJbm5lckVsLmNvbnRlbnRSZWN0XG5cbiAgICAgIHRoaXMudXBweS5sb2coYFtEYXNoYm9hcmRdIHJlc2l6ZWQ6ICR7d2lkdGh9IC8gJHtoZWlnaHR9YCwgJ2RlYnVnJylcblxuICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgIGNvbnRhaW5lcldpZHRoOiB3aWR0aCxcbiAgICAgICAgY29udGFpbmVySGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGFyZUluc2lkZXNSZWFkeVRvQmVWaXNpYmxlOiB0cnVlXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuZWwucXVlcnlTZWxlY3RvcignLnVwcHktRGFzaGJvYXJkLWlubmVyJykpXG5cbiAgICAvLyBJZiBSZXNpemVPYnNlcnZlciBmYWlscyB0byBlbWl0IGFuIGV2ZW50IHRlbGxpbmcgdXMgd2hhdCBzaXplIHRvIHVzZSAtIGRlZmF1bHQgdG8gdGhlIG1vYmlsZSB2aWV3XG4gICAgdGhpcy5tYWtlRGFzaGJvYXJkSW5zaWRlc1Zpc2libGVBbnl3YXlUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCBwbHVnaW5TdGF0ZSA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKVxuICAgICAgY29uc3QgaXNNb2RhbEFuZENsb3NlZCA9ICF0aGlzLm9wdHMuaW5saW5lICYmIHBsdWdpblN0YXRlLmlzSGlkZGVuXG4gICAgICBpZiAoXG4gICAgICAgIC8vIGlmIFJlc2l6ZU9ic2VydmVyIGhhc24ndCB5ZXQgZmlyZWQsXG4gICAgICAgICFwbHVnaW5TdGF0ZS5hcmVJbnNpZGVzUmVhZHlUb0JlVmlzaWJsZSAmJlxuICAgICAgICAvLyBhbmQgaXQncyBub3QgZHVlIHRvIHRoZSBtb2RhbCBiZWluZyBjbG9zZWRcbiAgICAgICAgIWlzTW9kYWxBbmRDbG9zZWRcbiAgICAgICkge1xuICAgICAgICB0aGlzLnVwcHkubG9nKFwiW0Rhc2hib2FyZF0gcmVzaXplIGV2ZW50IGRpZG4ndCBmaXJlIG9uIHRpbWU6IGRlZmF1bHRlZCB0byBtb2JpbGUgbGF5b3V0XCIsICdkZWJ1ZycpXG5cbiAgICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgICAgYXJlSW5zaWRlc1JlYWR5VG9CZVZpc2libGU6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LCAxMDAwKVxuICB9XG5cbiAgc3RvcExpc3RlbmluZ1RvUmVzaXplICgpIHtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubWFrZURhc2hib2FyZEluc2lkZXNWaXNpYmxlQW55d2F5VGltZW91dClcbiAgfVxuXG4gIC8vIFJlY29yZHMgd2hldGhlciB3ZSBoYXZlIGJlZW4gaW50ZXJhY3Rpbmcgd2l0aCB1cHB5IHJpZ2h0IG5vdywgd2hpY2ggaXMgdGhlbiB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHN0YXRlIHVwZGF0ZXMgc2hvdWxkIHRyaWdnZXIgYSByZWZvY3VzaW5nLlxuICByZWNvcmRJZkZvY3VzZWRPblVwcHlSZWNlbnRseSAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5lbC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICB0aGlzLmlmRm9jdXNlZE9uVXBweVJlY2VudGx5ID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlmRm9jdXNlZE9uVXBweVJlY2VudGx5ID0gZmFsc2VcbiAgICAgIC8vIF9fX1doeSBydW4gdGhpcy5zdXBlckZvY3VzLmNhbmNlbCBoZXJlIHdoZW4gaXQgYWxyZWFkeSBydW5zIGluIHN1cGVyRm9jdXNPbkVhY2hVcGRhdGU/XG4gICAgICAvLyAgICBCZWNhdXNlIHN1cGVyRm9jdXMgaXMgZGVib3VuY2VkLCB3aGVuIHdlIG1vdmUgZnJvbSBVcHB5IHRvIHNvbWUgb3RoZXIgZWxlbWVudCBvbiB0aGUgcGFnZSxcbiAgICAgIC8vICAgIHByZXZpb3VzbHkgcnVuIHN1cGVyRm9jdXMgc29tZXRpbWVzIGhpdHMgYW5kIG1vdmVzIGZvY3VzIGJhY2sgdG8gVXBweS5cbiAgICAgIHRoaXMuc3VwZXJGb2N1cy5jYW5jZWwoKVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUJyb3dzZXJIaXN0b3J5ICgpIHtcbiAgICAvLyBFbnN1cmUgaGlzdG9yeSBzdGF0ZSBkb2VzIG5vdCBhbHJlYWR5IGNvbnRhaW4gb3VyIG1vZGFsIG5hbWUgdG8gYXZvaWQgZG91YmxlLXB1c2hpbmdcbiAgICBpZiAoIWhpc3Rvcnkuc3RhdGUgfHwgIWhpc3Rvcnkuc3RhdGVbdGhpcy5tb2RhbE5hbWVdKSB7XG4gICAgICAvLyBQdXNoIHRvIGhpc3Rvcnkgc28gdGhhdCB0aGUgcGFnZSBpcyBub3QgbG9zdCBvbiBicm93c2VyIGJhY2sgYnV0dG9uIHByZXNzXG4gICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7XG4gICAgICAgIC4uLmhpc3Rvcnkuc3RhdGUsXG4gICAgICAgIFt0aGlzLm1vZGFsTmFtZV06IHRydWVcbiAgICAgIH0sICcnKVxuICAgIH1cblxuICAgIC8vIExpc3RlbiBmb3IgYmFjayBidXR0b24gcHJlc3Nlc1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuaGFuZGxlUG9wU3RhdGUsIGZhbHNlKVxuICB9XG5cbiAgaGFuZGxlUG9wU3RhdGUgKGV2ZW50KSB7XG4gICAgLy8gQ2xvc2UgdGhlIG1vZGFsIGlmIHRoZSBoaXN0b3J5IHN0YXRlIG5vIGxvbmdlciBjb250YWlucyBvdXIgbW9kYWwgbmFtZVxuICAgIGlmICh0aGlzLmlzTW9kYWxPcGVuKCkgJiYgKCFldmVudC5zdGF0ZSB8fCAhZXZlbnQuc3RhdGVbdGhpcy5tb2RhbE5hbWVdKSkge1xuICAgICAgdGhpcy5jbG9zZU1vZGFsKHsgbWFudWFsQ2xvc2U6IGZhbHNlIH0pXG4gICAgfVxuXG4gICAgLy8gV2hlbiB0aGUgYnJvd3NlciBiYWNrIGJ1dHRvbiBpcyBwcmVzc2VkIGFuZCB1cHB5IGlzIG5vdyB0aGUgbGF0ZXN0IGVudHJ5IGluIHRoZSBoaXN0b3J5IGJ1dCB0aGUgbW9kYWwgaXMgY2xvc2VkLCBmaXggdGhlIGhpc3RvcnkgYnkgcmVtb3ZpbmcgdGhlIHVwcHkgaGlzdG9yeSBlbnRyeVxuICAgIC8vIFRoaXMgb2NjdXJzIHdoZW4gYW5vdGhlciBlbnRyeSBpcyBhZGRlZCBpbnRvIHRoZSBoaXN0b3J5IHN0YXRlIHdoaWxlIHRoZSBtb2RhbCBpcyBvcGVuLCBhbmQgdGhlbiB0aGUgbW9kYWwgZ2V0cyBtYW51YWxseSBjbG9zZWRcbiAgICAvLyBTb2x2ZXMgUFIgIzU3NSAoaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvcHVsbC81NzUpXG4gICAgaWYgKCF0aGlzLmlzTW9kYWxPcGVuKCkgJiYgZXZlbnQuc3RhdGUgJiYgZXZlbnQuc3RhdGVbdGhpcy5tb2RhbE5hbWVdKSB7XG4gICAgICBoaXN0b3J5LmdvKC0xKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUtleURvd25Jbk1vZGFsIChldmVudCkge1xuICAgIC8vIGNsb3NlIG1vZGFsIG9uIGVzYyBrZXkgcHJlc3NcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gRVNDX0tFWSkgdGhpcy5yZXF1ZXN0Q2xvc2VNb2RhbChldmVudClcbiAgICAvLyB0cmFwIGZvY3VzIG9uIHRhYiBrZXkgcHJlc3NcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gVEFCX0tFWSkgdHJhcEZvY3VzLmZvck1vZGFsKGV2ZW50LCB0aGlzLmdldFBsdWdpblN0YXRlKCkuYWN0aXZlT3ZlcmxheVR5cGUsIHRoaXMuZWwpXG4gIH1cblxuICBoYW5kbGVDbGlja091dHNpZGUgKCkge1xuICAgIGlmICh0aGlzLm9wdHMuY2xvc2VNb2RhbE9uQ2xpY2tPdXRzaWRlKSB0aGlzLnJlcXVlc3RDbG9zZU1vZGFsKClcbiAgfVxuXG4gIGhhbmRsZVBhc3RlIChldmVudCkge1xuICAgIC8vIDEuIExldCBhbnkgYWNxdWlyZXIgcGx1Z2luIChVcmwvV2ViY2FtL2V0Yy4pIGhhbmRsZSBwYXN0ZXMgdG8gdGhlIHJvb3RcbiAgICB0aGlzLnVwcHkuaXRlcmF0ZVBsdWdpbnMoKHBsdWdpbikgPT4ge1xuICAgICAgaWYgKHBsdWdpbi50eXBlID09PSAnYWNxdWlyZXInKSB7XG4gICAgICAgIC8vIEV2ZXJ5IFBsdWdpbiB3aXRoIC50eXBlIGFjcXVpcmVyIGNhbiBkZWZpbmUgaGFuZGxlUm9vdFBhc3RlKGV2ZW50KVxuICAgICAgICBwbHVnaW4uaGFuZGxlUm9vdFBhc3RlICYmIHBsdWdpbi5oYW5kbGVSb290UGFzdGUoZXZlbnQpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIDIuIEFkZCBhbGwgZHJvcHBlZCBmaWxlc1xuICAgIGNvbnN0IGZpbGVzID0gdG9BcnJheShldmVudC5jbGlwYm9hcmREYXRhLmZpbGVzKVxuICAgIHRoaXMuYWRkRmlsZXMoZmlsZXMpXG4gIH1cblxuICBoYW5kbGVJbnB1dENoYW5nZSAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgY29uc3QgZmlsZXMgPSB0b0FycmF5KGV2ZW50LnRhcmdldC5maWxlcylcbiAgICB0aGlzLmFkZEZpbGVzKGZpbGVzKVxuICB9XG5cbiAgaGFuZGxlRHJhZ092ZXIgKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICAvLyAxLiBBZGQgYSBzbWFsbCAoKykgaWNvbiBvbiBkcm9wXG4gICAgLy8gKGFuZCBwcmV2ZW50IGJyb3dzZXJzIGZyb20gaW50ZXJwcmV0aW5nIHRoaXMgYXMgZmlsZXMgYmVpbmcgX21vdmVkXyBpbnRvIHRoZSBicm93c2VyLCBodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXMvMTk3OClcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdjb3B5J1xuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVtb3ZlRHJhZ092ZXJDbGFzc1RpbWVvdXQpXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7IGlzRHJhZ2dpbmdPdmVyOiB0cnVlIH0pXG4gIH1cblxuICBoYW5kbGVEcmFnTGVhdmUgKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZW1vdmVEcmFnT3ZlckNsYXNzVGltZW91dClcbiAgICAvLyBUaW1lb3V0IGFnYWluc3QgZmxpY2tlcmluZywgdGhpcyBzb2x1dGlvbiBpcyB0YWtlbiBmcm9tIGRyYWctZHJvcCBsaWJyYXJ5LiBTb2x1dGlvbiB3aXRoICdwb2ludGVyLWV2ZW50czogbm9uZScgZGlkbid0IHdvcmsgYWNyb3NzIGJyb3dzZXJzLlxuICAgIHRoaXMucmVtb3ZlRHJhZ092ZXJDbGFzc1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoeyBpc0RyYWdnaW5nT3ZlcjogZmFsc2UgfSlcbiAgICB9LCA1MClcbiAgfVxuXG4gIGhhbmRsZURyb3AgKGV2ZW50LCBkcm9wQ2F0ZWdvcnkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZW1vdmVEcmFnT3ZlckNsYXNzVGltZW91dClcblxuICAgIC8vIDIuIFJlbW92ZSBkcmFnb3ZlciBjbGFzc1xuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoeyBpc0RyYWdnaW5nT3ZlcjogZmFsc2UgfSlcblxuICAgIC8vIDMuIExldCBhbnkgYWNxdWlyZXIgcGx1Z2luIChVcmwvV2ViY2FtL2V0Yy4pIGhhbmRsZSBkcm9wcyB0byB0aGUgcm9vdFxuICAgIHRoaXMudXBweS5pdGVyYXRlUGx1Z2lucygocGx1Z2luKSA9PiB7XG4gICAgICBpZiAocGx1Z2luLnR5cGUgPT09ICdhY3F1aXJlcicpIHtcbiAgICAgICAgLy8gRXZlcnkgUGx1Z2luIHdpdGggLnR5cGUgYWNxdWlyZXIgY2FuIGRlZmluZSBoYW5kbGVSb290RHJvcChldmVudClcbiAgICAgICAgcGx1Z2luLmhhbmRsZVJvb3REcm9wICYmIHBsdWdpbi5oYW5kbGVSb290RHJvcChldmVudClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gNC4gQWRkIGFsbCBkcm9wcGVkIGZpbGVzXG4gICAgbGV0IGV4ZWN1dGVkRHJvcEVycm9yT25jZSA9IGZhbHNlXG4gICAgY29uc3QgbG9nRHJvcEVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLnVwcHkubG9nKGVycm9yLCAnZXJyb3InKVxuXG4gICAgICAvLyBJbiBwcmFjdGljZSBhbGwgZHJvcCBlcnJvcnMgYXJlIG1vc3QgbGlrZWx5IHRoZSBzYW1lLCBzbyBsZXQncyBqdXN0IHNob3cgb25lIHRvIGF2b2lkIG92ZXJ3aGVsbWluZyB0aGUgdXNlclxuICAgICAgaWYgKCFleGVjdXRlZERyb3BFcnJvck9uY2UpIHtcbiAgICAgICAgdGhpcy51cHB5LmluZm8oZXJyb3IubWVzc2FnZSwgJ2Vycm9yJylcbiAgICAgICAgZXhlY3V0ZWREcm9wRXJyb3JPbmNlID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBnZXREcm9wcGVkRmlsZXMoZXZlbnQuZGF0YVRyYW5zZmVyLCB7IGxvZ0Ryb3BFcnJvciB9KVxuICAgICAgLnRoZW4oKGZpbGVzKSA9PiB7XG4gICAgICAgIGlmIChmaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy51cHB5LmxvZygnW0Rhc2hib2FyZF0gRmlsZXMgd2VyZSBkcm9wcGVkJylcbiAgICAgICAgICB0aGlzLmFkZEZpbGVzKGZpbGVzKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgaGFuZGxlS2V5RG93bkluSW5saW5lIChldmVudCkge1xuICAgIC8vIFRyYXAgZm9jdXMgb24gdGFiIGtleSBwcmVzcy5cbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gVEFCX0tFWSkgdHJhcEZvY3VzLmZvcklubGluZShldmVudCwgdGhpcy5nZXRQbHVnaW5TdGF0ZSgpLmFjdGl2ZU92ZXJsYXlUeXBlLCB0aGlzLmVsKVxuICB9XG5cbiAgLy8gX19fV2h5IGRvIHdlIGxpc3RlbiB0byB0aGUgJ3Bhc3RlJyBldmVudCBvbiBhIGRvY3VtZW50IGluc3RlYWQgb2Ygb25QYXN0ZT17cHJvcHMuaGFuZGxlUGFzdGV9IHByb3AsIG9yIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcigncGFzdGUnKT9cbiAgLy8gICAgQmVjYXVzZSAoYXQgbGVhc3QpIENocm9tZSBkb2Vzbid0IGhhbmRsZSBwYXN0ZSBpZiBmb2N1cyBpcyBvbiBzb21lIGJ1dHRvbiwgZS5nLiAnTXkgRGV2aWNlJy5cbiAgLy8gICAgPT4gVGhlcmVmb3JlLCB0aGUgYmVzdCBvcHRpb24gaXMgdG8gbGlzdGVuIHRvIGFsbCAncGFzdGUnIGV2ZW50cywgYW5kIG9ubHkgcmVhY3QgdG8gdGhlbSB3aGVuIHdlIGFyZSBmb2N1c2VkIG9uIG91ciBwYXJ0aWN1bGFyIFVwcHkgaW5zdGFuY2UuXG4gIC8vIF9fX1doeSBkbyB3ZSBzdGlsbCBuZWVkIG9uUGFzdGU9e3Byb3BzLmhhbmRsZVBhc3RlfSBmb3IgdGhlIERhc2hib2FyZFVpP1xuICAvLyAgICBCZWNhdXNlIGlmIHdlIGNsaWNrIG9uIHRoZSAnRHJvcCBmaWxlcyBoZXJlJyBjYXB0aW9uIGUuZy4sIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCB3aWxsIGJlICdib2R5Jy4gV2hpY2ggbWVhbnMgb3VyIHN0YW5kYXJkIGRldGVybWluYXRpb24gb2Ygd2hldGhlciB3ZSdyZSBwYXN0aW5nIGludG8gb3VyIFVwcHkgaW5zdGFuY2Ugd29uJ3Qgd29yay5cbiAgLy8gICAgPT4gVGhlcmVmb3JlLCB3ZSBuZWVkIGEgdHJhZGl0aW9uYWwgb25QYXN0ZT17cHJvcHMuaGFuZGxlUGFzdGV9IGhhbmRsZXIgdG9vLlxuICBoYW5kbGVQYXN0ZU9uQm9keSAoZXZlbnQpIHtcbiAgICBjb25zdCBpc0ZvY3VzSW5PdmVybGF5ID0gdGhpcy5lbC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuICAgIGlmIChpc0ZvY3VzSW5PdmVybGF5KSB7XG4gICAgICB0aGlzLmhhbmRsZVBhc3RlKGV2ZW50KVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUNvbXBsZXRlICh7IGZhaWxlZCwgdXBsb2FkSUQgfSkge1xuICAgIGlmICh0aGlzLm9wdHMuY2xvc2VBZnRlckZpbmlzaCAmJiBmYWlsZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBBbGwgdXBsb2FkcyBhcmUgZG9uZVxuICAgICAgdGhpcy5yZXF1ZXN0Q2xvc2VNb2RhbCgpXG4gICAgfVxuICB9XG5cbiAgaW5pdEV2ZW50cyAoKSB7XG4gICAgLy8gTW9kYWwgb3BlbiBidXR0b25cbiAgICBjb25zdCBzaG93TW9kYWxUcmlnZ2VyID0gZmluZEFsbERPTUVsZW1lbnRzKHRoaXMub3B0cy50cmlnZ2VyKVxuICAgIGlmICghdGhpcy5vcHRzLmlubGluZSAmJiBzaG93TW9kYWxUcmlnZ2VyKSB7XG4gICAgICBzaG93TW9kYWxUcmlnZ2VyLmZvckVhY2godHJpZ2dlciA9PiB0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vcGVuTW9kYWwpKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5vcHRzLmlubGluZSAmJiAhc2hvd01vZGFsVHJpZ2dlcikge1xuICAgICAgdGhpcy51cHB5LmxvZygnRGFzaGJvYXJkIG1vZGFsIHRyaWdnZXIgbm90IGZvdW5kLiBNYWtlIHN1cmUgYHRyaWdnZXJgIGlzIHNldCBpbiBEYXNoYm9hcmQgb3B0aW9ucyB1bmxlc3MgeW91IGFyZSBwbGFubmluZyB0byBjYWxsIG9wZW5Nb2RhbCgpIG1ldGhvZCB5b3Vyc2VsZicsICdlcnJvcicpXG4gICAgfVxuXG4gICAgdGhpcy5zdGFydExpc3RlbmluZ1RvUmVzaXplKClcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIHRoaXMuaGFuZGxlUGFzdGVPbkJvZHkpXG5cbiAgICB0aGlzLnVwcHkub24oJ3BsdWdpbi1yZW1vdmUnLCB0aGlzLnJlbW92ZVRhcmdldClcbiAgICB0aGlzLnVwcHkub24oJ2ZpbGUtYWRkZWQnLCB0aGlzLmhpZGVBbGxQYW5lbHMpXG4gICAgdGhpcy51cHB5Lm9uKCdkYXNoYm9hcmQ6bW9kYWwtY2xvc2VkJywgdGhpcy5oaWRlQWxsUGFuZWxzKVxuICAgIHRoaXMudXBweS5vbignY29tcGxldGUnLCB0aGlzLmhhbmRsZUNvbXBsZXRlKVxuXG4gICAgLy8gX19fV2h5IGZpcmUgb24gY2FwdHVyZT9cbiAgICAvLyAgICBCZWNhdXNlIHRoaXMuaWZGb2N1c2VkT25VcHB5UmVjZW50bHkgbmVlZHMgdG8gY2hhbmdlIGJlZm9yZSBvblVwZGF0ZSgpIGZpcmVzLlxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5yZWNvcmRJZkZvY3VzZWRPblVwcHlSZWNlbnRseSwgdHJ1ZSlcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMucmVjb3JkSWZGb2N1c2VkT25VcHB5UmVjZW50bHksIHRydWUpXG5cbiAgICBpZiAodGhpcy5vcHRzLmlubGluZSkge1xuICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duSW5JbmxpbmUpXG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlRXZlbnRzICgpIHtcbiAgICBjb25zdCBzaG93TW9kYWxUcmlnZ2VyID0gZmluZEFsbERPTUVsZW1lbnRzKHRoaXMub3B0cy50cmlnZ2VyKVxuICAgIGlmICghdGhpcy5vcHRzLmlubGluZSAmJiBzaG93TW9kYWxUcmlnZ2VyKSB7XG4gICAgICBzaG93TW9kYWxUcmlnZ2VyLmZvckVhY2godHJpZ2dlciA9PiB0cmlnZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vcGVuTW9kYWwpKVxuICAgIH1cblxuICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvUmVzaXplKClcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwYXN0ZScsIHRoaXMuaGFuZGxlUGFzdGVPbkJvZHkpXG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLmhhbmRsZVBvcFN0YXRlLCBmYWxzZSlcbiAgICB0aGlzLnVwcHkub2ZmKCdwbHVnaW4tcmVtb3ZlJywgdGhpcy5yZW1vdmVUYXJnZXQpXG4gICAgdGhpcy51cHB5Lm9mZignZmlsZS1hZGRlZCcsIHRoaXMuaGlkZUFsbFBhbmVscylcbiAgICB0aGlzLnVwcHkub2ZmKCdkYXNoYm9hcmQ6bW9kYWwtY2xvc2VkJywgdGhpcy5oaWRlQWxsUGFuZWxzKVxuICAgIHRoaXMudXBweS5vZmYoJ2NvbXBsZXRlJywgdGhpcy5oYW5kbGVDb21wbGV0ZSlcblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5yZWNvcmRJZkZvY3VzZWRPblVwcHlSZWNlbnRseSlcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMucmVjb3JkSWZGb2N1c2VkT25VcHB5UmVjZW50bHkpXG5cbiAgICBpZiAodGhpcy5vcHRzLmlubGluZSkge1xuICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duSW5JbmxpbmUpXG4gICAgfVxuICB9XG5cbiAgc3VwZXJGb2N1c09uRWFjaFVwZGF0ZSAoKSB7XG4gICAgY29uc3QgaXNGb2N1c0luVXBweSA9IHRoaXMuZWwuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcbiAgICAvLyBXaGVuIGZvY3VzIGlzIGxvc3Qgb24gdGhlIHBhZ2UgKD09IGZvY3VzIGlzIG9uIGJvZHkgZm9yIG1vc3QgYnJvd3NlcnMsIG9yIGZvY3VzIGlzIG51bGwgZm9yIElFMTEpXG4gICAgY29uc3QgaXNGb2N1c05vd2hlcmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JykgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gbnVsbFxuICAgIGNvbnN0IGlzSW5mb3JtZXJIaWRkZW4gPSB0aGlzLnVwcHkuZ2V0U3RhdGUoKS5pbmZvLmlzSGlkZGVuXG4gICAgY29uc3QgaXNNb2RhbCA9ICF0aGlzLm9wdHMuaW5saW5lXG5cbiAgICBpZiAoXG4gICAgICAvLyBJZiB1cGRhdGUgaXMgY29ubmVjdGVkIHRvIHNob3dpbmcgdGhlIEluZm9ybWVyIC0gbGV0IHRoZSBzY3JlZW4gcmVhZGVyIGNhbG1seSByZWFkIGl0LlxuICAgICAgaXNJbmZvcm1lckhpZGRlbiAmJlxuICAgICAgKFxuICAgICAgICAvLyBJZiB3ZSBhcmUgaW4gYSBtb2RhbCAtIGFsd2F5cyBzdXBlcmZvY3VzIHdpdGhvdXQgY29uY2VybiBmb3Igb3RoZXIgZWxlbWVudHMgb24gdGhlIHBhZ2UgKHVzZXIgaXMgdW5saWtlbHkgdG8gd2FudCB0byBpbnRlcmFjdCB3aXRoIHRoZSByZXN0IG9mIHRoZSBwYWdlKVxuICAgICAgICBpc01vZGFsIHx8XG4gICAgICAgIC8vIElmIHdlIGFyZSBhbHJlYWR5IGluc2lkZSBvZiBVcHB5LCBvclxuICAgICAgICBpc0ZvY3VzSW5VcHB5IHx8XG4gICAgICAgIC8vIElmIHdlIGFyZSBub3QgZm9jdXNlZCBvbiBhbnl0aGluZyBCVVQgd2UgaGF2ZSBhbHJlYWR5LCBhdCBsZWFzdCBvbmNlLCBmb2N1c2VkIG9uIHVwcHlcbiAgICAgICAgLy8gICAxLiBXZSBmb2N1cyB3aGVuIGlzRm9jdXNOb3doZXJlLCBiZWNhdXNlIHdoZW4gdGhlIGVsZW1lbnQgd2Ugd2VyZSBmb2N1c2VkIG9uIGRpc2FwcGVhcnMgKGUuZy4gYW4gb3ZlcmxheSksIC0gZm9jdXMgZ2V0cyBsb3N0LiBJZiB1c2VyIGlzIHR5cGluZyBzb21ldGhpbmcgc29tZXdoZXJlIGVsc2Ugb24gdGhlIHBhZ2UsIC0gZm9jdXMgd29uJ3QgYmUgJ25vd2hlcmUnLlxuICAgICAgICAvLyAgIDIuIFdlIG9ubHkgZm9jdXMgd2hlbiBmb2N1cyBpcyBub3doZXJlIEFORCB0aGlzLmlmRm9jdXNlZE9uVXBweVJlY2VudGx5LCB0byBhdm9pZCBmb2N1cyBqdW1wcyBpZiB3ZSBkbyBzb21ldGhpbmcgZWxzZSBvbiB0aGUgcGFnZS5cbiAgICAgICAgLy8gICBbUHJhY3RpY2FsIGNoZWNrXSBXaXRob3V0ICcmJiB0aGlzLmlmRm9jdXNlZE9uVXBweVJlY2VudGx5JywgaW4gU2FmYXJpLCBpbiBpbmxpbmUgbW9kZSwgd2hlbiBmaWxlIGlzIHVwbG9hZGluZywgLSBuYXZpZ2F0ZSB2aWEgdGFiIHRvIHRoZSBjaGVja2JveCwgdHJ5IHRvIHByZXNzIHNwYWNlIG11bHRpcGxlIHRpbWVzLiBGb2N1cyB3aWxsIGp1bXAgdG8gVXBweS5cbiAgICAgICAgKGlzRm9jdXNOb3doZXJlICYmIHRoaXMuaWZGb2N1c2VkT25VcHB5UmVjZW50bHkpXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aGlzLnN1cGVyRm9jdXModGhpcy5lbCwgdGhpcy5nZXRQbHVnaW5TdGF0ZSgpLmFjdGl2ZU92ZXJsYXlUeXBlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN1cGVyRm9jdXMuY2FuY2VsKClcbiAgICB9XG4gIH1cblxuICBhZnRlclVwZGF0ZSAoKSB7XG4gICAgdGhpcy5zdXBlckZvY3VzT25FYWNoVXBkYXRlKClcbiAgfVxuXG4gIGNhbmNlbFVwbG9hZCA9IChmaWxlSUQpID0+IHtcbiAgICB0aGlzLnVwcHkucmVtb3ZlRmlsZShmaWxlSUQpXG4gIH1cblxuICBzYXZlRmlsZUNhcmQgPSAobWV0YSwgZmlsZUlEKSA9PiB7XG4gICAgdGhpcy51cHB5LnNldEZpbGVNZXRhKGZpbGVJRCwgbWV0YSlcbiAgICB0aGlzLnRvZ2dsZUZpbGVDYXJkKClcbiAgfVxuXG4gIF9hdHRhY2hSZW5kZXJGdW5jdGlvblRvVGFyZ2V0ID0gKHRhcmdldCkgPT4ge1xuICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMudXBweS5nZXRQbHVnaW4odGFyZ2V0LmlkKVxuICAgIHJldHVybiB7XG4gICAgICAuLi50YXJnZXQsXG4gICAgICBpY29uOiBwbHVnaW4uaWNvbiB8fCB0aGlzLm9wdHMuZGVmYXVsdFBpY2tlckljb24sXG4gICAgICByZW5kZXI6IHBsdWdpbi5yZW5kZXJcbiAgICB9XG4gIH1cblxuICBfaXNUYXJnZXRTdXBwb3J0ZWQgPSAodGFyZ2V0KSA9PiB7XG4gICAgY29uc3QgcGx1Z2luID0gdGhpcy51cHB5LmdldFBsdWdpbih0YXJnZXQuaWQpXG4gICAgLy8gSWYgdGhlIHBsdWdpbiBkb2VzIG5vdCBwcm92aWRlIGEgYHN1cHBvcnRlZGAgY2hlY2ssIGFzc3VtZSB0aGUgcGx1Z2luIHdvcmtzIGV2ZXJ5d2hlcmUuXG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaXNTdXBwb3J0ZWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBwbHVnaW4uaXNTdXBwb3J0ZWQoKVxuICB9XG5cbiAgX2dldEFjcXVpcmVycyA9IG1lbW9pemUoKHRhcmdldHMpID0+IHtcbiAgICByZXR1cm4gdGFyZ2V0c1xuICAgICAgLmZpbHRlcih0YXJnZXQgPT4gdGFyZ2V0LnR5cGUgPT09ICdhY3F1aXJlcicgJiYgdGhpcy5faXNUYXJnZXRTdXBwb3J0ZWQodGFyZ2V0KSlcbiAgICAgIC5tYXAodGhpcy5fYXR0YWNoUmVuZGVyRnVuY3Rpb25Ub1RhcmdldClcbiAgfSlcblxuICBfZ2V0UHJvZ3Jlc3NJbmRpY2F0b3JzID0gbWVtb2l6ZSgodGFyZ2V0cykgPT4ge1xuICAgIHJldHVybiB0YXJnZXRzXG4gICAgICAuZmlsdGVyKHRhcmdldCA9PiB0YXJnZXQudHlwZSA9PT0gJ3Byb2dyZXNzaW5kaWNhdG9yJylcbiAgICAgIC5tYXAodGhpcy5fYXR0YWNoUmVuZGVyRnVuY3Rpb25Ub1RhcmdldClcbiAgfSlcblxuICByZW5kZXIgKHN0YXRlKSB7XG4gICAgY29uc3QgcGx1Z2luU3RhdGUgPSB0aGlzLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCB7IGZpbGVzLCBjYXBhYmlsaXRpZXMsIGFsbG93TmV3VXBsb2FkIH0gPSBzdGF0ZVxuXG4gICAgLy8gVE9ETzogbW92ZSB0aGlzIHRvIENvcmUsIHRvIHNoYXJlIGJldHdlZW4gU3RhdHVzIEJhciBhbmQgRGFzaGJvYXJkXG4gICAgLy8gKGFuZCBhbnkgb3RoZXIgcGx1Z2luIHRoYXQgbWlnaHQgbmVlZCBpdCwgdG9vKVxuICAgIGNvbnN0IG5ld0ZpbGVzID0gT2JqZWN0LmtleXMoZmlsZXMpLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuICFmaWxlc1tmaWxlXS5wcm9ncmVzcy51cGxvYWRTdGFydGVkXG4gICAgfSlcblxuICAgIGNvbnN0IHVwbG9hZFN0YXJ0ZWRGaWxlcyA9IE9iamVjdC5rZXlzKGZpbGVzKS5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiBmaWxlc1tmaWxlXS5wcm9ncmVzcy51cGxvYWRTdGFydGVkXG4gICAgfSlcblxuICAgIGNvbnN0IHBhdXNlZEZpbGVzID0gT2JqZWN0LmtleXMoZmlsZXMpLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIGZpbGVzW2ZpbGVdLmlzUGF1c2VkXG4gICAgfSlcblxuICAgIGNvbnN0IGNvbXBsZXRlRmlsZXMgPSBPYmplY3Qua2V5cyhmaWxlcykuZmlsdGVyKChmaWxlKSA9PiB7XG4gICAgICByZXR1cm4gZmlsZXNbZmlsZV0ucHJvZ3Jlc3MudXBsb2FkQ29tcGxldGVcbiAgICB9KVxuXG4gICAgY29uc3QgZXJyb3JlZEZpbGVzID0gT2JqZWN0LmtleXMoZmlsZXMpLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIGZpbGVzW2ZpbGVdLmVycm9yXG4gICAgfSlcblxuICAgIGNvbnN0IGluUHJvZ3Jlc3NGaWxlcyA9IE9iamVjdC5rZXlzKGZpbGVzKS5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiAhZmlsZXNbZmlsZV0ucHJvZ3Jlc3MudXBsb2FkQ29tcGxldGUgJiZcbiAgICAgICAgICAgICBmaWxlc1tmaWxlXS5wcm9ncmVzcy51cGxvYWRTdGFydGVkXG4gICAgfSlcblxuICAgIGNvbnN0IGluUHJvZ3Jlc3NOb3RQYXVzZWRGaWxlcyA9IGluUHJvZ3Jlc3NGaWxlcy5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiAhZmlsZXNbZmlsZV0uaXNQYXVzZWRcbiAgICB9KVxuXG4gICAgY29uc3QgcHJvY2Vzc2luZ0ZpbGVzID0gT2JqZWN0LmtleXMoZmlsZXMpLmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIGZpbGVzW2ZpbGVdLnByb2dyZXNzLnByZXByb2Nlc3MgfHwgZmlsZXNbZmlsZV0ucHJvZ3Jlc3MucG9zdHByb2Nlc3NcbiAgICB9KVxuXG4gICAgY29uc3QgaXNVcGxvYWRTdGFydGVkID0gdXBsb2FkU3RhcnRlZEZpbGVzLmxlbmd0aCA+IDBcblxuICAgIGNvbnN0IGlzQWxsQ29tcGxldGUgPSBzdGF0ZS50b3RhbFByb2dyZXNzID09PSAxMDAgJiZcbiAgICAgIGNvbXBsZXRlRmlsZXMubGVuZ3RoID09PSBPYmplY3Qua2V5cyhmaWxlcykubGVuZ3RoICYmXG4gICAgICBwcm9jZXNzaW5nRmlsZXMubGVuZ3RoID09PSAwXG5cbiAgICBjb25zdCBpc0FsbEVycm9yZWQgPSBpc1VwbG9hZFN0YXJ0ZWQgJiZcbiAgICAgIGVycm9yZWRGaWxlcy5sZW5ndGggPT09IHVwbG9hZFN0YXJ0ZWRGaWxlcy5sZW5ndGhcblxuICAgIGNvbnN0IGlzQWxsUGF1c2VkID0gaW5Qcm9ncmVzc0ZpbGVzLmxlbmd0aCAhPT0gMCAmJlxuICAgICAgcGF1c2VkRmlsZXMubGVuZ3RoID09PSBpblByb2dyZXNzRmlsZXMubGVuZ3RoXG5cbiAgICBjb25zdCBhY3F1aXJlcnMgPSB0aGlzLl9nZXRBY3F1aXJlcnMocGx1Z2luU3RhdGUudGFyZ2V0cylcbiAgICBjb25zdCBwcm9ncmVzc2luZGljYXRvcnMgPSB0aGlzLl9nZXRQcm9ncmVzc0luZGljYXRvcnMocGx1Z2luU3RhdGUudGFyZ2V0cylcblxuICAgIHJldHVybiBEYXNoYm9hcmRVSSh7XG4gICAgICBzdGF0ZSxcbiAgICAgIGlzSGlkZGVuOiBwbHVnaW5TdGF0ZS5pc0hpZGRlbixcbiAgICAgIGZpbGVzLFxuICAgICAgbmV3RmlsZXMsXG4gICAgICB1cGxvYWRTdGFydGVkRmlsZXMsXG4gICAgICBjb21wbGV0ZUZpbGVzLFxuICAgICAgZXJyb3JlZEZpbGVzLFxuICAgICAgaW5Qcm9ncmVzc0ZpbGVzLFxuICAgICAgaW5Qcm9ncmVzc05vdFBhdXNlZEZpbGVzLFxuICAgICAgcHJvY2Vzc2luZ0ZpbGVzLFxuICAgICAgaXNVcGxvYWRTdGFydGVkLFxuICAgICAgaXNBbGxDb21wbGV0ZSxcbiAgICAgIGlzQWxsRXJyb3JlZCxcbiAgICAgIGlzQWxsUGF1c2VkLFxuICAgICAgdG90YWxGaWxlQ291bnQ6IE9iamVjdC5rZXlzKGZpbGVzKS5sZW5ndGgsXG4gICAgICB0b3RhbFByb2dyZXNzOiBzdGF0ZS50b3RhbFByb2dyZXNzLFxuICAgICAgYWxsb3dOZXdVcGxvYWQsXG4gICAgICBhY3F1aXJlcnMsXG4gICAgICBhY3RpdmVQaWNrZXJQYW5lbDogcGx1Z2luU3RhdGUuYWN0aXZlUGlja2VyUGFuZWwsXG4gICAgICBhbmltYXRlT3BlbkNsb3NlOiB0aGlzLm9wdHMuYW5pbWF0ZU9wZW5DbG9zZSxcbiAgICAgIGlzQ2xvc2luZzogcGx1Z2luU3RhdGUuaXNDbG9zaW5nLFxuICAgICAgZ2V0UGx1Z2luOiB0aGlzLnVwcHkuZ2V0UGx1Z2luLFxuICAgICAgcHJvZ3Jlc3NpbmRpY2F0b3JzOiBwcm9ncmVzc2luZGljYXRvcnMsXG4gICAgICBhdXRvUHJvY2VlZDogdGhpcy51cHB5Lm9wdHMuYXV0b1Byb2NlZWQsXG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGNsb3NlTW9kYWw6IHRoaXMucmVxdWVzdENsb3NlTW9kYWwsXG4gICAgICBoYW5kbGVDbGlja091dHNpZGU6IHRoaXMuaGFuZGxlQ2xpY2tPdXRzaWRlLFxuICAgICAgaGFuZGxlSW5wdXRDaGFuZ2U6IHRoaXMuaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgICBoYW5kbGVQYXN0ZTogdGhpcy5oYW5kbGVQYXN0ZSxcbiAgICAgIGlubGluZTogdGhpcy5vcHRzLmlubGluZSxcbiAgICAgIHNob3dQYW5lbDogdGhpcy5zaG93UGFuZWwsXG4gICAgICBoaWRlQWxsUGFuZWxzOiB0aGlzLmhpZGVBbGxQYW5lbHMsXG4gICAgICBsb2c6IHRoaXMudXBweS5sb2csXG4gICAgICBpMThuOiB0aGlzLmkxOG4sXG4gICAgICBpMThuQXJyYXk6IHRoaXMuaTE4bkFycmF5LFxuICAgICAgcmVtb3ZlRmlsZTogdGhpcy51cHB5LnJlbW92ZUZpbGUsXG4gICAgICBpbmZvOiB0aGlzLnVwcHkuaW5mbyxcbiAgICAgIG5vdGU6IHRoaXMub3B0cy5ub3RlLFxuICAgICAgbWV0YUZpZWxkczogcGx1Z2luU3RhdGUubWV0YUZpZWxkcyxcbiAgICAgIHJlc3VtYWJsZVVwbG9hZHM6IGNhcGFiaWxpdGllcy5yZXN1bWFibGVVcGxvYWRzIHx8IGZhbHNlLFxuICAgICAgaW5kaXZpZHVhbENhbmNlbGxhdGlvbjogY2FwYWJpbGl0aWVzLmluZGl2aWR1YWxDYW5jZWxsYXRpb24sXG4gICAgICBwYXVzZVVwbG9hZDogdGhpcy51cHB5LnBhdXNlUmVzdW1lLFxuICAgICAgcmV0cnlVcGxvYWQ6IHRoaXMudXBweS5yZXRyeVVwbG9hZCxcbiAgICAgIGNhbmNlbFVwbG9hZDogdGhpcy5jYW5jZWxVcGxvYWQsXG4gICAgICBjYW5jZWxBbGw6IHRoaXMudXBweS5jYW5jZWxBbGwsXG4gICAgICBmaWxlQ2FyZEZvcjogcGx1Z2luU3RhdGUuZmlsZUNhcmRGb3IsXG4gICAgICB0b2dnbGVGaWxlQ2FyZDogdGhpcy50b2dnbGVGaWxlQ2FyZCxcbiAgICAgIHRvZ2dsZUFkZEZpbGVzUGFuZWw6IHRoaXMudG9nZ2xlQWRkRmlsZXNQYW5lbCxcbiAgICAgIHNob3dBZGRGaWxlc1BhbmVsOiBwbHVnaW5TdGF0ZS5zaG93QWRkRmlsZXNQYW5lbCxcbiAgICAgIHNhdmVGaWxlQ2FyZDogdGhpcy5zYXZlRmlsZUNhcmQsXG4gICAgICB3aWR0aDogdGhpcy5vcHRzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLm9wdHMuaGVpZ2h0LFxuICAgICAgc2hvd0xpbmtUb0ZpbGVVcGxvYWRSZXN1bHQ6IHRoaXMub3B0cy5zaG93TGlua1RvRmlsZVVwbG9hZFJlc3VsdCxcbiAgICAgIHByb3VkbHlEaXNwbGF5UG93ZXJlZEJ5VXBweTogdGhpcy5vcHRzLnByb3VkbHlEaXNwbGF5UG93ZXJlZEJ5VXBweSxcbiAgICAgIGhpZGVDYW5jZWxCdXR0b246IHRoaXMub3B0cy5oaWRlQ2FuY2VsQnV0dG9uLFxuICAgICAgY29udGFpbmVyV2lkdGg6IHBsdWdpblN0YXRlLmNvbnRhaW5lcldpZHRoLFxuICAgICAgY29udGFpbmVySGVpZ2h0OiBwbHVnaW5TdGF0ZS5jb250YWluZXJIZWlnaHQsXG4gICAgICBhcmVJbnNpZGVzUmVhZHlUb0JlVmlzaWJsZTogcGx1Z2luU3RhdGUuYXJlSW5zaWRlc1JlYWR5VG9CZVZpc2libGUsXG4gICAgICBpc1RhcmdldERPTUVsOiB0aGlzLmlzVGFyZ2V0RE9NRWwsXG4gICAgICBwYXJlbnRFbGVtZW50OiB0aGlzLmVsLFxuICAgICAgYWxsb3dlZEZpbGVUeXBlczogdGhpcy51cHB5Lm9wdHMucmVzdHJpY3Rpb25zLmFsbG93ZWRGaWxlVHlwZXMsXG4gICAgICBtYXhOdW1iZXJPZkZpbGVzOiB0aGlzLnVwcHkub3B0cy5yZXN0cmljdGlvbnMubWF4TnVtYmVyT2ZGaWxlcyxcbiAgICAgIHNob3dTZWxlY3RlZEZpbGVzOiB0aGlzLm9wdHMuc2hvd1NlbGVjdGVkRmlsZXMsXG4gICAgICAvLyBkcmFnIHByb3BzXG4gICAgICBpc0RyYWdnaW5nT3ZlcjogcGx1Z2luU3RhdGUuaXNEcmFnZ2luZ092ZXIsXG4gICAgICBoYW5kbGVEcmFnT3ZlcjogdGhpcy5oYW5kbGVEcmFnT3ZlcixcbiAgICAgIGhhbmRsZURyYWdMZWF2ZTogdGhpcy5oYW5kbGVEcmFnTGVhdmUsXG4gICAgICBoYW5kbGVEcm9wOiB0aGlzLmhhbmRsZURyb3BcbiAgICB9KVxuICB9XG5cbiAgZGlzY292ZXJQcm92aWRlclBsdWdpbnMgKCkge1xuICAgIHRoaXMudXBweS5pdGVyYXRlUGx1Z2lucygocGx1Z2luKSA9PiB7XG4gICAgICBpZiAocGx1Z2luICYmICFwbHVnaW4udGFyZ2V0ICYmIHBsdWdpbi5vcHRzICYmIHBsdWdpbi5vcHRzLnRhcmdldCA9PT0gdGhpcy5jb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aGlzLmFkZFRhcmdldChwbHVnaW4pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIC8vIFNldCBkZWZhdWx0IHN0YXRlIGZvciBEYXNoYm9hcmRcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGlzSGlkZGVuOiB0cnVlLFxuICAgICAgZmlsZUNhcmRGb3I6IG51bGwsXG4gICAgICBhY3RpdmVPdmVybGF5VHlwZTogbnVsbCxcbiAgICAgIHNob3dBZGRGaWxlc1BhbmVsOiBmYWxzZSxcbiAgICAgIGFjdGl2ZVBpY2tlclBhbmVsOiBmYWxzZSxcbiAgICAgIG1ldGFGaWVsZHM6IHRoaXMub3B0cy5tZXRhRmllbGRzLFxuICAgICAgdGFyZ2V0czogW10sXG4gICAgICAvLyBXZSdsbCBtYWtlIHRoZW0gdmlzaWJsZSBvbmNlIC5jb250YWluZXJXaWR0aCBpcyBkZXRlcm1pbmVkXG4gICAgICBhcmVJbnNpZGVzUmVhZHlUb0JlVmlzaWJsZTogZmFsc2UsXG4gICAgICBpc0RyYWdnaW5nT3ZlcjogZmFsc2VcbiAgICB9KVxuXG4gICAgY29uc3QgeyBpbmxpbmUsIGNsb3NlQWZ0ZXJGaW5pc2ggfSA9IHRoaXMub3B0c1xuICAgIGlmIChpbmxpbmUgJiYgY2xvc2VBZnRlckZpbmlzaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbRGFzaGJvYXJkXSBgY2xvc2VBZnRlckZpbmlzaDogdHJ1ZWAgY2Fubm90IGJlIHVzZWQgb24gYW4gaW5saW5lIERhc2hib2FyZCwgYmVjYXVzZSBhbiBpbmxpbmUgRGFzaGJvYXJkIGNhbm5vdCBiZSBjbG9zZWQgYXQgYWxsLiBFaXRoZXIgc2V0IGBpbmxpbmU6IGZhbHNlYCwgb3IgZGlzYWJsZSB0aGUgYGNsb3NlQWZ0ZXJGaW5pc2hgIG9wdGlvbi4nKVxuICAgIH1cblxuICAgIGNvbnN0IHsgYWxsb3dNdWx0aXBsZVVwbG9hZHMgfSA9IHRoaXMudXBweS5vcHRzXG4gICAgaWYgKGFsbG93TXVsdGlwbGVVcGxvYWRzICYmIGNsb3NlQWZ0ZXJGaW5pc2gpIHtcbiAgICAgIHRoaXMudXBweS5sb2coJ1tEYXNoYm9hcmRdIFdoZW4gdXNpbmcgYGNsb3NlQWZ0ZXJGaW5pc2hgLCB3ZSByZWNvbW1lbmRlZCBzZXR0aW5nIHRoZSBgYWxsb3dNdWx0aXBsZVVwbG9hZHNgIG9wdGlvbiB0byBgZmFsc2VgIGluIHRoZSBVcHB5IGNvbnN0cnVjdG9yLiBTZWUgaHR0cHM6Ly91cHB5LmlvL2RvY3MvdXBweS8jYWxsb3dNdWx0aXBsZVVwbG9hZHMtdHJ1ZScsICd3YXJuaW5nJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5vcHRzXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuXG4gICAgY29uc3QgcGx1Z2lucyA9IHRoaXMub3B0cy5wbHVnaW5zIHx8IFtdXG4gICAgcGx1Z2lucy5mb3JFYWNoKChwbHVnaW5JRCkgPT4ge1xuICAgICAgY29uc3QgcGx1Z2luID0gdGhpcy51cHB5LmdldFBsdWdpbihwbHVnaW5JRClcbiAgICAgIGlmIChwbHVnaW4pIHtcbiAgICAgICAgcGx1Z2luLm1vdW50KHRoaXMsIHBsdWdpbilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKCF0aGlzLm9wdHMuZGlzYWJsZVN0YXR1c0Jhcikge1xuICAgICAgdGhpcy51cHB5LnVzZShTdGF0dXNCYXIsIHtcbiAgICAgICAgaWQ6IGAke3RoaXMuaWR9OlN0YXR1c0JhcmAsXG4gICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgaGlkZVVwbG9hZEJ1dHRvbjogdGhpcy5vcHRzLmhpZGVVcGxvYWRCdXR0b24sXG4gICAgICAgIGhpZGVSZXRyeUJ1dHRvbjogdGhpcy5vcHRzLmhpZGVSZXRyeUJ1dHRvbixcbiAgICAgICAgaGlkZVBhdXNlUmVzdW1lQnV0dG9uOiB0aGlzLm9wdHMuaGlkZVBhdXNlUmVzdW1lQnV0dG9uLFxuICAgICAgICBoaWRlQ2FuY2VsQnV0dG9uOiB0aGlzLm9wdHMuaGlkZUNhbmNlbEJ1dHRvbixcbiAgICAgICAgc2hvd1Byb2dyZXNzRGV0YWlsczogdGhpcy5vcHRzLnNob3dQcm9ncmVzc0RldGFpbHMsXG4gICAgICAgIGhpZGVBZnRlckZpbmlzaDogdGhpcy5vcHRzLmhpZGVQcm9ncmVzc0FmdGVyRmluaXNoLFxuICAgICAgICBsb2NhbGU6IHRoaXMub3B0cy5sb2NhbGVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdHMuZGlzYWJsZUluZm9ybWVyKSB7XG4gICAgICB0aGlzLnVwcHkudXNlKEluZm9ybWVyLCB7XG4gICAgICAgIGlkOiBgJHt0aGlzLmlkfTpJbmZvcm1lcmAsXG4gICAgICAgIHRhcmdldDogdGhpc1xuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMub3B0cy5kaXNhYmxlVGh1bWJuYWlsR2VuZXJhdG9yKSB7XG4gICAgICB0aGlzLnVwcHkudXNlKFRodW1ibmFpbEdlbmVyYXRvciwge1xuICAgICAgICBpZDogYCR7dGhpcy5pZH06VGh1bWJuYWlsR2VuZXJhdG9yYCxcbiAgICAgICAgdGh1bWJuYWlsV2lkdGg6IHRoaXMub3B0cy50aHVtYm5haWxXaWR0aCxcbiAgICAgICAgd2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWQ6IHRoaXMub3B0cy53YWl0Rm9yVGh1bWJuYWlsc0JlZm9yZVVwbG9hZFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmRpc2NvdmVyUHJvdmlkZXJQbHVnaW5zKClcblxuICAgIHRoaXMuaW5pdEV2ZW50cygpXG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIGlmICghdGhpcy5vcHRzLmRpc2FibGVJbmZvcm1lcikge1xuICAgICAgY29uc3QgaW5mb3JtZXIgPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKGAke3RoaXMuaWR9OkluZm9ybWVyYClcbiAgICAgIC8vIENoZWNraW5nIGlmIHRoaXMgcGx1Z2luIGV4aXN0cywgaW4gY2FzZSBpdCB3YXMgcmVtb3ZlZCBieSB1cHB5LWNvcmVcbiAgICAgIC8vIGJlZm9yZSB0aGUgRGFzaGJvYXJkIHdhcy5cbiAgICAgIGlmIChpbmZvcm1lcikgdGhpcy51cHB5LnJlbW92ZVBsdWdpbihpbmZvcm1lcilcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMub3B0cy5kaXNhYmxlU3RhdHVzQmFyKSB7XG4gICAgICBjb25zdCBzdGF0dXNCYXIgPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKGAke3RoaXMuaWR9OlN0YXR1c0JhcmApXG4gICAgICBpZiAoc3RhdHVzQmFyKSB0aGlzLnVwcHkucmVtb3ZlUGx1Z2luKHN0YXR1c0JhcilcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMub3B0cy5kaXNhYmxlVGh1bWJuYWlsR2VuZXJhdG9yKSB7XG4gICAgICBjb25zdCB0aHVtYm5haWwgPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKGAke3RoaXMuaWR9OlRodW1ibmFpbEdlbmVyYXRvcmApXG4gICAgICBpZiAodGh1bWJuYWlsKSB0aGlzLnVwcHkucmVtb3ZlUGx1Z2luKHRodW1ibmFpbClcbiAgICB9XG5cbiAgICBjb25zdCBwbHVnaW5zID0gdGhpcy5vcHRzLnBsdWdpbnMgfHwgW11cbiAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbklEKSA9PiB7XG4gICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnVwcHkuZ2V0UGx1Z2luKHBsdWdpbklEKVxuICAgICAgaWYgKHBsdWdpbikgcGx1Z2luLnVubW91bnQoKVxuICAgIH0pXG5cbiAgICB0aGlzLnVubW91bnQoKVxuICAgIHRoaXMucmVtb3ZlRXZlbnRzKClcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3BpZXMgdGV4dCB0byBjbGlwYm9hcmQgYnkgY3JlYXRpbmcgYW4gYWxtb3N0IGludmlzaWJsZSB0ZXh0YXJlYSxcbiAqIGFkZGluZyB0ZXh0IHRoZXJlLCB0aGVuIHJ1bm5pbmcgZXhlY0NvbW1hbmQoJ2NvcHknKS5cbiAqIEZhbGxzIGJhY2sgdG8gcHJvbXB0KCkgd2hlbiB0aGUgZWFzeSB3YXkgZmFpbHMgKGhlbGxvLCBTYWZhcmkhKVxuICogRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMDgxMDMyMlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0VG9Db3B5XG4gKiBAcGFyYW0ge3N0cmluZ30gZmFsbGJhY2tTdHJpbmdcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvcHlUb0NsaXBib2FyZCAodGV4dFRvQ29weSwgZmFsbGJhY2tTdHJpbmcpIHtcbiAgZmFsbGJhY2tTdHJpbmcgPSBmYWxsYmFja1N0cmluZyB8fCAnQ29weSB0aGUgVVJMIGJlbG93J1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IHRleHRBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKVxuICAgIHRleHRBcmVhLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCB7XG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB3aWR0aDogJzJlbScsXG4gICAgICBoZWlnaHQ6ICcyZW0nLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgb3V0bGluZTogJ25vbmUnLFxuICAgICAgYm94U2hhZG93OiAnbm9uZScsXG4gICAgICBiYWNrZ3JvdW5kOiAndHJhbnNwYXJlbnQnXG4gICAgfSlcblxuICAgIHRleHRBcmVhLnZhbHVlID0gdGV4dFRvQ29weVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGV4dEFyZWEpXG4gICAgdGV4dEFyZWEuc2VsZWN0KClcblxuICAgIGNvbnN0IG1hZ2ljQ29weUZhaWxlZCA9ICgpID0+IHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGV4dEFyZWEpXG4gICAgICB3aW5kb3cucHJvbXB0KGZhbGxiYWNrU3RyaW5nLCB0ZXh0VG9Db3B5KVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN1Y2Nlc3NmdWwgPSBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpXG4gICAgICBpZiAoIXN1Y2Nlc3NmdWwpIHtcbiAgICAgICAgcmV0dXJuIG1hZ2ljQ29weUZhaWxlZCgnY29weSBjb21tYW5kIHVuYXZhaWxhYmxlJylcbiAgICAgIH1cbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGV4dEFyZWEpXG4gICAgICByZXR1cm4gcmVzb2x2ZSgpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRleHRBcmVhKVxuICAgICAgcmV0dXJuIG1hZ2ljQ29weUZhaWxlZChlcnIpXG4gICAgfVxuICB9KVxufVxuIiwiY29uc3QgZGVib3VuY2UgPSByZXF1aXJlKCdsb2Rhc2guZGVib3VuY2UnKVxuY29uc3QgRk9DVVNBQkxFX0VMRU1FTlRTID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL0ZPQ1VTQUJMRV9FTEVNRU5UUycpXG5jb25zdCBnZXRBY3RpdmVPdmVybGF5RWwgPSByZXF1aXJlKCcuL2dldEFjdGl2ZU92ZXJsYXlFbCcpXG5cbi8qXG4gIEZvY3VzZXMgb24gc29tZSBlbGVtZW50IGluIHRoZSBjdXJyZW50bHkgdG9wbW9zdCBvdmVybGF5LlxuXG4gIDEuIElmIHRoZXJlIGFyZSBzb21lIFtkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXSBlbGVtZW50cyByZW5kZXJlZCBhbHJlYWR5IC0gZm9jdXNlcyBvbiB0aGUgZmlyc3Qgc3VwZXJmb2N1c2FibGUgZWxlbWVudCwgYW5kIGxlYXZlcyBmb2N1cyB1cCB0byB0aGUgY29udHJvbCBvZiBhIHVzZXIgKHVudGlsIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnQgZGlzYXBwZWFycyBmcm9tIHRoZSBzY3JlZW4gW3doaWNoIGNhbiBoYXBwZW4gd2hlbiBvdmVybGF5IGNoYW5nZXMsIG9yLCBlLmcuLCB3aGVuIHdlIGNsaWNrIG9uIGEgZm9sZGVyIGluIGdvb2dsZWRyaXZlXSkuXG4gIDIuIElmIHRoZXJlIGFyZSBubyBbZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZV0gZWxlbWVudHMgeWV0IChvciBldmVyKSAtIGZvY3VzZXMgb24gdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50LCBidXQgc3dpdGNoZXMgZm9jdXMgaWYgc3VwZXJmb2N1c2FibGUgZWxlbWVudHMgYXBwZWFyIG9uIG5leHQgcmVuZGVyLlxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlU3VwZXJGb2N1cyAoKSB7XG4gIGxldCBsYXN0Rm9jdXNXYXNPblN1cGVyRm9jdXNhYmxlRWwgPSBmYWxzZVxuXG4gIGNvbnN0IHN1cGVyRm9jdXMgPSAoZGFzaGJvYXJkRWwsIGFjdGl2ZU92ZXJsYXlUeXBlKSA9PiB7XG4gICAgY29uc3Qgb3ZlcmxheUVsID0gZ2V0QWN0aXZlT3ZlcmxheUVsKGRhc2hib2FyZEVsLCBhY3RpdmVPdmVybGF5VHlwZSlcblxuICAgIGNvbnN0IGlzRm9jdXNJbk92ZXJsYXkgPSBvdmVybGF5RWwuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcbiAgICAvLyBJZiBmb2N1cyBpcyBhbHJlYWR5IGluIHRoZSB0b3Btb3N0IG92ZXJsYXksIEFORCBvbiBsYXN0IHVwZGF0ZSB3ZSBmb2N1c2VkIG9uIHRoZSBzdXBlcmZvY3VzYWJsZSBlbGVtZW50IC0gdGhlbiBsZWF2ZSBmb2N1cyB1cCB0byB0aGUgdXNlci5cbiAgICAvLyBbUHJhY3RpY2FsIGNoZWNrXSB3aXRob3V0IHRoaXMgbGluZSwgdHlwaW5nIGluIHRoZSBzZWFyY2ggaW5wdXQgaW4gZ29vZ2xlZHJpdmUgb3ZlcmxheSB3b24ndCB3b3JrLlxuICAgIGlmIChpc0ZvY3VzSW5PdmVybGF5ICYmIGxhc3RGb2N1c1dhc09uU3VwZXJGb2N1c2FibGVFbCkgcmV0dXJuXG5cbiAgICBjb25zdCBzdXBlckZvY3VzYWJsZUVsID0gb3ZlcmxheUVsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXScpXG4gICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgaW4gdGhlIHRvcG1vc3Qgb3ZlcmxheSwgQU5EIHRoZXJlIGFyZSBubyBzdXBlciBmb2N1c2FibGUgZWxlbWVudHMgeWV0LCAtIGxlYXZlIGZvY3VzIHVwIHRvIHRoZSB1c2VyLlxuICAgIC8vIFtQcmFjdGljYWwgY2hlY2tdIHdpdGhvdXQgdGhpcyBsaW5lLCBpZiB5b3UgYXJlIGluIGFuIGVtcHR5IGZvbGRlciBpbiBnb29nbGUgZHJpdmUsIGFuZCBzb21ldGhpbmcncyB1cGxvYWRpbmcgaW4gdGhlIGJnLCAtIGZvY3VzIHdpbGwgYmUganVtcGluZyB0byBEb25lIGFsbCB0aGUgdGltZS5cbiAgICBpZiAoaXNGb2N1c0luT3ZlcmxheSAmJiAhc3VwZXJGb2N1c2FibGVFbCkgcmV0dXJuXG5cbiAgICBpZiAoc3VwZXJGb2N1c2FibGVFbCkge1xuICAgICAgc3VwZXJGb2N1c2FibGVFbC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSlcbiAgICAgIGxhc3RGb2N1c1dhc09uU3VwZXJGb2N1c2FibGVFbCA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZmlyc3RFbCA9IG92ZXJsYXlFbC5xdWVyeVNlbGVjdG9yKEZPQ1VTQUJMRV9FTEVNRU5UUylcbiAgICAgIGZpcnN0RWwgJiYgZmlyc3RFbC5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSlcbiAgICAgIGxhc3RGb2N1c1dhc09uU3VwZXJGb2N1c2FibGVFbCA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gX19fV2h5IGRvIHdlIG5lZWQgdG8gZGVib3VuY2U/XG4gIC8vICAgIDEuIFRvIGRlYWwgd2l0aCBhbmltYXRpb25zOiBvdmVybGF5IGNoYW5nZXMgdmlhIGFuaW1hdGlvbnMsIHdoaWNoIHJlc3VsdHMgaW4gdGhlIERPTSB1cGRhdGluZyBBRlRFUiBwbHVnaW4udXBkYXRlKCkgYWxyZWFkeSBleGVjdXRlZC5cbiAgLy8gICAgW1ByYWN0aWNhbCBjaGVja10gd2l0aG91dCBkZWJvdW5jZSwgaWYgd2Ugb3BlbiB0aGUgVXJsIG92ZXJsYXksIGFuZCBjbGljayAnRG9uZScsIERhc2hib2FyZCB3b24ndCBnZXQgZm9jdXNlZCBhZ2Fpbi5cbiAgLy8gICAgW1ByYWN0aWNhbCBjaGVja10gaWYgd2UgZGVsYXkgMjUwbXMgaW5zdGVhZCBvZiAyNjBtcyAtIElFMTEgd29uJ3QgZ2V0IGZvY3VzZWQgaW4gc2FtZSBzaXR1YXRpb24uXG4gIC8vICAgIDIuIFBlcmZvcm1hbmNlOiB0aGVyZSBjYW4gYmUgbWFueSBzdGF0ZSB1cGRhdGUoKXMgaW4gYSBzZWNvbmQsIGFuZCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBldmVyeSB0aW1lLlxuICByZXR1cm4gZGVib3VuY2Uoc3VwZXJGb2N1cywgMjYwKVxufVxuIiwiLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IC0gZWl0aGVyIGRhc2hib2FyZCBlbGVtZW50LCBvciB0aGUgb3ZlcmxheSB0aGF0J3MgbW9zdCBvbiB0b3BcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRBY3RpdmVPdmVybGF5RWwgKGRhc2hib2FyZEVsLCBhY3RpdmVPdmVybGF5VHlwZSkge1xuICBpZiAoYWN0aXZlT3ZlcmxheVR5cGUpIHtcbiAgICBjb25zdCBvdmVybGF5RWwgPSBkYXNoYm9hcmRFbC5xdWVyeVNlbGVjdG9yKGBbZGF0YS11cHB5LXBhbmVsdHlwZT1cIiR7YWN0aXZlT3ZlcmxheVR5cGV9XCJdYClcbiAgICAvLyBpZiBhbiBvdmVybGF5IGlzIGFscmVhZHkgbW91bnRlZFxuICAgIGlmIChvdmVybGF5RWwpIHJldHVybiBvdmVybGF5RWxcbiAgfVxuICByZXR1cm4gZGFzaGJvYXJkRWxcbn1cbiIsImNvbnN0IHsgaWNvbkZpbGUsIGljb25UZXh0LCBpY29uQXVkaW8sIGljb25WaWRlbywgaWNvblBERiB9ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9pY29ucycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0SWNvbkJ5TWltZSAoZmlsZVR5cGUpIHtcbiAgY29uc3QgZGVmYXVsdENob2ljZSA9IHtcbiAgICBjb2xvcjogJyM4Mzg5OTknLFxuICAgIGljb246IGljb25GaWxlKClcbiAgfVxuXG4gIGlmICghZmlsZVR5cGUpIHJldHVybiBkZWZhdWx0Q2hvaWNlXG5cbiAgY29uc3QgZmlsZVR5cGVHZW5lcmFsID0gZmlsZVR5cGUuc3BsaXQoJy8nKVswXVxuICBjb25zdCBmaWxlVHlwZVNwZWNpZmljID0gZmlsZVR5cGUuc3BsaXQoJy8nKVsxXVxuXG4gIGlmIChmaWxlVHlwZUdlbmVyYWwgPT09ICd0ZXh0Jykge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogJyM1YTVlNjknLFxuICAgICAgaWNvbjogaWNvblRleHQoKVxuICAgIH1cbiAgfVxuXG4gIGlmIChmaWxlVHlwZUdlbmVyYWwgPT09ICdhdWRpbycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sb3I6ICcjMDY4ZGJiJyxcbiAgICAgIGljb246IGljb25BdWRpbygpXG4gICAgfVxuICB9XG5cbiAgaWYgKGZpbGVUeXBlR2VuZXJhbCA9PT0gJ3ZpZGVvJykge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xvcjogJyMxOWFmNjcnLFxuICAgICAgaWNvbjogaWNvblZpZGVvKClcbiAgICB9XG4gIH1cblxuICBpZiAoZmlsZVR5cGVHZW5lcmFsID09PSAnYXBwbGljYXRpb24nICYmIGZpbGVUeXBlU3BlY2lmaWMgPT09ICdwZGYnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiAnI2UyNTE0OScsXG4gICAgICBpY29uOiBpY29uUERGKClcbiAgICB9XG4gIH1cblxuICBpZiAoZmlsZVR5cGVHZW5lcmFsID09PSAnaW1hZ2UnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiAnI2YyZjJmMicsXG4gICAgICBpY29uOiAnJ1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0Q2hvaWNlXG59XG4iLCIvLyBpZ25vcmUgZHJvcC9wYXN0ZSBldmVudHMgaWYgdGhleSBhcmUgbm90IGluIGlucHV0IG9yIHRleHRhcmVhIOKAlFxuLy8gb3RoZXJ3aXNlIHdoZW4gVXJsIHBsdWdpbiBhZGRzIGRyb3AvcGFzdGUgbGlzdGVuZXJzIHRvIHRoaXMuZWwsXG4vLyBkcmFnaW5nIFVJIGVsZW1lbnRzIG9yIHBhc3RpbmcgYW55dGhpbmcgaW50byBhbnkgZmllbGQgdHJpZ2dlcnMgdGhvc2UgZXZlbnRzIOKAlFxuLy8gVXJsIHRyZWF0cyB0aGVtIGFzIFVSTHMgdGhhdCBuZWVkIHRvIGJlIGltcG9ydGVkXG5cbmZ1bmN0aW9uIGlnbm9yZUV2ZW50IChldikge1xuICBjb25zdCB0YWdOYW1lID0gZXYudGFyZ2V0LnRhZ05hbWVcbiAgaWYgKHRhZ05hbWUgPT09ICdJTlBVVCcgfHxcbiAgICAgIHRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICBldi5zdG9wUHJvcGFnYXRpb24oKVxuICAgIHJldHVyblxuICB9XG4gIGV2LnByZXZlbnREZWZhdWx0KClcbiAgZXYuc3RvcFByb3BhZ2F0aW9uKClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZ25vcmVFdmVudFxuIiwiY29uc3QgdG9BcnJheSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi90b0FycmF5JylcbmNvbnN0IGdldEFjdGl2ZU92ZXJsYXlFbCA9IHJlcXVpcmUoJy4vZ2V0QWN0aXZlT3ZlcmxheUVsJylcbmNvbnN0IEZPQ1VTQUJMRV9FTEVNRU5UUyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi8vRk9DVVNBQkxFX0VMRU1FTlRTJylcblxuZnVuY3Rpb24gZm9jdXNPbkZpcnN0Tm9kZSAoZXZlbnQsIG5vZGVzKSB7XG4gIGNvbnN0IG5vZGUgPSBub2Rlc1swXVxuICBpZiAobm9kZSkge1xuICAgIG5vZGUuZm9jdXMoKVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgfVxufVxuXG5mdW5jdGlvbiBmb2N1c09uTGFzdE5vZGUgKGV2ZW50LCBub2Rlcykge1xuICBjb25zdCBub2RlID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV1cbiAgaWYgKG5vZGUpIHtcbiAgICBub2RlLmZvY3VzKClcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cbn1cblxuLy8gX19fV2h5IG5vdCBqdXN0IHVzZSAoZm9jdXNlZEl0ZW1JbmRleCA9PT0gLTEpP1xuLy8gICAgRmlyZWZveCB0aGlua3MgPHVsPiBpcyBmb2N1c2FibGUsIGJ1dCB3ZSBkb24ndCBoYXZlIDx1bD5zIGluIG91ciBGT0NVU0FCTEVfRUxFTUVOVFMuIFdoaWNoIG1lYW5zIHRoYXQgaWYgd2UgdGFiIGludG8gdGhlIDx1bD4sIGNvZGUgd2lsbCB0aGluayB0aGF0IHdlIGFyZSBub3QgaW4gdGhlIGFjdGl2ZSBvdmVybGF5LCBhbmQgd2Ugc2hvdWxkIGZvY3VzT25GaXJzdE5vZGUoKSBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBvdmVybGF5IVxuLy8gICAgW1ByYWN0aWNhbCBjaGVja10gaWYgd2UgdXNlIChmb2N1c2VkSXRlbUluZGV4ID09PSAtMSksIGluc3RhZ3JhbSBwcm92aWRlciBpbiBmaXJlZm94IHdpbGwgbmV2ZXIgZ2V0IGZvY3VzIG9uIGl0cyBwaWNzIGluIHRoZSA8dWw+LlxuZnVuY3Rpb24gaXNGb2N1c0luT3ZlcmxheSAoYWN0aXZlT3ZlcmxheUVsKSB7XG4gIHJldHVybiBhY3RpdmVPdmVybGF5RWwuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcbn1cblxuZnVuY3Rpb24gdHJhcEZvY3VzIChldmVudCwgYWN0aXZlT3ZlcmxheVR5cGUsIGRhc2hib2FyZEVsKSB7XG4gIGNvbnN0IGFjdGl2ZU92ZXJsYXlFbCA9IGdldEFjdGl2ZU92ZXJsYXlFbChkYXNoYm9hcmRFbCwgYWN0aXZlT3ZlcmxheVR5cGUpXG4gIGNvbnN0IGZvY3VzYWJsZU5vZGVzID0gdG9BcnJheShhY3RpdmVPdmVybGF5RWwucXVlcnlTZWxlY3RvckFsbChGT0NVU0FCTEVfRUxFTUVOVFMpKVxuXG4gIGNvbnN0IGZvY3VzZWRJdGVtSW5kZXggPSBmb2N1c2FibGVOb2Rlcy5pbmRleE9mKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpXG5cbiAgLy8gSWYgd2UgcHJlc3NlZCB0YWIsIGFuZCBmb2N1cyBpcyBub3QgeWV0IHdpdGhpbiB0aGUgY3VycmVudCBvdmVybGF5IC0gZm9jdXMgb24gdGhlIGZpcnN0IGVsZW1lbnQgd2l0aGluIHRoZSBjdXJyZW50IG92ZXJsYXkuXG4gIC8vIFRoaXMgaXMgYSBzYWZldHkgbWVhc3VyZSAoZm9yIHdoZW4gdXNlciByZXR1cm5zIGZyb20gYW5vdGhlciB0YWIgZS5nLiksIG1vc3QgcGx1Z2lucyB3aWxsIHRyeSB0byBmb2N1cyBvbiBzb21lIGltcG9ydGFudCBlbGVtZW50IGFzIGl0IGxvYWRzLlxuICBpZiAoIWlzRm9jdXNJbk92ZXJsYXkoYWN0aXZlT3ZlcmxheUVsKSkge1xuICAgIGZvY3VzT25GaXJzdE5vZGUoZXZlbnQsIGZvY3VzYWJsZU5vZGVzKVxuICAvLyBJZiB3ZSBwcmVzc2VkIHNoaWZ0ICsgdGFiLCBhbmQgd2UncmUgb24gdGhlIGZpcnN0IGVsZW1lbnQgb2YgYSBtb2RhbFxuICB9IGVsc2UgaWYgKGV2ZW50LnNoaWZ0S2V5ICYmIGZvY3VzZWRJdGVtSW5kZXggPT09IDApIHtcbiAgICBmb2N1c09uTGFzdE5vZGUoZXZlbnQsIGZvY3VzYWJsZU5vZGVzKVxuICAvLyBJZiB3ZSBwcmVzc2VkIHRhYiwgYW5kIHdlJ3JlIG9uIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIG1vZGFsXG4gIH0gZWxzZSBpZiAoIWV2ZW50LnNoaWZ0S2V5ICYmIGZvY3VzZWRJdGVtSW5kZXggPT09IGZvY3VzYWJsZU5vZGVzLmxlbmd0aCAtIDEpIHtcbiAgICBmb2N1c09uRmlyc3ROb2RlKGV2ZW50LCBmb2N1c2FibGVOb2RlcylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gVHJhcHMgZm9jdXMgaW5zaWRlIG9mIHRoZSBjdXJyZW50bHkgb3BlbiBvdmVybGF5IChlLmcuIERhc2hib2FyZCwgb3IgZS5nLiBJbnN0YWdyYW0pLCBuZXZlciBsZXRzIGZvY3VzIGRpc2FwcGVhciBmcm9tIHRoZSBtb2RhbC5cbiAgZm9yTW9kYWw6IChldmVudCwgYWN0aXZlT3ZlcmxheVR5cGUsIGRhc2hib2FyZEVsKSA9PiB7XG4gICAgdHJhcEZvY3VzKGV2ZW50LCBhY3RpdmVPdmVybGF5VHlwZSwgZGFzaGJvYXJkRWwpXG4gIH0sXG5cbiAgLy8gVHJhcHMgZm9jdXMgaW5zaWRlIG9mIHRoZSBjdXJyZW50bHkgb3BlbiBvdmVybGF5LCB1bmxlc3Mgb3ZlcmxheSBpcyBudWxsIC0gdGhlbiBsZXQgdGhlIHVzZXIgdGFiIGF3YXkuXG4gIGZvcklubGluZTogKGV2ZW50LCBhY3RpdmVPdmVybGF5VHlwZSwgZGFzaGJvYXJkRWwpID0+IHtcbiAgICAvLyBfX19XaGVuIHdlJ3JlIGluIHRoZSBiYXJlICdEcm9wIGZpbGVzIGhlcmUsIHBhc3RlLCBicm93c2Ugb3IgaW1wb3J0IGZyb20nIHNjcmVlblxuICAgIGlmIChhY3RpdmVPdmVybGF5VHlwZSA9PT0gbnVsbCkge1xuICAgICAgLy8gRG8gbm90aGluZyBhbmQgbGV0IHRoZSBicm93c2VyIGhhbmRsZSBpdCwgdXNlciBjYW4gdGFiIGF3YXkgZnJvbSBVcHB5IHRvIG90aGVyIGVsZW1lbnRzIG9uIHRoZSBwYWdlXG4gICAgLy8gX19fV2hlbiB0aGVyZSBpcyBzb21lIG92ZXJsYXkgd2l0aCAnRG9uZScgYnV0dG9uXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyYXAgdGhlIGZvY3VzIGluc2lkZSB0aGlzIG92ZXJsYXkhXG4gICAgICAvLyBVc2VyIGNhbiBjbG9zZSB0aGUgb3ZlcmxheSAoY2xpY2sgJ0RvbmUnKSBpZiB0aGV5IHdhbnQgdG8gdHJhdmVsIGF3YXkgZnJvbSBVcHB5LlxuICAgICAgdHJhcEZvY3VzKGV2ZW50LCBhY3RpdmVPdmVybGF5VHlwZSwgZGFzaGJvYXJkRWwpXG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIFRydW5jYXRlcyBhIHN0cmluZyB0byB0aGUgZ2l2ZW4gbnVtYmVyIG9mIGNoYXJzIChtYXhMZW5ndGgpIGJ5IGluc2VydGluZyAnLi4uJyBpbiB0aGUgbWlkZGxlIG9mIHRoYXQgc3RyaW5nLlxuICogUGFydGlhbGx5IHRha2VuIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzU3MjMyNzQvMzE5MjQ3MC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gc3RyaW5nIHRvIGJlIHRydW5jYXRlZFxuICogQHBhcmFtIHtudW1iZXJ9IG1heExlbmd0aCAtIG1heGltdW0gc2l6ZSBvZiB0aGUgcmVzdWx0aW5nIHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cnVuY2F0ZVN0cmluZyAoc3RyaW5nLCBtYXhMZW5ndGgpIHtcbiAgY29uc3Qgc2VwYXJhdG9yID0gJy4uLidcblxuICAvLyBSZXR1cm4gb3JpZ2luYWwgc3RyaW5nIGlmIGl0J3MgYWxyZWFkeSBzaG9ydGVyIHRoYW4gbWF4TGVuZ3RoXG4gIGlmIChzdHJpbmcubGVuZ3RoIDw9IG1heExlbmd0aCkge1xuICAgIHJldHVybiBzdHJpbmdcbiAgLy8gUmV0dXJuIHRydW5jYXRlZCBzdWJzdHJpbmcgd2l0aG91dCAnLi4uJyBpZiBzdHJpbmcgY2FuJ3QgYmUgbWVhbmluZ2Z1bGx5IHRydW5jYXRlZFxuICB9IGVsc2UgaWYgKG1heExlbmd0aCA8PSBzZXBhcmF0b3IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zdWJzdHIoMCwgbWF4TGVuZ3RoKVxuICAvLyBSZXR1cm4gdHJ1bmNhdGVkIHN0cmluZyBkaXZpZGVkIGluIGhhbGYgYnkgJy4uLidcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjaGFyc1RvU2hvdyA9IG1heExlbmd0aCAtIHNlcGFyYXRvci5sZW5ndGhcbiAgICBjb25zdCBmcm9udENoYXJzID0gTWF0aC5jZWlsKGNoYXJzVG9TaG93IC8gMilcbiAgICBjb25zdCBiYWNrQ2hhcnMgPSBNYXRoLmZsb29yKGNoYXJzVG9TaG93IC8gMilcblxuICAgIHJldHVybiBzdHJpbmcuc3Vic3RyKDAsIGZyb250Q2hhcnMpICsgc2VwYXJhdG9yICsgc3RyaW5nLnN1YnN0cihzdHJpbmcubGVuZ3RoIC0gYmFja0NoYXJzKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L2Ryb3Bib3hcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkltcG9ydCBmaWxlcyBmcm9tIERyb3Bib3gsIGludG8gVXBweS5cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS4zLjVcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCIsXG4gICAgXCJkcm9wYm94XCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb21wYW5pb24tY2xpZW50XCI6IFwiZmlsZTouLi9jb21wYW5pb24tY2xpZW50XCIsXG4gICAgXCJAdXBweS9wcm92aWRlci12aWV3c1wiOiBcImZpbGU6Li4vcHJvdmlkZXItdmlld3NcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHsgUHJvdmlkZXIgfSA9IHJlcXVpcmUoJ0B1cHB5L2NvbXBhbmlvbi1jbGllbnQnKVxuY29uc3QgUHJvdmlkZXJWaWV3cyA9IHJlcXVpcmUoJ0B1cHB5L3Byb3ZpZGVyLXZpZXdzJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBEcm9wYm94IGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ0Ryb3Bib3gnXG4gICAgUHJvdmlkZXIuaW5pdFBsdWdpbih0aGlzLCBvcHRzKVxuICAgIHRoaXMudGl0bGUgPSB0aGlzLm9wdHMudGl0bGUgfHwgJ0Ryb3Bib3gnXG4gICAgdGhpcy5pY29uID0gKCkgPT4gKFxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIHdpZHRoPVwiMTI4XCIgaGVpZ2h0PVwiMTI4XCIgdmlld0JveD1cIjAgMCAxMjggMTI4XCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNMzEuOTk3IDExTDY0IDMxLjgyNSAzMS45OTcgNTIuNjUxIDAgMzEuODI1IDMxLjk5NyAxMXpNOTYgMTFsMzIgMjAuODI1LTMyIDIwLjgyNi0zMi0yMC44MjZMOTYgMTF6TTAgNzMuNDc2bDMxLjk5Ny0yMC44MjVMNjQgNzMuNDc2IDMxLjk5NyA5NC4zMDIgMCA3My40NzZ6bTk2LTIwLjgyNWwzMiAyMC44MjUtMzIgMjAuODI2LTMyLTIwLjgyNiAzMi0yMC44MjV6bS02NC41MDggNDguMjU0bDMyLjAwMy0yMC44MjYgMzEuOTk3IDIwLjgyNi0zMS45OTcgMjAuODI1LTMyLjAwMy0yMC44MjV6XCIgZmlsbD1cIiMwMjYwRkZcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCIgLz5cbiAgICAgIDwvc3ZnPlxuICAgIClcblxuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIodXBweSwge1xuICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgY29tcGFuaW9uSGVhZGVyczogdGhpcy5vcHRzLmNvbXBhbmlvbkhlYWRlcnMgfHwgdGhpcy5vcHRzLnNlcnZlckhlYWRlcnMsXG4gICAgICBzdG9yYWdlOiB0aGlzLm9wdHMuc3RvcmFnZSxcbiAgICAgIHByb3ZpZGVyOiAnZHJvcGJveCcsXG4gICAgICBwbHVnaW5JZDogdGhpcy5pZFxuICAgIH0pXG5cbiAgICB0aGlzLm9uRmlyc3RSZW5kZXIgPSB0aGlzLm9uRmlyc3RSZW5kZXIuYmluZCh0aGlzKVxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3ID0gbmV3IFByb3ZpZGVyVmlld3ModGhpcywge1xuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXJcbiAgICB9KVxuICAgIC8vIFNldCBkZWZhdWx0IHN0YXRlIGZvciBEcm9wYm94XG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBhdXRoZW50aWNhdGVkOiBmYWxzZSxcbiAgICAgIGZpbGVzOiBbXSxcbiAgICAgIGZvbGRlcnM6IFtdLFxuICAgICAgZGlyZWN0b3JpZXM6IFtdLFxuICAgICAgYWN0aXZlUm93OiAtMSxcbiAgICAgIGZpbHRlcklucHV0OiAnJyxcbiAgICAgIGlzU2VhcmNoVmlzaWJsZTogZmFsc2VcbiAgICB9KVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRzLnRhcmdldFxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3LnRlYXJEb3duKClcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG5cbiAgb25GaXJzdFJlbmRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRGb2xkZXIoKVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnZpZXcucmVuZGVyKHN0YXRlKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L2ZhY2Vib29rXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJJbXBvcnQgZmlsZXMgZnJvbSBGYWNlYm9vaywgaW50byBVcHB5LlwiLFxuICBcInZlcnNpb25cIjogXCIwLjIuMlwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcImZhY2Vib29rXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb21wYW5pb24tY2xpZW50XCI6IFwiZmlsZTouLi9jb21wYW5pb24tY2xpZW50XCIsXG4gICAgXCJAdXBweS9wcm92aWRlci12aWV3c1wiOiBcImZpbGU6Li4vcHJvdmlkZXItdmlld3NcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHsgUHJvdmlkZXIgfSA9IHJlcXVpcmUoJ0B1cHB5L2NvbXBhbmlvbi1jbGllbnQnKVxuY29uc3QgUHJvdmlkZXJWaWV3cyA9IHJlcXVpcmUoJ0B1cHB5L3Byb3ZpZGVyLXZpZXdzJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBGYWNlYm9vayBleHRlbmRzIFBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdGYWNlYm9vaydcbiAgICBQcm92aWRlci5pbml0UGx1Z2luKHRoaXMsIG9wdHMpXG4gICAgdGhpcy50aXRsZSA9IHRoaXMub3B0cy50aXRsZSB8fCAnRmFjZWJvb2snXG4gICAgdGhpcy5pY29uID0gKCkgPT4gKFxuICAgICAgPHN2Z1xuICAgICAgICB2ZXJzaW9uPVwiMS4xXCIgaWQ9XCJMYXllcl8xXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHg9XCIwcHhcIiB5PVwiMHB4XCJcbiAgICAgICAgd2lkdGg9XCIyNjYuODkzcHhcIiBoZWlnaHQ9XCIyNjYuODk1cHhcIiB2aWV3Qm94PVwiMCAwIDI2Ni44OTMgMjY2Ljg5NVwiIGVuYWJsZS1iYWNrZ3JvdW5kPVwibmV3IDAgMCAyNjYuODkzIDI2Ni44OTVcIlxuICAgICAgPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGlkPVwiQmx1ZV8xX1wiIGZpbGw9XCIjM0M1QTk5XCIgZD1cIk0yNDguMDgyLDI2Mi4zMDdjNy44NTQsMCwxNC4yMjMtNi4zNjksMTQuMjIzLTE0LjIyNVYxOC44MTJcbiAgICAgICAgICBjMC03Ljg1Ny02LjM2OC0xNC4yMjQtMTQuMjIzLTE0LjIyNEgxOC44MTJjLTcuODU3LDAtMTQuMjI0LDYuMzY3LTE0LjIyNCwxNC4yMjR2MjI5LjI3YzAsNy44NTUsNi4zNjYsMTQuMjI1LDE0LjIyNCwxNC4yMjVcbiAgICAgICAgICBIMjQ4LjA4MnpcIlxuICAgICAgICAvPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGlkPVwiZlwiIGZpbGw9XCIjRkZGRkZGXCIgZD1cIk0xODIuNDA5LDI2Mi4zMDd2LTk5LjgwM2gzMy40OTlsNS4wMTYtMzguODk1aC0zOC41MTVWOTguNzc3YzAtMTEuMjYxLDMuMTI3LTE4LjkzNSwxOS4yNzUtMTguOTM1XG4gICAgICAgICAgbDIwLjU5Ni0wLjAwOVY0NS4wNDVjLTMuNTYyLTAuNDc0LTE1Ljc4OC0xLjUzMy0zMC4wMTItMS41MzNjLTI5LjY5NSwwLTUwLjAyNSwxOC4xMjYtNTAuMDI1LDUxLjQxM3YyOC42ODRoLTMzLjU4NXYzOC44OTVoMzMuNTg1XG4gICAgICAgICAgdjk5LjgwM0gxODIuNDA5elwiXG4gICAgICAgIC8+XG4gICAgICA8L3N2Zz5cbiAgICApXG5cbiAgICB0aGlzLnByb3ZpZGVyID0gbmV3IFByb3ZpZGVyKHVwcHksIHtcbiAgICAgIGNvbXBhbmlvblVybDogdGhpcy5vcHRzLmNvbXBhbmlvblVybCxcbiAgICAgIGNvbXBhbmlvbkhlYWRlcnM6IHRoaXMub3B0cy5jb21wYW5pb25IZWFkZXJzIHx8IHRoaXMub3B0cy5zZXJ2ZXJIZWFkZXJzLFxuICAgICAgc3RvcmFnZTogdGhpcy5vcHRzLnN0b3JhZ2UsXG4gICAgICBwcm92aWRlcjogJ2ZhY2Vib29rJyxcbiAgICAgIHBsdWdpbklkOiB0aGlzLmlkXG4gICAgfSlcblxuICAgIHRoaXMub25GaXJzdFJlbmRlciA9IHRoaXMub25GaXJzdFJlbmRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICB0aGlzLnZpZXcgPSBuZXcgUHJvdmlkZXJWaWV3cyh0aGlzLCB7XG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlclxuICAgIH0pXG4gICAgLy8gU2V0IGRlZmF1bHQgc3RhdGUgZm9yIERyb3Bib3hcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGF1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxuICAgICAgZmlsZXM6IFtdLFxuICAgICAgZm9sZGVyczogW10sXG4gICAgICBkaXJlY3RvcmllczogW10sXG4gICAgICBhY3RpdmVSb3c6IC0xLFxuICAgICAgZmlsdGVySW5wdXQ6ICcnLFxuICAgICAgaXNTZWFyY2hWaXNpYmxlOiBmYWxzZVxuICAgIH0pXG5cbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLm9wdHMudGFyZ2V0XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnZpZXcudGVhckRvd24oKVxuICAgIHRoaXMudW5tb3VudCgpXG4gIH1cblxuICBvbkZpcnN0UmVuZGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldEZvbGRlcigpXG4gIH1cblxuICByZW5kZXIgKHN0YXRlKSB7XG4gICAgY29uc3Qgdmlld09wdGlvbnMgPSB7fVxuICAgIGlmICh0aGlzLmdldFBsdWdpblN0YXRlKCkuZmlsZXMubGVuZ3RoICYmICF0aGlzLmdldFBsdWdpblN0YXRlKCkuZm9sZGVycy5sZW5ndGgpIHtcbiAgICAgIHZpZXdPcHRpb25zLnZpZXdUeXBlID0gJ2dyaWQnXG4gICAgICB2aWV3T3B0aW9ucy5zaG93RmlsdGVyID0gZmFsc2VcbiAgICAgIHZpZXdPcHRpb25zLnNob3dUaXRsZXMgPSBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy52aWV3LnJlbmRlcihzdGF0ZSwgdmlld09wdGlvbnMpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvZ29vZ2xlLWRyaXZlXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgR29vZ2xlIERyaXZlIHBsdWdpbiBmb3IgVXBweSBsZXRzIHVzZXJzIGltcG9ydCBmaWxlcyBmcm9tIHRoZWlyIEdvb2dsZSBEcml2ZSBhY2NvdW50XCIsXG4gIFwidmVyc2lvblwiOiBcIjEuMy41XCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJnb29nbGUgZHJpdmVcIixcbiAgICBcImNsb3VkIHN0b3JhZ2VcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb21wYW5pb24tY2xpZW50XCI6IFwiZmlsZTouLi9jb21wYW5pb24tY2xpZW50XCIsXG4gICAgXCJAdXBweS9wcm92aWRlci12aWV3c1wiOiBcImZpbGU6Li4vcHJvdmlkZXItdmlld3NcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IFByb3ZpZGVyVmlld3MgPSByZXF1aXJlKCdAdXBweS9wcm92aWRlci12aWV3cycpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRHJpdmVQcm92aWRlclZpZXdzIGV4dGVuZHMgUHJvdmlkZXJWaWV3cyB7XG4gIHRvZ2dsZUNoZWNrYm94IChlLCBmaWxlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgLy8gU2hhcmVkIERyaXZlcyBhcmVuJ3Qgc2VsZWN0YWJsZTsgZm9yIGFsbCBlbHNlLCBkZWZlciB0byB0aGUgYmFzZSBQcm92aWRlclZpZXcuXG4gICAgLy8gQHRvZG8gaXNUZWFtRHJpdmUgaXMgbGVmdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gV2Ugc2hvdWxkIHJlbW92ZSBpdCBpbiB0aGUgbmV4dFxuICAgIC8vIG1ham9yIHJlbGVhc2UuXG4gICAgaWYgKCFmaWxlLmN1c3RvbS5pc1RlYW1Ecml2ZSAmJiAhZmlsZS5jdXN0b20uaXNTaGFyZWREcml2ZSkge1xuICAgICAgc3VwZXIudG9nZ2xlQ2hlY2tib3goZSwgZmlsZSlcbiAgICB9XG4gIH1cbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHsgUHJvdmlkZXIgfSA9IHJlcXVpcmUoJ0B1cHB5L2NvbXBhbmlvbi1jbGllbnQnKVxuY29uc3QgRHJpdmVQcm92aWRlclZpZXdzID0gcmVxdWlyZSgnLi9Ecml2ZVByb3ZpZGVyVmlld3MnKVxuY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEdvb2dsZURyaXZlIGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ0dvb2dsZURyaXZlJ1xuICAgIHRoaXMudGl0bGUgPSB0aGlzLm9wdHMudGl0bGUgfHwgJ0dvb2dsZSBEcml2ZSdcbiAgICBQcm92aWRlci5pbml0UGx1Z2luKHRoaXMsIG9wdHMpXG4gICAgdGhpcy50aXRsZSA9IHRoaXMub3B0cy50aXRsZSB8fCAnR29vZ2xlIERyaXZlJ1xuICAgIHRoaXMuaWNvbiA9ICgpID0+IChcbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiB3aWR0aD1cIjE4cHhcIiBoZWlnaHQ9XCIxNnB4XCIgdmlld0JveD1cIjAgMCAxOCAxNlwiIHZlcnNpb249XCIxLjFcIj5cbiAgICAgICAgPGcgZmlsbC1ydWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgIDxwb2x5Z29uIGZpbGw9XCIjMzA4OUZDXCIgcG9pbnRzPVwiNi4zMjQ3NSAxMC4yIDE4IDEwLjIgMTQuOTk5NjI1IDE1LjMgMy4zMjQzNzUgMTUuM1wiIC8+XG4gICAgICAgICAgPHBvbHlnb24gZmlsbD1cIiMwMEE4NURcIiBwb2ludHM9XCIzLjAwMDM3NSAxNS4zIDAgMTAuMiA1LjgzODc1IDAuMjc1OTc0MDI2IDguODM4IDUuMzc1OTc0MDMgNS45OTk2MjUgMTAuMlwiIC8+XG4gICAgICAgICAgPHBvbHlnb24gZmlsbD1cIiNGRkQwMjRcIiBwb2ludHM9XCIxMS44MzgzNzUgOS45MjQwMjU5NyA1Ljk5OTYyNSAwIDEyLjAwMDM3NSAwIDE3LjgzOTEyNSA5LjkyNDAyNTk3XCIgLz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9zdmc+XG4gICAgKVxuXG4gICAgdGhpcy5wcm92aWRlciA9IG5ldyBQcm92aWRlcih1cHB5LCB7XG4gICAgICBjb21wYW5pb25Vcmw6IHRoaXMub3B0cy5jb21wYW5pb25VcmwsXG4gICAgICBjb21wYW5pb25IZWFkZXJzOiB0aGlzLm9wdHMuY29tcGFuaW9uSGVhZGVycyB8fCB0aGlzLm9wdHMuc2VydmVySGVhZGVycyxcbiAgICAgIHN0b3JhZ2U6IHRoaXMub3B0cy5zdG9yYWdlLFxuICAgICAgcHJvdmlkZXI6ICdkcml2ZScsXG4gICAgICBhdXRoUHJvdmlkZXI6ICdnb29nbGUnLFxuICAgICAgcGx1Z2luSWQ6IHRoaXMuaWRcbiAgICB9KVxuXG4gICAgdGhpcy5vbkZpcnN0UmVuZGVyID0gdGhpcy5vbkZpcnN0UmVuZGVyLmJpbmQodGhpcylcbiAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcylcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIHRoaXMudmlldyA9IG5ldyBEcml2ZVByb3ZpZGVyVmlld3ModGhpcywge1xuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXJcbiAgICB9KVxuICAgIC8vIFNldCBkZWZhdWx0IHN0YXRlIGZvciBHb29nbGUgRHJpdmVcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGF1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxuICAgICAgZmlsZXM6IFtdLFxuICAgICAgZm9sZGVyczogW10sXG4gICAgICBkaXJlY3RvcmllczogW10sXG4gICAgICBhY3RpdmVSb3c6IC0xLFxuICAgICAgZmlsdGVySW5wdXQ6ICcnLFxuICAgICAgaXNTZWFyY2hWaXNpYmxlOiBmYWxzZSxcbiAgICAgIGhhc1RlYW1Ecml2ZXM6IGZhbHNlLFxuICAgICAgdGVhbURyaXZlczogW10sXG4gICAgICB0ZWFtRHJpdmVJZDogJydcbiAgICB9KVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRzLnRhcmdldFxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3LnRlYXJEb3duKClcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG5cbiAgb25GaXJzdFJlbmRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRGb2xkZXIoJ3Jvb3QnLCAnLycpXG4gIH1cblxuICByZW5kZXIgKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5yZW5kZXIoc3RhdGUpXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvaW5mb3JtZXJcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkEgbm90aWZpY2F0aW9uIGFuZCBlcnJvciBwb3AtdXAgYmFyIGZvciBVcHB5LlwiLFxuICBcInZlcnNpb25cIjogXCIxLjMuNFwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwic3R5bGVcIjogXCJkaXN0L3N0eWxlLm1pbi5jc3NcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cHB5XCIsXG4gICAgXCJ1cHB5LXBsdWdpblwiLFxuICAgIFwibm90aWZpY2F0aW9uXCIsXG4gICAgXCJiYXJcIixcbiAgICBcInVpXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS91dGlsc1wiOiBcImZpbGU6Li4vdXRpbHNcIixcbiAgICBcInByZWFjdFwiOiBcIjguMi45XCJcbiAgfSxcbiAgXCJwZWVyRGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvcmVcIjogXCJeMS4wLjBcIlxuICB9XG59XG4iLCJjb25zdCB7IFBsdWdpbiB9ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbi8qKlxuICogSW5mb3JtZXJcbiAqIFNob3dzIHJhZCBtZXNzYWdlIGJ1YmJsZXNcbiAqIHVzZWQgbGlrZSB0aGlzOiBgdXBweS5pbmZvKCdoZWxsbyB3b3JsZCcsICdpbmZvJywgNTAwMClgXG4gKiBvciBmb3IgZXJyb3JzOiBgdXBweS5pbmZvKCdFcnJvciB1cGxvYWRpbmcgaW1nLmpwZycsICdlcnJvcicsIDUwMDApYFxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBJbmZvcm1lciBleHRlbmRzIFBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLnR5cGUgPSAncHJvZ3Jlc3NpbmRpY2F0b3InXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnSW5mb3JtZXInXG4gICAgdGhpcy50aXRsZSA9ICdJbmZvcm1lcidcblxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHt9XG5cbiAgICAvLyBtZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgb25lcyBzZXQgYnkgdXNlclxuICAgIHRoaXMub3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRzKVxuXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpXG4gIH1cblxuICByZW5kZXIgKHN0YXRlKSB7XG4gICAgY29uc3QgeyBpc0hpZGRlbiwgbWVzc2FnZSwgZGV0YWlscyB9ID0gc3RhdGUuaW5mb1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJ1cHB5IHVwcHktSW5mb3JtZXJcIlxuICAgICAgICBhcmlhLWhpZGRlbj17aXNIaWRkZW59XG4gICAgICA+XG4gICAgICAgIDxwIHJvbGU9XCJhbGVydFwiPlxuICAgICAgICAgIHttZXNzYWdlfVxuICAgICAgICAgIHsnICd9XG4gICAgICAgICAge2RldGFpbHMgJiYgKFxuICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgYXJpYS1sYWJlbD17ZGV0YWlsc31cbiAgICAgICAgICAgICAgZGF0YS1taWNyb3RpcC1wb3NpdGlvbj1cInRvcC1sZWZ0XCJcbiAgICAgICAgICAgICAgZGF0YS1taWNyb3RpcC1zaXplPVwibWVkaXVtXCJcbiAgICAgICAgICAgICAgcm9sZT1cInRvb2x0aXBcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA/XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9wPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRzLnRhcmdldFxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9pbnN0YWdyYW1cIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkltcG9ydCBwaG90b3MgYW5kIHZpZGVvcyBmcm9tIEluc3RhZ3JhbSwgaW50byBVcHB5LlwiLFxuICBcInZlcnNpb25cIjogXCIxLjMuNVwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcImluc3RhZ3JhbVwiLFxuICAgIFwicHJvdmlkZXJcIixcbiAgICBcInBob3Rvc1wiLFxuICAgIFwidmlkZW9zXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb21wYW5pb24tY2xpZW50XCI6IFwiZmlsZTouLi9jb21wYW5pb24tY2xpZW50XCIsXG4gICAgXCJAdXBweS9wcm92aWRlci12aWV3c1wiOiBcImZpbGU6Li4vcHJvdmlkZXItdmlld3NcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHsgUHJvdmlkZXIgfSA9IHJlcXVpcmUoJ0B1cHB5L2NvbXBhbmlvbi1jbGllbnQnKVxuY29uc3QgUHJvdmlkZXJWaWV3cyA9IHJlcXVpcmUoJ0B1cHB5L3Byb3ZpZGVyLXZpZXdzJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBJbnN0YWdyYW0gZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5pZCA9IHRoaXMub3B0cy5pZCB8fCAnSW5zdGFncmFtJ1xuICAgIFByb3ZpZGVyLmluaXRQbHVnaW4odGhpcywgb3B0cylcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5vcHRzLnRpdGxlIHx8ICdJbnN0YWdyYW0nXG4gICAgdGhpcy5pY29uID0gKCkgPT4gKFxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGZpbGw9XCIjREUzNTczXCIgd2lkdGg9XCIyOFwiIGhlaWdodD1cIjI4XCIgdmlld0JveD1cIjAgMCA1MTIgNTEyXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNMjU2LDQ5LjQ3MWM2Ny4yNjYsMCw3NS4yMzMuMjU3LDEwMS44LDEuNDY5LDI0LjU2MiwxLjEyMSwzNy45LDUuMjI0LDQ2Ljc3OCw4LjY3NGE3OC4wNTIsNzguMDUyLDAsMCwxLDI4Ljk2NiwxOC44NDUsNzguMDUyLDc4LjA1MiwwLDAsMSwxOC44NDUsMjguOTY2YzMuNDUsOC44NzcsNy41NTQsMjIuMjE2LDguNjc0LDQ2Ljc3OCwxLjIxMiwyNi41NjUsMS40NjksMzQuNTMyLDEuNDY5LDEwMS44cy0wLjI1Nyw3NS4yMzMtMS40NjksMTAxLjhjLTEuMTIxLDI0LjU2Mi01LjIyNSwzNy45LTguNjc0LDQ2Ljc3OGE4My40MjcsODMuNDI3LDAsMCwxLTQ3LjgxMSw0Ny44MTFjLTguODc3LDMuNDUtMjIuMjE2LDcuNTU0LTQ2Ljc3OCw4LjY3NC0yNi41NiwxLjIxMi0zNC41MjcsMS40NjktMTAxLjgsMS40NjlzLTc1LjIzNy0uMjU3LTEwMS44LTEuNDY5Yy0yNC41NjItMS4xMjEtMzcuOS01LjIyNS00Ni43NzgtOC42NzRhNzguMDUxLDc4LjA1MSwwLDAsMS0yOC45NjYtMTguODQ1LDc4LjA1Myw3OC4wNTMsMCwwLDEtMTguODQ1LTI4Ljk2NmMtMy40NS04Ljg3Ny03LjU1NC0yMi4yMTYtOC42NzQtNDYuNzc4LTEuMjEyLTI2LjU2NC0xLjQ2OS0zNC41MzItMS40NjktMTAxLjhzMC4yNTctNzUuMjMzLDEuNDY5LTEwMS44YzEuMTIxLTI0LjU2Miw1LjIyNC0zNy45LDguNjc0LTQ2Ljc3OEE3OC4wNTIsNzguMDUyLDAsMCwxLDc4LjQ1OCw3OC40NThhNzguMDUzLDc4LjA1MywwLDAsMSwyOC45NjYtMTguODQ1YzguODc3LTMuNDUsMjIuMjE2LTcuNTU0LDQ2Ljc3OC04LjY3NCwyNi41NjUtMS4yMTIsMzQuNTMyLTEuNDY5LDEwMS44LTEuNDY5bTAtNDUuMzkxYy02OC40MTgsMC03NywuMjktMTAzLjg2NiwxLjUxNi0yNi44MTUsMS4yMjQtNDUuMTI3LDUuNDgyLTYxLjE1MSwxMS43MWExMjMuNDg4LDEyMy40ODgsMCwwLDAtNDQuNjIsMjkuMDU3QTEyMy40ODgsMTIzLjQ4OCwwLDAsMCwxNy4zLDkwLjk4MkMxMS4wNzcsMTA3LjAwNyw2LjgxOSwxMjUuMzE5LDUuNiwxNTIuMTM0LDQuMzY5LDE3OSw0LjA3OSwxODcuNTgyLDQuMDc5LDI1NlM0LjM2OSwzMzMsNS42LDM1OS44NjZjMS4yMjQsMjYuODE1LDUuNDgyLDQ1LjEyNywxMS43MSw2MS4xNTFhMTIzLjQ4OSwxMjMuNDg5LDAsMCwwLDI5LjA1Nyw0NC42MiwxMjMuNDg2LDEyMy40ODYsMCwwLDAsNDQuNjIsMjkuMDU3YzE2LjAyNSw2LjIyOCwzNC4zMzcsMTAuNDg2LDYxLjE1MSwxMS43MSwyNi44NywxLjIyNiwzNS40NDksMS41MTYsMTAzLjg2NiwxLjUxNnM3Ny0uMjksMTAzLjg2Ni0xLjUxNmMyNi44MTUtMS4yMjQsNDUuMTI3LTUuNDgyLDYxLjE1MS0xMS43MWExMjguODE3LDEyOC44MTcsMCwwLDAsNzMuNjc3LTczLjY3N2M2LjIyOC0xNi4wMjUsMTAuNDg2LTM0LjMzNywxMS43MS02MS4xNTEsMS4yMjYtMjYuODcsMS41MTYtMzUuNDQ5LDEuNTE2LTEwMy44NjZzLTAuMjktNzctMS41MTYtMTAzLjg2NmMtMS4yMjQtMjYuODE1LTUuNDgyLTQ1LjEyNy0xMS43MS02MS4xNTFhMTIzLjQ4NiwxMjMuNDg2LDAsMCwwLTI5LjA1Ny00NC42MkExMjMuNDg3LDEyMy40ODcsMCwwLDAsNDIxLjAxOCwxNy4zQzQwNC45OTMsMTEuMDc3LDM4Ni42ODEsNi44MTksMzU5Ljg2Niw1LjYsMzMzLDQuMzY5LDMyNC40MTgsNC4wNzksMjU2LDQuMDc5aDBaXCIgLz5cbiAgICAgICAgPHBhdGggZD1cIk0yNTYsMTI2LjYzNUExMjkuMzY1LDEyOS4zNjUsMCwxLDAsMzg1LjM2NSwyNTYsMTI5LjM2NSwxMjkuMzY1LDAsMCwwLDI1NiwxMjYuNjM1Wm0wLDIxMy4zMzhBODMuOTczLDgzLjk3MywwLDEsMSwzMzkuOTc0LDI1Niw4My45NzQsODMuOTc0LDAsMCwxLDI1NiwzMzkuOTczWlwiIC8+XG4gICAgICAgIDxjaXJjbGUgY3g9XCIzOTAuNDc2XCIgY3k9XCIxMjEuNTI0XCIgcj1cIjMwLjIzXCIgLz5cbiAgICAgIDwvc3ZnPlxuICAgIClcblxuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIodXBweSwge1xuICAgICAgY29tcGFuaW9uVXJsOiB0aGlzLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgY29tcGFuaW9uSGVhZGVyczogdGhpcy5vcHRzLmNvbXBhbmlvbkhlYWRlcnMgfHwgdGhpcy5vcHRzLnNlcnZlckhlYWRlcnMsXG4gICAgICBzdG9yYWdlOiB0aGlzLm9wdHMuc3RvcmFnZSxcbiAgICAgIHByb3ZpZGVyOiAnaW5zdGFncmFtJyxcbiAgICAgIGF1dGhQcm92aWRlcjogJ2luc3RhZ3JhbScsXG4gICAgICBwbHVnaW5JZDogdGhpcy5pZFxuICAgIH0pXG5cbiAgICB0aGlzLm9uRmlyc3RSZW5kZXIgPSB0aGlzLm9uRmlyc3RSZW5kZXIuYmluZCh0aGlzKVxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3ID0gbmV3IFByb3ZpZGVyVmlld3ModGhpcywge1xuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgICB2aWV3VHlwZTogJ2dyaWQnLFxuICAgICAgc2hvd1RpdGxlczogZmFsc2UsXG4gICAgICBzaG93RmlsdGVyOiBmYWxzZSxcbiAgICAgIHNob3dCcmVhZGNydW1iczogZmFsc2VcbiAgICB9KVxuICAgIC8vIFNldCBkZWZhdWx0IHN0YXRlIGZvciBJbnN0YWdyYW1cbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGF1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxuICAgICAgZmlsZXM6IFtdLFxuICAgICAgZm9sZGVyczogW10sXG4gICAgICBkaXJlY3RvcmllczogW10sXG4gICAgICBhY3RpdmVSb3c6IC0xLFxuICAgICAgZmlsdGVySW5wdXQ6ICcnLFxuICAgICAgaXNTZWFyY2hWaXNpYmxlOiBmYWxzZVxuICAgIH0pXG5cbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLm9wdHMudGFyZ2V0XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnZpZXcudGVhckRvd24oKVxuICAgIHRoaXMudW5tb3VudCgpXG4gIH1cblxuICBvbkZpcnN0UmVuZGVyICgpIHtcbiAgICB0aGlzLnZpZXcuZ2V0Rm9sZGVyKCdyZWNlbnQnKVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnZpZXcucmVuZGVyKHN0YXRlKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L29uZWRyaXZlXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJJbXBvcnQgZmlsZXMgZnJvbSBPbmVEcml2ZSwgaW50byBVcHB5LlwiLFxuICBcInZlcnNpb25cIjogXCIwLjEuNFwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcIm9uZWRyaXZlXCJcbiAgXSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vdXBweS5pb1wiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkvaXNzdWVzXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS5naXRcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb21wYW5pb24tY2xpZW50XCI6IFwiZmlsZTouLi9jb21wYW5pb24tY2xpZW50XCIsXG4gICAgXCJAdXBweS9wcm92aWRlci12aWV3c1wiOiBcImZpbGU6Li4vcHJvdmlkZXItdmlld3NcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHsgUHJvdmlkZXIgfSA9IHJlcXVpcmUoJ0B1cHB5L2NvbXBhbmlvbi1jbGllbnQnKVxuY29uc3QgUHJvdmlkZXJWaWV3cyA9IHJlcXVpcmUoJ0B1cHB5L3Byb3ZpZGVyLXZpZXdzJylcbmNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBPbmVEcml2ZSBleHRlbmRzIFBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdPbmVEcml2ZSdcbiAgICBQcm92aWRlci5pbml0UGx1Z2luKHRoaXMsIG9wdHMpXG4gICAgdGhpcy50aXRsZSA9IHRoaXMub3B0cy50aXRsZSB8fCAnT25lRHJpdmUnXG4gICAgdGhpcy5pY29uID0gKCkgPT4gKFxuICAgICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCA0OCA0OFwiIHdpZHRoPVwiNDhcIiBoZWlnaHQ9XCI0OFwiPlxuICAgICAgICA8cGF0aCBmaWxsPVwiIzE1NjVjMFwiIGQ9XCJNNDAuNDI5LDM1Ljk5OWMwLDAsMi44OS0wLjM5MywzLjQ3LTMuMTg1QzQzLjk2NCwzMi41MDIsNDQsMzIuMTYxLDQ0LDMxLjc4NyBjMC0wLjIzMy0wLjAxNS0wLjQ1NC0wLjA0NC0wLjY2NWMtMC40MjgtMy4xNTgtMy44NTItMy44NjgtMy44NTItMy44NjhzMC41OTUtMy40MDEtMi41NDMtNS4xODNjLTMuMTM4LTEuNzgtNi4wMDUsMC02LjAwNSwwIHMtMS42NzgtMy40MDEtNi4yMjItMy40MDFjLTUuODQzLDAtNi44MTcsNi42NC02LjgxNyw2LjY0UzEzLDI1LjYzNiwxMywzMC40OTNDMTMsMzUuMzUyLDE4LjAzMSwzNiwxOC4wMzEsMzZMNDAuNDI5LDM1Ljk5OSBMNDAuNDI5LDM1Ljk5OXpcIiAvPlxuICAgICAgICA8cGF0aCBmaWxsPVwiIzE1NjVjMFwiIGQ9XCJNMTEsMzAuNDkzYzAtNC4zOTUsMy4yODYtNi4zMTksNS44NzUtNi45NDVjMC44OTgtMi45NTQsMy4zODQtNi44NzgsOC40Ni02Ljg3OCBjMC4wMDYsMCwwLjAxMSwwLjAwMSwwLjAxNywwLjAwMWMwLjAwNywwLDAuMDEzLTAuMDAxLDAuMDItMC4wMDFjMy41MjIsMCw1LjcxLDEuNjQ2LDYuODkyLDIuOTUzIGMwLjY1LTAuMTkxLDEuNDQ4LTAuMzQzLDIuMzQ3LTAuMzQzYzAuMDA0LDAsMC4wMDcsMC4wMDEsMC4wMTEsMC4wMDFjMC4wMDMsMCwwLjAwNiwwLDAuMDEsMGMwLjAyLDAsMC4wMzksMC4wMDQsMC4wNTksMC4wMDQgQzM0LjcyOSwxOSwzNC4wNjMsMTIsMjYuMDEzLDEyYy01LjUwMywwLTcuNDQ2LDQuNjkxLTcuNDQ2LDQuNjkxcy0zLjk5Mi0yLjk2NS04LjA5MiwxLjEzM2MtMi4xMDUsMi4xMDQtMS42MTksNS4zMzgtMS42MTksNS4zMzggUzQsMjMuNjQ4LDQsMjguODI1QzQuMDAxLDMzLjUxNSw5LjAxOCwzNCw5LjAxOCwzNGgyLjgwN0MxMS4zMiwzMy4wNDEsMTEsMzEuODg2LDExLDMwLjQ5M3pcIiAvPlxuICAgICAgPC9zdmc+XG4gICAgKVxuXG4gICAgdGhpcy5wcm92aWRlciA9IG5ldyBQcm92aWRlcih1cHB5LCB7XG4gICAgICBjb21wYW5pb25Vcmw6IHRoaXMub3B0cy5jb21wYW5pb25VcmwsXG4gICAgICBjb21wYW5pb25IZWFkZXJzOiB0aGlzLm9wdHMuY29tcGFuaW9uSGVhZGVycyB8fCB0aGlzLm9wdHMuc2VydmVySGVhZGVycyxcbiAgICAgIHN0b3JhZ2U6IHRoaXMub3B0cy5zdG9yYWdlLFxuICAgICAgcHJvdmlkZXI6ICdvbmVkcml2ZScsXG4gICAgICBwbHVnaW5JZDogdGhpcy5pZFxuICAgIH0pXG5cbiAgICB0aGlzLm9uRmlyc3RSZW5kZXIgPSB0aGlzLm9uRmlyc3RSZW5kZXIuYmluZCh0aGlzKVxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3ID0gbmV3IFByb3ZpZGVyVmlld3ModGhpcywge1xuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXJcbiAgICB9KVxuICAgIC8vIFNldCBkZWZhdWx0IHN0YXRlIGZvciBEcm9wYm94XG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBhdXRoZW50aWNhdGVkOiBmYWxzZSxcbiAgICAgIGZpbGVzOiBbXSxcbiAgICAgIGZvbGRlcnM6IFtdLFxuICAgICAgZGlyZWN0b3JpZXM6IFtdLFxuICAgICAgYWN0aXZlUm93OiAtMSxcbiAgICAgIGZpbHRlcklucHV0OiAnJyxcbiAgICAgIGlzU2VhcmNoVmlzaWJsZTogZmFsc2VcbiAgICB9KVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRzLnRhcmdldFxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy52aWV3LnRlYXJEb3duKClcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG5cbiAgb25GaXJzdFJlbmRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRGb2xkZXIoKVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLnZpZXcucmVuZGVyKHN0YXRlKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L3Byb3ZpZGVyLXZpZXdzXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJWaWV3IGxpYnJhcnkgZm9yIFVwcHkgcmVtb3RlIHByb3ZpZGVyIHBsdWdpbnMuXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuNS4yXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJzdHlsZVwiOiBcImRpc3Qvc3R5bGUubWluLmNzc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwiY2xhc3NuYW1lc1wiOiBcIl4yLjIuNlwiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgaCwgQ29tcG9uZW50IH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5jbGFzcyBBdXRoVmlldyBleHRlbmRzIENvbXBvbmVudCB7XG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3QgcGx1Z2luTmFtZUNvbXBvbmVudCA9IChcbiAgICAgIDxzcGFuIGNsYXNzPVwidXBweS1Qcm92aWRlci1hdXRoVGl0bGVOYW1lXCI+e3RoaXMucHJvcHMucGx1Z2luTmFtZX08YnIgLz48L3NwYW4+XG4gICAgKVxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzPVwidXBweS1Qcm92aWRlci1hdXRoXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LVByb3ZpZGVyLWF1dGhJY29uXCI+e3RoaXMucHJvcHMucGx1Z2luSWNvbigpfTwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwidXBweS1Qcm92aWRlci1hdXRoVGl0bGVcIj5cbiAgICAgICAgICB7dGhpcy5wcm9wcy5pMThuQXJyYXkoJ2F1dGhlbnRpY2F0ZVdpdGhUaXRsZScsIHsgcGx1Z2luTmFtZTogcGx1Z2luTmFtZUNvbXBvbmVudCB9KX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBjbGFzcz1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktYy1idG4tcHJpbWFyeSB1cHB5LVByb3ZpZGVyLWF1dGhCdG5cIlxuICAgICAgICAgIG9uY2xpY2s9e3RoaXMucHJvcHMuaGFuZGxlQXV0aH1cbiAgICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICAgID5cbiAgICAgICAgICB7dGhpcy5wcm9wcy5pMThuQXJyYXkoJ2F1dGhlbnRpY2F0ZVdpdGgnLCB7IHBsdWdpbk5hbWU6IHRoaXMucHJvcHMucGx1Z2luTmFtZSB9KX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBdXRoVmlld1xuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG4vLyBUT0RPIHVzZSBGcmFnbWVudCB3aGVuIHVwZ3JhZGluZyB0byBwcmVhY3QgWFxuY29uc3QgQnJlYWRjcnVtYiA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxzcGFuPlxuICAgICAgPGJ1dHRvblxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgY2xhc3M9XCJ1cHB5LXUtcmVzZXRcIlxuICAgICAgICBvbmNsaWNrPXtwcm9wcy5nZXRGb2xkZXJ9XG4gICAgICA+XG4gICAgICAgIHtwcm9wcy50aXRsZX1cbiAgICAgIDwvYnV0dG9uPlxuICAgICAgeyFwcm9wcy5pc0xhc3QgPyAnIC8gJyA6ICcnfVxuICAgIDwvc3Bhbj5cbiAgKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3M9XCJ1cHB5LVByb3ZpZGVyLWJyZWFkY3J1bWJzXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwidXBweS1Qcm92aWRlci1icmVhZGNydW1ic0ljb25cIj57cHJvcHMuYnJlYWRjcnVtYnNJY29ufTwvZGl2PlxuICAgICAge1xuICAgICAgICBwcm9wcy5kaXJlY3Rvcmllcy5tYXAoKGRpcmVjdG9yeSwgaSkgPT4gKFxuICAgICAgICAgIDxCcmVhZGNydW1iXG4gICAgICAgICAgICBrZXk9e2RpcmVjdG9yeS5pZH1cbiAgICAgICAgICAgIGdldEZvbGRlcj17KCkgPT4gcHJvcHMuZ2V0Rm9sZGVyKGRpcmVjdG9yeS5pZCl9XG4gICAgICAgICAgICB0aXRsZT17aSA9PT0gMCA/IHByb3BzLnRpdGxlIDogZGlyZWN0b3J5LnRpdGxlfVxuICAgICAgICAgICAgaXNMYXN0PXtpICsgMSA9PT0gcHJvcHMuZGlyZWN0b3JpZXMubGVuZ3RofVxuICAgICAgICAgIC8+XG4gICAgICAgICkpXG4gICAgICB9XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJylcbmNvbnN0IEJyZWFkY3J1bWJzID0gcmVxdWlyZSgnLi9CcmVhZGNydW1icycpXG5jb25zdCBGaWx0ZXIgPSByZXF1aXJlKCcuL0ZpbHRlcicpXG5jb25zdCBJdGVtTGlzdCA9IHJlcXVpcmUoJy4vSXRlbUxpc3QnKVxuY29uc3QgRm9vdGVyQWN0aW9ucyA9IHJlcXVpcmUoJy4vRm9vdGVyQWN0aW9ucycpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmNvbnN0IEJyb3dzZXIgPSAocHJvcHMpID0+IHtcbiAgbGV0IGZpbHRlcmVkRm9sZGVycyA9IHByb3BzLmZvbGRlcnNcbiAgbGV0IGZpbHRlcmVkRmlsZXMgPSBwcm9wcy5maWxlc1xuXG4gIGlmIChwcm9wcy5maWx0ZXJJbnB1dCAhPT0gJycpIHtcbiAgICBmaWx0ZXJlZEZvbGRlcnMgPSBwcm9wcy5maWx0ZXJJdGVtcyhwcm9wcy5mb2xkZXJzKVxuICAgIGZpbHRlcmVkRmlsZXMgPSBwcm9wcy5maWx0ZXJJdGVtcyhwcm9wcy5maWxlcylcbiAgfVxuXG4gIGNvbnN0IHNlbGVjdGVkID0gcHJvcHMuY3VycmVudFNlbGVjdGlvbi5sZW5ndGhcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3M9e2NsYXNzTmFtZXMoJ3VwcHktUHJvdmlkZXJCcm93c2VyJywgYHVwcHktUHJvdmlkZXJCcm93c2VyLXZpZXdUeXBlLS0ke3Byb3BzLnZpZXdUeXBlfWApfT5cbiAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LVByb3ZpZGVyQnJvd3Nlci1oZWFkZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz17Y2xhc3NOYW1lcygndXBweS1Qcm92aWRlckJyb3dzZXItaGVhZGVyQmFyJywgIXByb3BzLnNob3dCcmVhZGNydW1icyAmJiAndXBweS1Qcm92aWRlckJyb3dzZXItaGVhZGVyQmFyLS1zaW1wbGUnKX0+XG4gICAgICAgICAge3Byb3BzLnNob3dCcmVhZGNydW1icyAmJiBCcmVhZGNydW1icyh7XG4gICAgICAgICAgICBnZXRGb2xkZXI6IHByb3BzLmdldEZvbGRlcixcbiAgICAgICAgICAgIGRpcmVjdG9yaWVzOiBwcm9wcy5kaXJlY3RvcmllcyxcbiAgICAgICAgICAgIGJyZWFkY3J1bWJzSWNvbjogcHJvcHMucGx1Z2luSWNvbiAmJiBwcm9wcy5wbHVnaW5JY29uKCksXG4gICAgICAgICAgICB0aXRsZTogcHJvcHMudGl0bGVcbiAgICAgICAgICB9KX1cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cInVwcHktUHJvdmlkZXJCcm93c2VyLXVzZXJcIj57cHJvcHMudXNlcm5hbWV9PC9zcGFuPlxuICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIG9uY2xpY2s9e3Byb3BzLmxvZ291dH0gY2xhc3M9XCJ1cHB5LXUtcmVzZXQgdXBweS1Qcm92aWRlckJyb3dzZXItdXNlckxvZ291dFwiPlxuICAgICAgICAgICAge3Byb3BzLmkxOG4oJ2xvZ091dCcpfVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAge3Byb3BzLnNob3dGaWx0ZXIgJiYgPEZpbHRlciB7Li4ucHJvcHN9IC8+fVxuICAgICAgPEl0ZW1MaXN0XG4gICAgICAgIGNvbHVtbnM9e1t7XG4gICAgICAgICAgbmFtZTogJ05hbWUnLFxuICAgICAgICAgIGtleTogJ3RpdGxlJ1xuICAgICAgICB9XX1cbiAgICAgICAgZm9sZGVycz17ZmlsdGVyZWRGb2xkZXJzfVxuICAgICAgICBmaWxlcz17ZmlsdGVyZWRGaWxlc31cbiAgICAgICAgYWN0aXZlUm93PXtwcm9wcy5pc0FjdGl2ZVJvd31cbiAgICAgICAgc29ydEJ5VGl0bGU9e3Byb3BzLnNvcnRCeVRpdGxlfVxuICAgICAgICBzb3J0QnlEYXRlPXtwcm9wcy5zb3J0QnlEYXRlfVxuICAgICAgICBpc0NoZWNrZWQ9e3Byb3BzLmlzQ2hlY2tlZH1cbiAgICAgICAgaGFuZGxlRm9sZGVyQ2xpY2s9e3Byb3BzLmdldE5leHRGb2xkZXJ9XG4gICAgICAgIHRvZ2dsZUNoZWNrYm94PXtwcm9wcy50b2dnbGVDaGVja2JveH1cbiAgICAgICAgaGFuZGxlU2Nyb2xsPXtwcm9wcy5oYW5kbGVTY3JvbGx9XG4gICAgICAgIHRpdGxlPXtwcm9wcy50aXRsZX1cbiAgICAgICAgc2hvd1RpdGxlcz17cHJvcHMuc2hvd1RpdGxlc31cbiAgICAgICAgaTE4bj17cHJvcHMuaTE4bn1cbiAgICAgICAgdmlld1R5cGU9e3Byb3BzLnZpZXdUeXBlfVxuICAgICAgLz5cbiAgICAgIHtzZWxlY3RlZCA+IDAgJiYgPEZvb3RlckFjdGlvbnMgc2VsZWN0ZWQ9e3NlbGVjdGVkfSB7Li4ucHJvcHN9IC8+fVxuICAgIDwvZGl2PlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQnJvd3NlclxuIiwiY29uc3QgeyBoLCBDb21wb25lbnQgfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRmlsdGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IgKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG4gICAgdGhpcy5wcmV2ZW50RW50ZXJQcmVzcyA9IHRoaXMucHJldmVudEVudGVyUHJlc3MuYmluZCh0aGlzKVxuICB9XG5cbiAgcHJldmVudEVudGVyUHJlc3MgKGV2KSB7XG4gICAgaWYgKGV2LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgZXYucHJldmVudERlZmF1bHQoKVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LVByb3ZpZGVyQnJvd3Nlci1zZWFyY2hcIj5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgY2xhc3M9XCJ1cHB5LXUtcmVzZXQgdXBweS1Qcm92aWRlckJyb3dzZXItc2VhcmNoSW5wdXRcIlxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICBwbGFjZWhvbGRlcj17dGhpcy5wcm9wcy5pMThuKCdmaWx0ZXInKX1cbiAgICAgICAgICBhcmlhLWxhYmVsPXt0aGlzLnByb3BzLmkxOG4oJ2ZpbHRlcicpfVxuICAgICAgICAgIG9ua2V5dXA9e3RoaXMucHJldmVudEVudGVyUHJlc3N9XG4gICAgICAgICAgb25rZXlkb3duPXt0aGlzLnByZXZlbnRFbnRlclByZXNzfVxuICAgICAgICAgIG9ua2V5cHJlc3M9e3RoaXMucHJldmVudEVudGVyUHJlc3N9XG4gICAgICAgICAgb25pbnB1dD17KGUpID0+IHRoaXMucHJvcHMuZmlsdGVyUXVlcnkoZSl9XG4gICAgICAgICAgdmFsdWU9e3RoaXMucHJvcHMuZmlsdGVySW5wdXR9XG4gICAgICAgIC8+XG4gICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzcz1cIlVwcHlJY29uIHVwcHktUHJvdmlkZXJCcm93c2VyLXNlYXJjaEljb25cIiB3aWR0aD1cIjEyXCIgaGVpZ2h0PVwiMTJcIiB2aWV3Qm94PVwiMCAwIDEyIDEyXCI+XG4gICAgICAgICAgPHBhdGggZD1cIk04LjYzOCA3Ljk5bDMuMTcyIDMuMTcyYS40OTIuNDkyIDAgMSAxLS42OTcuNjk3TDcuOTEgOC42NTZhNC45NzcgNC45NzcgMCAwIDEtMi45ODMuOTgzQzIuMjA2IDkuNjM5IDAgNy40ODEgMCA0LjgxOSAwIDIuMTU4IDIuMjA2IDAgNC45MjcgMGMyLjcyMSAwIDQuOTI3IDIuMTU4IDQuOTI3IDQuODJhNC43NCA0Ljc0IDAgMCAxLTEuMjE2IDMuMTd6bS0zLjcxLjY4NWMyLjE3NiAwIDMuOTQtMS43MjYgMy45NC0zLjg1NiAwLTIuMTI5LTEuNzY0LTMuODU1LTMuOTQtMy44NTVDMi43NS45NjQuOTg0IDIuNjkuOTg0IDQuODE5YzAgMi4xMyAxLjc2NSAzLjg1NiAzLjk0MiAzLjg1NnpcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAge3RoaXMucHJvcHMuZmlsdGVySW5wdXQgJiYgKFxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIGNsYXNzPVwidXBweS11LXJlc2V0IHVwcHktUHJvdmlkZXJCcm93c2VyLXNlYXJjaENsb3NlXCJcbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgYXJpYS1sYWJlbD17dGhpcy5wcm9wcy5pMThuKCdyZXNldEZpbHRlcicpfVxuICAgICAgICAgICAgdGl0bGU9e3RoaXMucHJvcHMuaTE4bigncmVzZXRGaWx0ZXInKX1cbiAgICAgICAgICAgIG9uY2xpY2s9e3RoaXMucHJvcHMuZmlsdGVyUXVlcnl9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzPVwiVXBweUljb25cIiB2aWV3Qm94PVwiMCAwIDE5IDE5XCI+XG4gICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMTcuMzE4IDE3LjIzMkw5Ljk0IDkuODU0IDkuNTg2IDkuNWwtLjM1NC4zNTQtNy4zNzggNy4zNzhoLjcwN2wtLjYyLS42MnYuNzA2TDkuMzE4IDkuOTRsLjM1NC0uMzU0LS4zNTQtLjM1NEwxLjk0IDEuODU0di43MDdsLjYyLS42MmgtLjcwNmw3LjM3OCA3LjM3OC4zNTQuMzU0LjM1NC0uMzU0IDcuMzc4LTcuMzc4aC0uNzA3bC42MjIuNjJ2LS43MDZMOS44NTQgOS4yMzJsLS4zNTQuMzU0LjM1NC4zNTQgNy4zNzggNy4zNzguNzA4LS43MDctNy4zOC03LjM3OHYuNzA4bDcuMzgtNy4zOC4zNTMtLjM1My0uMzUzLS4zNTMtLjYyMi0uNjIyLS4zNTMtLjM1My0uMzU0LjM1Mi03LjM3OCA3LjM4aC43MDhMMi41NiAxLjIzIDIuMjA4Ljg4bC0uMzUzLjM1My0uNjIyLjYyLS4zNTMuMzU1LjM1Mi4zNTMgNy4zOCA3LjM4di0uNzA4bC03LjM4IDcuMzgtLjM1My4zNTMuMzUyLjM1My42MjIuNjIyLjM1My4zNTMuMzU0LS4zNTMgNy4zOC03LjM4aC0uNzA4bDcuMzggNy4zOHpcIiAvPlxuICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzPVwidXBweS1Qcm92aWRlckJyb3dzZXItZm9vdGVyXCI+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1jLWJ0bi1wcmltYXJ5XCIgb25jbGljaz17cHJvcHMuZG9uZX0+XG4gICAgICAgIHtwcm9wcy5pMThuKCdzZWxlY3RYJywge1xuICAgICAgICAgIHNtYXJ0X2NvdW50OiBwcm9wcy5zZWxlY3RlZFxuICAgICAgICB9KX1cbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiBjbGFzcz1cInVwcHktdS1yZXNldCB1cHB5LWMtYnRuIHVwcHktYy1idG4tbGlua1wiIG9uY2xpY2s9e3Byb3BzLmNhbmNlbH0+XG4gICAgICAgIHtwcm9wcy5pMThuKCdjYW5jZWwnKX1cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbi8vIGl0IGNvdWxkIGJlIGEgPGxpPjxidXR0b24gY2xhc3M9XCJmYWtlLWNoZWNrYm94XCIvPiA8YnV0dG9uLz48L2xpPlxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8bGkgY2xhc3M9e3Byb3BzLmNsYXNzTmFtZX0+XG4gICAgICA8ZGl2IGFyaWEtaGlkZGVuIGNsYXNzPXtgdXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLWZha2VDaGVja2JveCAke3Byb3BzLmlzQ2hlY2tlZCA/ICd1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0tZmFrZUNoZWNrYm94LS1pcy1jaGVja2VkJyA6ICcnfWB9IC8+XG4gICAgICA8YnV0dG9uXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICBjbGFzcz1cInVwcHktdS1yZXNldCB1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0taW5uZXJcIlxuICAgICAgICBvbmNsaWNrPXtwcm9wcy50b2dnbGVDaGVja2JveH1cblxuICAgICAgICByb2xlPVwib3B0aW9uXCJcbiAgICAgICAgYXJpYS1sYWJlbD17cHJvcHMuaXNDaGVja2VkID8gcHJvcHMuaTE4bigndW5zZWxlY3RGaWxlTmFtZWQnLCB7IG5hbWU6IHByb3BzLnRpdGxlIH0pIDogcHJvcHMuaTE4bignc2VsZWN0RmlsZU5hbWVkJywgeyBuYW1lOiBwcm9wcy50aXRsZSB9KX1cbiAgICAgICAgYXJpYS1zZWxlY3RlZD17cHJvcHMuaXNDaGVja2VkfVxuICAgICAgICBhcmlhLWRpc2FibGVkPXtwcm9wcy5pc0Rpc2FibGVkfVxuICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICA+XG4gICAgICAgIHtwcm9wcy5pdGVtSWNvbkVsfVxuICAgICAgICB7cHJvcHMuc2hvd1RpdGxlcyAmJiBwcm9wcy50aXRsZX1cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvbGk+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxuZnVuY3Rpb24gRmlsZUljb24gKCkge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzcz1cIlVwcHlJY29uXCIgd2lkdGg9ezExfSBoZWlnaHQ9ezE0LjV9IHZpZXdCb3g9XCIwIDAgNDQgNThcIj5cbiAgICAgIDxwYXRoIGQ9XCJNMjcuNDM3LjUxN2ExIDEgMCAwIDAtLjA5NC4wM0g0LjI1QzIuMDM3LjU0OC4yMTcgMi4zNjguMjE3IDQuNTh2NDguNDA1YzAgMi4yMTIgMS44MiA0LjAzIDQuMDMgNC4wM0gzOS4wM2MyLjIxIDAgNC4wMy0xLjgxOCA0LjAzLTQuMDNWMTUuNjFhMSAxIDAgMCAwLS4wMy0uMjggMSAxIDAgMCAwIDAtLjA5MyAxIDEgMCAwIDAtLjAzLS4wMzIgMSAxIDAgMCAwIDAtLjAzIDEgMSAwIDAgMC0uMDMyLS4wNjMgMSAxIDAgMCAwLS4wMy0uMDYzIDEgMSAwIDAgMC0uMDMyIDAgMSAxIDAgMCAwLS4wMy0uMDYzIDEgMSAwIDAgMC0uMDMyLS4wMyAxIDEgMCAwIDAtLjAzLS4wNjMgMSAxIDAgMCAwLS4wNjMtLjA2MmwtMTQuNTkzLTE0YTEgMSAwIDAgMC0uMDYyLS4wNjJBMSAxIDAgMCAwIDI4IC43MDhhMSAxIDAgMCAwLS4zNzQtLjE1NyAxIDEgMCAwIDAtLjE1NiAwIDEgMSAwIDAgMC0uMDMtLjAzbC0uMDAzLS4wMDN6TTQuMjUgMi41NDdoMjIuMjE4djkuOTdjMCAyLjIxIDEuODIgNC4wMyA0LjAzIDQuMDNoMTAuNTY0djM2LjQzOGEyLjAyIDIuMDIgMCAwIDEtMi4wMzIgMi4wMzJINC4yNWMtMS4xMyAwLTIuMDMyLS45LTIuMDMyLTIuMDMyVjQuNThjMC0xLjEzLjkwMi0yLjAzMiAyLjAzLTIuMDMyem0yNC4yMTggMS4zNDVsMTAuMzc1IDkuOTM3Ljc1LjcxOEgzMC41Yy0xLjEzIDAtMi4wMzItLjktMi4wMzItMi4wM1YzLjg5elwiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gRm9sZGVySWNvbiAoKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzPVwiVXBweUljb25cIiBzdHlsZT17eyB3aWR0aDogMTYsIG1hcmdpblJpZ2h0OiAzIH19IHZpZXdCb3g9XCIwIDAgMjc2LjE1NyAyNzYuMTU3XCI+XG4gICAgICA8cGF0aCBkPVwiTTI3My4wOCAxMDEuMzc4Yy0zLjMtNC42NS04Ljg2LTcuMzItMTUuMjU0LTcuMzJoLTI0LjM0VjY3LjU5YzAtMTAuMi04LjMtMTguNS0xOC41LTE4LjVoLTg1LjMyMmMtMy42MyAwLTkuMjk1LTIuODc1LTExLjQzNi01LjgwNWwtNi4zODYtOC43MzVjLTQuOTgyLTYuODE0LTE1LjEwNC0xMS45NTQtMjMuNTQ2LTExLjk1NEg1OC43M2MtOS4yOTIgMC0xOC42MzggNi42MDgtMjEuNzM3IDE1LjM3MmwtMi4wMzMgNS43NTJjLS45NTggMi43MS00LjcyIDUuMzctNy41OTYgNS4zN0gxOC41QzguMyA0OS4wOSAwIDU3LjM5IDAgNjcuNTl2MTY3LjA3YzAgLjg4Ni4xNiAxLjczLjQ0MyAyLjUyLjE1MiAzLjMwNiAxLjE4IDYuNDI0IDMuMDUzIDkuMDY0IDMuMyA0LjY1MiA4Ljg2IDcuMzIgMTUuMjU1IDcuMzJoMTg4LjQ4N2MxMS4zOTUgMCAyMy4yNy04LjQyNSAyNy4wMzUtMTkuMThsNDAuNjc3LTExNi4xODhjMi4xMS02LjAzNSAxLjQzLTEyLjE2NC0xLjg3LTE2LjgxNnpNMTguNSA2NC4wODhoOC44NjRjOS4yOTUgMCAxOC42NC02LjYwNyAyMS43MzgtMTUuMzdsMi4wMzItNS43NWMuOTYtMi43MTIgNC43MjItNS4zNzMgNy41OTctNS4zNzNoMjkuNTY1YzMuNjMgMCA5LjI5NSAyLjg3NiAxMS40MzcgNS44MDZsNi4zODYgOC43MzVjNC45ODIgNi44MTUgMTUuMTA0IDExLjk1NCAyMy41NDYgMTEuOTU0aDg1LjMyMmMxLjg5OCAwIDMuNSAxLjYwMiAzLjUgMy41djI2LjQ3SDY5LjM0Yy0xMS4zOTUgMC0yMy4yNyA4LjQyMy0yNy4wMzUgMTkuMTc4TDE1IDE5MS4yM1Y2Ny41OWMwLTEuODk4IDEuNjAzLTMuNSAzLjUtMy41em0yNDIuMjkgNDkuMTVsLTQwLjY3NiAxMTYuMTg4Yy0xLjY3NCA0Ljc4LTcuODEyIDkuMTM1LTEyLjg3NyA5LjEzNUgxOC43NWMtMS40NDcgMC0yLjU3Ni0uMzcyLTMuMDItLjk5Ny0uNDQyLS42MjUtLjQyMi0xLjgxNC4wNTctMy4xOGw0MC42NzctMTE2LjE5YzEuNjc0LTQuNzggNy44MTItOS4xMzQgMTIuODc3LTkuMTM0aDE4OC40ODdjMS40NDggMCAyLjU3Ny4zNzIgMy4wMi45OTcuNDQzLjYyNS40MjMgMS44MTQtLjA1NiAzLjE4elwiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuZnVuY3Rpb24gVmlkZW9JY29uICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgdmlld0JveD1cIjAgMCA1OCA1OFwiPlxuICAgICAgPHBhdGggZD1cIk0zNi41MzcgMjguMTU2bC0xMS03YTEuMDA1IDEuMDA1IDAgMCAwLTEuMDItLjAzM0MyNC4yIDIxLjMgMjQgMjEuNjM1IDI0IDIydjE0YTEgMSAwIDAgMCAxLjUzNy44NDRsMTEtN2ExLjAwMiAxLjAwMiAwIDAgMCAwLTEuNjg4ek0yNiAzNC4xOFYyMy44MkwzNC4xMzcgMjkgMjYgMzQuMTh6XCIgLz5cbiAgICAgIDxwYXRoIGQ9XCJNNTcgNkgxYTEgMSAwIDAgMC0xIDF2NDRhMSAxIDAgMCAwIDEgMWg1NmExIDEgMCAwIDAgMS0xVjdhMSAxIDAgMCAwLTEtMXpNMTAgMjhIMnYtOWg4djl6bS04IDJoOHY5SDJ2LTl6bTEwIDEwVjhoMzR2NDJIMTJWNDB6bTQ0LTEyaC04di05aDh2OXptLTggMmg4djloLTh2LTl6bTgtMjJ2OWgtOFY4aDh6TTIgOGg4djlIMlY4em0wIDQydi05aDh2OUgyem01NCAwaC04di05aDh2OXpcIiAvPlxuICAgIDwvc3ZnPlxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKHByb3BzKSA9PiB7XG4gIGlmIChwcm9wcy5pdGVtSWNvblN0cmluZyA9PT0gbnVsbCkgcmV0dXJuXG5cbiAgc3dpdGNoIChwcm9wcy5pdGVtSWNvblN0cmluZykge1xuICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgcmV0dXJuIDxGaWxlSWNvbiAvPlxuICAgIGNhc2UgJ2ZvbGRlcic6XG4gICAgICByZXR1cm4gPEZvbGRlckljb24gLz5cbiAgICBjYXNlICd2aWRlbyc6XG4gICAgICByZXR1cm4gPFZpZGVvSWNvbiAvPlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gPGltZyBzcmM9e3Byb3BzLml0ZW1JY29uU3RyaW5nfSAvPlxuICB9XG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmNvbnN0IGdldEFyaWFMYWJlbE9mQ2hlY2tib3ggPSAocHJvcHMpID0+IHtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdmb2xkZXInKSB7XG4gICAgaWYgKHByb3BzLmlzQ2hlY2tlZCkge1xuICAgICAgcmV0dXJuIHByb3BzLmkxOG4oJ3Vuc2VsZWN0QWxsRmlsZXNGcm9tRm9sZGVyTmFtZWQnLCB7IG5hbWU6IHByb3BzLnRpdGxlIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcm9wcy5pMThuKCdzZWxlY3RBbGxGaWxlc0Zyb21Gb2xkZXJOYW1lZCcsIHsgbmFtZTogcHJvcHMudGl0bGUgfSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByb3BzLmlzQ2hlY2tlZCkge1xuICAgICAgcmV0dXJuIHByb3BzLmkxOG4oJ3Vuc2VsZWN0RmlsZU5hbWVkJywgeyBuYW1lOiBwcm9wcy50aXRsZSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJvcHMuaTE4bignc2VsZWN0RmlsZU5hbWVkJywgeyBuYW1lOiBwcm9wcy50aXRsZSB9KVxuICAgIH1cbiAgfVxufVxuXG4vLyBpZiBmb2xkZXI6XG4vLyAgICsgY2hlY2tib3ggKHNlbGVjdHMgYWxsIGZpbGVzIGZyb20gZm9sZGVyKVxuLy8gICArIGZvbGRlciBuYW1lIChvcGVucyBmb2xkZXIpXG4vLyBpZiBmaWxlOlxuLy8gICArIGNoZWNrYm94IChzZWxlY3RzIGZpbGUpXG4vLyAgICsgZmlsZSBuYW1lIChzZWxlY3RzIGZpbGUpXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxsaSBjbGFzcz17cHJvcHMuY2xhc3NOYW1lfT5cbiAgICAgIDxidXR0b25cbiAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgIGNsYXNzPXtgdXBweS11LXJlc2V0IHVwcHktUHJvdmlkZXJCcm93c2VySXRlbS1mYWtlQ2hlY2tib3ggJHtwcm9wcy5pc0NoZWNrZWQgPyAndXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLWZha2VDaGVja2JveC0taXMtY2hlY2tlZCcgOiAnJ31gfVxuICAgICAgICBvbkNsaWNrPXtwcm9wcy50b2dnbGVDaGVja2JveH1cbiAgICAgICAgLy8gZm9yIHRoZSA8bGFiZWwvPlxuICAgICAgICBpZD17cHJvcHMuaWR9XG4gICAgICAgIHJvbGU9XCJvcHRpb25cIlxuICAgICAgICBhcmlhLWxhYmVsPXtnZXRBcmlhTGFiZWxPZkNoZWNrYm94KHByb3BzKX1cbiAgICAgICAgYXJpYS1zZWxlY3RlZD17cHJvcHMuaXNDaGVja2VkfVxuICAgICAgICBhcmlhLWRpc2FibGVkPXtwcm9wcy5pc0Rpc2FibGVkfVxuICAgICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgICAvPlxuXG4gICAgICB7cHJvcHMudHlwZSA9PT0gJ2ZpbGUnID8gKFxuICAgICAgICAvLyBsYWJlbCBmb3IgYSBjaGVja2JveFxuICAgICAgICA8bGFiZWwgZm9yPXtwcm9wcy5pZH0gY2xhc3NOYW1lPVwidXBweS11LXJlc2V0IHVwcHktUHJvdmlkZXJCcm93c2VySXRlbS1pbm5lclwiPlxuICAgICAgICAgIHtwcm9wcy5pdGVtSWNvbkVsfVxuICAgICAgICAgIHtwcm9wcy5zaG93VGl0bGVzICYmIHByb3BzLnRpdGxlfVxuICAgICAgICA8L2xhYmVsPlxuICAgICAgKSA6IChcbiAgICAgICAgLy8gYnV0dG9uIHRvIG9wZW4gYSBmb2xkZXJcbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIGNsYXNzPVwidXBweS11LXJlc2V0IHVwcHktUHJvdmlkZXJCcm93c2VySXRlbS1pbm5lclwiXG4gICAgICAgICAgb25jbGljaz17cHJvcHMuaGFuZGxlRm9sZGVyQ2xpY2t9XG4gICAgICAgICAgYXJpYS1sYWJlbD17cHJvcHMuaTE4bignb3BlbkZvbGRlck5hbWVkJywgeyBuYW1lOiBwcm9wcy50aXRsZSB9KX1cbiAgICAgICAgPlxuICAgICAgICAgIHtwcm9wcy5pdGVtSWNvbkVsfVxuICAgICAgICAgIHtwcm9wcy5zaG93VGl0bGVzICYmIHByb3BzLnRpdGxlfVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICl9XG4gICAgPC9saT5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKVxuY29uc3QgSXRlbUljb24gPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvSXRlbUljb24nKVxuY29uc3QgR3JpZExpID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL0dyaWRMaScpXG5jb25zdCBMaXN0TGkgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvTGlzdExpJylcblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgaXRlbUljb25TdHJpbmcgPSBwcm9wcy5nZXRJdGVtSWNvbigpXG5cbiAgY29uc3QgY2xhc3NOYW1lID0gY2xhc3NOYW1lcyhcbiAgICAndXBweS1Qcm92aWRlckJyb3dzZXJJdGVtJyxcbiAgICB7ICd1cHB5LVByb3ZpZGVyQnJvd3Nlckl0ZW0tLXNlbGVjdGVkJzogcHJvcHMuaXNDaGVja2VkIH0sXG4gICAgeyAndXBweS1Qcm92aWRlckJyb3dzZXJJdGVtLS1ub1ByZXZpZXcnOiBpdGVtSWNvblN0cmluZyA9PT0gJ3ZpZGVvJyB9XG4gIClcblxuICBjb25zdCBpdGVtSWNvbkVsID0gPEl0ZW1JY29uIGl0ZW1JY29uU3RyaW5nPXtpdGVtSWNvblN0cmluZ30gLz5cblxuICBzd2l0Y2ggKHByb3BzLnZpZXdUeXBlKSB7XG4gICAgY2FzZSAnZ3JpZCc6XG4gICAgICByZXR1cm4gPEdyaWRMaSB7Li4ucHJvcHN9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBpdGVtSWNvbkVsPXtpdGVtSWNvbkVsfSAvPlxuICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgcmV0dXJuIDxMaXN0TGkgey4uLnByb3BzfSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gaXRlbUljb25FbD17aXRlbUljb25FbH0gLz5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBubyBzdWNoIHR5cGUgJHtwcm9wcy52aWV3VHlwZX1gKVxuICB9XG59XG4iLCJjb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCBJdGVtID0gcmVxdWlyZSgnLi9JdGVtL2luZGV4JylcblxuY29uc3QgZ2V0U2hhcmVkUHJvcHMgPSAoZmlsZU9yRm9sZGVyLCBwcm9wcykgPT4gKHtcbiAgaWQ6IGZpbGVPckZvbGRlci5pZCxcbiAgdGl0bGU6IGZpbGVPckZvbGRlci5uYW1lLFxuICBnZXRJdGVtSWNvbjogKCkgPT4gZmlsZU9yRm9sZGVyLmljb24sXG4gIGlzQ2hlY2tlZDogcHJvcHMuaXNDaGVja2VkKGZpbGVPckZvbGRlciksXG4gIHRvZ2dsZUNoZWNrYm94OiAoZSkgPT4gcHJvcHMudG9nZ2xlQ2hlY2tib3goZSwgZmlsZU9yRm9sZGVyKSxcbiAgY29sdW1uczogcHJvcHMuY29sdW1ucyxcbiAgc2hvd1RpdGxlczogcHJvcHMuc2hvd1RpdGxlcyxcbiAgdmlld1R5cGU6IHByb3BzLnZpZXdUeXBlLFxuICBpMThuOiBwcm9wcy5pMThuXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICBpZiAoIXByb3BzLmZvbGRlcnMubGVuZ3RoICYmICFwcm9wcy5maWxlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gPGRpdiBjbGFzcz1cInVwcHktUHJvdmlkZXItZW1wdHlcIj57cHJvcHMuaTE4bignbm9GaWxlc0ZvdW5kJyl9PC9kaXY+XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3M9XCJ1cHB5LVByb3ZpZGVyQnJvd3Nlci1ib2R5XCI+XG4gICAgICA8dWxcbiAgICAgICAgY2xhc3M9XCJ1cHB5LVByb3ZpZGVyQnJvd3Nlci1saXN0XCJcbiAgICAgICAgb25zY3JvbGw9e3Byb3BzLmhhbmRsZVNjcm9sbH1cbiAgICAgICAgcm9sZT1cImxpc3Rib3hcIlxuICAgICAgICAvLyBtYWtpbmcgPHVsPiBub3QgZm9jdXNhYmxlIGZvciBmaXJlZm94XG4gICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgPlxuICAgICAgICB7cHJvcHMuZm9sZGVycy5tYXAoZm9sZGVyID0+XG4gICAgICAgICAgSXRlbSh7XG4gICAgICAgICAgICAuLi5nZXRTaGFyZWRQcm9wcyhmb2xkZXIsIHByb3BzKSxcbiAgICAgICAgICAgIHR5cGU6ICdmb2xkZXInLFxuICAgICAgICAgICAgaXNEaXNhYmxlZDogcHJvcHMuaXNDaGVja2VkKGZvbGRlcikgPyBwcm9wcy5pc0NoZWNrZWQoZm9sZGVyKS5sb2FkaW5nIDogZmFsc2UsXG4gICAgICAgICAgICBoYW5kbGVGb2xkZXJDbGljazogKCkgPT4gcHJvcHMuaGFuZGxlRm9sZGVyQ2xpY2soZm9sZGVyKVxuICAgICAgICAgIH0pXG4gICAgICAgICl9XG4gICAgICAgIHtwcm9wcy5maWxlcy5tYXAoZmlsZSA9PlxuICAgICAgICAgIEl0ZW0oe1xuICAgICAgICAgICAgLi4uZ2V0U2hhcmVkUHJvcHMoZmlsZSwgcHJvcHMpLFxuICAgICAgICAgICAgdHlwZTogJ2ZpbGUnLFxuICAgICAgICAgICAgaXNEaXNhYmxlZDogZmFsc2VcbiAgICAgICAgICB9KVxuICAgICAgICApfVxuICAgICAgPC91bD5cbiAgICA8L2Rpdj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3M9XCJ1cHB5LVByb3ZpZGVyLWxvYWRpbmdcIj5cbiAgICAgIDxzcGFuPntwcm9wcy5pMThuKCdsb2FkaW5nJyl9PC9zcGFuPlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJjb25zdCB7IGgsIENvbXBvbmVudCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IEF1dGhWaWV3ID0gcmVxdWlyZSgnLi9BdXRoVmlldycpXG5jb25zdCBCcm93c2VyID0gcmVxdWlyZSgnLi9Ccm93c2VyJylcbmNvbnN0IExvYWRlclZpZXcgPSByZXF1aXJlKCcuL0xvYWRlcicpXG5jb25zdCBnZW5lcmF0ZUZpbGVJRCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZW5lcmF0ZUZpbGVJRCcpXG5jb25zdCBnZXRGaWxlVHlwZSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRGaWxlVHlwZScpXG5jb25zdCBpc1ByZXZpZXdTdXBwb3J0ZWQgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvaXNQcmV2aWV3U3VwcG9ydGVkJylcblxuLyoqXG4gKiBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4IHBvbnlmaWxsIGZvciBvbGQgYnJvd3NlcnMuXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleCAoYXJyYXksIHByZWRpY2F0ZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpXSkpIHJldHVybiBpXG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8vIGxvY2F0aW9uLm9yaWdpbiBkb2VzIG5vdCBleGlzdCBpbiBJRVxuZnVuY3Rpb24gZ2V0T3JpZ2luICgpIHtcbiAgaWYgKCdvcmlnaW4nIGluIGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGxvY2F0aW9uLm9yaWdpbiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbXBhdC9jb21wYXRcbiAgfVxuICByZXR1cm4gYCR7bG9jYXRpb24ucHJvdG9jb2x9Ly8ke2xvY2F0aW9uLmhvc3RuYW1lfSR7bG9jYXRpb24ucG9ydCA/IGA6JHtsb2NhdGlvbi5wb3J0fWAgOiAnJ31gXG59XG5cbmNsYXNzIENsb3NlV3JhcHBlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50ICgpIHtcbiAgICB0aGlzLnByb3BzLm9uVW5tb3VudCgpXG4gIH1cblxuICByZW5kZXIgKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuWzBdXG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzcyB0byBlYXNpbHkgZ2VuZXJhdGUgZ2VuZXJpYyB2aWV3cyBmb3IgUHJvdmlkZXIgcGx1Z2luc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFByb3ZpZGVyVmlldyB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGx1Z2luIGluc3RhbmNlIG9mIHRoZSBwbHVnaW5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChwbHVnaW4sIG9wdHMpIHtcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpblxuICAgIHRoaXMucHJvdmlkZXIgPSBvcHRzLnByb3ZpZGVyXG5cbiAgICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICB2aWV3VHlwZTogJ2xpc3QnLFxuICAgICAgc2hvd1RpdGxlczogdHJ1ZSxcbiAgICAgIHNob3dGaWx0ZXI6IHRydWUsXG4gICAgICBzaG93QnJlYWRjcnVtYnM6IHRydWVcbiAgICB9XG5cbiAgICAvLyBtZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgb25lcyBzZXQgYnkgdXNlclxuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdHMgfVxuXG4gICAgLy8gTG9naWNcbiAgICB0aGlzLmFkZEZpbGUgPSB0aGlzLmFkZEZpbGUuYmluZCh0aGlzKVxuICAgIHRoaXMuZmlsdGVySXRlbXMgPSB0aGlzLmZpbHRlckl0ZW1zLmJpbmQodGhpcylcbiAgICB0aGlzLmZpbHRlclF1ZXJ5ID0gdGhpcy5maWx0ZXJRdWVyeS5iaW5kKHRoaXMpXG4gICAgdGhpcy50b2dnbGVTZWFyY2ggPSB0aGlzLnRvZ2dsZVNlYXJjaC5iaW5kKHRoaXMpXG4gICAgdGhpcy5nZXRGb2xkZXIgPSB0aGlzLmdldEZvbGRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5nZXROZXh0Rm9sZGVyID0gdGhpcy5nZXROZXh0Rm9sZGVyLmJpbmQodGhpcylcbiAgICB0aGlzLmxvZ291dCA9IHRoaXMubG9nb3V0LmJpbmQodGhpcylcbiAgICB0aGlzLnByZUZpcnN0UmVuZGVyID0gdGhpcy5wcmVGaXJzdFJlbmRlci5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVBdXRoID0gdGhpcy5oYW5kbGVBdXRoLmJpbmQodGhpcylcbiAgICB0aGlzLnNvcnRCeVRpdGxlID0gdGhpcy5zb3J0QnlUaXRsZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5zb3J0QnlEYXRlID0gdGhpcy5zb3J0QnlEYXRlLmJpbmQodGhpcylcbiAgICB0aGlzLmlzQWN0aXZlUm93ID0gdGhpcy5pc0FjdGl2ZVJvdy5iaW5kKHRoaXMpXG4gICAgdGhpcy5pc0NoZWNrZWQgPSB0aGlzLmlzQ2hlY2tlZC5iaW5kKHRoaXMpXG4gICAgdGhpcy50b2dnbGVDaGVja2JveCA9IHRoaXMudG9nZ2xlQ2hlY2tib3guYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlRXJyb3IgPSB0aGlzLmhhbmRsZUVycm9yLmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZVNjcm9sbCA9IHRoaXMuaGFuZGxlU2Nyb2xsLmJpbmQodGhpcylcbiAgICB0aGlzLmxpc3RBbGxGaWxlcyA9IHRoaXMubGlzdEFsbEZpbGVzLmJpbmQodGhpcylcbiAgICB0aGlzLmRvbmVQaWNraW5nID0gdGhpcy5kb25lUGlja2luZy5iaW5kKHRoaXMpXG4gICAgdGhpcy5jYW5jZWxQaWNraW5nID0gdGhpcy5jYW5jZWxQaWNraW5nLmJpbmQodGhpcylcbiAgICB0aGlzLmNsZWFyU2VsZWN0aW9uID0gdGhpcy5jbGVhclNlbGVjdGlvbi5iaW5kKHRoaXMpXG5cbiAgICAvLyBWaXN1YWxcbiAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcylcblxuICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKVxuICB9XG5cbiAgdGVhckRvd24gKCkge1xuICAgIC8vIE5vdGhpbmcuXG4gIH1cblxuICBfdXBkYXRlRmlsZXNBbmRGb2xkZXJzIChyZXMsIGZpbGVzLCBmb2xkZXJzKSB7XG4gICAgdGhpcy5uZXh0UGFnZVBhdGggPSByZXMubmV4dFBhZ2VQYXRoXG4gICAgcmVzLml0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtLmlzRm9sZGVyKSB7XG4gICAgICAgIGZvbGRlcnMucHVzaChpdGVtKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsZXMucHVzaChpdGVtKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGZvbGRlcnMsIGZpbGVzIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIG9ubHkgdGhlIGZpcnN0IHRpbWUgdGhlIHByb3ZpZGVyIHZpZXcgaXMgcmVuZGVyZWQuXG4gICAqIEtpbmQgb2YgbGlrZSBhbiBpbml0IGZ1bmN0aW9uLlxuICAgKi9cbiAgcHJlRmlyc3RSZW5kZXIgKCkge1xuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgZGlkRmlyc3RSZW5kZXI6IHRydWUgfSlcbiAgICB0aGlzLnBsdWdpbi5vbkZpcnN0UmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXNlZCBvbiBmb2xkZXIgSUQsIGZldGNoIGEgbmV3IGZvbGRlciBhbmQgdXBkYXRlIGl0IHRvIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWQgRm9sZGVyIGlkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSAgIEZvbGRlcnMvZmlsZXMgaW4gZm9sZGVyXG4gICAqL1xuICBnZXRGb2xkZXIgKGlkLCBuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRlcldyYXBwZXIoXG4gICAgICB0aGlzLnByb3ZpZGVyLmxpc3QoaWQpLFxuICAgICAgKHJlcykgPT4ge1xuICAgICAgICBjb25zdCBmb2xkZXJzID0gW11cbiAgICAgICAgY29uc3QgZmlsZXMgPSBbXVxuICAgICAgICBsZXQgdXBkYXRlZERpcmVjdG9yaWVzXG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgICAgIGNvbnN0IGluZGV4ID0gZmluZEluZGV4KHN0YXRlLmRpcmVjdG9yaWVzLCAoZGlyKSA9PiBpZCA9PT0gZGlyLmlkKVxuXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICB1cGRhdGVkRGlyZWN0b3JpZXMgPSBzdGF0ZS5kaXJlY3Rvcmllcy5zbGljZSgwLCBpbmRleCArIDEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBkYXRlZERpcmVjdG9yaWVzID0gc3RhdGUuZGlyZWN0b3JpZXMuY29uY2F0KFt7IGlkLCB0aXRsZTogbmFtZSB9XSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXNlcm5hbWUgPSB0aGlzLnVzZXJuYW1lID8gdGhpcy51c2VybmFtZSA6IHJlcy51c2VybmFtZVxuICAgICAgICB0aGlzLl91cGRhdGVGaWxlc0FuZEZvbGRlcnMocmVzLCBmaWxlcywgZm9sZGVycylcbiAgICAgICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBkaXJlY3RvcmllczogdXBkYXRlZERpcmVjdG9yaWVzIH0pXG4gICAgICB9LFxuICAgICAgdGhpcy5oYW5kbGVFcnJvcilcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIG5ldyBmb2xkZXJcbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBGb2xkZXJcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0aXRsZSBGb2xkZXIgdGl0bGVcbiAgICovXG4gIGdldE5leHRGb2xkZXIgKGZvbGRlcikge1xuICAgIHRoaXMuZ2V0Rm9sZGVyKGZvbGRlci5yZXF1ZXN0UGF0aCwgZm9sZGVyLm5hbWUpXG4gICAgdGhpcy5sYXN0Q2hlY2tib3ggPSB1bmRlZmluZWRcbiAgfVxuXG4gIGFkZEZpbGUgKGZpbGUpIHtcbiAgICBjb25zdCB0YWdGaWxlID0ge1xuICAgICAgaWQ6IHRoaXMucHJvdmlkZXJGaWxlVG9JZChmaWxlKSxcbiAgICAgIHNvdXJjZTogdGhpcy5wbHVnaW4uaWQsXG4gICAgICBkYXRhOiBmaWxlLFxuICAgICAgbmFtZTogZmlsZS5uYW1lIHx8IGZpbGUuaWQsXG4gICAgICB0eXBlOiBmaWxlLm1pbWVUeXBlLFxuICAgICAgaXNSZW1vdGU6IHRydWUsXG4gICAgICBib2R5OiB7XG4gICAgICAgIGZpbGVJZDogZmlsZS5pZFxuICAgICAgfSxcbiAgICAgIHJlbW90ZToge1xuICAgICAgICBjb21wYW5pb25Vcmw6IHRoaXMucGx1Z2luLm9wdHMuY29tcGFuaW9uVXJsLFxuICAgICAgICB1cmw6IGAke3RoaXMucHJvdmlkZXIuZmlsZVVybChmaWxlLnJlcXVlc3RQYXRoKX1gLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgZmlsZUlkOiBmaWxlLmlkXG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogdGhpcy5wcm92aWRlci5vcHRzXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZVR5cGUgPSBnZXRGaWxlVHlwZSh0YWdGaWxlKVxuICAgIC8vIFRPRE8gU2hvdWxkIHdlIGp1c3QgYWx3YXlzIHVzZSB0aGUgdGh1bWJuYWlsIFVSTCBpZiBpdCBleGlzdHM/XG4gICAgaWYgKGZpbGVUeXBlICYmIGlzUHJldmlld1N1cHBvcnRlZChmaWxlVHlwZSkpIHtcbiAgICAgIHRhZ0ZpbGUucHJldmlldyA9IGZpbGUudGh1bWJuYWlsXG4gICAgfVxuICAgIHRoaXMucGx1Z2luLnVwcHkubG9nKCdBZGRpbmcgcmVtb3RlIGZpbGUnKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLnBsdWdpbi51cHB5LmFkZEZpbGUodGFnRmlsZSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghZXJyLmlzUmVzdHJpY3Rpb24pIHtcbiAgICAgICAgdGhpcy5wbHVnaW4udXBweS5sb2coZXJyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUZpbGUgKGlkKSB7XG4gICAgY29uc3QgeyBjdXJyZW50U2VsZWN0aW9uIH0gPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgY3VycmVudFNlbGVjdGlvbjogY3VycmVudFNlbGVjdGlvbi5maWx0ZXIoKGZpbGUpID0+IGZpbGUuaWQgIT09IGlkKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBzZXNzaW9uIHRva2VuIG9uIGNsaWVudCBzaWRlLlxuICAgKi9cbiAgbG9nb3V0ICgpIHtcbiAgICB0aGlzLnByb3ZpZGVyLmxvZ291dCgpXG4gICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgICBpZiAoIXJlcy5yZXZva2VkKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5wbHVnaW4udXBweS5pMThuKCdjb21wYW5pb25VbmF1dGhvcml6ZUhpbnQnLCB7XG4gICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzLnBsdWdpbi50aXRsZSxcbiAgICAgICAgICAgICAgdXJsOiByZXMubWFudWFsX3Jldm9rZV91cmxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi51cHB5LmluZm8obWVzc2FnZSwgJ2luZm8nLCA3MDAwKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgICAgICAgICAgYXV0aGVudGljYXRlZDogZmFsc2UsXG4gICAgICAgICAgICBmaWxlczogW10sXG4gICAgICAgICAgICBmb2xkZXJzOiBbXSxcbiAgICAgICAgICAgIGRpcmVjdG9yaWVzOiBbXVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZShuZXdTdGF0ZSlcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2godGhpcy5oYW5kbGVFcnJvcilcbiAgfVxuXG4gIGZpbHRlclF1ZXJ5IChlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHtcbiAgICAgIGZpbHRlcklucHV0OiBlID8gZS50YXJnZXQudmFsdWUgOiAnJ1xuICAgIH0pKVxuICB9XG5cbiAgdG9nZ2xlU2VhcmNoIChpbnB1dEVsKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG5cbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBpc1NlYXJjaFZpc2libGU6ICFzdGF0ZS5pc1NlYXJjaFZpc2libGUsXG4gICAgICBmaWx0ZXJJbnB1dDogJydcbiAgICB9KVxuICB9XG5cbiAgZmlsdGVySXRlbXMgKGl0ZW1zKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgaWYgKCFzdGF0ZS5maWx0ZXJJbnB1dCB8fCBzdGF0ZS5maWx0ZXJJbnB1dCA9PT0gJycpIHtcbiAgICAgIHJldHVybiBpdGVtc1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKChmb2xkZXIpID0+IHtcbiAgICAgIHJldHVybiBmb2xkZXIubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc3RhdGUuZmlsdGVySW5wdXQudG9Mb3dlckNhc2UoKSkgIT09IC0xXG4gICAgfSlcbiAgfVxuXG4gIHNvcnRCeVRpdGxlICgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKCkpXG4gICAgY29uc3QgeyBmaWxlcywgZm9sZGVycywgc29ydGluZyB9ID0gc3RhdGVcblxuICAgIGNvbnN0IHNvcnRlZEZpbGVzID0gZmlsZXMuc29ydCgoZmlsZUEsIGZpbGVCKSA9PiB7XG4gICAgICBpZiAoc29ydGluZyA9PT0gJ3RpdGxlRGVzY2VuZGluZycpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVCLm5hbWUubG9jYWxlQ29tcGFyZShmaWxlQS5uYW1lKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbGVBLm5hbWUubG9jYWxlQ29tcGFyZShmaWxlQi5uYW1lKVxuICAgIH0pXG5cbiAgICBjb25zdCBzb3J0ZWRGb2xkZXJzID0gZm9sZGVycy5zb3J0KChmb2xkZXJBLCBmb2xkZXJCKSA9PiB7XG4gICAgICBpZiAoc29ydGluZyA9PT0gJ3RpdGxlRGVzY2VuZGluZycpIHtcbiAgICAgICAgcmV0dXJuIGZvbGRlckIubmFtZS5sb2NhbGVDb21wYXJlKGZvbGRlckEubmFtZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb2xkZXJBLm5hbWUubG9jYWxlQ29tcGFyZShmb2xkZXJCLm5hbWUpXG4gICAgfSlcblxuICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCB7XG4gICAgICBmaWxlczogc29ydGVkRmlsZXMsXG4gICAgICBmb2xkZXJzOiBzb3J0ZWRGb2xkZXJzLFxuICAgICAgc29ydGluZzogKHNvcnRpbmcgPT09ICd0aXRsZURlc2NlbmRpbmcnKSA/ICd0aXRsZUFzY2VuZGluZycgOiAndGl0bGVEZXNjZW5kaW5nJ1xuICAgIH0pKVxuICB9XG5cbiAgc29ydEJ5RGF0ZSAoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpKVxuICAgIGNvbnN0IHsgZmlsZXMsIGZvbGRlcnMsIHNvcnRpbmcgfSA9IHN0YXRlXG5cbiAgICBjb25zdCBzb3J0ZWRGaWxlcyA9IGZpbGVzLnNvcnQoKGZpbGVBLCBmaWxlQikgPT4ge1xuICAgICAgY29uc3QgYSA9IG5ldyBEYXRlKGZpbGVBLm1vZGlmaWVkRGF0ZSlcbiAgICAgIGNvbnN0IGIgPSBuZXcgRGF0ZShmaWxlQi5tb2RpZmllZERhdGUpXG5cbiAgICAgIGlmIChzb3J0aW5nID09PSAnZGF0ZURlc2NlbmRpbmcnKSB7XG4gICAgICAgIHJldHVybiBhID4gYiA/IC0xIDogYSA8IGIgPyAxIDogMFxuICAgICAgfVxuICAgICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwXG4gICAgfSlcblxuICAgIGNvbnN0IHNvcnRlZEZvbGRlcnMgPSBmb2xkZXJzLnNvcnQoKGZvbGRlckEsIGZvbGRlckIpID0+IHtcbiAgICAgIGNvbnN0IGEgPSBuZXcgRGF0ZShmb2xkZXJBLm1vZGlmaWVkRGF0ZSlcbiAgICAgIGNvbnN0IGIgPSBuZXcgRGF0ZShmb2xkZXJCLm1vZGlmaWVkRGF0ZSlcblxuICAgICAgaWYgKHNvcnRpbmcgPT09ICdkYXRlRGVzY2VuZGluZycpIHtcbiAgICAgICAgcmV0dXJuIGEgPiBiID8gLTEgOiBhIDwgYiA/IDEgOiAwXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMFxuICAgIH0pXG5cbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZShPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgZmlsZXM6IHNvcnRlZEZpbGVzLFxuICAgICAgZm9sZGVyczogc29ydGVkRm9sZGVycyxcbiAgICAgIHNvcnRpbmc6IChzb3J0aW5nID09PSAnZGF0ZURlc2NlbmRpbmcnKSA/ICdkYXRlQXNjZW5kaW5nJyA6ICdkYXRlRGVzY2VuZGluZydcbiAgICB9KSlcbiAgfVxuXG4gIHNvcnRCeVNpemUgKCkge1xuICAgIGNvbnN0IHN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKSlcbiAgICBjb25zdCB7IGZpbGVzLCBzb3J0aW5nIH0gPSBzdGF0ZVxuXG4gICAgLy8gY2hlY2sgdGhhdCBwbHVnaW4gc3VwcG9ydHMgZmlsZSBzaXplc1xuICAgIGlmICghZmlsZXMubGVuZ3RoIHx8ICF0aGlzLnBsdWdpbi5nZXRJdGVtRGF0YShmaWxlc1swXSkuc2l6ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc29ydGVkRmlsZXMgPSBmaWxlcy5zb3J0KChmaWxlQSwgZmlsZUIpID0+IHtcbiAgICAgIGNvbnN0IGEgPSBmaWxlQS5zaXplXG4gICAgICBjb25zdCBiID0gZmlsZUIuc2l6ZVxuXG4gICAgICBpZiAoc29ydGluZyA9PT0gJ3NpemVEZXNjZW5kaW5nJykge1xuICAgICAgICByZXR1cm4gYSA+IGIgPyAtMSA6IGEgPCBiID8gMSA6IDBcbiAgICAgIH1cbiAgICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMFxuICAgIH0pXG5cbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZShPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwge1xuICAgICAgZmlsZXM6IHNvcnRlZEZpbGVzLFxuICAgICAgc29ydGluZzogKHNvcnRpbmcgPT09ICdzaXplRGVzY2VuZGluZycpID8gJ3NpemVBc2NlbmRpbmcnIDogJ3NpemVEZXNjZW5kaW5nJ1xuICAgIH0pKVxuICB9XG5cbiAgaXNBY3RpdmVSb3cgKGZpbGUpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKS5hY3RpdmVSb3cgPT09IHRoaXMucGx1Z2luLmdldEl0ZW1JZChmaWxlKVxuICB9XG5cbiAgaXNDaGVja2VkIChmaWxlKSB7XG4gICAgY29uc3QgeyBjdXJyZW50U2VsZWN0aW9uIH0gPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgLy8gY29tcGFyaW5nIGlkIGluc3RlYWQgb2YgdGhlIGZpbGUgb2JqZWN0LCBiZWNhdXNlIHRoZSByZWZlcmVuY2UgdG8gdGhlIG9iamVjdFxuICAgIC8vIGNoYW5nZXMgd2hlbiB3ZSBzd2l0Y2ggZm9sZGVycywgYW5kIHRoZSBmaWxlIGxpc3QgaXMgdXBkYXRlZFxuICAgIHJldHVybiBjdXJyZW50U2VsZWN0aW9uLnNvbWUoKGl0ZW0pID0+IGl0ZW0uaWQgPT09IGZpbGUuaWQpXG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbGwgZmlsZXMgZm91bmQgaW5zaWRlIG9mIHNwZWNpZmllZCBmb2xkZXIuXG4gICAqXG4gICAqIFVzZXMgc2VwYXJhdGVkIHN0YXRlIHdoaWxlIGZvbGRlciBjb250ZW50cyBhcmUgYmVpbmcgZmV0Y2hlZCBhbmRcbiAgICogbWFudGFpbnMgbGlzdCBvZiBzZWxlY3RlZCBmb2xkZXJzLCB3aGljaCBhcmUgc2VwYXJhdGVkIGZyb20gZmlsZXMuXG4gICAqL1xuICBhZGRGb2xkZXIgKGZvbGRlcikge1xuICAgIGNvbnN0IGZvbGRlcklkID0gdGhpcy5wcm92aWRlckZpbGVUb0lkKGZvbGRlcilcbiAgICBsZXQgc3RhdGUgPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgY29uc3QgZm9sZGVycyA9IHN0YXRlLnNlbGVjdGVkRm9sZGVycyB8fCB7fVxuICAgIGlmIChmb2xkZXJJZCBpbiBmb2xkZXJzICYmIGZvbGRlcnNbZm9sZGVySWRdLmxvYWRpbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmb2xkZXJzW2ZvbGRlcklkXSA9IHsgbG9hZGluZzogdHJ1ZSwgZmlsZXM6IFtdIH1cbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IHNlbGVjdGVkRm9sZGVyczogZm9sZGVycyB9KVxuICAgIHJldHVybiB0aGlzLmxpc3RBbGxGaWxlcyhmb2xkZXIucmVxdWVzdFBhdGgpLnRoZW4oKGZpbGVzKSA9PiB7XG4gICAgICBmaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICAgIHRoaXMuYWRkRmlsZShmaWxlKVxuICAgICAgfSlcbiAgICAgIGNvbnN0IGlkcyA9IGZpbGVzLm1hcCh0aGlzLnByb3ZpZGVyRmlsZVRvSWQpXG4gICAgICBzdGF0ZSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICAgIHN0YXRlLnNlbGVjdGVkRm9sZGVyc1tmb2xkZXJJZF0gPSB7IGxvYWRpbmc6IGZhbHNlLCBmaWxlczogaWRzIH1cbiAgICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgc2VsZWN0ZWRGb2xkZXJzOiBmb2xkZXJzIH0pXG5cbiAgICAgIGxldCBtZXNzYWdlXG4gICAgICBpZiAoZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLnBsdWdpbi51cHB5LmkxOG4oJ2ZvbGRlckFkZGVkJywge1xuICAgICAgICAgIHNtYXJ0X2NvdW50OiBmaWxlcy5sZW5ndGgsIGZvbGRlcjogZm9sZGVyLm5hbWVcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLnBsdWdpbi51cHB5LmkxOG4oJ2VtcHR5Rm9sZGVyQWRkZWQnKVxuICAgICAgfVxuICAgICAgdGhpcy5wbHVnaW4udXBweS5pbmZvKG1lc3NhZ2UpXG4gICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgIHN0YXRlID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgICAgZGVsZXRlIHN0YXRlLnNlbGVjdGVkRm9sZGVyc1tmb2xkZXJJZF1cbiAgICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHsgc2VsZWN0ZWRGb2xkZXJzOiBzdGF0ZS5zZWxlY3RlZEZvbGRlcnMgfSlcbiAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgZmlsZS9mb2xkZXIgY2hlY2tib3ggdG8gb24vb2ZmIHN0YXRlIHdoaWxlIHVwZGF0aW5nIGZpbGVzIGxpc3QuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBzb21lIGV4dHJhIGNvbXBsZXhpdHkgY29tZXMgZnJvbSBzdXBwb3J0aW5nIHNoaWZ0K2NsaWNrIHRvXG4gICAqIHRvZ2dsZSBtdWx0aXBsZSBjaGVja2JveGVzIGF0IG9uY2UsIHdoaWNoIGlzIGRvbmUgYnkgZ2V0dGluZyBhbGwgZmlsZXNcbiAgICogaW4gYmV0d2VlbiBsYXN0IGNoZWNrZWQgZmlsZSBhbmQgY3VycmVudCBvbmUuXG4gICAqL1xuICB0b2dnbGVDaGVja2JveCAoZSwgZmlsZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLmN1cnJlbnRUYXJnZXQuZm9jdXMoKVxuICAgIGNvbnN0IHsgZm9sZGVycywgZmlsZXMgfSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuZmlsdGVySXRlbXMoZm9sZGVycy5jb25jYXQoZmlsZXMpKVxuXG4gICAgLy8gU2hpZnQtY2xpY2tpbmcgc2VsZWN0cyBhIHNpbmdsZSBjb25zZWN1dGl2ZSBsaXN0IG9mIGl0ZW1zXG4gICAgLy8gc3RhcnRpbmcgYXQgdGhlIHByZXZpb3VzIGNsaWNrIGFuZCBkZXNlbGVjdHMgZXZlcnl0aGluZyBlbHNlLlxuICAgIGlmICh0aGlzLmxhc3RDaGVja2JveCAmJiBlLnNoaWZ0S2V5KSB7XG4gICAgICBsZXQgY3VycmVudFNlbGVjdGlvblxuICAgICAgY29uc3QgcHJldkluZGV4ID0gaXRlbXMuaW5kZXhPZih0aGlzLmxhc3RDaGVja2JveClcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGl0ZW1zLmluZGV4T2YoZmlsZSlcbiAgICAgIGlmIChwcmV2SW5kZXggPCBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgY3VycmVudFNlbGVjdGlvbiA9IGl0ZW1zLnNsaWNlKHByZXZJbmRleCwgY3VycmVudEluZGV4ICsgMSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRTZWxlY3Rpb24gPSBpdGVtcy5zbGljZShjdXJyZW50SW5kZXgsIHByZXZJbmRleCArIDEpXG4gICAgICB9XG4gICAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGN1cnJlbnRTZWxlY3Rpb24gfSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMubGFzdENoZWNrYm94ID0gZmlsZVxuICAgIGNvbnN0IHsgY3VycmVudFNlbGVjdGlvbiB9ID0gdGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKVxuICAgIGlmICh0aGlzLmlzQ2hlY2tlZChmaWxlKSkge1xuICAgICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICBjdXJyZW50U2VsZWN0aW9uOiBjdXJyZW50U2VsZWN0aW9uLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5pZCAhPT0gZmlsZS5pZClcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGx1Z2luLnNldFBsdWdpblN0YXRlKHtcbiAgICAgICAgY3VycmVudFNlbGVjdGlvbjogY3VycmVudFNlbGVjdGlvbi5jb25jYXQoW2ZpbGVdKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBwcm92aWRlckZpbGVUb0lkIChmaWxlKSB7XG4gICAgcmV0dXJuIGdlbmVyYXRlRmlsZUlEKHtcbiAgICAgIGRhdGE6IGZpbGUsXG4gICAgICBuYW1lOiBmaWxlLm5hbWUgfHwgZmlsZS5pZCxcbiAgICAgIHR5cGU6IGZpbGUubWltZVR5cGVcbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlQXV0aCAoKSB7XG4gICAgY29uc3QgYXV0aFN0YXRlID0gYnRvYShKU09OLnN0cmluZ2lmeSh7IG9yaWdpbjogZ2V0T3JpZ2luKCkgfSkpXG4gICAgY29uc3QgY2xpZW50VmVyc2lvbiA9IGVuY29kZVVSSUNvbXBvbmVudChgQHVwcHkvcHJvdmlkZXItdmlld3M9JHtQcm92aWRlclZpZXcuVkVSU0lPTn1gKVxuICAgIGNvbnN0IGxpbmsgPSBgJHt0aGlzLnByb3ZpZGVyLmF1dGhVcmwoKX0/c3RhdGU9JHthdXRoU3RhdGV9JnVwcHlWZXJzaW9ucz0ke2NsaWVudFZlcnNpb259YFxuXG4gICAgY29uc3QgYXV0aFdpbmRvdyA9IHdpbmRvdy5vcGVuKGxpbmssICdfYmxhbmsnKVxuICAgIGNvbnN0IGhhbmRsZVRva2VuID0gKGUpID0+IHtcbiAgICAgIGlmICghdGhpcy5faXNPcmlnaW5BbGxvd2VkKGUub3JpZ2luLCB0aGlzLnBsdWdpbi5vcHRzLmNvbXBhbmlvbkFsbG93ZWRIb3N0cykgfHwgZS5zb3VyY2UgIT09IGF1dGhXaW5kb3cpIHtcbiAgICAgICAgdGhpcy5wbHVnaW4udXBweS5sb2coYHJlamVjdGluZyBldmVudCBmcm9tICR7ZS5vcmlnaW59IHZzIGFsbG93ZWQgcGF0dGVybiAke3RoaXMucGx1Z2luLm9wdHMuY29tcGFuaW9uQWxsb3dlZEhvc3RzfWApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiBpdCdzIGEgc3RyaW5nIGJlZm9yZSBkb2luZyB0aGUgSlNPTi5wYXJzZSB0byBtYWludGFpbiBzdXBwb3J0XG4gICAgICAvLyBmb3Igb2xkZXIgQ29tcGFuaW9uIHZlcnNpb25zIHRoYXQgdXNlZCBvYmplY3QgcmVmZXJlbmNlc1xuICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBlLmRhdGEgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShlLmRhdGEpIDogZS5kYXRhXG5cbiAgICAgIGlmICghZGF0YS50b2tlbikge1xuICAgICAgICB0aGlzLnBsdWdpbi51cHB5LmxvZygnZGlkIG5vdCByZWNlaXZlIHRva2VuIGZyb20gYXV0aCB3aW5kb3cnKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgYXV0aFdpbmRvdy5jbG9zZSgpXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZVRva2VuKVxuICAgICAgdGhpcy5wcm92aWRlci5zZXRBdXRoVG9rZW4oZGF0YS50b2tlbilcbiAgICAgIHRoaXMucHJlRmlyc3RSZW5kZXIoKVxuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZVRva2VuKVxuICB9XG5cbiAgX2lzT3JpZ2luQWxsb3dlZCAob3JpZ2luLCBhbGxvd2VkT3JpZ2luKSB7XG4gICAgY29uc3QgZ2V0UmVnZXggPSAodmFsdWUpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHt2YWx1ZX0kYClcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGF0dGVybnMgPSBBcnJheS5pc0FycmF5KGFsbG93ZWRPcmlnaW4pID8gYWxsb3dlZE9yaWdpbi5tYXAoZ2V0UmVnZXgpIDogW2dldFJlZ2V4KGFsbG93ZWRPcmlnaW4pXVxuICAgIHJldHVybiBwYXR0ZXJuc1xuICAgICAgLmZpbHRlcigocGF0dGVybikgPT4gcGF0dGVybiAhPSBudWxsKSAvLyBsb29zZSBjb21wYXJpc29uIHRvIGNhdGNoIHVuZGVmaW5lZFxuICAgICAgLnNvbWUoKHBhdHRlcm4pID0+IHBhdHRlcm4udGVzdChvcmlnaW4pIHx8IHBhdHRlcm4udGVzdChgJHtvcmlnaW59L2ApKSAvLyBhbGxvd2luZyBmb3IgdHJhaWxpbmcgJy8nXG4gIH1cblxuICBoYW5kbGVFcnJvciAoZXJyb3IpIHtcbiAgICBjb25zdCB1cHB5ID0gdGhpcy5wbHVnaW4udXBweVxuICAgIHVwcHkubG9nKGVycm9yLnRvU3RyaW5nKCkpXG4gICAgaWYgKGVycm9yLmlzQXV0aEVycm9yKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IHVwcHkuaTE4bignY29tcGFuaW9uRXJyb3InKVxuICAgIHVwcHkuaW5mbyh7IG1lc3NhZ2U6IG1lc3NhZ2UsIGRldGFpbHM6IGVycm9yLnRvU3RyaW5nKCkgfSwgJ2Vycm9yJywgNTAwMClcbiAgfVxuXG4gIGhhbmRsZVNjcm9sbCAoZSkge1xuICAgIGNvbnN0IHNjcm9sbFBvcyA9IGUudGFyZ2V0LnNjcm9sbEhlaWdodCAtIChlLnRhcmdldC5zY3JvbGxUb3AgKyBlLnRhcmdldC5vZmZzZXRIZWlnaHQpXG4gICAgY29uc3QgcGF0aCA9IHRoaXMubmV4dFBhZ2VQYXRoIHx8IG51bGxcblxuICAgIGlmIChzY3JvbGxQb3MgPCA1MCAmJiBwYXRoICYmICF0aGlzLl9pc0hhbmRsaW5nU2Nyb2xsKSB7XG4gICAgICB0aGlzLnByb3ZpZGVyLmxpc3QocGF0aClcbiAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZmlsZXMsIGZvbGRlcnMgfSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICAgICAgICB0aGlzLl91cGRhdGVGaWxlc0FuZEZvbGRlcnMocmVzLCBmaWxlcywgZm9sZGVycylcbiAgICAgICAgfSkuY2F0Y2godGhpcy5oYW5kbGVFcnJvcilcbiAgICAgICAgLnRoZW4oKCkgPT4geyB0aGlzLl9pc0hhbmRsaW5nU2Nyb2xsID0gZmFsc2UgfSkgLy8gYWx3YXlzIGNhbGxlZFxuXG4gICAgICB0aGlzLl9pc0hhbmRsaW5nU2Nyb2xsID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGxpc3RBbGxGaWxlcyAocGF0aCwgZmlsZXMgPSBudWxsKSB7XG4gICAgZmlsZXMgPSBmaWxlcyB8fCBbXVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnByb3ZpZGVyLmxpc3QocGF0aCkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIHJlcy5pdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKCFpdGVtLmlzRm9sZGVyKSB7XG4gICAgICAgICAgICBmaWxlcy5wdXNoKGl0ZW0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBjb25zdCBtb3JlRmlsZXMgPSByZXMubmV4dFBhZ2VQYXRoIHx8IG51bGxcbiAgICAgICAgaWYgKG1vcmVGaWxlcykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RBbGxGaWxlcyhtb3JlRmlsZXMsIGZpbGVzKVxuICAgICAgICAgICAgLnRoZW4oKGZpbGVzKSA9PiByZXNvbHZlKGZpbGVzKSlcbiAgICAgICAgICAgIC5jYXRjaChlID0+IHJlamVjdChlKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmaWxlcylcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goZSA9PiByZWplY3QoZSkpXG4gICAgfSlcbiAgfVxuXG4gIGRvbmVQaWNraW5nICgpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRTZWxlY3Rpb24gfSA9IHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKClcbiAgICBjb25zdCBwcm9taXNlcyA9IGN1cnJlbnRTZWxlY3Rpb24ubWFwKChmaWxlKSA9PiB7XG4gICAgICBpZiAoZmlsZS5pc0ZvbGRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRGb2xkZXIoZmlsZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZEZpbGUoZmlsZSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5fbG9hZGVyV3JhcHBlcihQcm9taXNlLmFsbChwcm9taXNlcyksICgpID0+IHtcbiAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKVxuICAgIH0sICgpID0+IHt9KVxuICB9XG5cbiAgY2FuY2VsUGlja2luZyAoKSB7XG4gICAgdGhpcy5jbGVhclNlbGVjdGlvbigpXG5cbiAgICBjb25zdCBkYXNoYm9hcmQgPSB0aGlzLnBsdWdpbi51cHB5LmdldFBsdWdpbignRGFzaGJvYXJkJylcbiAgICBpZiAoZGFzaGJvYXJkKSBkYXNoYm9hcmQuaGlkZUFsbFBhbmVscygpXG4gIH1cblxuICBjbGVhclNlbGVjdGlvbiAoKSB7XG4gICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBjdXJyZW50U2VsZWN0aW9uOiBbXSB9KVxuICB9XG5cbiAgLy8gZGlzcGxheXMgbG9hZGVyIHZpZXcgd2hpbGUgYXN5bmNocm9ub3VzIHJlcXVlc3QgaXMgYmVpbmcgbWFkZS5cbiAgX2xvYWRlcldyYXBwZXIgKHByb21pc2UsIHRoZW4sIGNhdGNoXykge1xuICAgIHByb21pc2VcbiAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBsb2FkaW5nOiBmYWxzZSB9KVxuICAgICAgICB0aGVuKHJlc3VsdClcbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5wbHVnaW4uc2V0UGx1Z2luU3RhdGUoeyBsb2FkaW5nOiBmYWxzZSB9KVxuICAgICAgICBjYXRjaF8oZXJyKVxuICAgICAgfSlcbiAgICB0aGlzLnBsdWdpbi5zZXRQbHVnaW5TdGF0ZSh7IGxvYWRpbmc6IHRydWUgfSlcbiAgfVxuXG4gIHJlbmRlciAoc3RhdGUsIHZpZXdPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGF1dGhlbnRpY2F0ZWQsIGRpZEZpcnN0UmVuZGVyIH0gPSB0aGlzLnBsdWdpbi5nZXRQbHVnaW5TdGF0ZSgpXG4gICAgaWYgKCFkaWRGaXJzdFJlbmRlcikge1xuICAgICAgdGhpcy5wcmVGaXJzdFJlbmRlcigpXG4gICAgfVxuXG4gICAgLy8gcmVsb2FkIHBsdWdpblN0YXRlIGZvciBcImxvYWRpbmdcIiBhdHRyaWJ1dGUgYmVjYXVzZSBpdCBtaWdodFxuICAgIC8vIGhhdmUgY2hhbmdlZCBhYm92ZS5cbiAgICBpZiAodGhpcy5wbHVnaW4uZ2V0UGx1Z2luU3RhdGUoKS5sb2FkaW5nKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8Q2xvc2VXcmFwcGVyIG9uVW5tb3VudD17dGhpcy5jbGVhclNlbGVjdGlvbn0+XG4gICAgICAgICAgPExvYWRlclZpZXcgaTE4bj17dGhpcy5wbHVnaW4udXBweS5pMThufSAvPlxuICAgICAgICA8L0Nsb3NlV3JhcHBlcj5cbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoIWF1dGhlbnRpY2F0ZWQpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxDbG9zZVdyYXBwZXIgb25Vbm1vdW50PXt0aGlzLmNsZWFyU2VsZWN0aW9ufT5cbiAgICAgICAgICA8QXV0aFZpZXdcbiAgICAgICAgICAgIHBsdWdpbk5hbWU9e3RoaXMucGx1Z2luLnRpdGxlfVxuICAgICAgICAgICAgcGx1Z2luSWNvbj17dGhpcy5wbHVnaW4uaWNvbn1cbiAgICAgICAgICAgIGhhbmRsZUF1dGg9e3RoaXMuaGFuZGxlQXV0aH1cbiAgICAgICAgICAgIGkxOG49e3RoaXMucGx1Z2luLnVwcHkuaTE4bn1cbiAgICAgICAgICAgIGkxOG5BcnJheT17dGhpcy5wbHVnaW4udXBweS5pMThuQXJyYXl9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9DbG9zZVdyYXBwZXI+XG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0Vmlld09wdGlvbnMgPSB7IC4uLnRoaXMub3B0cywgLi4udmlld09wdGlvbnMgfVxuICAgIGNvbnN0IGJyb3dzZXJQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGx1Z2luLmdldFBsdWdpblN0YXRlKCksIHtcbiAgICAgIHVzZXJuYW1lOiB0aGlzLnVzZXJuYW1lLFxuICAgICAgZ2V0TmV4dEZvbGRlcjogdGhpcy5nZXROZXh0Rm9sZGVyLFxuICAgICAgZ2V0Rm9sZGVyOiB0aGlzLmdldEZvbGRlcixcbiAgICAgIGZpbHRlckl0ZW1zOiB0aGlzLmZpbHRlckl0ZW1zLFxuICAgICAgZmlsdGVyUXVlcnk6IHRoaXMuZmlsdGVyUXVlcnksXG4gICAgICB0b2dnbGVTZWFyY2g6IHRoaXMudG9nZ2xlU2VhcmNoLFxuICAgICAgc29ydEJ5VGl0bGU6IHRoaXMuc29ydEJ5VGl0bGUsXG4gICAgICBzb3J0QnlEYXRlOiB0aGlzLnNvcnRCeURhdGUsXG4gICAgICBsb2dvdXQ6IHRoaXMubG9nb3V0LFxuICAgICAgaXNBY3RpdmVSb3c6IHRoaXMuaXNBY3RpdmVSb3csXG4gICAgICBpc0NoZWNrZWQ6IHRoaXMuaXNDaGVja2VkLFxuICAgICAgdG9nZ2xlQ2hlY2tib3g6IHRoaXMudG9nZ2xlQ2hlY2tib3gsXG4gICAgICBoYW5kbGVTY3JvbGw6IHRoaXMuaGFuZGxlU2Nyb2xsLFxuICAgICAgbGlzdEFsbEZpbGVzOiB0aGlzLmxpc3RBbGxGaWxlcyxcbiAgICAgIGRvbmU6IHRoaXMuZG9uZVBpY2tpbmcsXG4gICAgICBjYW5jZWw6IHRoaXMuY2FuY2VsUGlja2luZyxcbiAgICAgIHRpdGxlOiB0aGlzLnBsdWdpbi50aXRsZSxcbiAgICAgIHZpZXdUeXBlOiB0YXJnZXRWaWV3T3B0aW9ucy52aWV3VHlwZSxcbiAgICAgIHNob3dUaXRsZXM6IHRhcmdldFZpZXdPcHRpb25zLnNob3dUaXRsZXMsXG4gICAgICBzaG93RmlsdGVyOiB0YXJnZXRWaWV3T3B0aW9ucy5zaG93RmlsdGVyLFxuICAgICAgc2hvd0JyZWFkY3J1bWJzOiB0YXJnZXRWaWV3T3B0aW9ucy5zaG93QnJlYWRjcnVtYnMsXG4gICAgICBwbHVnaW5JY29uOiB0aGlzLnBsdWdpbi5pY29uLFxuICAgICAgaTE4bjogdGhpcy5wbHVnaW4udXBweS5pMThuXG4gICAgfSlcblxuICAgIHJldHVybiAoXG4gICAgICA8Q2xvc2VXcmFwcGVyIG9uVW5tb3VudD17dGhpcy5jbGVhclNlbGVjdGlvbn0+XG4gICAgICAgIDxCcm93c2VyIHsuLi5icm93c2VyUHJvcHN9IC8+XG4gICAgICA8L0Nsb3NlV3JhcHBlcj5cbiAgICApXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwiQHVwcHkvc3RhdHVzLWJhclwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQSBwcm9ncmVzcyBiYXIgZm9yIFVwcHksIHdpdGggbWFueSBiZWxscyBhbmQgd2hpc3RsZXMuXCIsXG4gIFwidmVyc2lvblwiOiBcIjEuNC4yXCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcbiAgXCJzdHlsZVwiOiBcImRpc3Qvc3R5bGUubWluLmNzc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCIsXG4gICAgXCJwcm9ncmVzcyBiYXJcIixcbiAgICBcInN0YXR1cyBiYXJcIixcbiAgICBcInByb2dyZXNzXCIsXG4gICAgXCJ1cGxvYWRcIixcbiAgICBcImV0YVwiLFxuICAgIFwic3BlZWRcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwiY2xhc3NuYW1lc1wiOiBcIl4yLjIuNlwiLFxuICAgIFwibG9kYXNoLnRocm90dGxlXCI6IFwiXjQuMS4xXCIsXG4gICAgXCJwcmVhY3RcIjogXCI4LjIuOVwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgdGhyb3R0bGUgPSByZXF1aXJlKCdsb2Rhc2gudGhyb3R0bGUnKVxuY29uc3QgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKVxuY29uc3Qgc3RhdHVzQmFyU3RhdGVzID0gcmVxdWlyZSgnLi9TdGF0dXNCYXJTdGF0ZXMnKVxuY29uc3QgcHJldHR5Qnl0ZXMgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvcHJldHR5Qnl0ZXMnKVxuY29uc3QgcHJldHR5RVRBID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL3ByZXR0eUVUQScpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVByb2Nlc3NpbmdQcm9ncmVzcyAoZmlsZXMpIHtcbiAgLy8gQ29sbGVjdCBwcmUgb3IgcG9zdHByb2Nlc3NpbmcgcHJvZ3Jlc3Mgc3RhdGVzLlxuICBjb25zdCBwcm9ncmVzc2VzID0gW11cbiAgT2JqZWN0LmtleXMoZmlsZXMpLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgIGNvbnN0IHsgcHJvZ3Jlc3MgfSA9IGZpbGVzW2ZpbGVJRF1cbiAgICBpZiAocHJvZ3Jlc3MucHJlcHJvY2Vzcykge1xuICAgICAgcHJvZ3Jlc3Nlcy5wdXNoKHByb2dyZXNzLnByZXByb2Nlc3MpXG4gICAgfVxuICAgIGlmIChwcm9ncmVzcy5wb3N0cHJvY2Vzcykge1xuICAgICAgcHJvZ3Jlc3Nlcy5wdXNoKHByb2dyZXNzLnBvc3Rwcm9jZXNzKVxuICAgIH1cbiAgfSlcblxuICAvLyBJbiB0aGUgZnV0dXJlIHdlIHNob3VsZCBwcm9iYWJseSBkbyB0aGlzIGRpZmZlcmVudGx5LiBGb3Igbm93IHdlJ2xsIHRha2UgdGhlXG4gIC8vIG1vZGUgYW5kIG1lc3NhZ2UgZnJvbSB0aGUgZmlyc3QgZmlsZeKAplxuICBjb25zdCB7IG1vZGUsIG1lc3NhZ2UgfSA9IHByb2dyZXNzZXNbMF1cbiAgY29uc3QgdmFsdWUgPSBwcm9ncmVzc2VzLmZpbHRlcihpc0RldGVybWluYXRlKS5yZWR1Y2UoKHRvdGFsLCBwcm9ncmVzcywgaW5kZXgsIGFsbCkgPT4ge1xuICAgIHJldHVybiB0b3RhbCArIHByb2dyZXNzLnZhbHVlIC8gYWxsLmxlbmd0aFxuICB9LCAwKVxuICBmdW5jdGlvbiBpc0RldGVybWluYXRlIChwcm9ncmVzcykge1xuICAgIHJldHVybiBwcm9ncmVzcy5tb2RlID09PSAnZGV0ZXJtaW5hdGUnXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1vZGUsXG4gICAgbWVzc2FnZSxcbiAgICB2YWx1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIHRvZ2dsZVBhdXNlUmVzdW1lIChwcm9wcykge1xuICBpZiAocHJvcHMuaXNBbGxDb21wbGV0ZSkgcmV0dXJuXG5cbiAgaWYgKCFwcm9wcy5yZXN1bWFibGVVcGxvYWRzKSB7XG4gICAgcmV0dXJuIHByb3BzLmNhbmNlbEFsbCgpXG4gIH1cblxuICBpZiAocHJvcHMuaXNBbGxQYXVzZWQpIHtcbiAgICByZXR1cm4gcHJvcHMucmVzdW1lQWxsKClcbiAgfVxuXG4gIHJldHVybiBwcm9wcy5wYXVzZUFsbCgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKHByb3BzKSA9PiB7XG4gIHByb3BzID0gcHJvcHMgfHwge31cblxuICBjb25zdCB7XG4gICAgbmV3RmlsZXMsXG4gICAgYWxsb3dOZXdVcGxvYWQsXG4gICAgaXNVcGxvYWRJblByb2dyZXNzLFxuICAgIGlzQWxsUGF1c2VkLFxuICAgIHJlc3VtYWJsZVVwbG9hZHMsXG4gICAgZXJyb3IsXG4gICAgaGlkZVVwbG9hZEJ1dHRvbixcbiAgICBoaWRlUGF1c2VSZXN1bWVCdXR0b24sXG4gICAgaGlkZUNhbmNlbEJ1dHRvbixcbiAgICBoaWRlUmV0cnlCdXR0b25cbiAgfSA9IHByb3BzXG5cbiAgY29uc3QgdXBsb2FkU3RhdGUgPSBwcm9wcy51cGxvYWRTdGF0ZVxuXG4gIGxldCBwcm9ncmVzc1ZhbHVlID0gcHJvcHMudG90YWxQcm9ncmVzc1xuICBsZXQgcHJvZ3Jlc3NNb2RlXG4gIGxldCBwcm9ncmVzc0JhckNvbnRlbnRcblxuICBpZiAodXBsb2FkU3RhdGUgPT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9QUkVQUk9DRVNTSU5HIHx8IHVwbG9hZFN0YXRlID09PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfUE9TVFBST0NFU1NJTkcpIHtcbiAgICBjb25zdCBwcm9ncmVzcyA9IGNhbGN1bGF0ZVByb2Nlc3NpbmdQcm9ncmVzcyhwcm9wcy5maWxlcylcbiAgICBwcm9ncmVzc01vZGUgPSBwcm9ncmVzcy5tb2RlXG4gICAgaWYgKHByb2dyZXNzTW9kZSA9PT0gJ2RldGVybWluYXRlJykge1xuICAgICAgcHJvZ3Jlc3NWYWx1ZSA9IHByb2dyZXNzLnZhbHVlICogMTAwXG4gICAgfVxuXG4gICAgcHJvZ3Jlc3NCYXJDb250ZW50ID0gUHJvZ3Jlc3NCYXJQcm9jZXNzaW5nKHByb2dyZXNzKVxuICB9IGVsc2UgaWYgKHVwbG9hZFN0YXRlID09PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfQ09NUExFVEUpIHtcbiAgICBwcm9ncmVzc0JhckNvbnRlbnQgPSBQcm9ncmVzc0JhckNvbXBsZXRlKHByb3BzKVxuICB9IGVsc2UgaWYgKHVwbG9hZFN0YXRlID09PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfVVBMT0FESU5HKSB7XG4gICAgaWYgKCFwcm9wcy5zdXBwb3J0c1VwbG9hZFByb2dyZXNzKSB7XG4gICAgICBwcm9ncmVzc01vZGUgPSAnaW5kZXRlcm1pbmF0ZSdcbiAgICAgIHByb2dyZXNzVmFsdWUgPSBudWxsXG4gICAgfVxuXG4gICAgcHJvZ3Jlc3NCYXJDb250ZW50ID0gUHJvZ3Jlc3NCYXJVcGxvYWRpbmcocHJvcHMpXG4gIH0gZWxzZSBpZiAodXBsb2FkU3RhdGUgPT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9FUlJPUikge1xuICAgIHByb2dyZXNzVmFsdWUgPSB1bmRlZmluZWRcbiAgICBwcm9ncmVzc0JhckNvbnRlbnQgPSBQcm9ncmVzc0JhckVycm9yKHByb3BzKVxuICB9XG5cbiAgY29uc3Qgd2lkdGggPSB0eXBlb2YgcHJvZ3Jlc3NWYWx1ZSA9PT0gJ251bWJlcicgPyBwcm9ncmVzc1ZhbHVlIDogMTAwXG4gIGNvbnN0IGlzSGlkZGVuID0gKHVwbG9hZFN0YXRlID09PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfV0FJVElORyAmJiBwcm9wcy5oaWRlVXBsb2FkQnV0dG9uKSB8fFxuICAgICh1cGxvYWRTdGF0ZSA9PT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1dBSVRJTkcgJiYgIXByb3BzLm5ld0ZpbGVzID4gMCkgfHxcbiAgICAodXBsb2FkU3RhdGUgPT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9DT01QTEVURSAmJiBwcm9wcy5oaWRlQWZ0ZXJGaW5pc2gpXG5cbiAgY29uc3Qgc2hvd1VwbG9hZEJ0biA9ICFlcnJvciAmJiBuZXdGaWxlcyAmJlxuICAgICFpc1VwbG9hZEluUHJvZ3Jlc3MgJiYgIWlzQWxsUGF1c2VkICYmXG4gICAgYWxsb3dOZXdVcGxvYWQgJiYgIWhpZGVVcGxvYWRCdXR0b25cbiAgY29uc3Qgc2hvd0NhbmNlbEJ0biA9ICFoaWRlQ2FuY2VsQnV0dG9uICYmXG4gICAgdXBsb2FkU3RhdGUgIT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9XQUlUSU5HICYmXG4gICAgdXBsb2FkU3RhdGUgIT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9DT01QTEVURVxuICBjb25zdCBzaG93UGF1c2VSZXN1bWVCdG4gPSByZXN1bWFibGVVcGxvYWRzICYmICFoaWRlUGF1c2VSZXN1bWVCdXR0b24gJiZcbiAgICB1cGxvYWRTdGF0ZSAhPT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1dBSVRJTkcgJiZcbiAgICB1cGxvYWRTdGF0ZSAhPT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1BSRVBST0NFU1NJTkcgJiZcbiAgICB1cGxvYWRTdGF0ZSAhPT0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1BPU1RQUk9DRVNTSU5HICYmXG4gICAgdXBsb2FkU3RhdGUgIT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9DT01QTEVURVxuICBjb25zdCBzaG93UmV0cnlCdG4gPSBlcnJvciAmJiAhaGlkZVJldHJ5QnV0dG9uXG5cbiAgY29uc3QgcHJvZ3Jlc3NDbGFzc05hbWVzID0gYHVwcHktU3RhdHVzQmFyLXByb2dyZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAke3Byb2dyZXNzTW9kZSA/ICdpcy0nICsgcHJvZ3Jlc3NNb2RlIDogJyd9YFxuXG4gIGNvbnN0IHN0YXR1c0JhckNsYXNzTmFtZXMgPSBjbGFzc05hbWVzKFxuICAgIHsgJ3VwcHktUm9vdCc6IHByb3BzLmlzVGFyZ2V0RE9NRWwgfSxcbiAgICAndXBweS1TdGF0dXNCYXInLFxuICAgIGBpcy0ke3VwbG9hZFN0YXRlfWBcbiAgKVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzcz17c3RhdHVzQmFyQ2xhc3NOYW1lc30gYXJpYS1oaWRkZW49e2lzSGlkZGVufT5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3M9e3Byb2dyZXNzQ2xhc3NOYW1lc31cbiAgICAgICAgc3R5bGU9e3sgd2lkdGg6IHdpZHRoICsgJyUnIH19XG4gICAgICAgIHJvbGU9XCJwcm9ncmVzc2JhclwiXG4gICAgICAgIGFyaWEtdmFsdWVtaW49XCIwXCJcbiAgICAgICAgYXJpYS12YWx1ZW1heD1cIjEwMFwiXG4gICAgICAgIGFyaWEtdmFsdWVub3c9e3Byb2dyZXNzVmFsdWV9XG4gICAgICAvPlxuICAgICAge3Byb2dyZXNzQmFyQ29udGVudH1cbiAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LVN0YXR1c0Jhci1hY3Rpb25zXCI+XG4gICAgICAgIHtzaG93VXBsb2FkQnRuID8gPFVwbG9hZEJ0biB7Li4ucHJvcHN9IHVwbG9hZFN0YXRlPXt1cGxvYWRTdGF0ZX0gLz4gOiBudWxsfVxuICAgICAgICB7c2hvd1JldHJ5QnRuID8gPFJldHJ5QnRuIHsuLi5wcm9wc30gLz4gOiBudWxsfVxuICAgICAgICB7c2hvd1BhdXNlUmVzdW1lQnRuID8gPFBhdXNlUmVzdW1lQnV0dG9uIHsuLi5wcm9wc30gLz4gOiBudWxsfVxuICAgICAgICB7c2hvd0NhbmNlbEJ0biA/IDxDYW5jZWxCdG4gey4uLnByb3BzfSAvPiA6IG51bGx9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5jb25zdCBVcGxvYWRCdG4gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdXBsb2FkQnRuQ2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMoXG4gICAgJ3VwcHktdS1yZXNldCcsXG4gICAgJ3VwcHktYy1idG4nLFxuICAgICd1cHB5LVN0YXR1c0Jhci1hY3Rpb25CdG4nLFxuICAgICd1cHB5LVN0YXR1c0Jhci1hY3Rpb25CdG4tLXVwbG9hZCcsXG4gICAgeyAndXBweS1jLWJ0bi1wcmltYXJ5JzogcHJvcHMudXBsb2FkU3RhdGUgPT09IHN0YXR1c0JhclN0YXRlcy5TVEFURV9XQUlUSU5HIH1cbiAgKVxuXG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBjbGFzcz17dXBsb2FkQnRuQ2xhc3NOYW1lc31cbiAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmkxOG4oJ3VwbG9hZFhGaWxlcycsIHsgc21hcnRfY291bnQ6IHByb3BzLm5ld0ZpbGVzIH0pfVxuICAgICAgb25jbGljaz17cHJvcHMuc3RhcnRVcGxvYWR9XG4gICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgPlxuICAgICAge3Byb3BzLm5ld0ZpbGVzICYmIHByb3BzLmlzVXBsb2FkU3RhcnRlZFxuICAgICAgICA/IHByb3BzLmkxOG4oJ3VwbG9hZFhOZXdGaWxlcycsIHsgc21hcnRfY291bnQ6IHByb3BzLm5ld0ZpbGVzIH0pXG4gICAgICAgIDogcHJvcHMuaTE4bigndXBsb2FkWEZpbGVzJywgeyBzbWFydF9jb3VudDogcHJvcHMubmV3RmlsZXMgfSl9XG4gICAgPC9idXR0b24+XG4gIClcbn1cblxuY29uc3QgUmV0cnlCdG4gPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIGNsYXNzPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1TdGF0dXNCYXItYWN0aW9uQnRuIHVwcHktU3RhdHVzQmFyLWFjdGlvbkJ0bi0tcmV0cnlcIiBhcmlhLWxhYmVsPXtwcm9wcy5pMThuKCdyZXRyeVVwbG9hZCcpfSBvbmNsaWNrPXtwcm9wcy5yZXRyeUFsbH1cbiAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICA+XG4gICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3M9XCJVcHB5SWNvblwiIHdpZHRoPVwiOFwiIGhlaWdodD1cIjEwXCIgdmlld0JveD1cIjAgMCA4IDEwXCI+XG4gICAgICAgIDxwYXRoIGQ9XCJNNCAyLjQwOGEyLjc1IDIuNzUgMCAxIDAgMi43NSAyLjc1LjYyNi42MjYgMCAwIDEgMS4yNS4wMTh2LjAyM2E0IDQgMCAxIDEtNC00LjA0MVYuMjVhLjI1LjI1IDAgMCAxIC4zODktLjIwOGwyLjI5OSAxLjUzM2EuMjUuMjUgMCAwIDEgMCAuNDE2bC0yLjMgMS41MzNBLjI1LjI1IDAgMCAxIDQgMy4zMTZ2LS45MDh6XCIgLz5cbiAgICAgIDwvc3ZnPlxuICAgICAge3Byb3BzLmkxOG4oJ3JldHJ5Jyl9XG4gICAgPC9idXR0b24+XG4gIClcbn1cblxuY29uc3QgQ2FuY2VsQnRuID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBjbGFzcz1cInVwcHktdS1yZXNldCB1cHB5LVN0YXR1c0Jhci1hY3Rpb25DaXJjbGVCdG5cIlxuICAgICAgdGl0bGU9e3Byb3BzLmkxOG4oJ2NhbmNlbCcpfVxuICAgICAgYXJpYS1sYWJlbD17cHJvcHMuaTE4bignY2FuY2VsJyl9XG4gICAgICBvbmNsaWNrPXtwcm9wcy5jYW5jZWxBbGx9XG4gICAgICBkYXRhLXVwcHktc3VwZXItZm9jdXNhYmxlXG4gICAgPlxuICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzPVwiVXBweUljb25cIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCI+XG4gICAgICAgIDxnIGZpbGw9XCJub25lXCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgIDxjaXJjbGUgZmlsbD1cIiM4ODhcIiBjeD1cIjhcIiBjeT1cIjhcIiByPVwiOFwiIC8+XG4gICAgICAgICAgPHBhdGggZmlsbD1cIiNGRkZcIiBkPVwiTTkuMjgzIDhsMi41NjcgMi41NjctMS4yODMgMS4yODNMOCA5LjI4MyA1LjQzMyAxMS44NSA0LjE1IDEwLjU2NyA2LjcxNyA4IDQuMTUgNS40MzMgNS40MzMgNC4xNSA4IDYuNzE3bDIuNTY3LTIuNTY3IDEuMjgzIDEuMjgzelwiIC8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIDwvYnV0dG9uPlxuICApXG59XG5cbmNvbnN0IFBhdXNlUmVzdW1lQnV0dG9uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgaXNBbGxQYXVzZWQsIGkxOG4gfSA9IHByb3BzXG4gIGNvbnN0IHRpdGxlID0gaXNBbGxQYXVzZWQgPyBpMThuKCdyZXN1bWUnKSA6IGkxOG4oJ3BhdXNlJylcblxuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIHRpdGxlPXt0aXRsZX1cbiAgICAgIGFyaWEtbGFiZWw9e3RpdGxlfVxuICAgICAgY2xhc3M9XCJ1cHB5LXUtcmVzZXQgdXBweS1TdGF0dXNCYXItYWN0aW9uQ2lyY2xlQnRuXCJcbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgb25jbGljaz17KCkgPT4gdG9nZ2xlUGF1c2VSZXN1bWUocHJvcHMpfVxuICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgID5cbiAgICAgIHtpc0FsbFBhdXNlZCA/IChcbiAgICAgICAgPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBmb2N1c2FibGU9XCJmYWxzZVwiIGNsYXNzPVwiVXBweUljb25cIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCI+XG4gICAgICAgICAgPGcgZmlsbD1cIm5vbmVcIiBmaWxsLXJ1bGU9XCJldmVub2RkXCI+XG4gICAgICAgICAgICA8Y2lyY2xlIGZpbGw9XCIjODg4XCIgY3g9XCI4XCIgY3k9XCI4XCIgcj1cIjhcIiAvPlxuICAgICAgICAgICAgPHBhdGggZmlsbD1cIiNGRkZcIiBkPVwiTTYgNC4yNUwxMS41IDggNiAxMS43NXpcIiAvPlxuICAgICAgICAgIDwvZz5cbiAgICAgICAgPC9zdmc+XG4gICAgICApIDogKFxuICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3M9XCJVcHB5SWNvblwiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMTYgMTZcIj5cbiAgICAgICAgICA8ZyBmaWxsPVwibm9uZVwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIj5cbiAgICAgICAgICAgIDxjaXJjbGUgZmlsbD1cIiM4ODhcIiBjeD1cIjhcIiBjeT1cIjhcIiByPVwiOFwiIC8+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTUgNC41aDJ2N0g1di03em00IDBoMnY3SDl2LTd6XCIgZmlsbD1cIiNGRkZcIiAvPlxuICAgICAgICAgIDwvZz5cbiAgICAgICAgPC9zdmc+XG4gICAgICApfVxuICAgIDwvYnV0dG9uPlxuICApXG59XG5cbmNvbnN0IExvYWRpbmdTcGlubmVyID0gKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzcz1cInVwcHktU3RhdHVzQmFyLXNwaW5uZXJcIiB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTRcIj5cbiAgICAgIDxwYXRoIGQ9XCJNMTMuOTgzIDYuNTQ3Yy0uMTItMi41MDktMS42NC00Ljg5My0zLjkzOS01LjkzNi0yLjQ4LTEuMTI3LTUuNDg4LS42NTYtNy41NTYgMS4wOTRDLjUyNCAzLjM2Ny0uMzk4IDYuMDQ4LjE2MiA4LjU2MmMuNTU2IDIuNDk1IDIuNDYgNC41MiA0Ljk0IDUuMTgzIDIuOTMyLjc4NCA1LjYxLS42MDIgNy4yNTYtMy4wMTUtMS40OTMgMS45OTMtMy43NDUgMy4zMDktNi4yOTggMi44NjgtMi41MTQtLjQzNC00LjU3OC0yLjM0OS01LjE1My00Ljg0YTYuMjI2IDYuMjI2IDAgMCAxIDIuOTgtNi43NzhDNi4zNC41ODYgOS43NCAxLjEgMTEuMzczIDMuNDkzYy40MDcuNTk2LjY5MyAxLjI4Mi44NDIgMS45ODguMTI3LjU5OC4wNzMgMS4xOTcuMTYxIDEuNzk0LjA3OC41MjUuNTQzIDEuMjU3IDEuMTUuODY0LjUyNS0uMzQxLjQ5LTEuMDUuNDU2LTEuNTkyLS4wMDctLjE1LjAyLjMgMCAwXCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuY29uc3QgUHJvZ3Jlc3NCYXJQcm9jZXNzaW5nID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHZhbHVlID0gTWF0aC5yb3VuZChwcm9wcy52YWx1ZSAqIDEwMClcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3M9XCJ1cHB5LVN0YXR1c0Jhci1jb250ZW50XCI+XG4gICAgICA8TG9hZGluZ1NwaW5uZXIgLz5cbiAgICAgIHtwcm9wcy5tb2RlID09PSAnZGV0ZXJtaW5hdGUnID8gYCR7dmFsdWV9JSBcXHUwMEI3IGAgOiAnJ31cbiAgICAgIHtwcm9wcy5tZXNzYWdlfVxuICAgIDwvZGl2PlxuICApXG59XG5cbmNvbnN0IHJlbmRlckRvdCA9ICgpID0+XG4gICcgXFx1MDBCNyAnXG5cbmNvbnN0IFByb2dyZXNzRGV0YWlscyA9IChwcm9wcykgPT4ge1xuICBjb25zdCBpZlNob3dGaWxlc1VwbG9hZGVkT2ZUb3RhbCA9IHByb3BzLm51bVVwbG9hZHMgPiAxXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzPVwidXBweS1TdGF0dXNCYXItc3RhdHVzU2Vjb25kYXJ5XCI+XG4gICAgICB7XG4gICAgICAgIGlmU2hvd0ZpbGVzVXBsb2FkZWRPZlRvdGFsICYmXG4gICAgICAgIHByb3BzLmkxOG4oJ2ZpbGVzVXBsb2FkZWRPZlRvdGFsJywge1xuICAgICAgICAgIGNvbXBsZXRlOiBwcm9wcy5jb21wbGV0ZSxcbiAgICAgICAgICBzbWFydF9jb3VudDogcHJvcHMubnVtVXBsb2Fkc1xuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgPHNwYW4gY2xhc3M9XCJ1cHB5LVN0YXR1c0Jhci1hZGRpdGlvbmFsSW5mb1wiPlxuICAgICAgICB7LyogV2hlbiBzaG91bGQgd2UgcmVuZGVyIHRoaXMgZG90P1xuICAgICAgICAgIDEuIC4tYWRkaXRpb25hbEluZm8gaXMgc2hvd24gKGhhcHBlbnMgb25seSBvbiBkZXNrdG9wcylcbiAgICAgICAgICAyLiBBTkQgJ2ZpbGVzVXBsb2FkZWRPZlRvdGFsJyB3YXMgc2hvd25cbiAgICAgICAgKi99XG4gICAgICAgIHtpZlNob3dGaWxlc1VwbG9hZGVkT2ZUb3RhbCAmJiByZW5kZXJEb3QoKX1cblxuICAgICAgICB7XG4gICAgICAgICAgcHJvcHMuaTE4bignZGF0YVVwbG9hZGVkT2ZUb3RhbCcsIHtcbiAgICAgICAgICAgIGNvbXBsZXRlOiBwcmV0dHlCeXRlcyhwcm9wcy50b3RhbFVwbG9hZGVkU2l6ZSksXG4gICAgICAgICAgICB0b3RhbDogcHJldHR5Qnl0ZXMocHJvcHMudG90YWxTaXplKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICB7cmVuZGVyRG90KCl9XG5cbiAgICAgICAge1xuICAgICAgICAgIHByb3BzLmkxOG4oJ3hUaW1lTGVmdCcsIHtcbiAgICAgICAgICAgIHRpbWU6IHByZXR0eUVUQShwcm9wcy50b3RhbEVUQSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICA8L3NwYW4+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuY29uc3QgVW5rbm93blByb2dyZXNzRGV0YWlscyA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3M9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNTZWNvbmRhcnlcIj5cbiAgICAgIHtwcm9wcy5pMThuKCdmaWxlc1VwbG9hZGVkT2ZUb3RhbCcsIHsgY29tcGxldGU6IHByb3BzLmNvbXBsZXRlLCBzbWFydF9jb3VudDogcHJvcHMubnVtVXBsb2FkcyB9KX1cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5jb25zdCBVcGxvYWROZXdseUFkZGVkRmlsZXMgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgdXBsb2FkQnRuQ2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMoXG4gICAgJ3VwcHktdS1yZXNldCcsXG4gICAgJ3VwcHktYy1idG4nLFxuICAgICd1cHB5LVN0YXR1c0Jhci1hY3Rpb25CdG4nLFxuICAgICd1cHB5LVN0YXR1c0Jhci1hY3Rpb25CdG4tLXVwbG9hZE5ld2x5QWRkZWQnXG4gIClcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3M9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNTZWNvbmRhcnlcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNTZWNvbmRhcnlIaW50XCI+XG4gICAgICAgIHtwcm9wcy5pMThuKCd4TW9yZUZpbGVzQWRkZWQnLCB7IHNtYXJ0X2NvdW50OiBwcm9wcy5uZXdGaWxlcyB9KX1cbiAgICAgIDwvZGl2PlxuICAgICAgPGJ1dHRvblxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgY2xhc3M9e3VwbG9hZEJ0bkNsYXNzTmFtZXN9XG4gICAgICAgIGFyaWEtbGFiZWw9e3Byb3BzLmkxOG4oJ3VwbG9hZFhGaWxlcycsIHsgc21hcnRfY291bnQ6IHByb3BzLm5ld0ZpbGVzIH0pfVxuICAgICAgICBvbmNsaWNrPXtwcm9wcy5zdGFydFVwbG9hZH1cbiAgICAgID5cbiAgICAgICAge3Byb3BzLmkxOG4oJ3VwbG9hZCcpfVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuY29uc3QgVGhyb3R0bGVkUHJvZ3Jlc3NEZXRhaWxzID0gdGhyb3R0bGUoUHJvZ3Jlc3NEZXRhaWxzLCA1MDAsIHsgbGVhZGluZzogdHJ1ZSwgdHJhaWxpbmc6IHRydWUgfSlcblxuY29uc3QgUHJvZ3Jlc3NCYXJVcGxvYWRpbmcgPSAocHJvcHMpID0+IHtcbiAgaWYgKCFwcm9wcy5pc1VwbG9hZFN0YXJ0ZWQgfHwgcHJvcHMuaXNBbGxDb21wbGV0ZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCB0aXRsZSA9IHByb3BzLmlzQWxsUGF1c2VkID8gcHJvcHMuaTE4bigncGF1c2VkJykgOiBwcm9wcy5pMThuKCd1cGxvYWRpbmcnKVxuICBjb25zdCBzaG93VXBsb2FkTmV3bHlBZGRlZEZpbGVzID0gcHJvcHMubmV3RmlsZXMgJiYgcHJvcHMuaXNVcGxvYWRTdGFydGVkXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzPVwidXBweS1TdGF0dXNCYXItY29udGVudFwiIGFyaWEtbGFiZWw9e3RpdGxlfSB0aXRsZT17dGl0bGV9PlxuICAgICAgeyFwcm9wcy5pc0FsbFBhdXNlZCA/IDxMb2FkaW5nU3Bpbm5lciAvPiA6IG51bGx9XG4gICAgICA8ZGl2IGNsYXNzPVwidXBweS1TdGF0dXNCYXItc3RhdHVzXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNQcmltYXJ5XCI+XG4gICAgICAgICAge3Byb3BzLnN1cHBvcnRzVXBsb2FkUHJvZ3Jlc3MgPyBgJHt0aXRsZX06ICR7cHJvcHMudG90YWxQcm9ncmVzc30lYCA6IHRpdGxlfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgeyFwcm9wcy5pc0FsbFBhdXNlZCAmJiAhc2hvd1VwbG9hZE5ld2x5QWRkZWRGaWxlcyAmJiBwcm9wcy5zaG93UHJvZ3Jlc3NEZXRhaWxzXG4gICAgICAgICAgPyAocHJvcHMuc3VwcG9ydHNVcGxvYWRQcm9ncmVzcyA/IDxUaHJvdHRsZWRQcm9ncmVzc0RldGFpbHMgey4uLnByb3BzfSAvPiA6IDxVbmtub3duUHJvZ3Jlc3NEZXRhaWxzIHsuLi5wcm9wc30gLz4pXG4gICAgICAgICAgOiBudWxsfVxuICAgICAgICB7c2hvd1VwbG9hZE5ld2x5QWRkZWRGaWxlcyA/IDxVcGxvYWROZXdseUFkZGVkRmlsZXMgey4uLnByb3BzfSAvPiA6IG51bGx9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5jb25zdCBQcm9ncmVzc0JhckNvbXBsZXRlID0gKHsgdG90YWxQcm9ncmVzcywgaTE4biB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzcz1cInVwcHktU3RhdHVzQmFyLWNvbnRlbnRcIiByb2xlPVwic3RhdHVzXCIgdGl0bGU9e2kxOG4oJ2NvbXBsZXRlJyl9PlxuICAgICAgPGRpdiBjbGFzcz1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidXBweS1TdGF0dXNCYXItc3RhdHVzUHJpbWFyeVwiPlxuICAgICAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzcz1cInVwcHktU3RhdHVzQmFyLXN0YXR1c0luZGljYXRvciBVcHB5SWNvblwiIHdpZHRoPVwiMTVcIiBoZWlnaHQ9XCIxMVwiIHZpZXdCb3g9XCIwIDAgMTUgMTFcIj5cbiAgICAgICAgICAgIDxwYXRoIGQ9XCJNLjQxNCA1Ljg0M0wxLjYyNyA0LjYzbDMuNDcyIDMuNDcyTDEzLjIwMiAwbDEuMjEyIDEuMjEzTDUuMSAxMC41Mjh6XCIgLz5cbiAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICB7aTE4bignY29tcGxldGUnKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5jb25zdCBQcm9ncmVzc0JhckVycm9yID0gKHsgZXJyb3IsIHJldHJ5QWxsLCBoaWRlUmV0cnlCdXR0b24sIGkxOG4gfSkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3M9XCJ1cHB5LVN0YXR1c0Jhci1jb250ZW50XCIgcm9sZT1cImFsZXJ0XCIgdGl0bGU9e2kxOG4oJ3VwbG9hZEZhaWxlZCcpfT5cbiAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVwcHktU3RhdHVzQmFyLXN0YXR1c1ByaW1hcnlcIj5cbiAgICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3M9XCJ1cHB5LVN0YXR1c0Jhci1zdGF0dXNJbmRpY2F0b3IgVXBweUljb25cIiB3aWR0aD1cIjExXCIgaGVpZ2h0PVwiMTFcIiB2aWV3Qm94PVwiMCAwIDExIDExXCI+XG4gICAgICAgICAgICA8cGF0aCBkPVwiTTQuMjc4IDUuNUwwIDEuMjIyIDEuMjIyIDAgNS41IDQuMjc4IDkuNzc4IDAgMTEgMS4yMjIgNi43MjIgNS41IDExIDkuNzc4IDkuNzc4IDExIDUuNSA2LjcyMiAxLjIyMiAxMSAwIDkuNzc4elwiIC8+XG4gICAgICAgICAgPC9zdmc+XG4gICAgICAgICAge2kxOG4oJ3VwbG9hZEZhaWxlZCcpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgey8qIHshaGlkZVJldHJ5QnV0dG9uICYmXG4gICAgICAgIDxzcGFuIGNsYXNzPVwidXBweS1TdGF0dXNCYXItY29udGVudFBhZGRpbmdcIj57aTE4bigncGxlYXNlUHJlc3NSZXRyeScpfTwvc3Bhbj5cbiAgICAgIH0gKi99XG4gICAgICA8c3BhblxuICAgICAgICBjbGFzcz1cInVwcHktU3RhdHVzQmFyLWRldGFpbHNcIlxuICAgICAgICBhcmlhLWxhYmVsPXtlcnJvcn1cbiAgICAgICAgZGF0YS1taWNyb3RpcC1wb3NpdGlvbj1cInRvcC1yaWdodFwiXG4gICAgICAgIGRhdGEtbWljcm90aXAtc2l6ZT1cIm1lZGl1bVwiXG4gICAgICAgIHJvbGU9XCJ0b29sdGlwXCJcbiAgICAgID5cbiAgICAgICAgP1xuICAgICAgPC9zcGFuPlxuICAgIDwvZGl2PlxuICApXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgU1RBVEVfRVJST1I6ICdlcnJvcicsXG4gIFNUQVRFX1dBSVRJTkc6ICd3YWl0aW5nJyxcbiAgU1RBVEVfUFJFUFJPQ0VTU0lORzogJ3ByZXByb2Nlc3NpbmcnLFxuICBTVEFURV9VUExPQURJTkc6ICd1cGxvYWRpbmcnLFxuICBTVEFURV9QT1NUUFJPQ0VTU0lORzogJ3Bvc3Rwcm9jZXNzaW5nJyxcbiAgU1RBVEVfQ09NUExFVEU6ICdjb21wbGV0ZSdcbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IFRyYW5zbGF0b3IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvVHJhbnNsYXRvcicpXG5jb25zdCBTdGF0dXNCYXJVSSA9IHJlcXVpcmUoJy4vU3RhdHVzQmFyJylcbmNvbnN0IHN0YXR1c0JhclN0YXRlcyA9IHJlcXVpcmUoJy4vU3RhdHVzQmFyU3RhdGVzJylcbmNvbnN0IGdldFNwZWVkID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldFNwZWVkJylcbmNvbnN0IGdldEJ5dGVzUmVtYWluaW5nID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2dldEJ5dGVzUmVtYWluaW5nJylcblxuLyoqXG4gKiBTdGF0dXNCYXI6IHJlbmRlcnMgYSBzdGF0dXMgYmFyIHdpdGggdXBsb2FkL3BhdXNlL3Jlc3VtZS9jYW5jZWwvcmV0cnkgYnV0dG9ucyxcbiAqIHByb2dyZXNzIHBlcmNlbnRhZ2UgYW5kIHRpbWUgcmVtYWluaW5nLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFN0YXR1c0JhciBleHRlbmRzIFBsdWdpbiB7XG4gIHN0YXRpYyBWRVJTSU9OID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvblxuXG4gIGNvbnN0cnVjdG9yICh1cHB5LCBvcHRzKSB7XG4gICAgc3VwZXIodXBweSwgb3B0cylcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdTdGF0dXNCYXInXG4gICAgdGhpcy50aXRsZSA9ICdTdGF0dXNCYXInXG4gICAgdGhpcy50eXBlID0gJ3Byb2dyZXNzaW5kaWNhdG9yJ1xuXG4gICAgdGhpcy5kZWZhdWx0TG9jYWxlID0ge1xuICAgICAgc3RyaW5nczoge1xuICAgICAgICB1cGxvYWRpbmc6ICdVcGxvYWRpbmcnLFxuICAgICAgICB1cGxvYWQ6ICdVcGxvYWQnLFxuICAgICAgICBjb21wbGV0ZTogJ0NvbXBsZXRlJyxcbiAgICAgICAgdXBsb2FkRmFpbGVkOiAnVXBsb2FkIGZhaWxlZCcsXG4gICAgICAgIHBhdXNlZDogJ1BhdXNlZCcsXG4gICAgICAgIHJldHJ5OiAnUmV0cnknLFxuICAgICAgICBjYW5jZWw6ICdDYW5jZWwnLFxuICAgICAgICBwYXVzZTogJ1BhdXNlJyxcbiAgICAgICAgcmVzdW1lOiAnUmVzdW1lJyxcbiAgICAgICAgZmlsZXNVcGxvYWRlZE9mVG90YWw6IHtcbiAgICAgICAgICAwOiAnJXtjb21wbGV0ZX0gb2YgJXtzbWFydF9jb3VudH0gZmlsZSB1cGxvYWRlZCcsXG4gICAgICAgICAgMTogJyV7Y29tcGxldGV9IG9mICV7c21hcnRfY291bnR9IGZpbGVzIHVwbG9hZGVkJyxcbiAgICAgICAgICAyOiAnJXtjb21wbGV0ZX0gb2YgJXtzbWFydF9jb3VudH0gZmlsZXMgdXBsb2FkZWQnXG4gICAgICAgIH0sXG4gICAgICAgIGRhdGFVcGxvYWRlZE9mVG90YWw6ICcle2NvbXBsZXRlfSBvZiAle3RvdGFsfScsXG4gICAgICAgIHhUaW1lTGVmdDogJyV7dGltZX0gbGVmdCcsXG4gICAgICAgIHVwbG9hZFhGaWxlczoge1xuICAgICAgICAgIDA6ICdVcGxvYWQgJXtzbWFydF9jb3VudH0gZmlsZScsXG4gICAgICAgICAgMTogJ1VwbG9hZCAle3NtYXJ0X2NvdW50fSBmaWxlcycsXG4gICAgICAgICAgMjogJ1VwbG9hZCAle3NtYXJ0X2NvdW50fSBmaWxlcydcbiAgICAgICAgfSxcbiAgICAgICAgdXBsb2FkWE5ld0ZpbGVzOiB7XG4gICAgICAgICAgMDogJ1VwbG9hZCArJXtzbWFydF9jb3VudH0gZmlsZScsXG4gICAgICAgICAgMTogJ1VwbG9hZCArJXtzbWFydF9jb3VudH0gZmlsZXMnLFxuICAgICAgICAgIDI6ICdVcGxvYWQgKyV7c21hcnRfY291bnR9IGZpbGVzJ1xuICAgICAgICB9LFxuICAgICAgICB4TW9yZUZpbGVzQWRkZWQ6IHtcbiAgICAgICAgICAwOiAnJXtzbWFydF9jb3VudH0gbW9yZSBmaWxlIGFkZGVkJyxcbiAgICAgICAgICAxOiAnJXtzbWFydF9jb3VudH0gbW9yZSBmaWxlcyBhZGRlZCcsXG4gICAgICAgICAgMjogJyV7c21hcnRfY291bnR9IG1vcmUgZmlsZXMgYWRkZWQnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICB0YXJnZXQ6ICdib2R5JyxcbiAgICAgIGhpZGVVcGxvYWRCdXR0b246IGZhbHNlLFxuICAgICAgaGlkZVJldHJ5QnV0dG9uOiBmYWxzZSxcbiAgICAgIGhpZGVQYXVzZVJlc3VtZUJ1dHRvbjogZmFsc2UsXG4gICAgICBoaWRlQ2FuY2VsQnV0dG9uOiBmYWxzZSxcbiAgICAgIHNob3dQcm9ncmVzc0RldGFpbHM6IGZhbHNlLFxuICAgICAgaGlkZUFmdGVyRmluaXNoOiB0cnVlXG4gICAgfVxuXG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9XG5cbiAgICB0aGlzLmkxOG5Jbml0KClcblxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuICAgIHRoaXMuaW5zdGFsbCA9IHRoaXMuaW5zdGFsbC5iaW5kKHRoaXMpXG4gIH1cblxuICBzZXRPcHRpb25zIChuZXdPcHRzKSB7XG4gICAgc3VwZXIuc2V0T3B0aW9ucyhuZXdPcHRzKVxuICAgIHRoaXMuaTE4bkluaXQoKVxuICB9XG5cbiAgaTE4bkluaXQgKCkge1xuICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKFt0aGlzLmRlZmF1bHRMb2NhbGUsIHRoaXMudXBweS5sb2NhbGUsIHRoaXMub3B0cy5sb2NhbGVdKVxuICAgIHRoaXMuaTE4biA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSgpIC8vIHNvIHRoYXQgVUkgcmUtcmVuZGVycyBhbmQgd2Ugc2VlIHRoZSB1cGRhdGVkIGxvY2FsZVxuICB9XG5cbiAgZ2V0VG90YWxTcGVlZCAoZmlsZXMpIHtcbiAgICBsZXQgdG90YWxTcGVlZCA9IDBcbiAgICBmaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICB0b3RhbFNwZWVkID0gdG90YWxTcGVlZCArIGdldFNwZWVkKGZpbGUucHJvZ3Jlc3MpXG4gICAgfSlcbiAgICByZXR1cm4gdG90YWxTcGVlZFxuICB9XG5cbiAgZ2V0VG90YWxFVEEgKGZpbGVzKSB7XG4gICAgY29uc3QgdG90YWxTcGVlZCA9IHRoaXMuZ2V0VG90YWxTcGVlZChmaWxlcylcbiAgICBpZiAodG90YWxTcGVlZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBjb25zdCB0b3RhbEJ5dGVzUmVtYWluaW5nID0gZmlsZXMucmVkdWNlKCh0b3RhbCwgZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIHRvdGFsICsgZ2V0Qnl0ZXNSZW1haW5pbmcoZmlsZS5wcm9ncmVzcylcbiAgICB9LCAwKVxuXG4gICAgcmV0dXJuIE1hdGgucm91bmQodG90YWxCeXRlc1JlbWFpbmluZyAvIHRvdGFsU3BlZWQgKiAxMCkgLyAxMFxuICB9XG5cbiAgc3RhcnRVcGxvYWQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMudXBweS51cGxvYWQoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBpZiAoIWVyci5pc1Jlc3RyaWN0aW9uKSB7XG4gICAgICAgIHRoaXMudXBweS5sb2coZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlIHx8IGVycilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZ2V0VXBsb2FkaW5nU3RhdGUgKGlzQWxsRXJyb3JlZCwgaXNBbGxDb21wbGV0ZSwgZmlsZXMpIHtcbiAgICBpZiAoaXNBbGxFcnJvcmVkKSB7XG4gICAgICByZXR1cm4gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX0VSUk9SXG4gICAgfVxuXG4gICAgaWYgKGlzQWxsQ29tcGxldGUpIHtcbiAgICAgIHJldHVybiBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfQ09NUExFVEVcbiAgICB9XG5cbiAgICBsZXQgc3RhdGUgPSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfV0FJVElOR1xuICAgIGNvbnN0IGZpbGVJRHMgPSBPYmplY3Qua2V5cyhmaWxlcylcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHByb2dyZXNzID0gZmlsZXNbZmlsZUlEc1tpXV0ucHJvZ3Jlc3NcbiAgICAgIC8vIElmIEFOWSBmaWxlcyBhcmUgYmVpbmcgdXBsb2FkZWQgcmlnaHQgbm93LCBzaG93IHRoZSB1cGxvYWRpbmcgc3RhdGUuXG4gICAgICBpZiAocHJvZ3Jlc3MudXBsb2FkU3RhcnRlZCAmJiAhcHJvZ3Jlc3MudXBsb2FkQ29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXR1c0JhclN0YXRlcy5TVEFURV9VUExPQURJTkdcbiAgICAgIH1cbiAgICAgIC8vIElmIGZpbGVzIGFyZSBiZWluZyBwcmVwcm9jZXNzZWQgQU5EIHBvc3Rwcm9jZXNzZWQgYXQgdGhpcyB0aW1lLCB3ZSBzaG93IHRoZVxuICAgICAgLy8gcHJlcHJvY2VzcyBzdGF0ZS4gSWYgYW55IGZpbGVzIGFyZSBiZWluZyB1cGxvYWRlZCB3ZSBzaG93IHVwbG9hZGluZy5cbiAgICAgIGlmIChwcm9ncmVzcy5wcmVwcm9jZXNzICYmIHN0YXRlICE9PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfVVBMT0FESU5HKSB7XG4gICAgICAgIHN0YXRlID0gc3RhdHVzQmFyU3RhdGVzLlNUQVRFX1BSRVBST0NFU1NJTkdcbiAgICAgIH1cbiAgICAgIC8vIElmIE5PIGZpbGVzIGFyZSBiZWluZyBwcmVwcm9jZXNzZWQgb3IgdXBsb2FkZWQgcmlnaHQgbm93LCBidXQgc29tZSBmaWxlcyBhcmVcbiAgICAgIC8vIGJlaW5nIHBvc3Rwcm9jZXNzZWQsIHNob3cgdGhlIHBvc3Rwcm9jZXNzIHN0YXRlLlxuICAgICAgaWYgKHByb2dyZXNzLnBvc3Rwcm9jZXNzICYmIHN0YXRlICE9PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfVVBMT0FESU5HICYmIHN0YXRlICE9PSBzdGF0dXNCYXJTdGF0ZXMuU1RBVEVfUFJFUFJPQ0VTU0lORykge1xuICAgICAgICBzdGF0ZSA9IHN0YXR1c0JhclN0YXRlcy5TVEFURV9QT1NUUFJPQ0VTU0lOR1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGVcbiAgfVxuXG4gIHJlbmRlciAoc3RhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjYXBhYmlsaXRpZXMsXG4gICAgICBmaWxlcyxcbiAgICAgIGFsbG93TmV3VXBsb2FkLFxuICAgICAgdG90YWxQcm9ncmVzcyxcbiAgICAgIGVycm9yXG4gICAgfSA9IHN0YXRlXG5cbiAgICAvLyBUT0RPOiBtb3ZlIHRoaXMgdG8gQ29yZSwgdG8gc2hhcmUgYmV0d2VlbiBTdGF0dXMgQmFyIGFuZCBEYXNoYm9hcmRcbiAgICAvLyAoYW5kIGFueSBvdGhlciBwbHVnaW4gdGhhdCBtaWdodCBuZWVkIGl0LCB0b28pXG5cbiAgICBjb25zdCBmaWxlc0FycmF5ID0gT2JqZWN0LmtleXMoZmlsZXMpLm1hcChmaWxlID0+IGZpbGVzW2ZpbGVdKVxuXG4gICAgY29uc3QgbmV3RmlsZXMgPSBmaWxlc0FycmF5LmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuICFmaWxlLnByb2dyZXNzLnVwbG9hZFN0YXJ0ZWQgJiZcbiAgICAgICAgIWZpbGUucHJvZ3Jlc3MucHJlcHJvY2VzcyAmJlxuICAgICAgICAhZmlsZS5wcm9ncmVzcy5wb3N0cHJvY2Vzc1xuICAgIH0pXG5cbiAgICBjb25zdCB1cGxvYWRTdGFydGVkRmlsZXMgPSBmaWxlc0FycmF5LmZpbHRlcihmaWxlID0+IGZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZClcbiAgICBjb25zdCBwYXVzZWRGaWxlcyA9IHVwbG9hZFN0YXJ0ZWRGaWxlcy5maWx0ZXIoZmlsZSA9PiBmaWxlLmlzUGF1c2VkKVxuICAgIGNvbnN0IGNvbXBsZXRlRmlsZXMgPSBmaWxlc0FycmF5LmZpbHRlcihmaWxlID0+IGZpbGUucHJvZ3Jlc3MudXBsb2FkQ29tcGxldGUpXG4gICAgY29uc3QgZXJyb3JlZEZpbGVzID0gZmlsZXNBcnJheS5maWx0ZXIoZmlsZSA9PiBmaWxlLmVycm9yKVxuXG4gICAgY29uc3QgaW5Qcm9ncmVzc0ZpbGVzID0gZmlsZXNBcnJheS5maWx0ZXIoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiAhZmlsZS5wcm9ncmVzcy51cGxvYWRDb21wbGV0ZSAmJlxuICAgICAgICAgICAgIGZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZFxuICAgIH0pXG5cbiAgICBjb25zdCBpblByb2dyZXNzTm90UGF1c2VkRmlsZXMgPSBpblByb2dyZXNzRmlsZXMuZmlsdGVyKGZpbGUgPT4gIWZpbGUuaXNQYXVzZWQpXG5cbiAgICBjb25zdCBzdGFydGVkRmlsZXMgPSBmaWxlc0FycmF5LmZpbHRlcigoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIGZpbGUucHJvZ3Jlc3MudXBsb2FkU3RhcnRlZCB8fFxuICAgICAgICBmaWxlLnByb2dyZXNzLnByZXByb2Nlc3MgfHxcbiAgICAgICAgZmlsZS5wcm9ncmVzcy5wb3N0cHJvY2Vzc1xuICAgIH0pXG5cbiAgICBjb25zdCBwcm9jZXNzaW5nRmlsZXMgPSBmaWxlc0FycmF5LmZpbHRlcihmaWxlID0+IGZpbGUucHJvZ3Jlc3MucHJlcHJvY2VzcyB8fCBmaWxlLnByb2dyZXNzLnBvc3Rwcm9jZXNzKVxuXG4gICAgY29uc3QgdG90YWxFVEEgPSB0aGlzLmdldFRvdGFsRVRBKGluUHJvZ3Jlc3NOb3RQYXVzZWRGaWxlcylcblxuICAgIGxldCB0b3RhbFNpemUgPSAwXG4gICAgbGV0IHRvdGFsVXBsb2FkZWRTaXplID0gMFxuICAgIHVwbG9hZFN0YXJ0ZWRGaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICB0b3RhbFNpemUgPSB0b3RhbFNpemUgKyAoZmlsZS5wcm9ncmVzcy5ieXRlc1RvdGFsIHx8IDApXG4gICAgICB0b3RhbFVwbG9hZGVkU2l6ZSA9IHRvdGFsVXBsb2FkZWRTaXplICsgKGZpbGUucHJvZ3Jlc3MuYnl0ZXNVcGxvYWRlZCB8fCAwKVxuICAgIH0pXG5cbiAgICBjb25zdCBpc1VwbG9hZFN0YXJ0ZWQgPSB1cGxvYWRTdGFydGVkRmlsZXMubGVuZ3RoID4gMFxuXG4gICAgY29uc3QgaXNBbGxDb21wbGV0ZSA9IHRvdGFsUHJvZ3Jlc3MgPT09IDEwMCAmJlxuICAgICAgY29tcGxldGVGaWxlcy5sZW5ndGggPT09IE9iamVjdC5rZXlzKGZpbGVzKS5sZW5ndGggJiZcbiAgICAgIHByb2Nlc3NpbmdGaWxlcy5sZW5ndGggPT09IDBcblxuICAgIGNvbnN0IGlzQWxsRXJyb3JlZCA9IGlzVXBsb2FkU3RhcnRlZCAmJlxuICAgICAgZXJyb3JlZEZpbGVzLmxlbmd0aCA9PT0gdXBsb2FkU3RhcnRlZEZpbGVzLmxlbmd0aFxuXG4gICAgY29uc3QgaXNBbGxQYXVzZWQgPSBpblByb2dyZXNzRmlsZXMubGVuZ3RoICE9PSAwICYmXG4gICAgICBwYXVzZWRGaWxlcy5sZW5ndGggPT09IGluUHJvZ3Jlc3NGaWxlcy5sZW5ndGhcblxuICAgIGNvbnN0IGlzVXBsb2FkSW5Qcm9ncmVzcyA9IGluUHJvZ3Jlc3NGaWxlcy5sZW5ndGggPiAwXG4gICAgY29uc3QgcmVzdW1hYmxlVXBsb2FkcyA9IGNhcGFiaWxpdGllcy5yZXN1bWFibGVVcGxvYWRzIHx8IGZhbHNlXG4gICAgY29uc3Qgc3VwcG9ydHNVcGxvYWRQcm9ncmVzcyA9IGNhcGFiaWxpdGllcy51cGxvYWRQcm9ncmVzcyAhPT0gZmFsc2VcblxuICAgIHJldHVybiBTdGF0dXNCYXJVSSh7XG4gICAgICBlcnJvcixcbiAgICAgIHVwbG9hZFN0YXRlOiB0aGlzLmdldFVwbG9hZGluZ1N0YXRlKGlzQWxsRXJyb3JlZCwgaXNBbGxDb21wbGV0ZSwgc3RhdGUuZmlsZXMgfHwge30pLFxuICAgICAgYWxsb3dOZXdVcGxvYWQsXG4gICAgICB0b3RhbFByb2dyZXNzLFxuICAgICAgdG90YWxTaXplLFxuICAgICAgdG90YWxVcGxvYWRlZFNpemUsXG4gICAgICBpc0FsbENvbXBsZXRlLFxuICAgICAgaXNBbGxQYXVzZWQsXG4gICAgICBpc0FsbEVycm9yZWQsXG4gICAgICBpc1VwbG9hZFN0YXJ0ZWQsXG4gICAgICBpc1VwbG9hZEluUHJvZ3Jlc3MsXG4gICAgICBjb21wbGV0ZTogY29tcGxldGVGaWxlcy5sZW5ndGgsXG4gICAgICBuZXdGaWxlczogbmV3RmlsZXMubGVuZ3RoLFxuICAgICAgbnVtVXBsb2Fkczogc3RhcnRlZEZpbGVzLmxlbmd0aCxcbiAgICAgIHRvdGFsRVRBLFxuICAgICAgZmlsZXMsXG4gICAgICBpMThuOiB0aGlzLmkxOG4sXG4gICAgICBwYXVzZUFsbDogdGhpcy51cHB5LnBhdXNlQWxsLFxuICAgICAgcmVzdW1lQWxsOiB0aGlzLnVwcHkucmVzdW1lQWxsLFxuICAgICAgcmV0cnlBbGw6IHRoaXMudXBweS5yZXRyeUFsbCxcbiAgICAgIGNhbmNlbEFsbDogdGhpcy51cHB5LmNhbmNlbEFsbCxcbiAgICAgIHN0YXJ0VXBsb2FkOiB0aGlzLnN0YXJ0VXBsb2FkLFxuICAgICAgcmVzdW1hYmxlVXBsb2FkcyxcbiAgICAgIHN1cHBvcnRzVXBsb2FkUHJvZ3Jlc3MsXG4gICAgICBzaG93UHJvZ3Jlc3NEZXRhaWxzOiB0aGlzLm9wdHMuc2hvd1Byb2dyZXNzRGV0YWlscyxcbiAgICAgIGhpZGVVcGxvYWRCdXR0b246IHRoaXMub3B0cy5oaWRlVXBsb2FkQnV0dG9uLFxuICAgICAgaGlkZVJldHJ5QnV0dG9uOiB0aGlzLm9wdHMuaGlkZVJldHJ5QnV0dG9uLFxuICAgICAgaGlkZVBhdXNlUmVzdW1lQnV0dG9uOiB0aGlzLm9wdHMuaGlkZVBhdXNlUmVzdW1lQnV0dG9uLFxuICAgICAgaGlkZUNhbmNlbEJ1dHRvbjogdGhpcy5vcHRzLmhpZGVDYW5jZWxCdXR0b24sXG4gICAgICBoaWRlQWZ0ZXJGaW5pc2g6IHRoaXMub3B0cy5oaWRlQWZ0ZXJGaW5pc2gsXG4gICAgICBpc1RhcmdldERPTUVsOiB0aGlzLmlzVGFyZ2V0RE9NRWxcbiAgICB9KVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRzLnRhcmdldFxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMubW91bnQodGFyZ2V0LCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy51bm1vdW50KClcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS9zdG9yZS1kZWZhdWx0XCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgZGVmYXVsdCBzaW1wbGUgb2JqZWN0LWJhc2VkIHN0b3JlIGZvciBVcHB5LlwiLFxuICBcInZlcnNpb25cIjogXCIxLjIuMFwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1zdG9yZVwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfVxufVxuIiwiLyoqXG4gKiBEZWZhdWx0IHN0b3JlIHRoYXQga2VlcHMgc3RhdGUgaW4gYSBzaW1wbGUgb2JqZWN0LlxuICovXG5jbGFzcyBEZWZhdWx0U3RvcmUge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHt9XG4gICAgdGhpcy5jYWxsYmFja3MgPSBbXVxuICB9XG5cbiAgZ2V0U3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlXG4gIH1cblxuICBzZXRTdGF0ZSAocGF0Y2gpIHtcbiAgICBjb25zdCBwcmV2U3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlKVxuICAgIGNvbnN0IG5leHRTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUsIHBhdGNoKVxuXG4gICAgdGhpcy5zdGF0ZSA9IG5leHRTdGF0ZVxuICAgIHRoaXMuX3B1Ymxpc2gocHJldlN0YXRlLCBuZXh0U3RhdGUsIHBhdGNoKVxuICB9XG5cbiAgc3Vic2NyaWJlIChsaXN0ZW5lcikge1xuICAgIHRoaXMuY2FsbGJhY2tzLnB1c2gobGlzdGVuZXIpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAgICB0aGlzLmNhbGxiYWNrcy5zcGxpY2UoXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmluZGV4T2YobGlzdGVuZXIpLFxuICAgICAgICAxXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgX3B1Ymxpc2ggKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmNhbGxiYWNrcy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgbGlzdGVuZXIoLi4uYXJncylcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmYXVsdFN0b3JlICgpIHtcbiAgcmV0dXJuIG5ldyBEZWZhdWx0U3RvcmUoKVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS90aHVtYm5haWwtZ2VuZXJhdG9yXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJVcHB5IHBsdWdpbiB0aGF0IGdlbmVyYXRlcyBzbWFsbCBwcmV2aWV3cyBvZiBpbWFnZXMgdG8gc2hvdyBvbiB5b3VyIHVwbG9hZCBVSS5cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS41LjJcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInR5cGVzXCI6IFwidHlwZXMvaW5kZXguZC50c1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImZpbGUgdXBsb2FkZXJcIixcbiAgICBcInVwcHlcIixcbiAgICBcInVwcHktcGx1Z2luXCIsXG4gICAgXCJ0aHVtYm5haWxcIixcbiAgICBcInByZXZpZXdcIixcbiAgICBcInJlc2l6ZVwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3VwcHkuaW9cIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5L2lzc3Vlc1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3RyYW5zbG9hZGl0L3VwcHkuZ2l0XCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvdXRpbHNcIjogXCJmaWxlOi4uL3V0aWxzXCJcbiAgfSxcbiAgXCJwZWVyRGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvcmVcIjogXCJeMS4wLjBcIlxuICB9XG59XG4iLCIvLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2V4aWYtanMvZXhpZi1qc1xuLy8gUmVtb3ZlZCBYTVAgYW5kIElQVEMgbWV0YWRhdGEgcGFyc2luZyBhbmQgRVhJRiB0aHVtYm5haWwgZ2VuZXJhdGlvblxuLy8gTUlUIExpY2Vuc2UgKGMpIEphY29iIFNlaWRlbGluIGh0dHBzOi8vZ2l0aHViLmNvbS9leGlmLWpzL2V4aWYtanMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuXG5jb25zdCBFeGlmVGFncyA9IHtcbiAgLy8gdmVyc2lvbiB0YWdzXG4gIDB4OTAwMDogJ0V4aWZWZXJzaW9uJywgLy8gRVhJRiB2ZXJzaW9uXG4gIDB4QTAwMDogJ0ZsYXNocGl4VmVyc2lvbicsIC8vIEZsYXNocGl4IGZvcm1hdCB2ZXJzaW9uXG5cbiAgLy8gY29sb3JzcGFjZSB0YWdzXG4gIDB4QTAwMTogJ0NvbG9yU3BhY2UnLCAvLyBDb2xvciBzcGFjZSBpbmZvcm1hdGlvbiB0YWdcblxuICAvLyBpbWFnZSBjb25maWd1cmF0aW9uXG4gIDB4QTAwMjogJ1BpeGVsWERpbWVuc2lvbicsIC8vIFZhbGlkIHdpZHRoIG9mIG1lYW5pbmdmdWwgaW1hZ2VcbiAgMHhBMDAzOiAnUGl4ZWxZRGltZW5zaW9uJywgLy8gVmFsaWQgaGVpZ2h0IG9mIG1lYW5pbmdmdWwgaW1hZ2VcbiAgMHg5MTAxOiAnQ29tcG9uZW50c0NvbmZpZ3VyYXRpb24nLCAvLyBJbmZvcm1hdGlvbiBhYm91dCBjaGFubmVsc1xuICAweDkxMDI6ICdDb21wcmVzc2VkQml0c1BlclBpeGVsJywgLy8gQ29tcHJlc3NlZCBiaXRzIHBlciBwaXhlbFxuXG4gIC8vIHVzZXIgaW5mb3JtYXRpb25cbiAgMHg5MjdDOiAnTWFrZXJOb3RlJywgLy8gQW55IGRlc2lyZWQgaW5mb3JtYXRpb24gd3JpdHRlbiBieSB0aGUgbWFudWZhY3R1cmVyXG4gIDB4OTI4NjogJ1VzZXJDb21tZW50JywgLy8gQ29tbWVudHMgYnkgdXNlclxuXG4gIC8vIHJlbGF0ZWQgZmlsZVxuICAweEEwMDQ6ICdSZWxhdGVkU291bmRGaWxlJywgLy8gTmFtZSBvZiByZWxhdGVkIHNvdW5kIGZpbGVcblxuICAvLyBkYXRlIGFuZCB0aW1lXG4gIDB4OTAwMzogJ0RhdGVUaW1lT3JpZ2luYWwnLCAvLyBEYXRlIGFuZCB0aW1lIHdoZW4gdGhlIG9yaWdpbmFsIGltYWdlIHdhcyBnZW5lcmF0ZWRcbiAgMHg5MDA0OiAnRGF0ZVRpbWVEaWdpdGl6ZWQnLCAvLyBEYXRlIGFuZCB0aW1lIHdoZW4gdGhlIGltYWdlIHdhcyBzdG9yZWQgZGlnaXRhbGx5XG4gIDB4OTI5MDogJ1N1YnNlY1RpbWUnLCAvLyBGcmFjdGlvbnMgb2Ygc2Vjb25kcyBmb3IgRGF0ZVRpbWVcbiAgMHg5MjkxOiAnU3Vic2VjVGltZU9yaWdpbmFsJywgLy8gRnJhY3Rpb25zIG9mIHNlY29uZHMgZm9yIERhdGVUaW1lT3JpZ2luYWxcbiAgMHg5MjkyOiAnU3Vic2VjVGltZURpZ2l0aXplZCcsIC8vIEZyYWN0aW9ucyBvZiBzZWNvbmRzIGZvciBEYXRlVGltZURpZ2l0aXplZFxuXG4gIC8vIHBpY3R1cmUtdGFraW5nIGNvbmRpdGlvbnNcbiAgMHg4MjlBOiAnRXhwb3N1cmVUaW1lJywgLy8gRXhwb3N1cmUgdGltZSAoaW4gc2Vjb25kcylcbiAgMHg4MjlEOiAnRk51bWJlcicsIC8vIEYgbnVtYmVyXG4gIDB4ODgyMjogJ0V4cG9zdXJlUHJvZ3JhbScsIC8vIEV4cG9zdXJlIHByb2dyYW1cbiAgMHg4ODI0OiAnU3BlY3RyYWxTZW5zaXRpdml0eScsIC8vIFNwZWN0cmFsIHNlbnNpdGl2aXR5XG4gIDB4ODgyNzogJ0lTT1NwZWVkUmF0aW5ncycsIC8vIElTTyBzcGVlZCByYXRpbmdcbiAgMHg4ODI4OiAnT0VDRicsIC8vIE9wdG9lbGVjdHJpYyBjb252ZXJzaW9uIGZhY3RvclxuICAweDkyMDE6ICdTaHV0dGVyU3BlZWRWYWx1ZScsIC8vIFNodXR0ZXIgc3BlZWRcbiAgMHg5MjAyOiAnQXBlcnR1cmVWYWx1ZScsIC8vIExlbnMgYXBlcnR1cmVcbiAgMHg5MjAzOiAnQnJpZ2h0bmVzc1ZhbHVlJywgLy8gVmFsdWUgb2YgYnJpZ2h0bmVzc1xuICAweDkyMDQ6ICdFeHBvc3VyZUJpYXMnLCAvLyBFeHBvc3VyZSBiaWFzXG4gIDB4OTIwNTogJ01heEFwZXJ0dXJlVmFsdWUnLCAvLyBTbWFsbGVzdCBGIG51bWJlciBvZiBsZW5zXG4gIDB4OTIwNjogJ1N1YmplY3REaXN0YW5jZScsIC8vIERpc3RhbmNlIHRvIHN1YmplY3QgaW4gbWV0ZXJzXG4gIDB4OTIwNzogJ01ldGVyaW5nTW9kZScsIC8vIE1ldGVyaW5nIG1vZGVcbiAgMHg5MjA4OiAnTGlnaHRTb3VyY2UnLCAvLyBLaW5kIG9mIGxpZ2h0IHNvdXJjZVxuICAweDkyMDk6ICdGbGFzaCcsIC8vIEZsYXNoIHN0YXR1c1xuICAweDkyMTQ6ICdTdWJqZWN0QXJlYScsIC8vIExvY2F0aW9uIGFuZCBhcmVhIG9mIG1haW4gc3ViamVjdFxuICAweDkyMEE6ICdGb2NhbExlbmd0aCcsIC8vIEZvY2FsIGxlbmd0aCBvZiB0aGUgbGVucyBpbiBtbVxuICAweEEyMEI6ICdGbGFzaEVuZXJneScsIC8vIFN0cm9iZSBlbmVyZ3kgaW4gQkNQU1xuICAweEEyMEM6ICdTcGF0aWFsRnJlcXVlbmN5UmVzcG9uc2UnLCAvL1xuICAweEEyMEU6ICdGb2NhbFBsYW5lWFJlc29sdXRpb24nLCAvLyBOdW1iZXIgb2YgcGl4ZWxzIGluIHdpZHRoIGRpcmVjdGlvbiBwZXIgRm9jYWxQbGFuZVJlc29sdXRpb25Vbml0XG4gIDB4QTIwRjogJ0ZvY2FsUGxhbmVZUmVzb2x1dGlvbicsIC8vIE51bWJlciBvZiBwaXhlbHMgaW4gaGVpZ2h0IGRpcmVjdGlvbiBwZXIgRm9jYWxQbGFuZVJlc29sdXRpb25Vbml0XG4gIDB4QTIxMDogJ0ZvY2FsUGxhbmVSZXNvbHV0aW9uVW5pdCcsIC8vIFVuaXQgZm9yIG1lYXN1cmluZyBGb2NhbFBsYW5lWFJlc29sdXRpb24gYW5kIEZvY2FsUGxhbmVZUmVzb2x1dGlvblxuICAweEEyMTQ6ICdTdWJqZWN0TG9jYXRpb24nLCAvLyBMb2NhdGlvbiBvZiBzdWJqZWN0IGluIGltYWdlXG4gIDB4QTIxNTogJ0V4cG9zdXJlSW5kZXgnLCAvLyBFeHBvc3VyZSBpbmRleCBzZWxlY3RlZCBvbiBjYW1lcmFcbiAgMHhBMjE3OiAnU2Vuc2luZ01ldGhvZCcsIC8vIEltYWdlIHNlbnNvciB0eXBlXG4gIDB4QTMwMDogJ0ZpbGVTb3VyY2UnLCAvLyBJbWFnZSBzb3VyY2UgKDMgPT09IERTQylcbiAgMHhBMzAxOiAnU2NlbmVUeXBlJywgLy8gU2NlbmUgdHlwZSAoMSA9PT0gZGlyZWN0bHkgcGhvdG9ncmFwaGVkKVxuICAweEEzMDI6ICdDRkFQYXR0ZXJuJywgLy8gQ29sb3IgZmlsdGVyIGFycmF5IGdlb21ldHJpYyBwYXR0ZXJuXG4gIDB4QTQwMTogJ0N1c3RvbVJlbmRlcmVkJywgLy8gU3BlY2lhbCBwcm9jZXNzaW5nXG4gIDB4QTQwMjogJ0V4cG9zdXJlTW9kZScsIC8vIEV4cG9zdXJlIG1vZGVcbiAgMHhBNDAzOiAnV2hpdGVCYWxhbmNlJywgLy8gMSA9IGF1dG8gd2hpdGUgYmFsYW5jZSwgMiA9IG1hbnVhbFxuICAweEE0MDQ6ICdEaWdpdGFsWm9vbVJhdGlvbicsIC8vIERpZ2l0YWwgem9vbSByYXRpb1xuICAweEE0MDU6ICdGb2NhbExlbmd0aEluMzVtbUZpbG0nLCAvLyBFcXVpdmFsZW50IGZvYWNsIGxlbmd0aCBhc3N1bWluZyAzNW1tIGZpbG0gY2FtZXJhIChpbiBtbSlcbiAgMHhBNDA2OiAnU2NlbmVDYXB0dXJlVHlwZScsIC8vIFR5cGUgb2Ygc2NlbmVcbiAgMHhBNDA3OiAnR2FpbkNvbnRyb2wnLCAvLyBEZWdyZWUgb2Ygb3ZlcmFsbCBpbWFnZSBnYWluIGFkanVzdG1lbnRcbiAgMHhBNDA4OiAnQ29udHJhc3QnLCAvLyBEaXJlY3Rpb24gb2YgY29udHJhc3QgcHJvY2Vzc2luZyBhcHBsaWVkIGJ5IGNhbWVyYVxuICAweEE0MDk6ICdTYXR1cmF0aW9uJywgLy8gRGlyZWN0aW9uIG9mIHNhdHVyYXRpb24gcHJvY2Vzc2luZyBhcHBsaWVkIGJ5IGNhbWVyYVxuICAweEE0MEE6ICdTaGFycG5lc3MnLCAvLyBEaXJlY3Rpb24gb2Ygc2hhcnBuZXNzIHByb2Nlc3NpbmcgYXBwbGllZCBieSBjYW1lcmFcbiAgMHhBNDBCOiAnRGV2aWNlU2V0dGluZ0Rlc2NyaXB0aW9uJywgLy9cbiAgMHhBNDBDOiAnU3ViamVjdERpc3RhbmNlUmFuZ2UnLCAvLyBEaXN0YW5jZSB0byBzdWJqZWN0XG5cbiAgLy8gb3RoZXIgdGFnc1xuICAweEEwMDU6ICdJbnRlcm9wZXJhYmlsaXR5SUZEUG9pbnRlcicsXG4gIDB4QTQyMDogJ0ltYWdlVW5pcXVlSUQnIC8vIElkZW50aWZpZXIgYXNzaWduZWQgdW5pcXVlbHkgdG8gZWFjaCBpbWFnZVxufVxuXG5jb25zdCBUaWZmVGFncyA9IHtcbiAgMHgwMTAwOiAnSW1hZ2VXaWR0aCcsXG4gIDB4MDEwMTogJ0ltYWdlSGVpZ2h0JyxcbiAgMHg4NzY5OiAnRXhpZklGRFBvaW50ZXInLFxuICAweDg4MjU6ICdHUFNJbmZvSUZEUG9pbnRlcicsXG4gIDB4QTAwNTogJ0ludGVyb3BlcmFiaWxpdHlJRkRQb2ludGVyJyxcbiAgMHgwMTAyOiAnQml0c1BlclNhbXBsZScsXG4gIDB4MDEwMzogJ0NvbXByZXNzaW9uJyxcbiAgMHgwMTA2OiAnUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbicsXG4gIDB4MDExMjogJ09yaWVudGF0aW9uJyxcbiAgMHgwMTE1OiAnU2FtcGxlc1BlclBpeGVsJyxcbiAgMHgwMTFDOiAnUGxhbmFyQ29uZmlndXJhdGlvbicsXG4gIDB4MDIxMjogJ1lDYkNyU3ViU2FtcGxpbmcnLFxuICAweDAyMTM6ICdZQ2JDclBvc2l0aW9uaW5nJyxcbiAgMHgwMTFBOiAnWFJlc29sdXRpb24nLFxuICAweDAxMUI6ICdZUmVzb2x1dGlvbicsXG4gIDB4MDEyODogJ1Jlc29sdXRpb25Vbml0JyxcbiAgMHgwMTExOiAnU3RyaXBPZmZzZXRzJyxcbiAgMHgwMTE2OiAnUm93c1BlclN0cmlwJyxcbiAgMHgwMTE3OiAnU3RyaXBCeXRlQ291bnRzJyxcbiAgMHgwMjAxOiAnSlBFR0ludGVyY2hhbmdlRm9ybWF0JyxcbiAgMHgwMjAyOiAnSlBFR0ludGVyY2hhbmdlRm9ybWF0TGVuZ3RoJyxcbiAgMHgwMTJEOiAnVHJhbnNmZXJGdW5jdGlvbicsXG4gIDB4MDEzRTogJ1doaXRlUG9pbnQnLFxuICAweDAxM0Y6ICdQcmltYXJ5Q2hyb21hdGljaXRpZXMnLFxuICAweDAyMTE6ICdZQ2JDckNvZWZmaWNpZW50cycsXG4gIDB4MDIxNDogJ1JlZmVyZW5jZUJsYWNrV2hpdGUnLFxuICAweDAxMzI6ICdEYXRlVGltZScsXG4gIDB4MDEwRTogJ0ltYWdlRGVzY3JpcHRpb24nLFxuICAweDAxMEY6ICdNYWtlJyxcbiAgMHgwMTEwOiAnTW9kZWwnLFxuICAweDAxMzE6ICdTb2Z0d2FyZScsXG4gIDB4MDEzQjogJ0FydGlzdCcsXG4gIDB4ODI5ODogJ0NvcHlyaWdodCdcbn1cblxuY29uc3QgR1BTVGFncyA9IHtcbiAgMHgwMDAwOiAnR1BTVmVyc2lvbklEJyxcbiAgMHgwMDAxOiAnR1BTTGF0aXR1ZGVSZWYnLFxuICAweDAwMDI6ICdHUFNMYXRpdHVkZScsXG4gIDB4MDAwMzogJ0dQU0xvbmdpdHVkZVJlZicsXG4gIDB4MDAwNDogJ0dQU0xvbmdpdHVkZScsXG4gIDB4MDAwNTogJ0dQU0FsdGl0dWRlUmVmJyxcbiAgMHgwMDA2OiAnR1BTQWx0aXR1ZGUnLFxuICAweDAwMDc6ICdHUFNUaW1lU3RhbXAnLFxuICAweDAwMDg6ICdHUFNTYXRlbGxpdGVzJyxcbiAgMHgwMDA5OiAnR1BTU3RhdHVzJyxcbiAgMHgwMDBBOiAnR1BTTWVhc3VyZU1vZGUnLFxuICAweDAwMEI6ICdHUFNET1AnLFxuICAweDAwMEM6ICdHUFNTcGVlZFJlZicsXG4gIDB4MDAwRDogJ0dQU1NwZWVkJyxcbiAgMHgwMDBFOiAnR1BTVHJhY2tSZWYnLFxuICAweDAwMEY6ICdHUFNUcmFjaycsXG4gIDB4MDAxMDogJ0dQU0ltZ0RpcmVjdGlvblJlZicsXG4gIDB4MDAxMTogJ0dQU0ltZ0RpcmVjdGlvbicsXG4gIDB4MDAxMjogJ0dQU01hcERhdHVtJyxcbiAgMHgwMDEzOiAnR1BTRGVzdExhdGl0dWRlUmVmJyxcbiAgMHgwMDE0OiAnR1BTRGVzdExhdGl0dWRlJyxcbiAgMHgwMDE1OiAnR1BTRGVzdExvbmdpdHVkZVJlZicsXG4gIDB4MDAxNjogJ0dQU0Rlc3RMb25naXR1ZGUnLFxuICAweDAwMTc6ICdHUFNEZXN0QmVhcmluZ1JlZicsXG4gIDB4MDAxODogJ0dQU0Rlc3RCZWFyaW5nJyxcbiAgMHgwMDE5OiAnR1BTRGVzdERpc3RhbmNlUmVmJyxcbiAgMHgwMDFBOiAnR1BTRGVzdERpc3RhbmNlJyxcbiAgMHgwMDFCOiAnR1BTUHJvY2Vzc2luZ01ldGhvZCcsXG4gIDB4MDAxQzogJ0dQU0FyZWFJbmZvcm1hdGlvbicsXG4gIDB4MDAxRDogJ0dQU0RhdGVTdGFtcCcsXG4gIDB4MDAxRTogJ0dQU0RpZmZlcmVudGlhbCdcbn1cblxuY29uc3QgU3RyaW5nVmFsdWVzID0ge1xuICBFeHBvc3VyZVByb2dyYW06IHtcbiAgICAwOiAnTm90IGRlZmluZWQnLFxuICAgIDE6ICdNYW51YWwnLFxuICAgIDI6ICdOb3JtYWwgcHJvZ3JhbScsXG4gICAgMzogJ0FwZXJ0dXJlIHByaW9yaXR5JyxcbiAgICA0OiAnU2h1dHRlciBwcmlvcml0eScsXG4gICAgNTogJ0NyZWF0aXZlIHByb2dyYW0nLFxuICAgIDY6ICdBY3Rpb24gcHJvZ3JhbScsXG4gICAgNzogJ1BvcnRyYWl0IG1vZGUnLFxuICAgIDg6ICdMYW5kc2NhcGUgbW9kZSdcbiAgfSxcbiAgTWV0ZXJpbmdNb2RlOiB7XG4gICAgMDogJ1Vua25vd24nLFxuICAgIDE6ICdBdmVyYWdlJyxcbiAgICAyOiAnQ2VudGVyV2VpZ2h0ZWRBdmVyYWdlJyxcbiAgICAzOiAnU3BvdCcsXG4gICAgNDogJ011bHRpU3BvdCcsXG4gICAgNTogJ1BhdHRlcm4nLFxuICAgIDY6ICdQYXJ0aWFsJyxcbiAgICAyNTU6ICdPdGhlcidcbiAgfSxcbiAgTGlnaHRTb3VyY2U6IHtcbiAgICAwOiAnVW5rbm93bicsXG4gICAgMTogJ0RheWxpZ2h0JyxcbiAgICAyOiAnRmx1b3Jlc2NlbnQnLFxuICAgIDM6ICdUdW5nc3RlbiAoaW5jYW5kZXNjZW50IGxpZ2h0KScsXG4gICAgNDogJ0ZsYXNoJyxcbiAgICA5OiAnRmluZSB3ZWF0aGVyJyxcbiAgICAxMDogJ0Nsb3VkeSB3ZWF0aGVyJyxcbiAgICAxMTogJ1NoYWRlJyxcbiAgICAxMjogJ0RheWxpZ2h0IGZsdW9yZXNjZW50IChEIDU3MDAgLSA3MTAwSyknLFxuICAgIDEzOiAnRGF5IHdoaXRlIGZsdW9yZXNjZW50IChOIDQ2MDAgLSA1NDAwSyknLFxuICAgIDE0OiAnQ29vbCB3aGl0ZSBmbHVvcmVzY2VudCAoVyAzOTAwIC0gNDUwMEspJyxcbiAgICAxNTogJ1doaXRlIGZsdW9yZXNjZW50IChXVyAzMjAwIC0gMzcwMEspJyxcbiAgICAxNzogJ1N0YW5kYXJkIGxpZ2h0IEEnLFxuICAgIDE4OiAnU3RhbmRhcmQgbGlnaHQgQicsXG4gICAgMTk6ICdTdGFuZGFyZCBsaWdodCBDJyxcbiAgICAyMDogJ0Q1NScsXG4gICAgMjE6ICdENjUnLFxuICAgIDIyOiAnRDc1JyxcbiAgICAyMzogJ0Q1MCcsXG4gICAgMjQ6ICdJU08gc3R1ZGlvIHR1bmdzdGVuJyxcbiAgICAyNTU6ICdPdGhlcidcbiAgfSxcbiAgRmxhc2g6IHtcbiAgICAweDAwMDA6ICdGbGFzaCBkaWQgbm90IGZpcmUnLFxuICAgIDB4MDAwMTogJ0ZsYXNoIGZpcmVkJyxcbiAgICAweDAwMDU6ICdTdHJvYmUgcmV0dXJuIGxpZ2h0IG5vdCBkZXRlY3RlZCcsXG4gICAgMHgwMDA3OiAnU3Ryb2JlIHJldHVybiBsaWdodCBkZXRlY3RlZCcsXG4gICAgMHgwMDA5OiAnRmxhc2ggZmlyZWQsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZScsXG4gICAgMHgwMDBEOiAnRmxhc2ggZmlyZWQsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZSwgcmV0dXJuIGxpZ2h0IG5vdCBkZXRlY3RlZCcsXG4gICAgMHgwMDBGOiAnRmxhc2ggZmlyZWQsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZSwgcmV0dXJuIGxpZ2h0IGRldGVjdGVkJyxcbiAgICAweDAwMTA6ICdGbGFzaCBkaWQgbm90IGZpcmUsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZScsXG4gICAgMHgwMDE4OiAnRmxhc2ggZGlkIG5vdCBmaXJlLCBhdXRvIG1vZGUnLFxuICAgIDB4MDAxOTogJ0ZsYXNoIGZpcmVkLCBhdXRvIG1vZGUnLFxuICAgIDB4MDAxRDogJ0ZsYXNoIGZpcmVkLCBhdXRvIG1vZGUsIHJldHVybiBsaWdodCBub3QgZGV0ZWN0ZWQnLFxuICAgIDB4MDAxRjogJ0ZsYXNoIGZpcmVkLCBhdXRvIG1vZGUsIHJldHVybiBsaWdodCBkZXRlY3RlZCcsXG4gICAgMHgwMDIwOiAnTm8gZmxhc2ggZnVuY3Rpb24nLFxuICAgIDB4MDA0MTogJ0ZsYXNoIGZpcmVkLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlJyxcbiAgICAweDAwNDU6ICdGbGFzaCBmaXJlZCwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZSwgcmV0dXJuIGxpZ2h0IG5vdCBkZXRlY3RlZCcsXG4gICAgMHgwMDQ3OiAnRmxhc2ggZmlyZWQsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUsIHJldHVybiBsaWdodCBkZXRlY3RlZCcsXG4gICAgMHgwMDQ5OiAnRmxhc2ggZmlyZWQsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZSwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZScsXG4gICAgMHgwMDREOiAnRmxhc2ggZmlyZWQsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZSwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZSwgcmV0dXJuIGxpZ2h0IG5vdCBkZXRlY3RlZCcsXG4gICAgMHgwMDRGOiAnRmxhc2ggZmlyZWQsIGNvbXB1bHNvcnkgZmxhc2ggbW9kZSwgcmVkLWV5ZSByZWR1Y3Rpb24gbW9kZSwgcmV0dXJuIGxpZ2h0IGRldGVjdGVkJyxcbiAgICAweDAwNTk6ICdGbGFzaCBmaXJlZCwgYXV0byBtb2RlLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlJyxcbiAgICAweDAwNUQ6ICdGbGFzaCBmaXJlZCwgYXV0byBtb2RlLCByZXR1cm4gbGlnaHQgbm90IGRldGVjdGVkLCByZWQtZXllIHJlZHVjdGlvbiBtb2RlJyxcbiAgICAweDAwNUY6ICdGbGFzaCBmaXJlZCwgYXV0byBtb2RlLCByZXR1cm4gbGlnaHQgZGV0ZWN0ZWQsIHJlZC1leWUgcmVkdWN0aW9uIG1vZGUnXG4gIH0sXG4gIFNlbnNpbmdNZXRob2Q6IHtcbiAgICAxOiAnTm90IGRlZmluZWQnLFxuICAgIDI6ICdPbmUtY2hpcCBjb2xvciBhcmVhIHNlbnNvcicsXG4gICAgMzogJ1R3by1jaGlwIGNvbG9yIGFyZWEgc2Vuc29yJyxcbiAgICA0OiAnVGhyZWUtY2hpcCBjb2xvciBhcmVhIHNlbnNvcicsXG4gICAgNTogJ0NvbG9yIHNlcXVlbnRpYWwgYXJlYSBzZW5zb3InLFxuICAgIDc6ICdUcmlsaW5lYXIgc2Vuc29yJyxcbiAgICA4OiAnQ29sb3Igc2VxdWVudGlhbCBsaW5lYXIgc2Vuc29yJ1xuICB9LFxuICBTY2VuZUNhcHR1cmVUeXBlOiB7XG4gICAgMDogJ1N0YW5kYXJkJyxcbiAgICAxOiAnTGFuZHNjYXBlJyxcbiAgICAyOiAnUG9ydHJhaXQnLFxuICAgIDM6ICdOaWdodCBzY2VuZSdcbiAgfSxcbiAgU2NlbmVUeXBlOiB7XG4gICAgMTogJ0RpcmVjdGx5IHBob3RvZ3JhcGhlZCdcbiAgfSxcbiAgQ3VzdG9tUmVuZGVyZWQ6IHtcbiAgICAwOiAnTm9ybWFsIHByb2Nlc3MnLFxuICAgIDE6ICdDdXN0b20gcHJvY2VzcydcbiAgfSxcbiAgV2hpdGVCYWxhbmNlOiB7XG4gICAgMDogJ0F1dG8gd2hpdGUgYmFsYW5jZScsXG4gICAgMTogJ01hbnVhbCB3aGl0ZSBiYWxhbmNlJ1xuICB9LFxuICBHYWluQ29udHJvbDoge1xuICAgIDA6ICdOb25lJyxcbiAgICAxOiAnTG93IGdhaW4gdXAnLFxuICAgIDI6ICdIaWdoIGdhaW4gdXAnLFxuICAgIDM6ICdMb3cgZ2FpbiBkb3duJyxcbiAgICA0OiAnSGlnaCBnYWluIGRvd24nXG4gIH0sXG4gIENvbnRyYXN0OiB7XG4gICAgMDogJ05vcm1hbCcsXG4gICAgMTogJ1NvZnQnLFxuICAgIDI6ICdIYXJkJ1xuICB9LFxuICBTYXR1cmF0aW9uOiB7XG4gICAgMDogJ05vcm1hbCcsXG4gICAgMTogJ0xvdyBzYXR1cmF0aW9uJyxcbiAgICAyOiAnSGlnaCBzYXR1cmF0aW9uJ1xuICB9LFxuICBTaGFycG5lc3M6IHtcbiAgICAwOiAnTm9ybWFsJyxcbiAgICAxOiAnU29mdCcsXG4gICAgMjogJ0hhcmQnXG4gIH0sXG4gIFN1YmplY3REaXN0YW5jZVJhbmdlOiB7XG4gICAgMDogJ1Vua25vd24nLFxuICAgIDE6ICdNYWNybycsXG4gICAgMjogJ0Nsb3NlIHZpZXcnLFxuICAgIDM6ICdEaXN0YW50IHZpZXcnXG4gIH0sXG4gIEZpbGVTb3VyY2U6IHtcbiAgICAzOiAnRFNDJ1xuICB9LFxuXG4gIENvbXBvbmVudHM6IHtcbiAgICAwOiAnJyxcbiAgICAxOiAnWScsXG4gICAgMjogJ0NiJyxcbiAgICAzOiAnQ3InLFxuICAgIDQ6ICdSJyxcbiAgICA1OiAnRycsXG4gICAgNjogJ0InXG4gIH1cbn1cblxuZnVuY3Rpb24gaW1hZ2VIYXNEYXRhIChpbWcpIHtcbiAgcmV0dXJuICEhKGltZy5leGlmZGF0YSlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9BcnJheUJ1ZmZlciAoYmFzZTY0LCBjb250ZW50VHlwZSkge1xuICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlIHx8IGJhc2U2NC5tYXRjaCgvXmRhdGE6KFteO10rKTtiYXNlNjQsL21pKVsxXSB8fCAnJyAvLyBlLmcuICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC4uLicgPT4gJ2ltYWdlL2pwZWcnXG4gIGJhc2U2NCA9IGJhc2U2NC5yZXBsYWNlKC9eZGF0YTooW147XSspO2Jhc2U2NCwvZ21pLCAnJylcbiAgdmFyIGJpbmFyeSA9IGF0b2IoYmFzZTY0KVxuICB2YXIgbGVuID0gYmluYXJ5Lmxlbmd0aFxuICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGxlbilcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2aWV3W2ldID0gYmluYXJ5LmNoYXJDb2RlQXQoaSlcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFVSTFRvQmxvYiAodXJsLCBjYWxsYmFjaykge1xuICB2YXIgaHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gIGh0dHAub3BlbignR0VUJywgdXJsLCB0cnVlKVxuICBodHRwLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICBodHRwLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDAgfHwgdGhpcy5zdGF0dXMgPT09IDApIHtcbiAgICAgIGNhbGxiYWNrKHRoaXMucmVzcG9uc2UpXG4gICAgfVxuICB9XG4gIGh0dHAuc2VuZCgpXG59XG5cbmZ1bmN0aW9uIGdldEltYWdlRGF0YSAoaW1nLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBoYW5kbGVCaW5hcnlGaWxlIChiaW5GaWxlKSB7XG4gICAgdmFyIGRhdGEgPSBmaW5kRVhJRmluSlBFRyhiaW5GaWxlKVxuICAgIGltZy5leGlmZGF0YSA9IGRhdGEgfHwge31cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoaW1nKVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbWcuc3JjKSB7XG4gICAgaWYgKC9eZGF0YTovaS50ZXN0KGltZy5zcmMpKSB7IC8vIERhdGEgVVJJXG4gICAgICB2YXIgYXJyYXlCdWZmZXIgPSBiYXNlNjRUb0FycmF5QnVmZmVyKGltZy5zcmMpXG4gICAgICBoYW5kbGVCaW5hcnlGaWxlKGFycmF5QnVmZmVyKVxuICAgIH0gZWxzZSBpZiAoL15ibG9iOi9pLnRlc3QoaW1nLnNyYykpIHsgLy8gT2JqZWN0IFVSTFxuICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaGFuZGxlQmluYXJ5RmlsZShlLnRhcmdldC5yZXN1bHQpXG4gICAgICB9XG4gICAgICBvYmplY3RVUkxUb0Jsb2IoaW1nLnNyYywgZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICAgICAgaHR0cC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwIHx8IHRoaXMuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgaGFuZGxlQmluYXJ5RmlsZShodHRwLnJlc3BvbnNlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGxvYWQgaW1hZ2UnKVxuICAgICAgICB9XG4gICAgICAgIGh0dHAgPSBudWxsXG4gICAgICB9XG4gICAgICBodHRwLm9wZW4oJ0dFVCcsIGltZy5zcmMsIHRydWUpXG4gICAgICBodHRwLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgICAgIGh0dHAuc2VuZChudWxsKVxuICAgIH1cbiAgfSBlbHNlIGlmIChzZWxmLkZpbGVSZWFkZXIgJiYgKGltZyBpbnN0YW5jZW9mIHNlbGYuQmxvYiB8fCBpbWcgaW5zdGFuY2VvZiBzZWxmLkZpbGUpKSB7XG4gICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBoYW5kbGVCaW5hcnlGaWxlKGUudGFyZ2V0LnJlc3VsdClcbiAgICB9XG5cbiAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGltZylcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kRVhJRmluSlBFRyAoZmlsZSkge1xuICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoZmlsZSlcblxuICBpZiAoKGRhdGFWaWV3LmdldFVpbnQ4KDApICE9PSAweEZGKSB8fCAoZGF0YVZpZXcuZ2V0VWludDgoMSkgIT09IDB4RDgpKSB7XG4gICAgcmV0dXJuIGZhbHNlIC8vIG5vdCBhIHZhbGlkIGpwZWdcbiAgfVxuXG4gIHZhciBvZmZzZXQgPSAyXG4gIHZhciBsZW5ndGggPSBmaWxlLmJ5dGVMZW5ndGhcbiAgdmFyIG1hcmtlclxuXG4gIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KSAhPT0gMHhGRikge1xuICAgICAgcmV0dXJuIGZhbHNlIC8vIG5vdCBhIHZhbGlkIG1hcmtlciwgc29tZXRoaW5nIGlzIHdyb25nXG4gICAgfVxuXG4gICAgbWFya2VyID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgMSlcblxuICAgIC8vIHdlIGNvdWxkIGltcGxlbWVudCBoYW5kbGluZyBmb3Igb3RoZXIgbWFya2VycyBoZXJlLFxuICAgIC8vIGJ1dCB3ZSdyZSBvbmx5IGxvb2tpbmcgZm9yIDB4RkZFMSBmb3IgRVhJRiBkYXRhXG5cbiAgICBpZiAobWFya2VyID09PSAyMjUpIHtcbiAgICAgIHJldHVybiByZWFkRVhJRkRhdGEoZGF0YVZpZXcsIG9mZnNldCArIDQsIGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyAyKSAtIDIpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCArPSAyICsgZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCArIDIpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdzIChmaWxlLCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBzdHJpbmdzLCBiaWdFbmQpIHtcbiAgdmFyIGVudHJpZXMgPSBmaWxlLmdldFVpbnQxNihkaXJTdGFydCwgIWJpZ0VuZClcbiAgdmFyIHRhZ3MgPSB7fVxuICB2YXIgZW50cnlPZmZzZXQ7IHZhciB0YWdcbiAgdmFyIGlcblxuICBmb3IgKGkgPSAwOyBpIDwgZW50cmllczsgaSsrKSB7XG4gICAgZW50cnlPZmZzZXQgPSBkaXJTdGFydCArIGkgKiAxMiArIDJcbiAgICB0YWcgPSBzdHJpbmdzW2ZpbGUuZ2V0VWludDE2KGVudHJ5T2Zmc2V0LCAhYmlnRW5kKV1cbiAgICB0YWdzW3RhZ10gPSByZWFkVGFnVmFsdWUoZmlsZSwgZW50cnlPZmZzZXQsIHRpZmZTdGFydCwgZGlyU3RhcnQsIGJpZ0VuZClcbiAgfVxuICByZXR1cm4gdGFnc1xufVxuXG5mdW5jdGlvbiByZWFkVGFnVmFsdWUgKGZpbGUsIGVudHJ5T2Zmc2V0LCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBiaWdFbmQpIHtcbiAgdmFyIHR5cGUgPSBmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCArIDIsICFiaWdFbmQpXG4gIHZhciBudW1WYWx1ZXMgPSBmaWxlLmdldFVpbnQzMihlbnRyeU9mZnNldCArIDQsICFiaWdFbmQpXG4gIHZhciB2YWx1ZU9mZnNldCA9IGZpbGUuZ2V0VWludDMyKGVudHJ5T2Zmc2V0ICsgOCwgIWJpZ0VuZCkgKyB0aWZmU3RhcnRcbiAgdmFyIG9mZnNldFxuICB2YXIgdmFsczsgdmFyIHZhbDsgdmFyIG5cbiAgdmFyIG51bWVyYXRvcjsgdmFyIGRlbm9taW5hdG9yXG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAxOiAvLyBieXRlLCA4LWJpdCB1bnNpZ25lZCBpbnRcbiAgICBjYXNlIDc6IC8vIHVuZGVmaW5lZCwgOC1iaXQgYnl0ZSwgdmFsdWUgZGVwZW5kaW5nIG9uIGZpZWxkXG4gICAgICBpZiAobnVtVmFsdWVzID09PSAxKSB7XG4gICAgICAgIHJldHVybiBmaWxlLmdldFVpbnQ4KGVudHJ5T2Zmc2V0ICsgOCwgIWJpZ0VuZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9IG51bVZhbHVlcyA+IDQgPyB2YWx1ZU9mZnNldCA6IChlbnRyeU9mZnNldCArIDgpXG4gICAgICAgIHZhbHMgPSBbXVxuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbnVtVmFsdWVzOyBuKyspIHtcbiAgICAgICAgICB2YWxzW25dID0gZmlsZS5nZXRVaW50OChvZmZzZXQgKyBuKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxzXG4gICAgICB9XG5cbiAgICBjYXNlIDI6IC8vIGFzY2lpLCA4LWJpdCBieXRlXG4gICAgICBvZmZzZXQgPSBudW1WYWx1ZXMgPiA0ID8gdmFsdWVPZmZzZXQgOiAoZW50cnlPZmZzZXQgKyA4KVxuICAgICAgcmV0dXJuIGdldFN0cmluZ0Zyb21EQihmaWxlLCBvZmZzZXQsIG51bVZhbHVlcyAtIDEpXG5cbiAgICBjYXNlIDM6IC8vIHNob3J0LCAxNiBiaXQgaW50XG4gICAgICBpZiAobnVtVmFsdWVzID09PSAxKSB7XG4gICAgICAgIHJldHVybiBmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCArIDgsICFiaWdFbmQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSBudW1WYWx1ZXMgPiAyID8gdmFsdWVPZmZzZXQgOiAoZW50cnlPZmZzZXQgKyA4KVxuICAgICAgICB2YWxzID0gW11cbiAgICAgICAgZm9yIChuID0gMDsgbiA8IG51bVZhbHVlczsgbisrKSB7XG4gICAgICAgICAgdmFsc1tuXSA9IGZpbGUuZ2V0VWludDE2KG9mZnNldCArIDIgKiBuLCAhYmlnRW5kKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxzXG4gICAgICB9XG5cbiAgICBjYXNlIDQ6IC8vIGxvbmcsIDMyIGJpdCBpbnRcbiAgICAgIGlmIChudW1WYWx1ZXMgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZpbGUuZ2V0VWludDMyKGVudHJ5T2Zmc2V0ICsgOCwgIWJpZ0VuZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHMgPSBbXVxuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbnVtVmFsdWVzOyBuKyspIHtcbiAgICAgICAgICB2YWxzW25dID0gZmlsZS5nZXRVaW50MzIodmFsdWVPZmZzZXQgKyA0ICogbiwgIWJpZ0VuZClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsc1xuICAgICAgfVxuXG4gICAgY2FzZSA1OiAvLyByYXRpb25hbCA9IHR3byBsb25nIHZhbHVlcywgZmlyc3QgaXMgbnVtZXJhdG9yLCBzZWNvbmQgaXMgZGVub21pbmF0b3JcbiAgICAgIGlmIChudW1WYWx1ZXMgPT09IDEpIHtcbiAgICAgICAgbnVtZXJhdG9yID0gZmlsZS5nZXRVaW50MzIodmFsdWVPZmZzZXQsICFiaWdFbmQpXG4gICAgICAgIGRlbm9taW5hdG9yID0gZmlsZS5nZXRVaW50MzIodmFsdWVPZmZzZXQgKyA0LCAhYmlnRW5kKVxuICAgICAgICB2YWwgPSArKG51bWVyYXRvciAvIGRlbm9taW5hdG9yKVxuICAgICAgICByZXR1cm4gdmFsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxzID0gW11cbiAgICAgICAgZm9yIChuID0gMDsgbiA8IG51bVZhbHVlczsgbisrKSB7XG4gICAgICAgICAgbnVtZXJhdG9yID0gZmlsZS5nZXRVaW50MzIodmFsdWVPZmZzZXQgKyA4ICogbiwgIWJpZ0VuZClcbiAgICAgICAgICBkZW5vbWluYXRvciA9IGZpbGUuZ2V0VWludDMyKHZhbHVlT2Zmc2V0ICsgNCArIDggKiBuLCAhYmlnRW5kKVxuICAgICAgICAgIHZhbHNbbl0gPSArKG51bWVyYXRvciAvIGRlbm9taW5hdG9yKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxzXG4gICAgICB9XG5cbiAgICBjYXNlIDk6IC8vIHNsb25nLCAzMiBiaXQgc2lnbmVkIGludFxuICAgICAgaWYgKG51bVZhbHVlcyA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZmlsZS5nZXRJbnQzMihlbnRyeU9mZnNldCArIDgsICFiaWdFbmQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxzID0gW11cbiAgICAgICAgZm9yIChuID0gMDsgbiA8IG51bVZhbHVlczsgbisrKSB7XG4gICAgICAgICAgdmFsc1tuXSA9IGZpbGUuZ2V0SW50MzIodmFsdWVPZmZzZXQgKyA0ICogbiwgIWJpZ0VuZClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsc1xuICAgICAgfVxuXG4gICAgY2FzZSAxMDogLy8gc2lnbmVkIHJhdGlvbmFsLCB0d28gc2xvbmdzLCBmaXJzdCBpcyBudW1lcmF0b3IsIHNlY29uZCBpcyBkZW5vbWluYXRvclxuICAgICAgaWYgKG51bVZhbHVlcyA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZmlsZS5nZXRJbnQzMih2YWx1ZU9mZnNldCwgIWJpZ0VuZCkgLyBmaWxlLmdldEludDMyKHZhbHVlT2Zmc2V0ICsgNCwgIWJpZ0VuZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHMgPSBbXVxuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbnVtVmFsdWVzOyBuKyspIHtcbiAgICAgICAgICB2YWxzW25dID0gZmlsZS5nZXRJbnQzMih2YWx1ZU9mZnNldCArIDggKiBuLCAhYmlnRW5kKSAvIGZpbGUuZ2V0SW50MzIodmFsdWVPZmZzZXQgKyA0ICsgOCAqIG4sICFiaWdFbmQpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHNcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdHJpbmdGcm9tREIgKGJ1ZmZlciwgc3RhcnQsIGxlbmd0aCkge1xuICB2YXIgb3V0c3RyID0gJydcbiAgZm9yIChsZXQgbiA9IHN0YXJ0OyBuIDwgc3RhcnQgKyBsZW5ndGg7IG4rKykge1xuICAgIG91dHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlci5nZXRVaW50OChuKSlcbiAgfVxuICByZXR1cm4gb3V0c3RyXG59XG5cbmZ1bmN0aW9uIHJlYWRFWElGRGF0YSAoZmlsZSwgc3RhcnQpIHtcbiAgaWYgKGdldFN0cmluZ0Zyb21EQihmaWxlLCBzdGFydCwgNCkgIT09ICdFeGlmJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdmFyIGJpZ0VuZFxuICB2YXIgdGFnczsgdmFyIHRhZ1xuICB2YXIgZXhpZkRhdGE7IHZhciBncHNEYXRhXG4gIHZhciB0aWZmT2Zmc2V0ID0gc3RhcnQgKyA2XG5cbiAgLy8gdGVzdCBmb3IgVElGRiB2YWxpZGl0eSBhbmQgZW5kaWFubmVzc1xuICBpZiAoZmlsZS5nZXRVaW50MTYodGlmZk9mZnNldCkgPT09IDB4NDk0OSkge1xuICAgIGJpZ0VuZCA9IGZhbHNlXG4gIH0gZWxzZSBpZiAoZmlsZS5nZXRVaW50MTYodGlmZk9mZnNldCkgPT09IDB4NEQ0RCkge1xuICAgIGJpZ0VuZCA9IHRydWVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0ICsgMiwgIWJpZ0VuZCkgIT09IDB4MDAyQSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdmFyIGZpcnN0SUZET2Zmc2V0ID0gZmlsZS5nZXRVaW50MzIodGlmZk9mZnNldCArIDQsICFiaWdFbmQpXG5cbiAgaWYgKGZpcnN0SUZET2Zmc2V0IDwgMHgwMDAwMDAwOCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdGFncyA9IHJlYWRUYWdzKGZpbGUsIHRpZmZPZmZzZXQsIHRpZmZPZmZzZXQgKyBmaXJzdElGRE9mZnNldCwgVGlmZlRhZ3MsIGJpZ0VuZClcblxuICBpZiAodGFncy5FeGlmSUZEUG9pbnRlcikge1xuICAgIGV4aWZEYXRhID0gcmVhZFRhZ3MoZmlsZSwgdGlmZk9mZnNldCwgdGlmZk9mZnNldCArIHRhZ3MuRXhpZklGRFBvaW50ZXIsIEV4aWZUYWdzLCBiaWdFbmQpXG4gICAgZm9yICh0YWcgaW4gZXhpZkRhdGEpIHtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgJ0xpZ2h0U291cmNlJyA6XG4gICAgICAgIGNhc2UgJ0ZsYXNoJyA6XG4gICAgICAgIGNhc2UgJ01ldGVyaW5nTW9kZScgOlxuICAgICAgICBjYXNlICdFeHBvc3VyZVByb2dyYW0nIDpcbiAgICAgICAgY2FzZSAnU2Vuc2luZ01ldGhvZCcgOlxuICAgICAgICBjYXNlICdTY2VuZUNhcHR1cmVUeXBlJyA6XG4gICAgICAgIGNhc2UgJ1NjZW5lVHlwZScgOlxuICAgICAgICBjYXNlICdDdXN0b21SZW5kZXJlZCcgOlxuICAgICAgICBjYXNlICdXaGl0ZUJhbGFuY2UnIDpcbiAgICAgICAgY2FzZSAnR2FpbkNvbnRyb2wnIDpcbiAgICAgICAgY2FzZSAnQ29udHJhc3QnIDpcbiAgICAgICAgY2FzZSAnU2F0dXJhdGlvbicgOlxuICAgICAgICBjYXNlICdTaGFycG5lc3MnIDpcbiAgICAgICAgY2FzZSAnU3ViamVjdERpc3RhbmNlUmFuZ2UnIDpcbiAgICAgICAgY2FzZSAnRmlsZVNvdXJjZScgOlxuICAgICAgICAgIGV4aWZEYXRhW3RhZ10gPSBTdHJpbmdWYWx1ZXNbdGFnXVtleGlmRGF0YVt0YWddXVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgY2FzZSAnRXhpZlZlcnNpb24nIDpcbiAgICAgICAgY2FzZSAnRmxhc2hwaXhWZXJzaW9uJyA6XG4gICAgICAgICAgZXhpZkRhdGFbdGFnXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXhpZkRhdGFbdGFnXVswXSwgZXhpZkRhdGFbdGFnXVsxXSwgZXhpZkRhdGFbdGFnXVsyXSwgZXhpZkRhdGFbdGFnXVszXSlcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ0NvbXBvbmVudHNDb25maWd1cmF0aW9uJyA6XG4gICAgICAgICAgZXhpZkRhdGFbdGFnXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmdWYWx1ZXMuQ29tcG9uZW50c1tleGlmRGF0YVt0YWddWzBdXSArXG4gICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmdWYWx1ZXMuQ29tcG9uZW50c1tleGlmRGF0YVt0YWddWzFdXSArXG4gICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmdWYWx1ZXMuQ29tcG9uZW50c1tleGlmRGF0YVt0YWddWzJdXSArXG4gICAgICAgICAgICAgICAgICAgICAgICBTdHJpbmdWYWx1ZXMuQ29tcG9uZW50c1tleGlmRGF0YVt0YWddWzNdXVxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICB0YWdzW3RhZ10gPSBleGlmRGF0YVt0YWddXG4gICAgfVxuICB9XG5cbiAgaWYgKHRhZ3MuR1BTSW5mb0lGRFBvaW50ZXIpIHtcbiAgICBncHNEYXRhID0gcmVhZFRhZ3MoZmlsZSwgdGlmZk9mZnNldCwgdGlmZk9mZnNldCArIHRhZ3MuR1BTSW5mb0lGRFBvaW50ZXIsIEdQU1RhZ3MsIGJpZ0VuZClcbiAgICBmb3IgKHRhZyBpbiBncHNEYXRhKSB7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlICdHUFNWZXJzaW9uSUQnIDpcbiAgICAgICAgICBncHNEYXRhW3RhZ10gPSBncHNEYXRhW3RhZ11bMF0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgJy4nICsgZ3BzRGF0YVt0YWddWzFdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcuJyArIGdwc0RhdGFbdGFnXVsyXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnLicgKyBncHNEYXRhW3RhZ11bM11cbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgdGFnc1t0YWddID0gZ3BzRGF0YVt0YWddXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhZ3Ncbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoaW1nLCBjYWxsYmFjaykge1xuICBpZiAoKChzZWxmLkltYWdlICYmIGltZyBpbnN0YW5jZW9mIHNlbGYuSW1hZ2UpIHx8XG4gICAgICAgIChzZWxmLkhUTUxJbWFnZUVsZW1lbnQgJiYgaW1nIGluc3RhbmNlb2Ygc2VsZi5IVE1MSW1hZ2VFbGVtZW50KSkgJiZcbiAgICAgICAgIWltZy5jb21wbGV0ZSkgeyByZXR1cm4gZmFsc2UgfVxuXG4gIGlmICghaW1hZ2VIYXNEYXRhKGltZykpIHtcbiAgICBnZXRJbWFnZURhdGEoaW1nLCBjYWxsYmFjaylcbiAgfSBlbHNlIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoaW1nKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZXRUYWcgKGltZywgdGFnKSB7XG4gIGlmICghaW1hZ2VIYXNEYXRhKGltZykpIHJldHVyblxuICByZXR1cm4gaW1nLmV4aWZkYXRhW3RhZ11cbn1cblxuZnVuY3Rpb24gZ2V0QWxsVGFncyAoaW1nKSB7XG4gIGlmICghaW1hZ2VIYXNEYXRhKGltZykpIHJldHVybiB7fVxuICByZXR1cm4gaW1nLmV4aWZkYXRhXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRBbGxUYWdzLFxuICBnZXREYXRhLFxuICBnZXRUYWdcbn1cbiIsImNvbnN0IE9SSUVOVEFUSU9OUyA9IHtcbiAgMToge1xuICAgIHJvdGF0aW9uOiAwLFxuICAgIHhTY2FsZTogMSxcbiAgICB5U2NhbGU6IDFcbiAgfSxcbiAgMjoge1xuICAgIHJvdGF0aW9uOiAwLFxuICAgIHhTY2FsZTogLTEsXG4gICAgeVNjYWxlOiAxXG4gIH0sXG4gIDM6IHtcbiAgICByb3RhdGlvbjogMTgwLFxuICAgIHhTY2FsZTogMSxcbiAgICB5U2NhbGU6IDFcbiAgfSxcbiAgNDoge1xuICAgIHJvdGF0aW9uOiAxODAsXG4gICAgeFNjYWxlOiAtMSxcbiAgICB5U2NhbGU6IDFcbiAgfSxcbiAgNToge1xuICAgIHJvdGF0aW9uOiA5MCxcbiAgICB4U2NhbGU6IDEsXG4gICAgeVNjYWxlOiAtMVxuICB9LFxuICA2OiB7XG4gICAgcm90YXRpb246IDkwLFxuICAgIHhTY2FsZTogMSxcbiAgICB5U2NhbGU6IDFcbiAgfSxcbiAgNzoge1xuICAgIHJvdGF0aW9uOiAyNzAsXG4gICAgeFNjYWxlOiAxLFxuICAgIHlTY2FsZTogLTFcbiAgfSxcbiAgODoge1xuICAgIHJvdGF0aW9uOiAyNzAsXG4gICAgeFNjYWxlOiAxLFxuICAgIHlTY2FsZTogMVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gT1JJRU5UQVRJT05TXG4iLCJjb25zdCB7IFBsdWdpbiB9ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCBUcmFuc2xhdG9yID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL1RyYW5zbGF0b3InKVxuY29uc3QgZGF0YVVSSXRvQmxvYiA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9kYXRhVVJJdG9CbG9iJylcbmNvbnN0IGlzT2JqZWN0VVJMID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL2lzT2JqZWN0VVJMJylcbmNvbnN0IGlzUHJldmlld1N1cHBvcnRlZCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9pc1ByZXZpZXdTdXBwb3J0ZWQnKVxuY29uc3QgT1JJRU5UQVRJT05TID0gcmVxdWlyZSgnLi9pbWFnZS1vcmllbnRhdGlvbnMnKVxuY29uc3QgRXhpZiA9IHJlcXVpcmUoJy4vZXhpZicpXG5cbi8qKlxuICogVGhlIFRodW1ibmFpbCBHZW5lcmF0b3IgcGx1Z2luXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBUaHVtYm5haWxHZW5lcmF0b3IgZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy50eXBlID0gJ21vZGlmaWVyJ1xuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ1RodW1ibmFpbEdlbmVyYXRvcidcbiAgICB0aGlzLnRpdGxlID0gJ1RodW1ibmFpbCBHZW5lcmF0b3InXG4gICAgdGhpcy5xdWV1ZSA9IFtdXG4gICAgdGhpcy5xdWV1ZVByb2Nlc3NpbmcgPSBmYWxzZVxuICAgIHRoaXMuZGVmYXVsdFRodW1ibmFpbERpbWVuc2lvbiA9IDIwMFxuXG4gICAgdGhpcy5kZWZhdWx0TG9jYWxlID0ge1xuICAgICAgc3RyaW5nczoge1xuICAgICAgICBnZW5lcmF0aW5nVGh1bWJuYWlsczogJ0dlbmVyYXRpbmcgdGh1bWJuYWlscy4uLidcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHRodW1ibmFpbFdpZHRoOiBudWxsLFxuICAgICAgdGh1bWJuYWlsSGVpZ2h0OiBudWxsLFxuICAgICAgd2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWQ6IGZhbHNlXG4gICAgfVxuXG4gICAgdGhpcy5vcHRzID0geyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0cyB9XG5cbiAgICB0aGlzLmkxOG5Jbml0KClcbiAgfVxuXG4gIHNldE9wdGlvbnMgKG5ld09wdHMpIHtcbiAgICBzdXBlci5zZXRPcHRpb25zKG5ld09wdHMpXG4gICAgdGhpcy5pMThuSW5pdCgpXG4gIH1cblxuICBpMThuSW5pdCAoKSB7XG4gICAgdGhpcy50cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IoW3RoaXMuZGVmYXVsdExvY2FsZSwgdGhpcy51cHB5LmxvY2FsZSwgdGhpcy5vcHRzLmxvY2FsZV0pXG4gICAgdGhpcy5pMThuID0gdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKCkgLy8gc28gdGhhdCBVSSByZS1yZW5kZXJzIGFuZCB3ZSBzZWUgdGhlIHVwZGF0ZWQgbG9jYWxlXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdGh1bWJuYWlsIGZvciB0aGUgZ2l2ZW4gVXBweSBmaWxlIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHt7ZGF0YTogQmxvYn19IGZpbGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRIZWlnaHRcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBjcmVhdGVUaHVtYm5haWwgKGZpbGUsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQpIHtcbiAgICBjb25zdCBvcmlnaW5hbFVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZS5kYXRhKVxuXG4gICAgY29uc3Qgb25sb2FkID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKVxuICAgICAgaW1hZ2Uuc3JjID0gb3JpZ2luYWxVcmxcbiAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwob3JpZ2luYWxVcmwpXG4gICAgICAgIHJlc29sdmUoaW1hZ2UpXG4gICAgICB9KVxuICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChvcmlnaW5hbFVybClcbiAgICAgICAgcmVqZWN0KGV2ZW50LmVycm9yIHx8IG5ldyBFcnJvcignQ291bGQgbm90IGNyZWF0ZSB0aHVtYm5haWwnKSlcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChbb25sb2FkLCB0aGlzLmdldE9yaWVudGF0aW9uKGZpbGUpXSlcbiAgICAgIC50aGVuKHZhbHVlcyA9PiB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gdmFsdWVzWzBdXG4gICAgICAgIGNvbnN0IG9yaWVudGF0aW9uID0gdmFsdWVzWzFdXG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB0aGlzLmdldFByb3BvcnRpb25hbERpbWVuc2lvbnMoaW1hZ2UsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIG9yaWVudGF0aW9uLnJvdGF0aW9uKVxuICAgICAgICBjb25zdCByb3RhdGVkSW1hZ2UgPSB0aGlzLnJvdGF0ZUltYWdlKGltYWdlLCBvcmllbnRhdGlvbilcbiAgICAgICAgY29uc3QgcmVzaXplZEltYWdlID0gdGhpcy5yZXNpemVJbWFnZShyb3RhdGVkSW1hZ2UsIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0KVxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXNUb0Jsb2IocmVzaXplZEltYWdlLCAnaW1hZ2UvcG5nJylcbiAgICAgIH0pXG4gICAgICAudGhlbihibG9iID0+IHtcbiAgICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYilcbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuZXcgY2FsY3VsYXRlZCBkaW1lbnNpb25zIGZvciB0aGUgZ2l2ZW4gaW1hZ2UgYW5kIGEgdGFyZ2V0IHdpZHRoXG4gICAqIG9yIGhlaWdodC4gSWYgYm90aCB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBnaXZlbiwgb25seSB3aWR0aCBpcyB0YWtlbiBpbnRvXG4gICAqIGFjY291bnQuIElmIG5laXRoZXIgd2lkdGggbm9yIGhlaWdodCBhcmUgZ2l2ZW4sIHRoZSBkZWZhdWx0IGRpbWVuc2lvblxuICAgKiBpcyB1c2VkLlxuICAgKi9cbiAgZ2V0UHJvcG9ydGlvbmFsRGltZW5zaW9ucyAoaW1nLCB3aWR0aCwgaGVpZ2h0LCByb3RhdGlvbikge1xuICAgIHZhciBhc3BlY3QgPSBpbWcud2lkdGggLyBpbWcuaGVpZ2h0XG4gICAgaWYgKHJvdGF0aW9uID09PSA5MCB8fCByb3RhdGlvbiA9PT0gMjcwKSB7XG4gICAgICBhc3BlY3QgPSBpbWcuaGVpZ2h0IC8gaW1nLndpZHRoXG4gICAgfVxuXG4gICAgaWYgKHdpZHRoICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKHdpZHRoIC8gYXNwZWN0KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IE1hdGgucm91bmQoaGVpZ2h0ICogYXNwZWN0KSxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHRoaXMuZGVmYXVsdFRodW1ibmFpbERpbWVuc2lvbixcbiAgICAgIGhlaWdodDogTWF0aC5yb3VuZCh0aGlzLmRlZmF1bHRUaHVtYm5haWxEaW1lbnNpb24gLyBhc3BlY3QpXG4gICAgfVxuICB9XG5cbiAgZ2V0T3JpZW50YXRpb24gKGZpbGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IHVwcHkgPSB0aGlzLnVwcHlcbiAgICAgIEV4aWYuZ2V0RGF0YShmaWxlLmRhdGEsIGZ1bmN0aW9uIGV4aWZHZXREYXRhQ2FsbGJhY2sgKCkge1xuICAgICAgICB1cHB5LnNldEZpbGVNZXRhKGZpbGUuaWQsIHsgZXhpZmRhdGE6IEV4aWYuZ2V0QWxsVGFncyh0aGlzKSB9KVxuICAgICAgICBjb25zdCBvcmllbnRhdGlvbiA9IEV4aWYuZ2V0VGFnKHRoaXMsICdPcmllbnRhdGlvbicpIHx8IDFcbiAgICAgICAgcmVzb2x2ZShPUklFTlRBVElPTlNbb3JpZW50YXRpb25dKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2Ugc3VyZSB0aGUgaW1hZ2UgZG9lc27igJl0IGV4Y2VlZCBicm93c2VyL2RldmljZSBjYW52YXMgbGltaXRzLlxuICAgKiBGb3IgaW9zIHdpdGggMjU2IFJBTSBhbmQgaWVcbiAgICovXG4gIHByb3RlY3QgKGltYWdlKSB7XG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjA4MTQ4My9tYXhpbXVtLXNpemUtb2YtYS1jYW52YXMtZWxlbWVudFxuXG4gICAgdmFyIHJhdGlvID0gaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHRcblxuICAgIHZhciBtYXhTcXVhcmUgPSA1MDAwMDAwIC8vIGlvcyBtYXggY2FudmFzIHNxdWFyZVxuICAgIHZhciBtYXhTaXplID0gNDA5NiAvLyBpZSBtYXggY2FudmFzIGRpbWVuc2lvbnNcblxuICAgIHZhciBtYXhXID0gTWF0aC5mbG9vcihNYXRoLnNxcnQobWF4U3F1YXJlICogcmF0aW8pKVxuICAgIHZhciBtYXhIID0gTWF0aC5mbG9vcihtYXhTcXVhcmUgLyBNYXRoLnNxcnQobWF4U3F1YXJlICogcmF0aW8pKVxuICAgIGlmIChtYXhXID4gbWF4U2l6ZSkge1xuICAgICAgbWF4VyA9IG1heFNpemVcbiAgICAgIG1heEggPSBNYXRoLnJvdW5kKG1heFcgLyByYXRpbylcbiAgICB9XG4gICAgaWYgKG1heEggPiBtYXhTaXplKSB7XG4gICAgICBtYXhIID0gbWF4U2l6ZVxuICAgICAgbWF4VyA9IE1hdGgucm91bmQocmF0aW8gKiBtYXhIKVxuICAgIH1cbiAgICBpZiAoaW1hZ2Uud2lkdGggPiBtYXhXKSB7XG4gICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgIGNhbnZhcy53aWR0aCA9IG1heFdcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBtYXhIXG4gICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIG1heFcsIG1heEgpXG4gICAgICBpbWFnZSA9IGNhbnZhc1xuICAgIH1cblxuICAgIHJldHVybiBpbWFnZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZSBhbiBpbWFnZSB0byB0aGUgdGFyZ2V0IGB3aWR0aGAgYW5kIGBoZWlnaHRgLlxuICAgKlxuICAgKiBSZXR1cm5zIGEgQ2FudmFzIHdpdGggdGhlIHJlc2l6ZWQgaW1hZ2Ugb24gaXQuXG4gICAqL1xuICByZXNpemVJbWFnZSAoaW1hZ2UsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQpIHtcbiAgICAvLyBSZXNpemluZyBpbiBzdGVwcyByZWZhY3RvcmVkIHRvIHVzZSBhIHNvbHV0aW9uIGZyb21cbiAgICAvLyBodHRwczovL2Jsb2cudXBsb2FkY2FyZS5jb20vaW1hZ2UtcmVzaXplLWluLWJyb3dzZXJzLWlzLWJyb2tlbi1lMzhlZWQwOGRmMDFcblxuICAgIGltYWdlID0gdGhpcy5wcm90ZWN0KGltYWdlKVxuXG4gICAgLy8gVXNlIHRoZSBQb2x5ZmlsbCBmb3IgTWF0aC5sb2cyKCkgc2luY2UgSUUgZG9lc24ndCBzdXBwb3J0IGxvZzJcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2xvZzIjUG9seWZpbGxcbiAgICB2YXIgc3RlcHMgPSBNYXRoLmNlaWwoTWF0aC5sb2coaW1hZ2Uud2lkdGggLyB0YXJnZXRXaWR0aCkgKiBNYXRoLkxPRzJFKVxuICAgIGlmIChzdGVwcyA8IDEpIHtcbiAgICAgIHN0ZXBzID0gMVxuICAgIH1cbiAgICB2YXIgc1cgPSB0YXJnZXRXaWR0aCAqIE1hdGgucG93KDIsIHN0ZXBzIC0gMSlcbiAgICB2YXIgc0ggPSB0YXJnZXRIZWlnaHQgKiBNYXRoLnBvdygyLCBzdGVwcyAtIDEpXG4gICAgdmFyIHggPSAyXG5cbiAgICB3aGlsZSAoc3RlcHMtLSkge1xuICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICBjYW52YXMud2lkdGggPSBzV1xuICAgICAgY2FudmFzLmhlaWdodCA9IHNIXG4gICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHNXLCBzSClcbiAgICAgIGltYWdlID0gY2FudmFzXG5cbiAgICAgIHNXID0gTWF0aC5yb3VuZChzVyAvIHgpXG4gICAgICBzSCA9IE1hdGgucm91bmQoc0ggLyB4KVxuICAgIH1cblxuICAgIHJldHVybiBpbWFnZVxuICB9XG5cbiAgcm90YXRlSW1hZ2UgKGltYWdlLCB0cmFuc2xhdGUpIHtcbiAgICB2YXIgdyA9IGltYWdlLndpZHRoXG4gICAgdmFyIGggPSBpbWFnZS5oZWlnaHRcblxuICAgIGlmICh0cmFuc2xhdGUucm90YXRpb24gPT09IDkwIHx8IHRyYW5zbGF0ZS5yb3RhdGlvbiA9PT0gMjcwKSB7XG4gICAgICB3ID0gaW1hZ2UuaGVpZ2h0XG4gICAgICBoID0gaW1hZ2Uud2lkdGhcbiAgICB9XG5cbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICBjYW52YXMud2lkdGggPSB3XG4gICAgY2FudmFzLmhlaWdodCA9IGhcblxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh3IC8gMiwgaCAvIDIpXG4gICAgY29udGV4dC5yb3RhdGUodHJhbnNsYXRlLnJvdGF0aW9uICogTWF0aC5QSSAvIDE4MClcbiAgICBjb250ZXh0LnNjYWxlKHRyYW5zbGF0ZS54U2NhbGUsIHRyYW5zbGF0ZS55U2NhbGUpXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIC1pbWFnZS53aWR0aCAvIDIsIC1pbWFnZS5oZWlnaHQgLyAyLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KVxuXG4gICAgcmV0dXJuIGNhbnZhc1xuICB9XG5cbiAgLyoqXG4gICAqIFNhdmUgYSA8Y2FudmFzPiBlbGVtZW50J3MgY29udGVudCB0byBhIEJsb2Igb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBjYW52YXNUb0Jsb2IgKGNhbnZhcywgdHlwZSwgcXVhbGl0eSkge1xuICAgIHRyeSB7XG4gICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gMTgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignY2Fubm90IHJlYWQgaW1hZ2UsIHByb2JhYmx5IGFuIHN2ZyB3aXRoIGV4dGVybmFsIHJlc291cmNlcycpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjYW52YXMudG9CbG9iKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNhbnZhcy50b0Jsb2IocmVzb2x2ZSwgdHlwZSwgcXVhbGl0eSlcbiAgICAgIH0pLnRoZW4oKGJsb2IpID0+IHtcbiAgICAgICAgaWYgKGJsb2IgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCByZWFkIGltYWdlLCBwcm9iYWJseSBhbiBzdmcgd2l0aCBleHRlcm5hbCByZXNvdXJjZXMnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9iXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gZGF0YVVSSXRvQmxvYihjYW52YXMudG9EYXRhVVJMKHR5cGUsIHF1YWxpdHkpLCB7fSlcbiAgICB9KS50aGVuKChibG9iKSA9PiB7XG4gICAgICBpZiAoYmxvYiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCBleHRyYWN0IGJsb2IsIHByb2JhYmx5IGFuIG9sZCBicm93c2VyJylcbiAgICAgIH1cbiAgICAgIHJldHVybiBibG9iXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHByZXZpZXcgVVJMIGZvciBhIGZpbGUuXG4gICAqL1xuICBzZXRQcmV2aWV3VVJMIChmaWxlSUQsIHByZXZpZXcpIHtcbiAgICB0aGlzLnVwcHkuc2V0RmlsZVN0YXRlKGZpbGVJRCwgeyBwcmV2aWV3IH0pXG4gIH1cblxuICBhZGRUb1F1ZXVlIChpdGVtKSB7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKGl0ZW0pXG4gICAgaWYgKHRoaXMucXVldWVQcm9jZXNzaW5nID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5wcm9jZXNzUXVldWUoKVxuICAgIH1cbiAgfVxuXG4gIHByb2Nlc3NRdWV1ZSAoKSB7XG4gICAgdGhpcy5xdWV1ZVByb2Nlc3NpbmcgPSB0cnVlXG4gICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMucXVldWUuc2hpZnQoKVxuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFRodW1ibmFpbChjdXJyZW50KVxuICAgICAgICAuY2F0Y2goZXJyID0+IHt9KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGhhbmRsZS1jYWxsYmFjay1lcnJcbiAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5wcm9jZXNzUXVldWUoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5xdWV1ZVByb2Nlc3NpbmcgPSBmYWxzZVxuICAgICAgdGhpcy51cHB5LmxvZygnW1RodW1ibmFpbEdlbmVyYXRvcl0gRW1wdGllZCB0aHVtYm5haWwgcXVldWUnKVxuICAgICAgdGhpcy51cHB5LmVtaXQoJ3RodW1ibmFpbDphbGwtZ2VuZXJhdGVkJylcbiAgICB9XG4gIH1cblxuICByZXF1ZXN0VGh1bWJuYWlsIChmaWxlKSB7XG4gICAgaWYgKGlzUHJldmlld1N1cHBvcnRlZChmaWxlLnR5cGUpICYmICFmaWxlLmlzUmVtb3RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVUaHVtYm5haWwoZmlsZSwgdGhpcy5vcHRzLnRodW1ibmFpbFdpZHRoLCB0aGlzLm9wdHMudGh1bWJuYWlsSGVpZ2h0KVxuICAgICAgICAudGhlbihwcmV2aWV3ID0+IHtcbiAgICAgICAgICB0aGlzLnNldFByZXZpZXdVUkwoZmlsZS5pZCwgcHJldmlldylcbiAgICAgICAgICB0aGlzLnVwcHkubG9nKGBbVGh1bWJuYWlsR2VuZXJhdG9yXSBHZW5lcmF0ZWQgdGh1bWJuYWlsIGZvciAke2ZpbGUuaWR9YClcbiAgICAgICAgICB0aGlzLnVwcHkuZW1pdCgndGh1bWJuYWlsOmdlbmVyYXRlZCcsIHRoaXMudXBweS5nZXRGaWxlKGZpbGUuaWQpLCBwcmV2aWV3KVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICB0aGlzLnVwcHkubG9nKGBbVGh1bWJuYWlsR2VuZXJhdG9yXSBGYWlsZWQgdGh1bWJuYWlsIGZvciAke2ZpbGUuaWR9OmAsICd3YXJuaW5nJylcbiAgICAgICAgICB0aGlzLnVwcHkubG9nKGVyciwgJ3dhcm5pbmcnKVxuICAgICAgICAgIHRoaXMudXBweS5lbWl0KCd0aHVtYm5haWw6ZXJyb3InLCB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlLmlkKSwgZXJyKVxuICAgICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxuXG4gIG9uRmlsZUFkZGVkID0gKGZpbGUpID0+IHtcbiAgICBpZiAoIWZpbGUucHJldmlldyAmJiBpc1ByZXZpZXdTdXBwb3J0ZWQoZmlsZS50eXBlKSAmJiAhZmlsZS5pc1JlbW90ZSkge1xuICAgICAgdGhpcy5hZGRUb1F1ZXVlKGZpbGUpXG4gICAgfVxuICB9XG5cbiAgb25GaWxlUmVtb3ZlZCA9IChmaWxlKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnF1ZXVlLmluZGV4T2YoZmlsZSlcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLnF1ZXVlLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG5cbiAgICAvLyBDbGVhbiB1cCBvYmplY3QgVVJMcy5cbiAgICBpZiAoZmlsZS5wcmV2aWV3ICYmIGlzT2JqZWN0VVJMKGZpbGUucHJldmlldykpIHtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoZmlsZS5wcmV2aWV3KVxuICAgIH1cbiAgfVxuXG4gIG9uUmVzdG9yZWQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBmaWxlcyB9ID0gdGhpcy51cHB5LmdldFN0YXRlKClcbiAgICBjb25zdCBmaWxlSURzID0gT2JqZWN0LmtleXMoZmlsZXMpXG4gICAgZmlsZUlEcy5mb3JFYWNoKChmaWxlSUQpID0+IHtcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlSUQpXG4gICAgICBpZiAoIWZpbGUuaXNSZXN0b3JlZCkgcmV0dXJuXG4gICAgICAvLyBPbmx5IGFkZCBibG9iIFVSTHM7IHRoZXkgYXJlIGxpa2VseSBpbnZhbGlkIGFmdGVyIGJlaW5nIHJlc3RvcmVkLlxuICAgICAgaWYgKCFmaWxlLnByZXZpZXcgfHwgaXNPYmplY3RVUkwoZmlsZS5wcmV2aWV3KSkge1xuICAgICAgICB0aGlzLmFkZFRvUXVldWUoZmlsZSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgd2FpdFVudGlsQWxsUHJvY2Vzc2VkID0gKGZpbGVJRHMpID0+IHtcbiAgICBmaWxlSURzLmZvckVhY2goKGZpbGVJRCkgPT4ge1xuICAgICAgY29uc3QgZmlsZSA9IHRoaXMudXBweS5nZXRGaWxlKGZpbGVJRClcbiAgICAgIHRoaXMudXBweS5lbWl0KCdwcmVwcm9jZXNzLXByb2dyZXNzJywgZmlsZSwge1xuICAgICAgICBtb2RlOiAnaW5kZXRlcm1pbmF0ZScsXG4gICAgICAgIG1lc3NhZ2U6IHRoaXMuaTE4bignZ2VuZXJhdGluZ1RodW1ibmFpbHMnKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgY29uc3QgZW1pdFByZXByb2Nlc3NDb21wbGV0ZUZvckFsbCA9ICgpID0+IHtcbiAgICAgIGZpbGVJRHMuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlSUQpXG4gICAgICAgIHRoaXMudXBweS5lbWl0KCdwcmVwcm9jZXNzLWNvbXBsZXRlJywgZmlsZSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLnF1ZXVlUHJvY2Vzc2luZykge1xuICAgICAgICB0aGlzLnVwcHkub25jZSgndGh1bWJuYWlsOmFsbC1nZW5lcmF0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgZW1pdFByZXByb2Nlc3NDb21wbGV0ZUZvckFsbCgpXG4gICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbWl0UHJlcHJvY2Vzc0NvbXBsZXRlRm9yQWxsKClcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIHRoaXMudXBweS5vbignZmlsZS1yZW1vdmVkJywgdGhpcy5vbkZpbGVSZW1vdmVkKVxuICAgIHRoaXMudXBweS5vbignZmlsZS1hZGRlZCcsIHRoaXMub25GaWxlQWRkZWQpXG4gICAgdGhpcy51cHB5Lm9uKCdyZXN0b3JlZCcsIHRoaXMub25SZXN0b3JlZClcblxuICAgIGlmICh0aGlzLm9wdHMud2FpdEZvclRodW1ibmFpbHNCZWZvcmVVcGxvYWQpIHtcbiAgICAgIHRoaXMudXBweS5hZGRQcmVQcm9jZXNzb3IodGhpcy53YWl0VW50aWxBbGxQcm9jZXNzZWQpXG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnVwcHkub2ZmKCdmaWxlLXJlbW92ZWQnLCB0aGlzLm9uRmlsZVJlbW92ZWQpXG4gICAgdGhpcy51cHB5Lm9mZignZmlsZS1hZGRlZCcsIHRoaXMub25GaWxlQWRkZWQpXG4gICAgdGhpcy51cHB5Lm9mZigncmVzdG9yZWQnLCB0aGlzLm9uUmVzdG9yZWQpXG5cbiAgICBpZiAodGhpcy5vcHRzLndhaXRGb3JUaHVtYm5haWxzQmVmb3JlVXBsb2FkKSB7XG4gICAgICB0aGlzLnVwcHkucmVtb3ZlUHJlUHJvY2Vzc29yKHRoaXMud2FpdFVudGlsQWxsUHJvY2Vzc2VkKVxuICAgIH1cbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS90dXNcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlJlc3VtYWJsZSB1cGxvYWRzIGZvciBVcHB5IHVzaW5nIFR1cy5pb1wiLFxuICBcInZlcnNpb25cIjogXCIxLjUuMlwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcInVwbG9hZFwiLFxuICAgIFwicmVzdW1hYmxlXCIsXG4gICAgXCJ0dXNcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvbXBhbmlvbi1jbGllbnRcIjogXCJmaWxlOi4uL2NvbXBhbmlvbi1jbGllbnRcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwidHVzLWpzLWNsaWVudFwiOiBcIl4xLjguMFwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAdXBweS9jb3JlXCI6IFwiXjEuMC4wXCJcbiAgfVxufVxuIiwiY29uc3QgdHVzID0gcmVxdWlyZSgndHVzLWpzLWNsaWVudCcpXG5cbmZ1bmN0aW9uIGlzQ29yZG92YSAoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgdHlwZW9mIHdpbmRvdy5QaG9uZUdhcCAhPT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2Ygd2luZG93LkNvcmRvdmEgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgdHlwZW9mIHdpbmRvdy5jb3Jkb3ZhICE9PSAndW5kZWZpbmVkJ1xuICApXG59XG5cbmZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUgKCkge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdzdHJpbmcnICYmXG4gICAgbmF2aWdhdG9yLnByb2R1Y3QudG9Mb3dlckNhc2UoKSA9PT0gJ3JlYWN0bmF0aXZlJ1xufVxuXG4vLyBXZSBvdmVycmlkZSB0dXMgZmluZ2VycHJpbnQgdG8gdXBweeKAmXMgYGZpbGUuaWRgLCBzaW5jZSB0aGUgYGZpbGUuaWRgXG4vLyBub3cgYWxzbyBpbmNsdWRlcyBgcmVsYXRpdmVQYXRoYCBmb3IgZmlsZXMgYWRkZWQgZnJvbSBmb2xkZXJzLlxuLy8gVGhpcyBtZWFucyB5b3UgY2FuIGFkZCAyIGlkZW50aWNhbCBmaWxlcywgaWYgb25lIGlzIGluIGZvbGRlciBhLFxuLy8gdGhlIG90aGVyIGluIGZvbGRlciBiIOKAlCBgYS9maWxlLmpwZ2AgYW5kIGBiL2ZpbGUuanBnYCwgd2hlbiBhZGRlZFxuLy8gdG9nZXRoZXIgd2l0aCBhIGZvbGRlciwgd2lsbCBiZSB0cmVhdGVkIGFzIDIgc2VwYXJhdGUgZmlsZXMuXG4vL1xuLy8gRm9yIFJlYWN0IE5hdGl2ZSBhbmQgQ29yZG92YSwgd2UgbGV0IHR1cy1qcy1jbGllbnTigJlzIGRlZmF1bHRcbi8vIGZpbmdlcnByaW50IGhhbmRsaW5nIHRha2UgY2hhcmdlLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRGaW5nZXJwcmludCAodXBweUZpbGVPYmopIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChmaWxlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmIChpc0NvcmRvdmEoKSB8fCBpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgIHJldHVybiB0dXMuVXBsb2FkLmRlZmF1bHRPcHRpb25zLmZpbmdlcnByaW50KGZpbGUsIG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIH1cblxuICAgIGNvbnN0IHVwcHlGaW5nZXJwcmludCA9IFtcbiAgICAgICd0dXMnLFxuICAgICAgdXBweUZpbGVPYmouaWQsXG4gICAgICBvcHRpb25zLmVuZHBvaW50XG4gICAgXS5qb2luKCctJylcblxuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1cHB5RmluZ2VycHJpbnQpXG4gIH1cbn1cbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IHR1cyA9IHJlcXVpcmUoJ3R1cy1qcy1jbGllbnQnKVxuY29uc3QgeyBQcm92aWRlciwgUmVxdWVzdENsaWVudCwgU29ja2V0IH0gPSByZXF1aXJlKCdAdXBweS9jb21wYW5pb24tY2xpZW50JylcbmNvbnN0IGVtaXRTb2NrZXRQcm9ncmVzcyA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9lbWl0U29ja2V0UHJvZ3Jlc3MnKVxuY29uc3QgZ2V0U29ja2V0SG9zdCA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRTb2NrZXRIb3N0JylcbmNvbnN0IHNldHRsZSA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9zZXR0bGUnKVxuY29uc3QgRXZlbnRUcmFja2VyID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL0V2ZW50VHJhY2tlcicpXG5jb25zdCBSYXRlTGltaXRlZFF1ZXVlID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL1JhdGVMaW1pdGVkUXVldWUnKVxuY29uc3QgZ2V0RmluZ2VycHJpbnQgPSByZXF1aXJlKCcuL2dldEZpbmdlcnByaW50JylcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uJykuVHVzT3B0aW9uc30gVHVzT3B0aW9ucyAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ0B1cHB5L2NvcmUnKS5VcHB5fSBVcHB5ICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnQHVwcHkvY29yZScpLlVwcHlGaWxlfSBVcHB5RmlsZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ0B1cHB5L2NvcmUnKS5GYWlsZWRVcHB5RmlsZTx7fT59IEZhaWxlZFVwcHlGaWxlICovXG5cbi8qKlxuICogRXh0cmFjdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3R1cy90dXMtanMtY2xpZW50L2Jsb2IvbWFzdGVyL2xpYi91cGxvYWQuanMjTDEzXG4gKiBleGNlcHRlZCB3ZSByZW1vdmVkICdmaW5nZXJwcmludCcga2V5IHRvIGF2b2lkIGFkZGluZyBtb3JlIGRlcGVuZGVuY2llc1xuICpcbiAqIEB0eXBlIHtUdXNPcHRpb25zfVxuICovXG5jb25zdCB0dXNEZWZhdWx0T3B0aW9ucyA9IHtcbiAgZW5kcG9pbnQ6ICcnLFxuICByZXN1bWU6IHRydWUsXG4gIG9uUHJvZ3Jlc3M6IG51bGwsXG4gIG9uQ2h1bmtDb21wbGV0ZTogbnVsbCxcbiAgb25TdWNjZXNzOiBudWxsLFxuICBvbkVycm9yOiBudWxsLFxuICBoZWFkZXJzOiB7fSxcbiAgY2h1bmtTaXplOiBJbmZpbml0eSxcbiAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgdXBsb2FkVXJsOiBudWxsLFxuICB1cGxvYWRTaXplOiBudWxsLFxuICBvdmVycmlkZVBhdGNoTWV0aG9kOiBmYWxzZSxcbiAgcmV0cnlEZWxheXM6IG51bGxcbn1cblxuLyoqXG4gKiBUdXMgcmVzdW1hYmxlIGZpbGUgdXBsb2FkZXJcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBUdXMgZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICAvKipcbiAgICogQHBhcmFtIHtVcHB5fSB1cHB5XG4gICAqIEBwYXJhbSB7VHVzT3B0aW9uc30gb3B0c1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMudHlwZSA9ICd1cGxvYWRlcidcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdUdXMnXG4gICAgdGhpcy50aXRsZSA9ICdUdXMnXG5cbiAgICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICByZXN1bWU6IHRydWUsXG4gICAgICBhdXRvUmV0cnk6IHRydWUsXG4gICAgICB1c2VGYXN0UmVtb3RlUmV0cnk6IHRydWUsXG4gICAgICBsaW1pdDogMCxcbiAgICAgIHJldHJ5RGVsYXlzOiBbMCwgMTAwMCwgMzAwMCwgNTAwMF1cbiAgICB9XG5cbiAgICAvLyBtZXJnZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgb25lcyBzZXQgYnkgdXNlclxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi5cIikuVHVzT3B0aW9uc30gKi9cbiAgICB0aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0cylcblxuICAgIC8qKlxuICAgICAqIFNpbXVsdGFuZW91cyB1cGxvYWQgbGltaXRpbmcgaXMgc2hhcmVkIGFjcm9zcyBhbGwgdXBsb2FkcyB3aXRoIHRoaXMgcGx1Z2luLlxuICAgICAqXG4gICAgICogQHR5cGUge1JhdGVMaW1pdGVkUXVldWV9XG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0cyA9IG5ldyBSYXRlTGltaXRlZFF1ZXVlKHRoaXMub3B0cy5saW1pdClcblxuICAgIHRoaXMudXBsb2FkZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIHRoaXMudXBsb2FkZXJFdmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgdGhpcy51cGxvYWRlclNvY2tldHMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgICB0aGlzLmhhbmRsZVJlc2V0UHJvZ3Jlc3MgPSB0aGlzLmhhbmRsZVJlc2V0UHJvZ3Jlc3MuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlVXBsb2FkID0gdGhpcy5oYW5kbGVVcGxvYWQuYmluZCh0aGlzKVxuICB9XG5cbiAgaGFuZGxlUmVzZXRQcm9ncmVzcyAoKSB7XG4gICAgY29uc3QgZmlsZXMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnVwcHkuZ2V0U3RhdGUoKS5maWxlcylcbiAgICBPYmplY3Qua2V5cyhmaWxlcykuZm9yRWFjaCgoZmlsZUlEKSA9PiB7XG4gICAgICAvLyBPbmx5IGNsb25lIHRoZSBmaWxlIG9iamVjdCBpZiBpdCBoYXMgYSBUdXMgYHVwbG9hZFVybGAgYXR0YWNoZWQuXG4gICAgICBpZiAoZmlsZXNbZmlsZUlEXS50dXMgJiYgZmlsZXNbZmlsZUlEXS50dXMudXBsb2FkVXJsKSB7XG4gICAgICAgIGNvbnN0IHR1c1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgZmlsZXNbZmlsZUlEXS50dXMpXG4gICAgICAgIGRlbGV0ZSB0dXNTdGF0ZS51cGxvYWRVcmxcbiAgICAgICAgZmlsZXNbZmlsZUlEXSA9IE9iamVjdC5hc3NpZ24oe30sIGZpbGVzW2ZpbGVJRF0sIHsgdHVzOiB0dXNTdGF0ZSB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLnVwcHkuc2V0U3RhdGUoeyBmaWxlcyB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGFsbCByZWZlcmVuY2VzIGZvciBhIGZpbGUncyB1cGxvYWQ6IHRoZSB0dXMuVXBsb2FkIGluc3RhbmNlLFxuICAgKiBhbnkgZXZlbnRzIHJlbGF0ZWQgdG8gdGhlIGZpbGUsIGFuZCB0aGUgQ29tcGFuaW9uIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEXG4gICAqL1xuICByZXNldFVwbG9hZGVyUmVmZXJlbmNlcyAoZmlsZUlELCBvcHRzID0ge30pIHtcbiAgICBpZiAodGhpcy51cGxvYWRlcnNbZmlsZUlEXSkge1xuICAgICAgY29uc3QgdXBsb2FkZXIgPSB0aGlzLnVwbG9hZGVyc1tmaWxlSURdXG4gICAgICB1cGxvYWRlci5hYm9ydCgpXG4gICAgICBpZiAob3B0cy5hYm9ydCkge1xuICAgICAgICAvLyB0byBhdm9pZCA0MjMgZXJyb3IgZnJvbSB0dXMgc2VydmVyLCB3ZSB3YWl0XG4gICAgICAgIC8vIHRvIGJlIHN1cmUgdGhlIHByZXZpb3VzIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZCBiZWZvcmUgdGVybWluYXRpbmcgdGhlIHVwbG9hZFxuICAgICAgICAvLyBAdG9kbyByZW1vdmUgdGhlIHRpbWVvdXQgd2hlbiB0aGlzIFwid2FpdFwiIGlzIGhhbmRsZWQgaW4gdHVzLWpzLWNsaWVudCBpbnRlcm5hbGx5XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdXBsb2FkZXIuYWJvcnQodHJ1ZSksIDEwMDApXG4gICAgICB9XG4gICAgICB0aGlzLnVwbG9hZGVyc1tmaWxlSURdID0gbnVsbFxuICAgIH1cbiAgICBpZiAodGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdKSB7XG4gICAgICB0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGVJRF0ucmVtb3ZlKClcbiAgICAgIHRoaXMudXBsb2FkZXJFdmVudHNbZmlsZUlEXSA9IG51bGxcbiAgICB9XG4gICAgaWYgKHRoaXMudXBsb2FkZXJTb2NrZXRzW2ZpbGVJRF0pIHtcbiAgICAgIHRoaXMudXBsb2FkZXJTb2NrZXRzW2ZpbGVJRF0uY2xvc2UoKVxuICAgICAgdGhpcy51cGxvYWRlclNvY2tldHNbZmlsZUlEXSA9IG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFR1cyB1cGxvYWQuXG4gICAqXG4gICAqIEEgbG90IGNhbiBoYXBwZW4gZHVyaW5nIGFuIHVwbG9hZCwgc28gdGhpcyBpcyBxdWl0ZSBoYXJkIHRvIGZvbGxvdyFcbiAgICogLSBGaXJzdCwgdGhlIHVwbG9hZCBpcyBzdGFydGVkLiBJZiB0aGUgZmlsZSB3YXMgYWxyZWFkeSBwYXVzZWQgYnkgdGhlIHRpbWUgdGhlIHVwbG9hZCBzdGFydHMsIG5vdGhpbmcgc2hvdWxkIGhhcHBlbi5cbiAgICogICBJZiB0aGUgYGxpbWl0YCBvcHRpb24gaXMgdXNlZCwgdGhlIHVwbG9hZCBtdXN0IGJlIHF1ZXVlZCBvbnRvIHRoZSBgdGhpcy5yZXF1ZXN0c2AgcXVldWUuXG4gICAqICAgV2hlbiBhbiB1cGxvYWQgc3RhcnRzLCB3ZSBzdG9yZSB0aGUgdHVzLlVwbG9hZCBpbnN0YW5jZSwgYW5kIGFuIEV2ZW50VHJhY2tlciBpbnN0YW5jZSB0aGF0IG1hbmFnZXMgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgKiAgIGZvciBwYXVzaW5nLCBjYW5jZWxsYXRpb24sIHJlbW92YWwsIGV0Yy5cbiAgICogLSBXaGlsZSB0aGUgdXBsb2FkIGlzIGluIHByb2dyZXNzLCBpdCBtYXkgYmUgcGF1c2VkIG9yIGNhbmNlbGxlZC5cbiAgICogICBQYXVzaW5nIGFib3J0cyB0aGUgdW5kZXJseWluZyB0dXMuVXBsb2FkLCBhbmQgcmVtb3ZlcyB0aGUgdXBsb2FkIGZyb20gdGhlIGB0aGlzLnJlcXVlc3RzYCBxdWV1ZS4gQWxsIG90aGVyIHN0YXRlIGlzXG4gICAqICAgbWFpbnRhaW5lZC5cbiAgICogICBDYW5jZWxsaW5nIHJlbW92ZXMgdGhlIHVwbG9hZCBmcm9tIHRoZSBgdGhpcy5yZXF1ZXN0c2AgcXVldWUsIGFuZCBjb21wbGV0ZWx5IGFib3J0cyB0aGUgdXBsb2FkLS10aGUgdHVzLlVwbG9hZCBpbnN0YW5jZVxuICAgKiAgIGlzIGFib3J0ZWQgYW5kIGRpc2NhcmRlZCwgdGhlIEV2ZW50VHJhY2tlciBpbnN0YW5jZSBpcyBkZXN0cm95ZWQgKHJlbW92aW5nIGFsbCBsaXN0ZW5lcnMpLlxuICAgKiAgIFJlc3VtaW5nIHRoZSB1cGxvYWQgdXNlcyB0aGUgYHRoaXMucmVxdWVzdHNgIHF1ZXVlIGFzIHdlbGwsIHRvIHByZXZlbnQgc2VsZWN0aXZlbHkgcGF1c2luZyBhbmQgcmVzdW1pbmcgdXBsb2FkcyBmcm9tXG4gICAqICAgYnlwYXNzaW5nIHRoZSBsaW1pdC5cbiAgICogLSBBZnRlciBjb21wbGV0aW5nIGFuIHVwbG9hZCwgdGhlIHR1cy5VcGxvYWQgYW5kIEV2ZW50VHJhY2tlciBpbnN0YW5jZXMgYXJlIGNsZWFuZWQgdXAsIGFuZCB0aGUgdXBsb2FkIGlzIG1hcmtlZCBhcyBkb25lXG4gICAqICAgaW4gdGhlIGB0aGlzLnJlcXVlc3RzYCBxdWV1ZS5cbiAgICogLSBXaGVuIGFuIHVwbG9hZCBjb21wbGV0ZWQgd2l0aCBhbiBlcnJvciwgdGhlIHNhbWUgaGFwcGVucyBhcyBvbiBzdWNjZXNzZnVsIGNvbXBsZXRpb24sIGJ1dCB0aGUgYHVwbG9hZCgpYCBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKlxuICAgKiBXaGVuIHdvcmtpbmcgb24gdGhpcyBmdW5jdGlvbiwga2VlcCBpbiBtaW5kOlxuICAgKiAgLSBXaGVuIGFuIHVwbG9hZCBpcyBjb21wbGV0ZWQgb3IgY2FuY2VsbGVkIGZvciBhbnkgcmVhc29uLCB0aGUgdHVzLlVwbG9hZCBhbmQgRXZlbnRUcmFja2VyIGluc3RhbmNlcyBuZWVkIHRvIGJlIGNsZWFuZWQgdXAgdXNpbmcgdGhpcy5yZXNldFVwbG9hZGVyUmVmZXJlbmNlcygpLlxuICAgKiAgLSBXaGVuIGFuIHVwbG9hZCBpcyBjYW5jZWxsZWQgb3IgcGF1c2VkLCBmb3IgYW55IHJlYXNvbiwgaXQgbmVlZHMgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBgdGhpcy5yZXF1ZXN0c2AgcXVldWUgdXNpbmcgYHF1ZXVlZFJlcXVlc3QuYWJvcnQoKWAuXG4gICAqICAtIFdoZW4gYW4gdXBsb2FkIGlzIGNvbXBsZXRlZCBmb3IgYW55IHJlYXNvbiwgaW5jbHVkaW5nIGVycm9ycywgaXQgbmVlZHMgdG8gYmUgbWFya2VkIGFzIHN1Y2ggdXNpbmcgYHF1ZXVlZFJlcXVlc3QuZG9uZSgpYC5cbiAgICogIC0gV2hlbiBhbiB1cGxvYWQgaXMgc3RhcnRlZCBvciByZXN1bWVkLCBpdCBuZWVkcyB0byBnbyB0aHJvdWdoIHRoZSBgdGhpcy5yZXF1ZXN0c2AgcXVldWUuIFRoZSBgcXVldWVkUmVxdWVzdGAgdmFyaWFibGUgbXVzdCBiZSB1cGRhdGVkIHNvIHRoZSBvdGhlciB1c2VzIG9mIGl0IGFyZSB2YWxpZC5cbiAgICogIC0gQmVmb3JlIHJlcGxhY2luZyB0aGUgYHF1ZXVlZFJlcXVlc3RgIHZhcmlhYmxlLCB0aGUgcHJldmlvdXMgYHF1ZXVlZFJlcXVlc3RgIG11c3QgYmUgYWJvcnRlZCwgZWxzZSBpdCB3aWxsIGtlZXAgdGFraW5nIHVwIGEgc3BvdCBpbiB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7VXBweUZpbGV9IGZpbGUgZm9yIHVzZSB3aXRoIHVwbG9hZFxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudCBmaWxlIGluIGEgcXVldWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvdGFsIG51bWJlciBvZiBmaWxlcyBpbiBhIHF1ZXVlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgdXBsb2FkIChmaWxlLCBjdXJyZW50LCB0b3RhbCkge1xuICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcblxuICAgIC8vIENyZWF0ZSBhIG5ldyB0dXMgdXBsb2FkXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudXBweS5lbWl0KCd1cGxvYWQtc3RhcnRlZCcsIGZpbGUpXG5cbiAgICAgIGNvbnN0IG9wdHNUdXMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAgdHVzRGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIHRoaXMub3B0cyxcbiAgICAgICAgLy8gSW5zdGFsbCBmaWxlLXNwZWNpZmljIHVwbG9hZCBvdmVycmlkZXMuXG4gICAgICAgIGZpbGUudHVzIHx8IHt9XG4gICAgICApXG5cbiAgICAgIC8vIFdlIG92ZXJyaWRlIHR1cyBmaW5nZXJwcmludCB0byB1cHB54oCZcyBgZmlsZS5pZGAsIHNpbmNlIHRoZSBgZmlsZS5pZGBcbiAgICAgIC8vIG5vdyBhbHNvIGluY2x1ZGVzIGByZWxhdGl2ZVBhdGhgIGZvciBmaWxlcyBhZGRlZCBmcm9tIGZvbGRlcnMuXG4gICAgICAvLyBUaGlzIG1lYW5zIHlvdSBjYW4gYWRkIDIgaWRlbnRpY2FsIGZpbGVzLCBpZiBvbmUgaXMgaW4gZm9sZGVyIGEsXG4gICAgICAvLyB0aGUgb3RoZXIgaW4gZm9sZGVyIGIuXG4gICAgICBvcHRzVHVzLmZpbmdlcnByaW50ID0gZ2V0RmluZ2VycHJpbnQoZmlsZSlcblxuICAgICAgb3B0c1R1cy5vbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICB0aGlzLnVwcHkubG9nKGVycilcbiAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1lcnJvcicsIGZpbGUsIGVycilcbiAgICAgICAgZXJyLm1lc3NhZ2UgPSBgRmFpbGVkIGJlY2F1c2U6ICR7ZXJyLm1lc3NhZ2V9YFxuXG4gICAgICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcbiAgICAgICAgcXVldWVkUmVxdWVzdC5kb25lKClcbiAgICAgICAgcmVqZWN0KGVycilcbiAgICAgIH1cblxuICAgICAgb3B0c1R1cy5vblByb2dyZXNzID0gKGJ5dGVzVXBsb2FkZWQsIGJ5dGVzVG90YWwpID0+IHtcbiAgICAgICAgdGhpcy5vblJlY2VpdmVVcGxvYWRVcmwoZmlsZSwgdXBsb2FkLnVybClcbiAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1wcm9ncmVzcycsIGZpbGUsIHtcbiAgICAgICAgICB1cGxvYWRlcjogdGhpcyxcbiAgICAgICAgICBieXRlc1VwbG9hZGVkOiBieXRlc1VwbG9hZGVkLFxuICAgICAgICAgIGJ5dGVzVG90YWw6IGJ5dGVzVG90YWxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgb3B0c1R1cy5vblN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwbG9hZFJlc3AgPSB7XG4gICAgICAgICAgdXBsb2FkVVJMOiB1cGxvYWQudXJsXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLXN1Y2Nlc3MnLCBmaWxlLCB1cGxvYWRSZXNwKVxuXG4gICAgICAgIGlmICh1cGxvYWQudXJsKSB7XG4gICAgICAgICAgdGhpcy51cHB5LmxvZygnRG93bmxvYWQgJyArIHVwbG9hZC5maWxlLm5hbWUgKyAnIGZyb20gJyArIHVwbG9hZC51cmwpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKGZpbGUuaWQpXG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuZG9uZSgpXG4gICAgICAgIHJlc29sdmUodXBsb2FkKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjb3B5UHJvcCA9IChvYmosIHNyY1Byb3AsIGRlc3RQcm9wKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBzcmNQcm9wKSAmJlxuICAgICAgICAgICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBkZXN0UHJvcClcbiAgICAgICAgKSB7XG4gICAgICAgICAgb2JqW2Rlc3RQcm9wXSA9IG9ialtzcmNQcm9wXVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1ldGEgPSB7fVxuICAgICAgY29uc3QgbWV0YUZpZWxkcyA9IEFycmF5LmlzQXJyYXkob3B0c1R1cy5tZXRhRmllbGRzKVxuICAgICAgICA/IG9wdHNUdXMubWV0YUZpZWxkc1xuICAgICAgICAvLyBTZW5kIGFsb25nIGFsbCBmaWVsZHMgYnkgZGVmYXVsdC5cbiAgICAgICAgOiBPYmplY3Qua2V5cyhmaWxlLm1ldGEpXG4gICAgICBtZXRhRmllbGRzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgbWV0YVtpdGVtXSA9IGZpbGUubWV0YVtpdGVtXVxuICAgICAgfSlcblxuICAgICAgLy8gdHVzZCB1c2VzIG1ldGFkYXRhIGZpZWxkcyAnZmlsZXR5cGUnIGFuZCAnZmlsZW5hbWUnXG4gICAgICBjb3B5UHJvcChtZXRhLCAndHlwZScsICdmaWxldHlwZScpXG4gICAgICBjb3B5UHJvcChtZXRhLCAnbmFtZScsICdmaWxlbmFtZScpXG5cbiAgICAgIG9wdHNUdXMubWV0YWRhdGEgPSBtZXRhXG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUuZGF0YSwgb3B0c1R1cylcbiAgICAgIHRoaXMudXBsb2FkZXJzW2ZpbGUuaWRdID0gdXBsb2FkXG4gICAgICB0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGUuaWRdID0gbmV3IEV2ZW50VHJhY2tlcih0aGlzLnVwcHkpXG5cbiAgICAgIGxldCBxdWV1ZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5ydW4oKCkgPT4ge1xuICAgICAgICBpZiAoIWZpbGUuaXNQYXVzZWQpIHtcbiAgICAgICAgICB1cGxvYWQuc3RhcnQoKVxuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGhlcmUsIHRoZSBjYWxsZXIgd2lsbCB0YWtlIGNhcmUgb2YgY2FuY2VsbGluZyB0aGUgdXBsb2FkIGl0c2VsZlxuICAgICAgICAvLyB1c2luZyByZXNldFVwbG9hZGVyUmVmZXJlbmNlcygpLiBUaGlzIGlzIGJlY2F1c2UgcmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoKSBoYXMgdG8gYmVcbiAgICAgICAgLy8gY2FsbGVkIHdoZW4gdGhpcyByZXF1ZXN0IGlzIHN0aWxsIGluIHRoZSBxdWV1ZSwgYW5kIGhhcyBub3QgYmVlbiBzdGFydGVkIHlldCwgdG9vLiBBdFxuICAgICAgICAvLyB0aGF0IHBvaW50IHRoaXMgY2FuY2VsbGF0aW9uIGZ1bmN0aW9uIGlzIG5vdCBnb2luZyB0byBiZSBjYWxsZWQuXG4gICAgICAgIC8vIEFsc28sIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSByZXF1ZXN0IGZyb20gdGhlIHF1ZXVlIF93aXRob3V0XyBkZXN0cm95aW5nIGV2ZXJ5dGhpbmdcbiAgICAgICAgLy8gcmVsYXRlZCB0byB0aGlzIHVwbG9hZCB0byBoYW5kbGUgcGF1c2VzLlxuICAgICAgICByZXR1cm4gKCkgPT4ge31cbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25GaWxlUmVtb3ZlKGZpbGUuaWQsICh0YXJnZXRGaWxlSUQpID0+IHtcbiAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZCwgeyBhYm9ydDogISF1cGxvYWQudXJsIH0pXG4gICAgICAgIHJlc29sdmUoYHVwbG9hZCAke3RhcmdldEZpbGVJRH0gd2FzIHJlbW92ZWRgKVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vblBhdXNlKGZpbGUuaWQsIChpc1BhdXNlZCkgPT4ge1xuICAgICAgICBpZiAoaXNQYXVzZWQpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhpcyBmaWxlIGZyb20gdGhlIHF1ZXVlIHNvIGFub3RoZXIgZmlsZSBjYW4gc3RhcnQgaW4gaXRzIHBsYWNlLlxuICAgICAgICAgIHF1ZXVlZFJlcXVlc3QuYWJvcnQoKVxuICAgICAgICAgIHVwbG9hZC5hYm9ydCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVzdW1pbmcgYW4gdXBsb2FkIHNob3VsZCBiZSBxdWV1ZWQsIGVsc2UgeW91IGNvdWxkIHBhdXNlIGFuZCB0aGVuIHJlc3VtZSBhIHF1ZXVlZCB1cGxvYWQgdG8gbWFrZSBpdCBza2lwIHRoZSBxdWV1ZS5cbiAgICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgICBxdWV1ZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgdXBsb2FkLnN0YXJ0KClcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7fVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25QYXVzZUFsbChmaWxlLmlkLCAoKSA9PiB7XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuYWJvcnQoKVxuICAgICAgICB1cGxvYWQuYWJvcnQoKVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vbkNhbmNlbEFsbChmaWxlLmlkLCAoKSA9PiB7XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuYWJvcnQoKVxuICAgICAgICB0aGlzLnJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKGZpbGUuaWQsIHsgYWJvcnQ6ICEhdXBsb2FkLnVybCB9KVxuICAgICAgICByZXNvbHZlKGB1cGxvYWQgJHtmaWxlLmlkfSB3YXMgY2FuY2VsZWRgKVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vblJlc3VtZUFsbChmaWxlLmlkLCAoKSA9PiB7XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuYWJvcnQoKVxuICAgICAgICBpZiAoZmlsZS5lcnJvcikge1xuICAgICAgICAgIHVwbG9hZC5hYm9ydCgpXG4gICAgICAgIH1cbiAgICAgICAgcXVldWVkUmVxdWVzdCA9IHRoaXMucmVxdWVzdHMucnVuKCgpID0+IHtcbiAgICAgICAgICB1cGxvYWQuc3RhcnQoKVxuICAgICAgICAgIHJldHVybiAoKSA9PiB7fVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLWVycm9yJywgZmlsZSwgZXJyKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwcHlGaWxlfSBmaWxlIGZvciB1c2Ugd2l0aCB1cGxvYWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnQgZmlsZSBpbiBhIHF1ZXVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b3RhbCBudW1iZXIgb2YgZmlsZXMgaW4gYSBxdWV1ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIHVwbG9hZFJlbW90ZSAoZmlsZSwgY3VycmVudCwgdG90YWwpIHtcbiAgICB0aGlzLnJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKGZpbGUuaWQpXG5cbiAgICBjb25zdCBvcHRzID0geyAuLi50aGlzLm9wdHMgfVxuICAgIGlmIChmaWxlLnR1cykge1xuICAgICAgLy8gSW5zdGFsbCBmaWxlLXNwZWNpZmljIHVwbG9hZCBvdmVycmlkZXMuXG4gICAgICBPYmplY3QuYXNzaWduKG9wdHMsIGZpbGUudHVzKVxuICAgIH1cblxuICAgIHRoaXMudXBweS5lbWl0KCd1cGxvYWQtc3RhcnRlZCcsIGZpbGUpXG4gICAgdGhpcy51cHB5LmxvZyhmaWxlLnJlbW90ZS51cmwpXG5cbiAgICBpZiAoZmlsZS5zZXJ2ZXJUb2tlbikge1xuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdFRvU2VydmVyU29ja2V0KGZpbGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IENsaWVudCA9IGZpbGUucmVtb3RlLnByb3ZpZGVyT3B0aW9ucy5wcm92aWRlciA/IFByb3ZpZGVyIDogUmVxdWVzdENsaWVudFxuICAgICAgY29uc3QgY2xpZW50ID0gbmV3IENsaWVudCh0aGlzLnVwcHksIGZpbGUucmVtb3RlLnByb3ZpZGVyT3B0aW9ucylcblxuICAgICAgLy8gISEgY2FuY2VsbGF0aW9uIGlzIE5PVCBzdXBwb3J0ZWQgYXQgdGhpcyBzdGFnZSB5ZXRcbiAgICAgIGNsaWVudC5wb3N0KGZpbGUucmVtb3RlLnVybCwge1xuICAgICAgICAuLi5maWxlLnJlbW90ZS5ib2R5LFxuICAgICAgICBlbmRwb2ludDogb3B0cy5lbmRwb2ludCxcbiAgICAgICAgdXBsb2FkVXJsOiBvcHRzLnVwbG9hZFVybCxcbiAgICAgICAgcHJvdG9jb2w6ICd0dXMnLFxuICAgICAgICBzaXplOiBmaWxlLmRhdGEuc2l6ZSxcbiAgICAgICAgbWV0YWRhdGE6IGZpbGUubWV0YVxuICAgICAgfSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgIHRoaXMudXBweS5zZXRGaWxlU3RhdGUoZmlsZS5pZCwgeyBzZXJ2ZXJUb2tlbjogcmVzLnRva2VuIH0pXG4gICAgICAgIGZpbGUgPSB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlLmlkKVxuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0VG9TZXJ2ZXJTb2NrZXQoZmlsZSlcbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnIpKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNlZSB0aGUgY29tbWVudCBvbiB0aGUgdXBsb2FkKCkgbWV0aG9kLlxuICAgKlxuICAgKiBBZGRpdGlvbmFsbHksIHdoZW4gYW4gdXBsb2FkIGlzIHJlbW92ZWQsIGNvbXBsZXRlZCwgb3IgY2FuY2VsbGVkLCB3ZSBuZWVkIHRvIGNsb3NlIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi4gVGhpcyBpcyBoYW5kbGVkIGJ5IHRoZSByZXNldFVwbG9hZGVyUmVmZXJlbmNlcygpIGZ1bmN0aW9uLCBzbyB0aGUgc2FtZSBndWlkZWxpbmVzIGFwcGx5IGFzIGluIHVwbG9hZCgpLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwcHlGaWxlfSBmaWxlXG4gICAqL1xuICBjb25uZWN0VG9TZXJ2ZXJTb2NrZXQgKGZpbGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW4gPSBmaWxlLnNlcnZlclRva2VuXG4gICAgICBjb25zdCBob3N0ID0gZ2V0U29ja2V0SG9zdChmaWxlLnJlbW90ZS5jb21wYW5pb25VcmwpXG4gICAgICBjb25zdCBzb2NrZXQgPSBuZXcgU29ja2V0KHsgdGFyZ2V0OiBgJHtob3N0fS9hcGkvJHt0b2tlbn1gLCBhdXRvT3BlbjogZmFsc2UgfSlcbiAgICAgIHRoaXMudXBsb2FkZXJTb2NrZXRzW2ZpbGUuaWRdID0gc29ja2V0XG4gICAgICB0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGUuaWRdID0gbmV3IEV2ZW50VHJhY2tlcih0aGlzLnVwcHkpXG5cbiAgICAgIHRoaXMub25GaWxlUmVtb3ZlKGZpbGUuaWQsICgpID0+IHtcbiAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgIC8vIHN0aWxsIHNlbmQgcGF1c2UgZXZlbnQgaW4gY2FzZSB3ZSBhcmUgZGVhbGluZyB3aXRoIG9sZGVyIHZlcnNpb24gb2YgY29tcGFuaW9uXG4gICAgICAgIC8vIEB0b2RvIGRvbid0IHNlbmQgcGF1c2UgZXZlbnQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgc29ja2V0LnNlbmQoJ3BhdXNlJywge30pXG4gICAgICAgIHNvY2tldC5zZW5kKCdjYW5jZWwnLCB7fSlcbiAgICAgICAgdGhpcy5yZXNldFVwbG9hZGVyUmVmZXJlbmNlcyhmaWxlLmlkKVxuICAgICAgICByZXNvbHZlKGB1cGxvYWQgJHtmaWxlLmlkfSB3YXMgcmVtb3ZlZGApXG4gICAgICB9KVxuXG4gICAgICB0aGlzLm9uUGF1c2UoZmlsZS5pZCwgKGlzUGF1c2VkKSA9PiB7XG4gICAgICAgIGlmIChpc1BhdXNlZCkge1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGlzIGZpbGUgZnJvbSB0aGUgcXVldWUgc28gYW5vdGhlciBmaWxlIGNhbiBzdGFydCBpbiBpdHMgcGxhY2UuXG4gICAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgICAgc29ja2V0LnNlbmQoJ3BhdXNlJywge30pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVzdW1pbmcgYW4gdXBsb2FkIHNob3VsZCBiZSBxdWV1ZWQsIGVsc2UgeW91IGNvdWxkIHBhdXNlIGFuZCB0aGVuIHJlc3VtZSBhIHF1ZXVlZCB1cGxvYWQgdG8gbWFrZSBpdCBza2lwIHRoZSBxdWV1ZS5cbiAgICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgICBxdWV1ZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgc29ja2V0LnNlbmQoJ3Jlc3VtZScsIHt9KVxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHt9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vblBhdXNlQWxsKGZpbGUuaWQsICgpID0+IHtcbiAgICAgICAgcXVldWVkUmVxdWVzdC5hYm9ydCgpXG4gICAgICAgIHNvY2tldC5zZW5kKCdwYXVzZScsIHt9KVxuICAgICAgfSlcblxuICAgICAgdGhpcy5vbkNhbmNlbEFsbChmaWxlLmlkLCAoKSA9PiB7XG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuYWJvcnQoKVxuICAgICAgICAvLyBzdGlsbCBzZW5kIHBhdXNlIGV2ZW50IGluIGNhc2Ugd2UgYXJlIGRlYWxpbmcgd2l0aCBvbGRlciB2ZXJzaW9uIG9mIGNvbXBhbmlvblxuICAgICAgICAvLyBAdG9kbyBkb24ndCBzZW5kIHBhdXNlIGV2ZW50IGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHNvY2tldC5zZW5kKCdwYXVzZScsIHt9KVxuICAgICAgICBzb2NrZXQuc2VuZCgnY2FuY2VsJywge30pXG4gICAgICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcbiAgICAgICAgcmVzb2x2ZShgdXBsb2FkICR7ZmlsZS5pZH0gd2FzIGNhbmNlbGVkYClcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25SZXN1bWVBbGwoZmlsZS5pZCwgKCkgPT4ge1xuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmFib3J0KClcbiAgICAgICAgaWYgKGZpbGUuZXJyb3IpIHtcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncGF1c2UnLCB7fSlcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5ydW4oKCkgPT4ge1xuICAgICAgICAgIHNvY2tldC5zZW5kKCdyZXN1bWUnLCB7fSlcbiAgICAgICAgICByZXR1cm4gKCkgPT4ge31cbiAgICAgICAgfSlcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25SZXRyeShmaWxlLmlkLCAoKSA9PiB7XG4gICAgICAgIC8vIE9ubHkgZG8gdGhlIHJldHJ5IGlmIHRoZSB1cGxvYWQgaXMgYWN0dWFsbHkgaW4gcHJvZ3Jlc3M7XG4gICAgICAgIC8vIGVsc2Ugd2UgY291bGQgdHJ5IHRvIHNlbmQgdGhlc2UgbWVzc2FnZXMgd2hlbiB0aGUgdXBsb2FkIGlzIHN0aWxsIHF1ZXVlZC5cbiAgICAgICAgLy8gV2UgbWF5IG5lZWQgYSBiZXR0ZXIgY2hlY2sgZm9yIHRoaXMgc2luY2UgdGhlIHNvY2tldCBtYXkgYWxzbyBiZSBjbG9zZWRcbiAgICAgICAgLy8gZm9yIG90aGVyIHJlYXNvbnMsIGxpa2UgbmV0d29yayBmYWlsdXJlcy5cbiAgICAgICAgaWYgKHNvY2tldC5pc09wZW4pIHtcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncGF1c2UnLCB7fSlcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncmVzdW1lJywge30pXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHRoaXMub25SZXRyeUFsbChmaWxlLmlkLCAoKSA9PiB7XG4gICAgICAgIC8vIFNlZSB0aGUgY29tbWVudCBpbiB0aGUgb25SZXRyeSgpIGNhbGxcbiAgICAgICAgaWYgKHNvY2tldC5pc09wZW4pIHtcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncGF1c2UnLCB7fSlcbiAgICAgICAgICBzb2NrZXQuc2VuZCgncmVzdW1lJywge30pXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbigncHJvZ3Jlc3MnLCAocHJvZ3Jlc3NEYXRhKSA9PiBlbWl0U29ja2V0UHJvZ3Jlc3ModGhpcywgcHJvZ3Jlc3NEYXRhLCBmaWxlKSlcblxuICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIChlcnJEYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gZXJyRGF0YS5lcnJvclxuICAgICAgICBjb25zdCBlcnJvciA9IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKG1lc3NhZ2UpLCB7IGNhdXNlOiBlcnJEYXRhLmVycm9yIH0pXG5cbiAgICAgICAgLy8gSWYgdGhlIHJlbW90ZSByZXRyeSBvcHRpbWlzYXRpb24gc2hvdWxkIG5vdCBiZSB1c2VkLFxuICAgICAgICAvLyBjbG9zZSB0aGUgc29ja2V04oCUdGhpcyB3aWxsIHRlbGwgY29tcGFuaW9uIHRvIGNsZWFyIHN0YXRlIGFuZCBkZWxldGUgdGhlIGZpbGUuXG4gICAgICAgIGlmICghdGhpcy5vcHRzLnVzZUZhc3RSZW1vdGVSZXRyeSkge1xuICAgICAgICAgIHRoaXMucmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoZmlsZS5pZClcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlcnZlclRva2VuIHNvIHRoYXQgYSBuZXcgb25lIHdpbGwgYmUgY3JlYXRlZCBmb3IgdGhlIHJldHJ5LlxuICAgICAgICAgIHRoaXMudXBweS5zZXRGaWxlU3RhdGUoZmlsZS5pZCwge1xuICAgICAgICAgICAgc2VydmVyVG9rZW46IG51bGxcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNvY2tldC5jbG9zZSgpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwcHkuZW1pdCgndXBsb2FkLWVycm9yJywgZmlsZSwgZXJyb3IpXG4gICAgICAgIHF1ZXVlZFJlcXVlc3QuZG9uZSgpXG4gICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgIH0pXG5cbiAgICAgIHNvY2tldC5vbignc3VjY2VzcycsIChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwbG9hZFJlc3AgPSB7XG4gICAgICAgICAgdXBsb2FkVVJMOiBkYXRhLnVybFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cHB5LmVtaXQoJ3VwbG9hZC1zdWNjZXNzJywgZmlsZSwgdXBsb2FkUmVzcClcbiAgICAgICAgdGhpcy5yZXNldFVwbG9hZGVyUmVmZXJlbmNlcyhmaWxlLmlkKVxuICAgICAgICBxdWV1ZWRSZXF1ZXN0LmRvbmUoKVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0pXG5cbiAgICAgIGxldCBxdWV1ZWRSZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5ydW4oKCkgPT4ge1xuICAgICAgICBzb2NrZXQub3BlbigpXG4gICAgICAgIGlmIChmaWxlLmlzUGF1c2VkKSB7XG4gICAgICAgICAgc29ja2V0LnNlbmQoJ3BhdXNlJywge30pXG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBoZXJlLCB0aGUgY2FsbGVyIHdpbGwgdGFrZSBjYXJlIG9mIGNhbmNlbGxpbmcgdGhlIHVwbG9hZCBpdHNlbGZcbiAgICAgICAgLy8gdXNpbmcgcmVzZXRVcGxvYWRlclJlZmVyZW5jZXMoKS4gVGhpcyBpcyBiZWNhdXNlIHJlc2V0VXBsb2FkZXJSZWZlcmVuY2VzKCkgaGFzIHRvIGJlXG4gICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoaXMgcmVxdWVzdCBpcyBzdGlsbCBpbiB0aGUgcXVldWUsIGFuZCBoYXMgbm90IGJlZW4gc3RhcnRlZCB5ZXQsIHRvby4gQXRcbiAgICAgICAgLy8gdGhhdCBwb2ludCB0aGlzIGNhbmNlbGxhdGlvbiBmdW5jdGlvbiBpcyBub3QgZ29pbmcgdG8gYmUgY2FsbGVkLlxuICAgICAgICAvLyBBbHNvLCB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgcmVxdWVzdCBmcm9tIHRoZSBxdWV1ZSBfd2l0aG91dF8gZGVzdHJveWluZyBldmVyeXRoaW5nXG4gICAgICAgIC8vIHJlbGF0ZWQgdG8gdGhpcyB1cGxvYWQgdG8gaGFuZGxlIHBhdXNlcy5cbiAgICAgICAgcmV0dXJuICgpID0+IHt9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU3RvcmUgdGhlIHVwbG9hZFVybCBvbiB0aGUgZmlsZSBvcHRpb25zLCBzbyB0aGF0IHdoZW4gR29sZGVuIFJldHJpZXZlclxuICAgKiByZXN0b3JlcyBzdGF0ZSwgd2Ugd2lsbCBjb250aW51ZSB1cGxvYWRpbmcgdG8gdGhlIGNvcnJlY3QgVVJMLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwcHlGaWxlfSBmaWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cGxvYWRVUkxcbiAgICovXG4gIG9uUmVjZWl2ZVVwbG9hZFVybCAoZmlsZSwgdXBsb2FkVVJMKSB7XG4gICAgY29uc3QgY3VycmVudEZpbGUgPSB0aGlzLnVwcHkuZ2V0RmlsZShmaWxlLmlkKVxuICAgIGlmICghY3VycmVudEZpbGUpIHJldHVyblxuICAgIC8vIE9ubHkgZG8gdGhlIHVwZGF0ZSBpZiB3ZSBkaWRuJ3QgaGF2ZSBhbiB1cGxvYWQgVVJMIHlldC5cbiAgICBpZiAoIWN1cnJlbnRGaWxlLnR1cyB8fCBjdXJyZW50RmlsZS50dXMudXBsb2FkVXJsICE9PSB1cGxvYWRVUkwpIHtcbiAgICAgIHRoaXMudXBweS5sb2coJ1tUdXNdIFN0b3JpbmcgdXBsb2FkIHVybCcpXG4gICAgICB0aGlzLnVwcHkuc2V0RmlsZVN0YXRlKGN1cnJlbnRGaWxlLmlkLCB7XG4gICAgICAgIHR1czogT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudEZpbGUudHVzLCB7XG4gICAgICAgICAgdXBsb2FkVXJsOiB1cGxvYWRVUkxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSURcbiAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpOiB2b2lkfSBjYlxuICAgKi9cbiAgb25GaWxlUmVtb3ZlIChmaWxlSUQsIGNiKSB7XG4gICAgdGhpcy51cGxvYWRlckV2ZW50c1tmaWxlSURdLm9uKCdmaWxlLXJlbW92ZWQnLCAoZmlsZSkgPT4ge1xuICAgICAgaWYgKGZpbGVJRCA9PT0gZmlsZS5pZCkgY2IoZmlsZS5pZClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSURcbiAgICogQHBhcmFtIHtmdW5jdGlvbihib29sZWFuKTogdm9pZH0gY2JcbiAgICovXG4gIG9uUGF1c2UgKGZpbGVJRCwgY2IpIHtcbiAgICB0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGVJRF0ub24oJ3VwbG9hZC1wYXVzZScsICh0YXJnZXRGaWxlSUQsIGlzUGF1c2VkKSA9PiB7XG4gICAgICBpZiAoZmlsZUlEID09PSB0YXJnZXRGaWxlSUQpIHtcbiAgICAgICAgLy8gY29uc3QgaXNQYXVzZWQgPSB0aGlzLnVwcHkucGF1c2VSZXN1bWUoZmlsZUlEKVxuICAgICAgICBjYihpc1BhdXNlZClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSURcbiAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBjYlxuICAgKi9cbiAgb25SZXRyeSAoZmlsZUlELCBjYikge1xuICAgIHRoaXMudXBsb2FkZXJFdmVudHNbZmlsZUlEXS5vbigndXBsb2FkLXJldHJ5JywgKHRhcmdldEZpbGVJRCkgPT4ge1xuICAgICAgaWYgKGZpbGVJRCA9PT0gdGFyZ2V0RmlsZUlEKSB7XG4gICAgICAgIGNiKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSURcbiAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBjYlxuICAgKi9cbiAgb25SZXRyeUFsbCAoZmlsZUlELCBjYikge1xuICAgIHRoaXMudXBsb2FkZXJFdmVudHNbZmlsZUlEXS5vbigncmV0cnktYWxsJywgKGZpbGVzVG9SZXRyeSkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnVwcHkuZ2V0RmlsZShmaWxlSUQpKSByZXR1cm5cbiAgICAgIGNiKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSURcbiAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBjYlxuICAgKi9cbiAgb25QYXVzZUFsbCAoZmlsZUlELCBjYikge1xuICAgIHRoaXMudXBsb2FkZXJFdmVudHNbZmlsZUlEXS5vbigncGF1c2UtYWxsJywgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnVwcHkuZ2V0RmlsZShmaWxlSUQpKSByZXR1cm5cbiAgICAgIGNiKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSURcbiAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBjYlxuICAgKi9cbiAgb25DYW5jZWxBbGwgKGZpbGVJRCwgY2IpIHtcbiAgICB0aGlzLnVwbG9hZGVyRXZlbnRzW2ZpbGVJRF0ub24oJ2NhbmNlbC1hbGwnLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMudXBweS5nZXRGaWxlKGZpbGVJRCkpIHJldHVyblxuICAgICAgY2IoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IGNiXG4gICAqL1xuICBvblJlc3VtZUFsbCAoZmlsZUlELCBjYikge1xuICAgIHRoaXMudXBsb2FkZXJFdmVudHNbZmlsZUlEXS5vbigncmVzdW1lLWFsbCcsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy51cHB5LmdldEZpbGUoZmlsZUlEKSkgcmV0dXJuXG4gICAgICBjYigpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyhVcHB5RmlsZSB8IEZhaWxlZFVwcHlGaWxlKVtdfSBmaWxlc1xuICAgKi9cbiAgdXBsb2FkRmlsZXMgKGZpbGVzKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBmaWxlcy5tYXAoKGZpbGUsIGkpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSBpICsgMVxuICAgICAgY29uc3QgdG90YWwgPSBmaWxlcy5sZW5ndGhcblxuICAgICAgaWYgKCdlcnJvcicgaW4gZmlsZSAmJiBmaWxlLmVycm9yKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoZmlsZS5lcnJvcikpXG4gICAgICB9IGVsc2UgaWYgKGZpbGUuaXNSZW1vdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBsb2FkUmVtb3RlKGZpbGUsIGN1cnJlbnQsIHRvdGFsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBsb2FkKGZpbGUsIGN1cnJlbnQsIHRvdGFsKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gc2V0dGxlKHByb21pc2VzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGZpbGVJRHNcbiAgICovXG4gIGhhbmRsZVVwbG9hZCAoZmlsZUlEcykge1xuICAgIGlmIChmaWxlSURzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy51cHB5LmxvZygnW1R1c10gTm8gZmlsZXMgdG8gdXBsb2FkJylcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdHMubGltaXQgPT09IDApIHtcbiAgICAgIHRoaXMudXBweS5sb2coXG4gICAgICAgICdbVHVzXSBXaGVuIHVwbG9hZGluZyBtdWx0aXBsZSBmaWxlcyBhdCBvbmNlLCBjb25zaWRlciBzZXR0aW5nIHRoZSBgbGltaXRgIG9wdGlvbiAodG8gYDEwYCBmb3IgZXhhbXBsZSksIHRvIGxpbWl0IHRoZSBudW1iZXIgb2YgY29uY3VycmVudCB1cGxvYWRzLCB3aGljaCBoZWxwcyBwcmV2ZW50IG1lbW9yeSBhbmQgbmV0d29yayBpc3N1ZXM6IGh0dHBzOi8vdXBweS5pby9kb2NzL3R1cy8jbGltaXQtMCcsXG4gICAgICAgICd3YXJuaW5nJ1xuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMudXBweS5sb2coJ1tUdXNdIFVwbG9hZGluZy4uLicpXG4gICAgY29uc3QgZmlsZXNUb1VwbG9hZCA9IGZpbGVJRHMubWFwKChmaWxlSUQpID0+IHRoaXMudXBweS5nZXRGaWxlKGZpbGVJRCkpXG5cbiAgICByZXR1cm4gdGhpcy51cGxvYWRGaWxlcyhmaWxlc1RvVXBsb2FkKVxuICAgICAgLnRoZW4oKCkgPT4gbnVsbClcbiAgfVxuXG4gIGluc3RhbGwgKCkge1xuICAgIHRoaXMudXBweS5zZXRTdGF0ZSh7XG4gICAgICBjYXBhYmlsaXRpZXM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMudXBweS5nZXRTdGF0ZSgpLmNhcGFiaWxpdGllcywge1xuICAgICAgICByZXN1bWFibGVVcGxvYWRzOiB0cnVlXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy51cHB5LmFkZFVwbG9hZGVyKHRoaXMuaGFuZGxlVXBsb2FkKVxuXG4gICAgdGhpcy51cHB5Lm9uKCdyZXNldC1wcm9ncmVzcycsIHRoaXMuaGFuZGxlUmVzZXRQcm9ncmVzcylcblxuICAgIGlmICh0aGlzLm9wdHMuYXV0b1JldHJ5KSB7XG4gICAgICB0aGlzLnVwcHkub24oJ2JhY2stb25saW5lJywgdGhpcy51cHB5LnJldHJ5QWxsKVxuICAgIH1cbiAgfVxuXG4gIHVuaW5zdGFsbCAoKSB7XG4gICAgdGhpcy51cHB5LnNldFN0YXRlKHtcbiAgICAgIGNhcGFiaWxpdGllczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy51cHB5LmdldFN0YXRlKCkuY2FwYWJpbGl0aWVzLCB7XG4gICAgICAgIHJlc3VtYWJsZVVwbG9hZHM6IGZhbHNlXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy51cHB5LnJlbW92ZVVwbG9hZGVyKHRoaXMuaGFuZGxlVXBsb2FkKVxuXG4gICAgaWYgKHRoaXMub3B0cy5hdXRvUmV0cnkpIHtcbiAgICAgIHRoaXMudXBweS5vZmYoJ2JhY2stb25saW5lJywgdGhpcy51cHB5LnJldHJ5QWxsKVxuICAgIH1cbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJAdXBweS91cmxcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBVcmwgcGx1Z2luIGxldHMgdXNlcnMgaW1wb3J0IGZpbGVzIGZyb20gdGhlIEludGVybmV0LiBQYXN0ZSBhbnkgVVJMIGFuZCBpdOKAmWxsIGJlIGFkZGVkIVwiLFxuICBcInZlcnNpb25cIjogXCIxLjQuMlwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL2luZGV4LmpzXCIsXG4gIFwic3R5bGVcIjogXCJkaXN0L3N0eWxlLm1pbi5jc3NcIixcbiAgXCJ0eXBlc1wiOiBcInR5cGVzL2luZGV4LmQudHNcIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJmaWxlIHVwbG9hZGVyXCIsXG4gICAgXCJ1cmxcIixcbiAgICBcImltcG9ydCBmcm9tIHVybFwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L2NvbXBhbmlvbi1jbGllbnRcIjogXCJmaWxlOi4uL2NvbXBhbmlvbi1jbGllbnRcIixcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgaCwgQ29tcG9uZW50IH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuXG5jbGFzcyBVcmxVSSBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIHRoaXMuaGFuZGxlS2V5UHJlc3MgPSB0aGlzLmhhbmRsZUtleVByZXNzLmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZUNsaWNrID0gdGhpcy5oYW5kbGVDbGljay5iaW5kKHRoaXMpXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgdGhpcy5pbnB1dC52YWx1ZSA9ICcnXG4gIH1cblxuICBoYW5kbGVLZXlQcmVzcyAoZXYpIHtcbiAgICBpZiAoZXYua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIHRoaXMucHJvcHMuYWRkRmlsZSh0aGlzLmlucHV0LnZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUNsaWNrICgpIHtcbiAgICB0aGlzLnByb3BzLmFkZEZpbGUodGhpcy5pbnB1dC52YWx1ZSlcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3M9XCJ1cHB5LVVybFwiPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICBjbGFzcz1cInVwcHktdS1yZXNldCB1cHB5LWMtdGV4dElucHV0IHVwcHktVXJsLWlucHV0XCJcbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgYXJpYS1sYWJlbD17dGhpcy5wcm9wcy5pMThuKCdlbnRlclVybFRvSW1wb3J0Jyl9XG4gICAgICAgICAgcGxhY2Vob2xkZXI9e3RoaXMucHJvcHMuaTE4bignZW50ZXJVcmxUb0ltcG9ydCcpfVxuICAgICAgICAgIG9ua2V5dXA9e3RoaXMuaGFuZGxlS2V5UHJlc3N9XG4gICAgICAgICAgcmVmPXsoaW5wdXQpID0+IHsgdGhpcy5pbnB1dCA9IGlucHV0IH19XG4gICAgICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgICAgICAvPlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3M9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LWMtYnRuLXByaW1hcnkgdXBweS1VcmwtaW1wb3J0QnV0dG9uXCJcbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBvbmNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfVxuICAgICAgICA+XG4gICAgICAgICAge3RoaXMucHJvcHMuaTE4bignaW1wb3J0Jyl9XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVXJsVUlcbiIsImNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IFRyYW5zbGF0b3IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvVHJhbnNsYXRvcicpXG5jb25zdCB7IGggfSA9IHJlcXVpcmUoJ3ByZWFjdCcpXG5jb25zdCB7IFJlcXVlc3RDbGllbnQgfSA9IHJlcXVpcmUoJ0B1cHB5L2NvbXBhbmlvbi1jbGllbnQnKVxuY29uc3QgVXJsVUkgPSByZXF1aXJlKCcuL1VybFVJLmpzJylcbmNvbnN0IGZvckVhY2hEcm9wcGVkT3JQYXN0ZWRVcmwgPSByZXF1aXJlKCcuL3V0aWxzL2ZvckVhY2hEcm9wcGVkT3JQYXN0ZWRVcmwnKVxuXG5mdW5jdGlvbiBVcmxJY29uICgpIHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgd2lkdGg9XCIyM1wiIGhlaWdodD1cIjIzXCIgdmlld0JveD1cIjAgMCAyMyAyM1wiPlxuICAgICAgPHBhdGggZD1cIk0yMC40ODUgMTEuMjM2bC0yLjc0OCAyLjczN2MtLjE4NC4xODItLjM2Ny4zNjUtLjY0Mi41NDctMS4wMDcuNzMtMi4xMDcgMS4wOTUtMy4yOTggMS4wOTUtMS42NSAwLTMuMjk4LS43My00LjM5OC0yLjE5LS4yNzUtLjM2NS0uMTgzLTEuMDAzLjE4My0xLjI3Ny4zNjctLjI3MyAxLjAwOC0uMTgyIDEuMjgzLjE4MyAxLjE5MSAxLjY0MiAzLjQ4MiAxLjkxNSA1LjEzLjczYS43MTQuNzE0IDAgMCAwIC4zNjctLjM2NWwyLjc1LTIuNzM3YzEuMzczLTEuNDYgMS4zNzMtMy43NC0uMDkzLTUuMTA4YTMuNzIgMy43MiAwIDAgMC01LjEzIDBMMTIuMzMgNi40YS44ODguODg4IDAgMCAxLTEuMjgzIDAgLjg4Ljg4IDAgMCAxIDAtMS4yNzdsMS41NTgtMS41NWE1LjM4IDUuMzggMCAwIDEgNy42MDUgMGMyLjI5IDIuMDA2IDIuMzgyIDUuNTY0LjI3NCA3LjY2MnptLTguOTc5IDYuMjk0TDkuOTUgMTkuMDgxYTMuNzIgMy43MiAwIDAgMS01LjEzIDBjLTEuNDY3LTEuMzY4LTEuNDY3LTMuNzQtLjA5My01LjEwOGwyLjc1LTIuNzM3LjM2Ni0uMzY1Yy44MjQtLjU0NyAxLjc0LS44MiAyLjc0OC0uNzMgMS4wMDguMTgzIDEuODMzLjYzOSAyLjM4MiAxLjQ2LjI3NS4zNjUuOTE3LjQ1NiAxLjI4My4xODIuMzY3LS4yNzMuNDU4LS45MTIuMTgzLTEuMjc3LS45MTYtMS4xODYtMi4xOTktMS45MTUtMy41NzMtMi4wOTgtMS4zNzQtLjI3My0yLjg0LjA5MS00LjAzMSAxLjAwNGwtLjU1LjU0Ny0yLjc0OSAyLjczN2MtMi4xMDcgMi4xODktMi4wMTUgNS42NTUuMDkyIDcuNzUzQzQuNzI3IDIxLjQ1MyA2LjEwMSAyMiA3LjQ3NSAyMmMxLjM3NCAwIDIuNzQ5LS41NDcgMy44NDgtMS41NWwxLjU1OC0xLjU1MWEuODguODggMCAwIDAgMC0xLjI3OGMtLjM2Ny0uMzY0LTEuMDA4LS40NTYtMS4zNzUtLjA5elwiIGZpbGw9XCIjRkY4MTRGXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuLyoqXG4gKiBVcmxcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgVXJsIGV4dGVuZHMgUGx1Z2luIHtcbiAgc3RhdGljIFZFUlNJT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uXG5cbiAgY29uc3RydWN0b3IgKHVwcHksIG9wdHMpIHtcbiAgICBzdXBlcih1cHB5LCBvcHRzKVxuICAgIHRoaXMuaWQgPSB0aGlzLm9wdHMuaWQgfHwgJ1VybCdcbiAgICB0aGlzLnRpdGxlID0gdGhpcy5vcHRzLnRpdGxlIHx8ICdMaW5rJ1xuICAgIHRoaXMudHlwZSA9ICdhY3F1aXJlcidcbiAgICB0aGlzLmljb24gPSAoKSA9PiA8VXJsSWNvbiAvPlxuXG4gICAgLy8gU2V0IGRlZmF1bHQgb3B0aW9ucyBhbmQgbG9jYWxlXG4gICAgdGhpcy5kZWZhdWx0TG9jYWxlID0ge1xuICAgICAgc3RyaW5nczoge1xuICAgICAgICBpbXBvcnQ6ICdJbXBvcnQnLFxuICAgICAgICBlbnRlclVybFRvSW1wb3J0OiAnRW50ZXIgVVJMIHRvIGltcG9ydCBhIGZpbGUnLFxuICAgICAgICBmYWlsZWRUb0ZldGNoOiAnQ29tcGFuaW9uIGZhaWxlZCB0byBmZXRjaCB0aGlzIFVSTCwgcGxlYXNlIG1ha2Ugc3VyZSBpdOKAmXMgY29ycmVjdCcsXG4gICAgICAgIGVudGVyQ29ycmVjdFVybDogJ0luY29ycmVjdCBVUkw6IFBsZWFzZSBtYWtlIHN1cmUgeW91IGFyZSBlbnRlcmluZyBhIGRpcmVjdCBsaW5rIHRvIGEgZmlsZSdcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHt9XG5cbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRzIH1cblxuICAgIHRoaXMuaTE4bkluaXQoKVxuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMub3B0cy5jb21wYW5pb25VcmxcblxuICAgIGlmICghdGhpcy5ob3N0bmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21wYW5pb24gaG9zdG5hbWUgaXMgcmVxdWlyZWQsIHBsZWFzZSBjb25zdWx0IGh0dHBzOi8vdXBweS5pby9kb2NzL2NvbXBhbmlvbicpXG4gICAgfVxuXG4gICAgLy8gQmluZCBhbGwgZXZlbnQgaGFuZGxlcnMgZm9yIHJlZmVyZW5jYWJpbGl0eVxuICAgIHRoaXMuZ2V0TWV0YSA9IHRoaXMuZ2V0TWV0YS5iaW5kKHRoaXMpXG4gICAgdGhpcy5hZGRGaWxlID0gdGhpcy5hZGRGaWxlLmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZVJvb3REcm9wID0gdGhpcy5oYW5kbGVSb290RHJvcC5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVSb290UGFzdGUgPSB0aGlzLmhhbmRsZVJvb3RQYXN0ZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLmNsaWVudCA9IG5ldyBSZXF1ZXN0Q2xpZW50KHVwcHksIHtcbiAgICAgIGNvbXBhbmlvblVybDogdGhpcy5vcHRzLmNvbXBhbmlvblVybCxcbiAgICAgIGNvbXBhbmlvbkhlYWRlcnM6IHRoaXMub3B0cy5jb21wYW5pb25IZWFkZXJzIHx8IHRoaXMub3B0cy5zZXJ2ZXJIZWFkZXJzXG4gICAgfSlcbiAgfVxuXG4gIHNldE9wdGlvbnMgKG5ld09wdHMpIHtcbiAgICBzdXBlci5zZXRPcHRpb25zKG5ld09wdHMpXG4gICAgdGhpcy5pMThuSW5pdCgpXG4gIH1cblxuICBpMThuSW5pdCAoKSB7XG4gICAgdGhpcy50cmFuc2xhdG9yID0gbmV3IFRyYW5zbGF0b3IoW3RoaXMuZGVmYXVsdExvY2FsZSwgdGhpcy51cHB5LmxvY2FsZSwgdGhpcy5vcHRzLmxvY2FsZV0pXG4gICAgdGhpcy5pMThuID0gdGhpcy50cmFuc2xhdG9yLnRyYW5zbGF0ZS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgICB0aGlzLmkxOG5BcnJheSA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGVBcnJheS5iaW5kKHRoaXMudHJhbnNsYXRvcilcbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKCkgLy8gc28gdGhhdCBVSSByZS1yZW5kZXJzIGFuZCB3ZSBzZWUgdGhlIHVwZGF0ZWQgbG9jYWxlXG4gIH1cblxuICBnZXRGaWxlTmFtZUZyb21VcmwgKHVybCkge1xuICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKHVybC5sYXN0SW5kZXhPZignLycpICsgMSlcbiAgfVxuXG4gIGNoZWNrSWZDb3JyZWN0VVJMICh1cmwpIHtcbiAgICBpZiAoIXVybCkgcmV0dXJuIGZhbHNlXG5cbiAgICBjb25zdCBwcm90b2NvbCA9IHVybC5tYXRjaCgvXihbYS16MC05XSspOlxcL1xcLy8pWzFdXG4gICAgaWYgKHByb3RvY29sICE9PSAnaHR0cCcgJiYgcHJvdG9jb2wgIT09ICdodHRwcycpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBhZGRQcm90b2NvbFRvVVJMICh1cmwpIHtcbiAgICBjb25zdCBwcm90b2NvbFJlZ2V4ID0gL15bYS16MC05XSs6XFwvXFwvL1xuICAgIGNvbnN0IGRlZmF1bHRQcm90b2NvbCA9ICdodHRwOi8vJ1xuICAgIGlmIChwcm90b2NvbFJlZ2V4LnRlc3QodXJsKSkge1xuICAgICAgcmV0dXJuIHVybFxuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0UHJvdG9jb2wgKyB1cmxcbiAgfVxuXG4gIGdldE1ldGEgKHVybCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5wb3N0KCd1cmwvbWV0YScsIHsgdXJsIH0pXG4gICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgIGlmIChyZXMuZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLnVwcHkubG9nKCdbVVJMXSBFcnJvcjonKVxuICAgICAgICAgIHRoaXMudXBweS5sb2cocmVzLmVycm9yKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHRoZSBmaWxlJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzXG4gICAgICB9KVxuICB9XG5cbiAgYWRkRmlsZSAodXJsKSB7XG4gICAgdXJsID0gdGhpcy5hZGRQcm90b2NvbFRvVVJMKHVybClcbiAgICBpZiAoIXRoaXMuY2hlY2tJZkNvcnJlY3RVUkwodXJsKSkge1xuICAgICAgdGhpcy51cHB5LmxvZyhgW1VSTF0gSW5jb3JyZWN0IFVSTCBlbnRlcmVkOiAke3VybH1gKVxuICAgICAgdGhpcy51cHB5LmluZm8odGhpcy5pMThuKCdlbnRlckNvcnJlY3RVcmwnKSwgJ2Vycm9yJywgNDAwMClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldE1ldGEodXJsKVxuICAgICAgLnRoZW4oKG1ldGEpID0+IHtcbiAgICAgICAgY29uc3QgdGFnRmlsZSA9IHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgICAgbmFtZTogdGhpcy5nZXRGaWxlTmFtZUZyb21VcmwodXJsKSxcbiAgICAgICAgICB0eXBlOiBtZXRhLnR5cGUsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgc2l6ZTogbWV0YS5zaXplXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpc1JlbW90ZTogdHJ1ZSxcbiAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3RlOiB7XG4gICAgICAgICAgICBjb21wYW5pb25Vcmw6IHRoaXMub3B0cy5jb21wYW5pb25VcmwsXG4gICAgICAgICAgICB1cmw6IGAke3RoaXMuaG9zdG5hbWV9L3VybC9nZXRgLFxuICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICBmaWxlSWQ6IHVybCxcbiAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHRoaXMuY2xpZW50Lm9wdHNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZ0ZpbGVcbiAgICAgIH0pXG4gICAgICAudGhlbigodGFnRmlsZSkgPT4ge1xuICAgICAgICB0aGlzLnVwcHkubG9nKCdbVXJsXSBBZGRpbmcgcmVtb3RlIGZpbGUnKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMudXBweS5hZGRGaWxlKHRhZ0ZpbGUpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmICghZXJyLmlzUmVzdHJpY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgICB0aGlzLnVwcHkuaW5mbyh7XG4gICAgICAgICAgbWVzc2FnZTogdGhpcy5pMThuKCdmYWlsZWRUb0ZldGNoJyksXG4gICAgICAgICAgZGV0YWlsczogZXJyXG4gICAgICAgIH0sICdlcnJvcicsIDQwMDApXG4gICAgICB9KVxuICB9XG5cbiAgaGFuZGxlUm9vdERyb3AgKGUpIHtcbiAgICBmb3JFYWNoRHJvcHBlZE9yUGFzdGVkVXJsKGUuZGF0YVRyYW5zZmVyLCAnZHJvcCcsICh1cmwpID0+IHtcbiAgICAgIHRoaXMudXBweS5sb2coYFtVUkxdIEFkZGluZyBmaWxlIGZyb20gZHJvcHBlZCB1cmw6ICR7dXJsfWApXG4gICAgICB0aGlzLmFkZEZpbGUodXJsKVxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVSb290UGFzdGUgKGUpIHtcbiAgICBmb3JFYWNoRHJvcHBlZE9yUGFzdGVkVXJsKGUuY2xpcGJvYXJkRGF0YSwgJ3Bhc3RlJywgKHVybCkgPT4ge1xuICAgICAgdGhpcy51cHB5LmxvZyhgW1VSTF0gQWRkaW5nIGZpbGUgZnJvbSBwYXN0ZWQgdXJsOiAke3VybH1gKVxuICAgICAgdGhpcy5hZGRGaWxlKHVybClcbiAgICB9KVxuICB9XG5cbiAgcmVuZGVyIChzdGF0ZSkge1xuICAgIHJldHVybiA8VXJsVUkgaTE4bj17dGhpcy5pMThufSBhZGRGaWxlPXt0aGlzLmFkZEZpbGV9IC8+XG4gIH1cblxuICBpbnN0YWxsICgpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLm9wdHMudGFyZ2V0XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5tb3VudCh0YXJnZXQsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgdW5pbnN0YWxsICgpIHtcbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG59XG4iLCJjb25zdCB0b0FycmF5ID0gcmVxdWlyZSgnQHVwcHkvdXRpbHMvbGliL3RvQXJyYXknKVxuXG4vKlxuICBTSVRVQVRJT05cblxuICAgIDEuIENyb3NzLWJyb3dzZXIgZGF0YVRyYW5zZmVyLml0ZW1zXG5cbiAgICAgIHBhc3RlIGluIGNocm9tZSBbQ29weSBJbWFnZV06XG4gICAgICAwOiB7a2luZDogXCJmaWxlXCIsIHR5cGU6IFwiaW1hZ2UvcG5nXCJ9XG4gICAgICAxOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L2h0bWxcIn1cbiAgICAgIHBhc3RlIGluIHNhZmFyaSBbQ29weSBJbWFnZV06XG4gICAgICAwOiB7a2luZDogXCJmaWxlXCIsIHR5cGU6IFwiaW1hZ2UvcG5nXCJ9XG4gICAgICAxOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L2h0bWxcIn1cbiAgICAgIDI6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvcGxhaW5cIn1cbiAgICAgIDM6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvdXJpLWxpc3RcIn1cbiAgICAgIHBhc3RlIGluIGZpcmVmb3ggW0NvcHkgSW1hZ2VdOlxuICAgICAgMDoge2tpbmQ6IFwiZmlsZVwiLCB0eXBlOiBcImltYWdlL3BuZ1wifVxuICAgICAgMToge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC9odG1sXCJ9XG5cbiAgICAgIHBhc3RlIGluIGNocm9tZSBbQ29weSBJbWFnZSBBZGRyZXNzXTpcbiAgICAgIDA6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvcGxhaW5cIn1cbiAgICAgIHBhc3RlIGluIHNhZmFyaSBbQ29weSBJbWFnZSBBZGRyZXNzXTpcbiAgICAgIDA6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvcGxhaW5cIn1cbiAgICAgIDE6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvdXJpLWxpc3RcIn1cbiAgICAgIHBhc3RlIGluIGZpcmVmb3ggW0NvcHkgSW1hZ2UgQWRkcmVzc106XG4gICAgICAwOiB7a2luZDogXCJzdHJpbmdcIiwgdHlwZTogXCJ0ZXh0L3BsYWluXCJ9XG5cbiAgICAgIGRyb3AgaW4gY2hyb21lIFtmcm9tIGJyb3dzZXJdOlxuICAgICAgMDoge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC91cmktbGlzdFwifVxuICAgICAgMToge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC9odG1sXCJ9XG4gICAgICBkcm9wIGluIHNhZmFyaSBbZnJvbSBicm93c2VyXTpcbiAgICAgIDA6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvdXJpLWxpc3RcIn1cbiAgICAgIDE6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvaHRtbFwifVxuICAgICAgMjoge2tpbmQ6IFwiZmlsZVwiLCB0eXBlOiBcImltYWdlL3BuZ1wifVxuICAgICAgZHJvcCBpbiBmaXJlZm94IFtmcm9tIGJyb3dzZXJdOlxuICAgICAgMDoge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC91cmktbGlzdFwifVxuICAgICAgMToge2tpbmQ6IFwic3RyaW5nXCIsIHR5cGU6IFwidGV4dC94LW1vei11cmxcIn1cbiAgICAgIDI6IHtraW5kOiBcInN0cmluZ1wiLCB0eXBlOiBcInRleHQvcGxhaW5cIn1cblxuICAgIDIuIFdlIGNhbiBkZXRlcm1pbmUgaWYgaXQncyBhICdjb3B5cGFzdGUnIG9yIGEgJ2Ryb3AnLCBidXQgd2UgY2FuJ3QgZGlzY2VybiBiZXR3ZWVuIFtDb3B5IEltYWdlXSBhbmQgW0NvcHkgSW1hZ2UgQWRkcmVzc10uXG5cbiAgQ09OQ0xVU0lPTlxuXG4gICAgMS4gJ3Bhc3RlJyAoW0NvcHkgSW1hZ2VdIG9yIFtDb3B5IEltYWdlIEFkZHJlc3NdLCB3ZSBjYW4ndCBkaXNjZXJuIGJldHdlZW4gdGhlc2UgdHdvKVxuICAgICAgRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlcmUgaXMgJ2ZpbGUnIGl0ZW0uIC5oYW5kbGVQYXN0ZSBpbiB0aGUgRGFzaGJvYXJkUGx1Z2luIHdpbGwgZGVhbCB3aXRoIGFsbCAnZmlsZScgaXRlbXMuXG4gICAgICBJZiB0aGVyZSBhcmUgbm8gJ2ZpbGUnIGl0ZW1zIC0gaGFuZGxlICd0ZXh0L3BsYWluJyBpdGVtcy5cblxuICAgIDIuICdkcm9wJ1xuICAgICAgVGFrZSAndGV4dC91cmktbGlzdCcgaXRlbXMuIFNhZmFyaSBoYXMgYW4gYWRkaXRpb25hbCBpdGVtIG9mIC5raW5kID09PSAnZmlsZScsIGFuZCB5b3UgbWF5IHdvcnJ5IGFib3V0IHRoZSBpdGVtIGJlaW5nIGR1cGxpY2F0ZWQgKGZpcnN0IGJ5IERhc2hib2FyZFBsdWdpbiwgYW5kIHRoZW4gYnkgVXJsUGx1Z2luLCBub3cpLCBidXQgZG9uJ3QuIERpcmVjdG9yeSBoYW5kbGluZyBjb2RlIHdvbid0IHBheSBhdHRlbnRpb24gdG8gdGhpcyBwYXJ0aWN1bGFyIGl0ZW0gb2Yga2luZCAnZmlsZScuXG4qL1xuXG4vKipcbiAqIEZpbmRzIGFsbCBsaW5rcyBkcm9wcGVkL3Bhc3RlZCBmcm9tIG9uZSBicm93c2VyIHdpbmRvdyB0byBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhVHJhbnNmZXIgLSBEYXRhVHJhbnNmZXIgaW5zdGFuY2UsIGUuZy4gZS5jbGlwYm9hcmREYXRhLCBvciBlLmRhdGFUcmFuc2ZlclxuICogQHBhcmFtIHtzdHJpbmd9IGlzRHJvcE9yUGFzdGUgLSBlaXRoZXIgJ2Ryb3AnIG9yICdwYXN0ZSdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gKHVybFN0cmluZykgPT4ge31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoRHJvcHBlZE9yUGFzdGVkVXJsIChkYXRhVHJhbnNmZXIsIGlzRHJvcE9yUGFzdGUsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGl0ZW1zID0gdG9BcnJheShkYXRhVHJhbnNmZXIuaXRlbXMpXG5cbiAgbGV0IHVybEl0ZW1zXG5cbiAgc3dpdGNoIChpc0Ryb3BPclBhc3RlKSB7XG4gICAgY2FzZSAncGFzdGUnOiB7XG4gICAgICBjb25zdCBhdExlYXN0T25lRmlsZUlzRHJhZ2dlZCA9IGl0ZW1zLnNvbWUoKGl0ZW0pID0+IGl0ZW0ua2luZCA9PT0gJ2ZpbGUnKVxuICAgICAgaWYgKGF0TGVhc3RPbmVGaWxlSXNEcmFnZ2VkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsSXRlbXMgPSBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+XG4gICAgICAgICAgaXRlbS5raW5kID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgIGl0ZW0udHlwZSA9PT0gJ3RleHQvcGxhaW4nXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgJ2Ryb3AnOiB7XG4gICAgICB1cmxJdGVtcyA9IGl0ZW1zLmZpbHRlcigoaXRlbSkgPT5cbiAgICAgICAgaXRlbS5raW5kID09PSAnc3RyaW5nJyAmJlxuICAgICAgICBpdGVtLnR5cGUgPT09ICd0ZXh0L3VyaS1saXN0J1xuICAgICAgKVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpc0Ryb3BPclBhc3RlIG11c3QgYmUgZWl0aGVyICdkcm9wJyBvciAncGFzdGUnLCBidXQgaXQncyAke2lzRHJvcE9yUGFzdGV9YClcbiAgICB9XG4gIH1cblxuICB1cmxJdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgaXRlbS5nZXRBc1N0cmluZygodXJsU3RyaW5nKSA9PlxuICAgICAgY2FsbGJhY2sodXJsU3RyaW5nKVxuICAgIClcbiAgfSlcbn1cbiIsIi8qKlxuICogQ3JlYXRlIGEgd3JhcHBlciBhcm91bmQgYW4gZXZlbnQgZW1pdHRlciB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kIHRvIHJlbW92ZVxuICogYWxsIGV2ZW50cyB0aGF0IHdlcmUgYWRkZWQgdXNpbmcgdGhlIHdyYXBwZWQgZW1pdHRlci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBFdmVudFRyYWNrZXIge1xuICBjb25zdHJ1Y3RvciAoZW1pdHRlcikge1xuICAgIHRoaXMuX2V2ZW50cyA9IFtdXG4gICAgdGhpcy5fZW1pdHRlciA9IGVtaXR0ZXJcbiAgfVxuXG4gIG9uIChldmVudCwgZm4pIHtcbiAgICB0aGlzLl9ldmVudHMucHVzaChbZXZlbnQsIGZuXSlcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5vbihldmVudCwgZm4pXG4gIH1cblxuICByZW1vdmUgKCkge1xuICAgIHRoaXMuX2V2ZW50cy5mb3JFYWNoKChbZXZlbnQsIGZuXSkgPT4ge1xuICAgICAgdGhpcy5fZW1pdHRlci5vZmYoZXZlbnQsIGZuKVxuICAgIH0pXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuICAnYVtocmVmXTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pOm5vdChbaW5lcnRdKTpub3QoW2FyaWEtaGlkZGVuXSknLFxuICAnYXJlYVtocmVmXTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pOm5vdChbaW5lcnRdKTpub3QoW2FyaWEtaGlkZGVuXSknLFxuICAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pOm5vdChbaW5lcnRdKTpub3QoW2FyaWEtaGlkZGVuXSknLFxuICAnc2VsZWN0Om5vdChbZGlzYWJsZWRdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ3RleHRhcmVhOm5vdChbZGlzYWJsZWRdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSk6bm90KFtpbmVydF0pOm5vdChbYXJpYS1oaWRkZW5dKScsXG4gICdpZnJhbWU6bm90KFt0YWJpbmRleF49XCItXCJdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ29iamVjdDpub3QoW3RhYmluZGV4Xj1cIi1cIl0pOm5vdChbaW5lcnRdKTpub3QoW2FyaWEtaGlkZGVuXSknLFxuICAnZW1iZWQ6bm90KFt0YWJpbmRleF49XCItXCJdKTpub3QoW2luZXJ0XSk6bm90KFthcmlhLWhpZGRlbl0pJyxcbiAgJ1tjb250ZW50ZWRpdGFibGVdOm5vdChbdGFiaW5kZXhePVwiLVwiXSk6bm90KFtpbmVydF0pOm5vdChbYXJpYS1oaWRkZW5dKScsXG4gICdbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXhePVwiLVwiXSk6bm90KFtpbmVydF0pOm5vdChbYXJpYS1oaWRkZW5dKSdcbl1cbiIsIm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUmF0ZUxpbWl0ZWRRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yIChsaW1pdCkge1xuICAgIGlmICh0eXBlb2YgbGltaXQgIT09ICdudW1iZXInIHx8IGxpbWl0ID09PSAwKSB7XG4gICAgICB0aGlzLmxpbWl0ID0gSW5maW5pdHlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5saW1pdCA9IGxpbWl0XG4gICAgfVxuXG4gICAgdGhpcy5hY3RpdmVSZXF1ZXN0cyA9IDBcbiAgICB0aGlzLnF1ZXVlZEhhbmRsZXJzID0gW11cbiAgfVxuXG4gIF9jYWxsIChmbikge1xuICAgIHRoaXMuYWN0aXZlUmVxdWVzdHMgKz0gMVxuXG4gICAgbGV0IGRvbmUgPSBmYWxzZVxuXG4gICAgbGV0IGNhbmNlbEFjdGl2ZVxuICAgIHRyeSB7XG4gICAgICBjYW5jZWxBY3RpdmUgPSBmbigpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmFjdGl2ZVJlcXVlc3RzIC09IDFcbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhYm9ydDogKCkgPT4ge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuXG4gICAgICAgIGRvbmUgPSB0cnVlXG4gICAgICAgIHRoaXMuYWN0aXZlUmVxdWVzdHMgLT0gMVxuICAgICAgICBjYW5jZWxBY3RpdmUoKVxuICAgICAgICB0aGlzLl9xdWV1ZU5leHQoKVxuICAgICAgfSxcblxuICAgICAgZG9uZTogKCkgPT4ge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuXG4gICAgICAgIGRvbmUgPSB0cnVlXG4gICAgICAgIHRoaXMuYWN0aXZlUmVxdWVzdHMgLT0gMVxuICAgICAgICB0aGlzLl9xdWV1ZU5leHQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9xdWV1ZU5leHQgKCkge1xuICAgIC8vIERvIGl0IHNvb24gYnV0IG5vdCBpbW1lZGlhdGVseSwgdGhpcyBhbGxvd3MgY2xlYXJpbmcgb3V0IHRoZSBlbnRpcmUgcXVldWUgc3luY2hyb25vdXNseVxuICAgIC8vIG9uZSBieSBvbmUgd2l0aG91dCBjb250aW51b3VzbHkgX2FkdmFuY2luZ18gaXQgKGFuZCBzdGFydGluZyBuZXcgdGFza3MgYmVmb3JlIGltbWVkaWF0ZWx5XG4gICAgLy8gYWJvcnRpbmcgdGhlbSlcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuX25leHQoKVxuICAgIH0pXG4gIH1cblxuICBfbmV4dCAoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlUmVxdWVzdHMgPj0gdGhpcy5saW1pdCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh0aGlzLnF1ZXVlZEhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIG5leHQgcmVxdWVzdCwgYW5kIHVwZGF0ZSB0aGUgYWJvcnQvZG9uZSBoYW5kbGVyc1xuICAgIC8vIHNvIHRoYXQgY2FuY2VsbGluZyBpdCBkb2VzIHRoZSBSaWdodCBUaGluZyAoYW5kIGRvZXNuJ3QganVzdCB0cnlcbiAgICAvLyB0byBkZXF1ZXVlIGFuIGFscmVhZHktcnVubmluZyByZXF1ZXN0KS5cbiAgICBjb25zdCBuZXh0ID0gdGhpcy5xdWV1ZWRIYW5kbGVycy5zaGlmdCgpXG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX2NhbGwobmV4dC5mbilcbiAgICBuZXh0LmFib3J0ID0gaGFuZGxlci5hYm9ydFxuICAgIG5leHQuZG9uZSA9IGhhbmRsZXIuZG9uZVxuICB9XG5cbiAgX3F1ZXVlIChmbikge1xuICAgIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgICBmbixcbiAgICAgIGFib3J0OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RlcXVldWUoaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkb25lOiAoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG1hcmsgYSBxdWV1ZWQgcmVxdWVzdCBhcyBkb25lOiB0aGlzIGluZGljYXRlcyBhIGJ1ZycpXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucXVldWVkSGFuZGxlcnMucHVzaChoYW5kbGVyKVxuICAgIHJldHVybiBoYW5kbGVyXG4gIH1cblxuICBfZGVxdWV1ZSAoaGFuZGxlcikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5xdWV1ZWRIYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5xdWV1ZWRIYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG5cbiAgcnVuIChmbikge1xuICAgIGlmICh0aGlzLmFjdGl2ZVJlcXVlc3RzIDwgdGhpcy5saW1pdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhbGwoZm4pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9xdWV1ZShmbilcbiAgfVxuXG4gIHdyYXBQcm9taXNlRnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBxdWV1ZWRSZXF1ZXN0ID0gdGhpcy5ydW4oKCkgPT4ge1xuICAgICAgICBsZXQgY2FuY2VsRXJyb3JcbiAgICAgICAgbGV0IHByb21pc2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGZuKC4uLmFyZ3MpKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QoZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvbWlzZS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICBpZiAoY2FuY2VsRXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChjYW5jZWxFcnJvcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcXVldWVkUmVxdWVzdC5kb25lKClcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChjYW5jZWxFcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGNhbmNlbEVycm9yKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWV1ZWRSZXF1ZXN0LmRvbmUoKVxuICAgICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBjYW5jZWxFcnJvciA9IG5ldyBFcnJvcignQ2FuY2VsbGVkJylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG4iLCJjb25zdCBoYXMgPSByZXF1aXJlKCcuL2hhc1Byb3BlcnR5JylcblxuLyoqXG4gKiBUcmFuc2xhdGVzIHN0cmluZ3Mgd2l0aCBpbnRlcnBvbGF0aW9uICYgcGx1cmFsaXphdGlvbiBzdXBwb3J0LlxuICogRXh0ZW5zaWJsZSB3aXRoIGN1c3RvbSBkaWN0aW9uYXJpZXMgYW5kIHBsdXJhbGl6YXRpb24gZnVuY3Rpb25zLlxuICpcbiAqIEJvcnJvd3MgaGVhdmlseSBmcm9tIGFuZCBpbnNwaXJlZCBieSBQb2x5Z2xvdCBodHRwczovL2dpdGh1Yi5jb20vYWlyYm5iL3BvbHlnbG90LmpzLFxuICogYmFzaWNhbGx5IGEgc3RyaXBwZWQtZG93biB2ZXJzaW9uIG9mIGl0LiBEaWZmZXJlbmNlczogcGx1cmFsaXphdGlvbiBmdW5jdGlvbnMgYXJlIG5vdCBoYXJkY29kZWRcbiAqIGFuZCBjYW4gYmUgZWFzaWx5IGFkZGVkIGFtb25nIHdpdGggZGljdGlvbmFyaWVzLCBuZXN0ZWQgb2JqZWN0cyBhcmUgdXNlZCBmb3IgcGx1cmFsaXphdGlvblxuICogYXMgb3Bwb3NlZCB0byBgfHx8fGAgZGVsaW1ldGVyXG4gKlxuICogVXNhZ2UgZXhhbXBsZTogYHRyYW5zbGF0b3IudHJhbnNsYXRlKCdmaWxlc19jaG9zZW4nLCB7c21hcnRfY291bnQ6IDN9KWBcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBUcmFuc2xhdG9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fEFycmF5PG9iamVjdD59IGxvY2FsZXMgLSBsb2NhbGUgb3IgbGlzdCBvZiBsb2NhbGVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKGxvY2FsZXMpIHtcbiAgICB0aGlzLmxvY2FsZSA9IHtcbiAgICAgIHN0cmluZ3M6IHt9LFxuICAgICAgcGx1cmFsaXplOiBmdW5jdGlvbiAobikge1xuICAgICAgICBpZiAobiA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShsb2NhbGVzKSkge1xuICAgICAgbG9jYWxlcy5mb3JFYWNoKChsb2NhbGUpID0+IHRoaXMuX2FwcGx5KGxvY2FsZSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FwcGx5KGxvY2FsZXMpXG4gICAgfVxuICB9XG5cbiAgX2FwcGx5IChsb2NhbGUpIHtcbiAgICBpZiAoIWxvY2FsZSB8fCAhbG9jYWxlLnN0cmluZ3MpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHByZXZMb2NhbGUgPSB0aGlzLmxvY2FsZVxuICAgIHRoaXMubG9jYWxlID0gT2JqZWN0LmFzc2lnbih7fSwgcHJldkxvY2FsZSwge1xuICAgICAgc3RyaW5nczogT2JqZWN0LmFzc2lnbih7fSwgcHJldkxvY2FsZS5zdHJpbmdzLCBsb2NhbGUuc3RyaW5ncylcbiAgICB9KVxuICAgIHRoaXMubG9jYWxlLnBsdXJhbGl6ZSA9IGxvY2FsZS5wbHVyYWxpemUgfHwgcHJldkxvY2FsZS5wbHVyYWxpemVcbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlcyBhIHN0cmluZyB3aXRoIHBsYWNlaG9sZGVyIHZhcmlhYmxlcyBsaWtlIGAle3NtYXJ0X2NvdW50fSBmaWxlIHNlbGVjdGVkYFxuICAgKiBhbmQgcmVwbGFjZXMgaXQgd2l0aCB2YWx1ZXMgZnJvbSBvcHRpb25zIGB7c21hcnRfY291bnQ6IDV9YFxuICAgKlxuICAgKiBAbGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vYWlyYm5iL3BvbHlnbG90LmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAgICogdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYWlyYm5iL3BvbHlnbG90LmpzL2Jsb2IvbWFzdGVyL2xpYi9wb2x5Z2xvdC5qcyNMMjk5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwaHJhc2UgdGhhdCBuZWVkcyBpbnRlcnBvbGF0aW9uLCB3aXRoIHBsYWNlaG9sZGVyc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyB3aXRoIHZhbHVlcyB0aGF0IHdpbGwgYmUgdXNlZCB0byByZXBsYWNlIHBsYWNlaG9sZGVyc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBpbnRlcnBvbGF0ZWRcbiAgICovXG4gIGludGVycG9sYXRlIChwaHJhc2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHNwbGl0LCByZXBsYWNlIH0gPSBTdHJpbmcucHJvdG90eXBlXG4gICAgY29uc3QgZG9sbGFyUmVnZXggPSAvXFwkL2dcbiAgICBjb25zdCBkb2xsYXJCaWxsc1lhbGwgPSAnJCQkJCdcbiAgICBsZXQgaW50ZXJwb2xhdGVkID0gW3BocmFzZV1cblxuICAgIGZvciAoY29uc3QgYXJnIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChhcmcgIT09ICdfJyAmJiBoYXMob3B0aW9ucywgYXJnKSkge1xuICAgICAgICAvLyBFbnN1cmUgcmVwbGFjZW1lbnQgdmFsdWUgaXMgZXNjYXBlZCB0byBwcmV2ZW50IHNwZWNpYWwgJC1wcmVmaXhlZFxuICAgICAgICAvLyByZWdleCByZXBsYWNlIHRva2Vucy4gdGhlIFwiJCQkJFwiIGlzIG5lZWRlZCBiZWNhdXNlIGVhY2ggXCIkXCIgbmVlZHMgdG9cbiAgICAgICAgLy8gYmUgZXNjYXBlZCB3aXRoIFwiJFwiIGl0c2VsZiwgYW5kIHdlIG5lZWQgdHdvIGluIHRoZSByZXN1bHRpbmcgb3V0cHV0LlxuICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBvcHRpb25zW2FyZ11cbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXBsYWNlbWVudCA9IHJlcGxhY2UuY2FsbChvcHRpb25zW2FyZ10sIGRvbGxhclJlZ2V4LCBkb2xsYXJCaWxsc1lhbGwpXG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgY3JlYXRlIGEgbmV3IGBSZWdFeHBgIGVhY2ggdGltZSBpbnN0ZWFkIG9mIHVzaW5nIGEgbW9yZS1lZmZpY2llbnRcbiAgICAgICAgLy8gc3RyaW5nIHJlcGxhY2Ugc28gdGhhdCB0aGUgc2FtZSBhcmd1bWVudCBjYW4gYmUgcmVwbGFjZWQgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgLy8gaW4gdGhlIHNhbWUgcGhyYXNlLlxuICAgICAgICBpbnRlcnBvbGF0ZWQgPSBpbnNlcnRSZXBsYWNlbWVudChpbnRlcnBvbGF0ZWQsIG5ldyBSZWdFeHAoJyVcXFxceycgKyBhcmcgKyAnXFxcXH0nLCAnZycpLCByZXBsYWNlbWVudClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJwb2xhdGVkXG5cbiAgICBmdW5jdGlvbiBpbnNlcnRSZXBsYWNlbWVudCAoc291cmNlLCByeCwgcmVwbGFjZW1lbnQpIHtcbiAgICAgIGNvbnN0IG5ld1BhcnRzID0gW11cbiAgICAgIHNvdXJjZS5mb3JFYWNoKChjaHVuaykgPT4ge1xuICAgICAgICBzcGxpdC5jYWxsKGNodW5rLCByeCkuZm9yRWFjaCgocmF3LCBpLCBsaXN0KSA9PiB7XG4gICAgICAgICAgaWYgKHJhdyAhPT0gJycpIHtcbiAgICAgICAgICAgIG5ld1BhcnRzLnB1c2gocmF3KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEludGVybGFjZSB3aXRoIHRoZSBgcmVwbGFjZW1lbnRgIHZhbHVlXG4gICAgICAgICAgaWYgKGkgPCBsaXN0Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIG5ld1BhcnRzLnB1c2gocmVwbGFjZW1lbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIHJldHVybiBuZXdQYXJ0c1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMgdHJhbnNsYXRlIG1ldGhvZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIHdpdGggdmFsdWVzIHRoYXQgd2lsbCBiZSB1c2VkIGxhdGVyIHRvIHJlcGxhY2UgcGxhY2Vob2xkZXJzIGluIHN0cmluZ1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0cmFuc2xhdGVkIChhbmQgaW50ZXJwb2xhdGVkKVxuICAgKi9cbiAgdHJhbnNsYXRlIChrZXksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVBcnJheShrZXksIG9wdGlvbnMpLmpvaW4oJycpXG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdHJhbnNsYXRpb24gYW5kIHJldHVybiB0aGUgdHJhbnNsYXRlZCBhbmQgaW50ZXJwb2xhdGVkIHBhcnRzIGFzIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIHdpdGggdmFsdWVzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHJlcGxhY2UgcGxhY2Vob2xkZXJzXG4gICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHRyYW5zbGF0ZWQgYW5kIGludGVycG9sYXRlZCBwYXJ0cywgaW4gb3JkZXIuXG4gICAqL1xuICB0cmFuc2xhdGVBcnJheSAoa2V5LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuc21hcnRfY291bnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgcGx1cmFsID0gdGhpcy5sb2NhbGUucGx1cmFsaXplKG9wdGlvbnMuc21hcnRfY291bnQpXG4gICAgICByZXR1cm4gdGhpcy5pbnRlcnBvbGF0ZSh0aGlzLmxvY2FsZS5zdHJpbmdzW2tleV1bcGx1cmFsXSwgb3B0aW9ucylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5pbnRlcnBvbGF0ZSh0aGlzLmxvY2FsZS5zdHJpbmdzW2tleV0sIG9wdGlvbnMpXG4gIH1cbn1cbiIsImNvbnN0IGRhdGFVUkl0b0Jsb2IgPSByZXF1aXJlKCcuL2RhdGFVUkl0b0Jsb2InKVxuXG4vKipcbiAqIFNhdmUgYSA8Y2FudmFzPiBlbGVtZW50J3MgY29udGVudCB0byBhIEJsb2Igb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FudmFzVG9CbG9iIChjYW52YXMsIHR5cGUsIHF1YWxpdHkpIHtcbiAgaWYgKGNhbnZhcy50b0Jsb2IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNhbnZhcy50b0Jsb2IocmVzb2x2ZSwgdHlwZSwgcXVhbGl0eSlcbiAgICB9KVxuICB9XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICByZXR1cm4gZGF0YVVSSXRvQmxvYihjYW52YXMudG9EYXRhVVJMKHR5cGUsIHF1YWxpdHkpLCB7fSlcbiAgfSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGF0YVVSSXRvQmxvYiAoZGF0YVVSSSwgb3B0cywgdG9GaWxlKSB7XG4gIC8vIGdldCB0aGUgYmFzZTY0IGRhdGFcbiAgY29uc3QgZGF0YSA9IGRhdGFVUkkuc3BsaXQoJywnKVsxXVxuXG4gIC8vIHVzZXIgbWF5IHByb3ZpZGUgbWltZSB0eXBlLCBpZiBub3QgZ2V0IGl0IGZyb20gZGF0YSBVUklcbiAgbGV0IG1pbWVUeXBlID0gb3B0cy5taW1lVHlwZSB8fCBkYXRhVVJJLnNwbGl0KCcsJylbMF0uc3BsaXQoJzonKVsxXS5zcGxpdCgnOycpWzBdXG5cbiAgLy8gZGVmYXVsdCB0byBwbGFpbi90ZXh0IGlmIGRhdGEgVVJJIGhhcyBubyBtaW1lVHlwZVxuICBpZiAobWltZVR5cGUgPT0gbnVsbCkge1xuICAgIG1pbWVUeXBlID0gJ3BsYWluL3RleHQnXG4gIH1cblxuICBjb25zdCBiaW5hcnkgPSBhdG9iKGRhdGEpXG4gIGNvbnN0IGFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnkubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheS5wdXNoKGJpbmFyeS5jaGFyQ29kZUF0KGkpKVxuICB9XG5cbiAgbGV0IGJ5dGVzXG4gIHRyeSB7XG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb21wYXQvY29tcGF0XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBDb252ZXJ0IHRvIGEgRmlsZT9cbiAgaWYgKHRvRmlsZSkge1xuICAgIHJldHVybiBuZXcgRmlsZShbYnl0ZXNdLCBvcHRzLm5hbWUgfHwgJycsIHsgdHlwZTogbWltZVR5cGUgfSlcbiAgfVxuXG4gIHJldHVybiBuZXcgQmxvYihbYnl0ZXNdLCB7IHR5cGU6IG1pbWVUeXBlIH0pXG59XG4iLCJjb25zdCB0aHJvdHRsZSA9IHJlcXVpcmUoJ2xvZGFzaC50aHJvdHRsZScpXG5cbmZ1bmN0aW9uIF9lbWl0U29ja2V0UHJvZ3Jlc3MgKHVwbG9hZGVyLCBwcm9ncmVzc0RhdGEsIGZpbGUpIHtcbiAgY29uc3QgeyBwcm9ncmVzcywgYnl0ZXNVcGxvYWRlZCwgYnl0ZXNUb3RhbCB9ID0gcHJvZ3Jlc3NEYXRhXG4gIGlmIChwcm9ncmVzcykge1xuICAgIHVwbG9hZGVyLnVwcHkubG9nKGBVcGxvYWQgcHJvZ3Jlc3M6ICR7cHJvZ3Jlc3N9YClcbiAgICB1cGxvYWRlci51cHB5LmVtaXQoJ3VwbG9hZC1wcm9ncmVzcycsIGZpbGUsIHtcbiAgICAgIHVwbG9hZGVyLFxuICAgICAgYnl0ZXNVcGxvYWRlZDogYnl0ZXNVcGxvYWRlZCxcbiAgICAgIGJ5dGVzVG90YWw6IGJ5dGVzVG90YWxcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGUoX2VtaXRTb2NrZXRQcm9ncmVzcywgMzAwLCB7XG4gIGxlYWRpbmc6IHRydWUsXG4gIHRyYWlsaW5nOiB0cnVlXG59KVxuIiwiY29uc3QgaXNET01FbGVtZW50ID0gcmVxdWlyZSgnLi9pc0RPTUVsZW1lbnQnKVxuXG4vKipcbiAqIEZpbmQgb25lIG9yIG1vcmUgRE9NIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50XG4gKiBAcmV0dXJucyB7QXJyYXl8bnVsbH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaW5kQWxsRE9NRWxlbWVudHMgKGVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnQpKVxuICAgIHJldHVybiBlbGVtZW50cy5sZW5ndGggPiAwID8gZWxlbWVudHMgOiBudWxsXG4gIH1cblxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnICYmIGlzRE9NRWxlbWVudChlbGVtZW50KSkge1xuICAgIHJldHVybiBbZWxlbWVudF1cbiAgfVxufVxuIiwiY29uc3QgaXNET01FbGVtZW50ID0gcmVxdWlyZSgnLi9pc0RPTUVsZW1lbnQnKVxuXG4vKipcbiAqIEZpbmQgYSBET00gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge05vZGV8c3RyaW5nfSBlbGVtZW50XG4gKiBAcmV0dXJucyB7Tm9kZXxudWxsfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbmRET01FbGVtZW50IChlbGVtZW50LCBjb250ZXh0ID0gZG9jdW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudClcbiAgfVxuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgaXNET01FbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRcbiAgfVxufVxuIiwiLyoqXG4gKiBUYWtlcyBhIGZpbGUgb2JqZWN0IGFuZCB0dXJucyBpdCBpbnRvIGZpbGVJRCwgYnkgY29udmVydGluZyBmaWxlLm5hbWUgdG8gbG93ZXJjYXNlLFxuICogcmVtb3ZpbmcgZXh0cmEgY2hhcmFjdGVycyBhbmQgYWRkaW5nIHR5cGUsIHNpemUgYW5kIGxhc3RNb2RpZmllZFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBmaWxlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZmlsZUlEXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVGaWxlSUQgKGZpbGUpIHtcbiAgLy8gSXQncyB0ZW1wdGluZyB0byBkbyBgW2l0ZW1zXS5maWx0ZXIoQm9vbGVhbikuam9pbignLScpYCBoZXJlLCBidXQgdGhhdFxuICAvLyBpcyBzbG93ZXIhIHNpbXBsZSBzdHJpbmcgY29uY2F0ZW5hdGlvbiBpcyBmYXN0XG5cbiAgbGV0IGlkID0gJ3VwcHknXG4gIGlmICh0eXBlb2YgZmlsZS5uYW1lID09PSAnc3RyaW5nJykge1xuICAgIGlkICs9ICctJyArIGVuY29kZUZpbGVuYW1lKGZpbGUubmFtZS50b0xvd2VyQ2FzZSgpKVxuICB9XG5cbiAgaWYgKGZpbGUudHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWQgKz0gJy0nICsgZmlsZS50eXBlXG4gIH1cblxuICBpZiAoZmlsZS5tZXRhICYmIHR5cGVvZiBmaWxlLm1ldGEucmVsYXRpdmVQYXRoID09PSAnc3RyaW5nJykge1xuICAgIGlkICs9ICctJyArIGVuY29kZUZpbGVuYW1lKGZpbGUubWV0YS5yZWxhdGl2ZVBhdGgudG9Mb3dlckNhc2UoKSlcbiAgfVxuXG4gIGlmIChmaWxlLmRhdGEuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWQgKz0gJy0nICsgZmlsZS5kYXRhLnNpemVcbiAgfVxuICBpZiAoZmlsZS5kYXRhLmxhc3RNb2RpZmllZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWQgKz0gJy0nICsgZmlsZS5kYXRhLmxhc3RNb2RpZmllZFxuICB9XG5cbiAgcmV0dXJuIGlkXG59XG5cbmZ1bmN0aW9uIGVuY29kZUZpbGVuYW1lIChuYW1lKSB7XG4gIGxldCBzdWZmaXggPSAnJ1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKC9bXkEtWjAtOV0vaWcsIChjaGFyYWN0ZXIpID0+IHtcbiAgICBzdWZmaXggKz0gJy0nICsgZW5jb2RlQ2hhcmFjdGVyKGNoYXJhY3RlcilcbiAgICByZXR1cm4gJy8nXG4gIH0pICsgc3VmZml4XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNoYXJhY3RlciAoY2hhcmFjdGVyKSB7XG4gIHJldHVybiBjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKS50b1N0cmluZygzMilcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0Qnl0ZXNSZW1haW5pbmcgKGZpbGVQcm9ncmVzcykge1xuICByZXR1cm4gZmlsZVByb2dyZXNzLmJ5dGVzVG90YWwgLSBmaWxlUHJvZ3Jlc3MuYnl0ZXNVcGxvYWRlZFxufVxuIiwiY29uc3Qgd2Via2l0R2V0QXNFbnRyeUFwaSA9IHJlcXVpcmUoJy4vdXRpbHMvd2Via2l0R2V0QXNFbnRyeUFwaS9pbmRleCcpXG5jb25zdCBmYWxsYmFja0FwaSA9IHJlcXVpcmUoJy4vdXRpbHMvZmFsbGJhY2tBcGknKVxuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGFycmF5IG9mIGRyb3BwZWQgZmlsZXMgKGlmIGEgZm9sZGVyIGlzIGRyb3BwZWQsIGFuZCBicm93c2VyIHN1cHBvcnRzIGZvbGRlciBwYXJzaW5nIC0gcHJvbWlzZSByZXNvbHZlcyB0byB0aGUgZmxhdCBhcnJheSBvZiBhbGwgZmlsZXMgaW4gYWxsIGRpcmVjdG9yaWVzKS5cbiAqIEVhY2ggZmlsZSBoYXMgLnJlbGF0aXZlUGF0aCBwcm9wIGFwcGVuZGVkIHRvIGl0IChlLmcuIFwiL2RvY3MvUHJhZ3VlL3RpY2tldF9mcm9tX3ByYWd1ZV90b191ZmEucGRmXCIpIGlmIGJyb3dzZXIgc3VwcG9ydHMgaXQuIE90aGVyd2lzZSBpdCdzIHVuZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0ge0RhdGFUcmFuc2Zlcn0gZGF0YVRyYW5zZmVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsb2dEcm9wRXJyb3IgLSBhIGZ1bmN0aW9uIHRoYXQncyBjYWxsZWQgZXZlcnkgdGltZSBzb21lIGZvbGRlciBvciBzb21lIGZpbGUgZXJyb3Igb3V0IChlLmcuIGJlY2F1c2Ugb2YgdGhlIGZvbGRlciBuYW1lIGJlaW5nIHRvbyBsb25nIG9uIFdpbmRvd3MpLiBOb3RpY2UgdGhhdCByZXN1bHRpbmcgcHJvbWlzZSB3aWxsIGFsd2F5cyBiZSByZXNvbHZlZCBhbnl3YXkuXG4gKlxuICogQHJldHVybnMge1Byb21pc2V9IC0gQXJyYXk8RmlsZT5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXREcm9wcGVkRmlsZXMgKGRhdGFUcmFuc2ZlciwgeyBsb2dEcm9wRXJyb3IgPSAoKSA9PiB7fSB9ID0ge30pIHtcbiAgLy8gR2V0IGFsbCBmaWxlcyBmcm9tIGFsbCBzdWJkaXJzLiBXb3JrcyAoYXQgbGVhc3QpIGluIENocm9tZSwgTW96aWxsYSwgYW5kIFNhZmFyaVxuICBpZiAoZGF0YVRyYW5zZmVyLml0ZW1zICYmIGRhdGFUcmFuc2Zlci5pdGVtc1swXSAmJiAnd2Via2l0R2V0QXNFbnRyeScgaW4gZGF0YVRyYW5zZmVyLml0ZW1zWzBdKSB7XG4gICAgcmV0dXJuIHdlYmtpdEdldEFzRW50cnlBcGkoZGF0YVRyYW5zZmVyLCBsb2dEcm9wRXJyb3IpXG4gIC8vIE90aGVyd2lzZSBqdXN0IHJldHVybiBhbGwgZmlyc3Qtb3JkZXIgZmlsZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsbGJhY2tBcGkoZGF0YVRyYW5zZmVyKVxuICB9XG59XG4iLCJjb25zdCB0b0FycmF5ID0gcmVxdWlyZSgnLi4vLi4vdG9BcnJheScpXG5cbi8vIC5maWxlcyBmYWxsYmFjaywgc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIGFueSBicm93c2VyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZhbGxiYWNrQXBpIChkYXRhVHJhbnNmZXIpIHtcbiAgY29uc3QgZmlsZXMgPSB0b0FycmF5KGRhdGFUcmFuc2Zlci5maWxlcylcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmaWxlcylcbn1cbiIsIi8qKlxuICogUmVjdXJzaXZlIGZ1bmN0aW9uLCBjYWxscyB0aGUgb3JpZ2luYWwgY2FsbGJhY2soKSB3aGVuIHRoZSBkaXJlY3RvcnkgaXMgZW50aXJlbHkgcGFyc2VkLlxuICpcbiAqIEBwYXJhbSB7RmlsZVN5c3RlbURpcmVjdG9yeVJlYWRlcn0gZGlyZWN0b3J5UmVhZGVyXG4gKiBAcGFyYW0ge0FycmF5fSBvbGRFbnRyaWVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsb2dEcm9wRXJyb3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gY2FsbGVkIHdpdGggKFsgYWxsIGZpbGVzIGFuZCBkaXJlY3RvcmllcyBpbiB0aGF0IGRpcmVjdG9yeVJlYWRlciBdKVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEZpbGVzQW5kRGlyZWN0b3JpZXNGcm9tRGlyZWN0b3J5IChkaXJlY3RvcnlSZWFkZXIsIG9sZEVudHJpZXMsIGxvZ0Ryb3BFcnJvciwgeyBvblN1Y2Nlc3MgfSkge1xuICBkaXJlY3RvcnlSZWFkZXIucmVhZEVudHJpZXMoXG4gICAgKGVudHJpZXMpID0+IHtcbiAgICAgIGNvbnN0IG5ld0VudHJpZXMgPSBbLi4ub2xkRW50cmllcywgLi4uZW50cmllc11cbiAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgRmlsZVN5c3RlbSBBUEkgc3BlYywgZ2V0RmlsZXNBbmREaXJlY3Rvcmllc0Zyb21EaXJlY3RvcnkoKSBtdXN0IGJlIGNhbGxlZCB1bnRpbCBpdCBjYWxscyB0aGUgb25TdWNjZXNzIHdpdGggYW4gZW1wdHkgYXJyYXkuXG4gICAgICBpZiAoZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgZ2V0RmlsZXNBbmREaXJlY3Rvcmllc0Zyb21EaXJlY3RvcnkoZGlyZWN0b3J5UmVhZGVyLCBuZXdFbnRyaWVzLCBsb2dEcm9wRXJyb3IsIHsgb25TdWNjZXNzIH0pXG4gICAgICAgIH0sIDApXG4gICAgICAvLyBEb25lIGl0ZXJhdGluZyB0aGlzIHBhcnRpY3VsYXIgZGlyZWN0b3J5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblN1Y2Nlc3MobmV3RW50cmllcylcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIE1ha2Ugc3VyZSB3ZSByZXNvbHZlIG9uIGVycm9yIGFueXdheSwgaXQncyBmaW5lIGlmIG9ubHkgb25lIGRpcmVjdG9yeSBjb3VsZG4ndCBiZSBwYXJzZWQhXG4gICAgKGVycm9yKSA9PiB7XG4gICAgICBsb2dEcm9wRXJyb3IoZXJyb3IpXG4gICAgICBvblN1Y2Nlc3Mob2xkRW50cmllcylcbiAgICB9XG4gIClcbn1cbiIsIi8qKlxuICogR2V0IHRoZSByZWxhdGl2ZSBwYXRoIGZyb20gdGhlIEZpbGVFbnRyeSNmdWxsUGF0aCwgYmVjYXVzZSBGaWxlI3dlYmtpdFJlbGF0aXZlUGF0aCBpcyBhbHdheXMgJycsIGF0IGxlYXN0IG9uRHJvcC5cbiAqXG4gKiBAcGFyYW0ge0ZpbGVFbnRyeX0gZmlsZUVudHJ5XG4gKlxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSAtIGlmIGZpbGUgaXMgbm90IGluIGEgZm9sZGVyIC0gcmV0dXJuIG51bGwgKHRoaXMgaXMgdG8gYmUgY29uc2lzdGVudCB3aXRoIC5yZWxhdGl2ZVBhdGgtcyBvZiBmaWxlcyBzZWxlY3RlZCBmcm9tIE15IERldmljZSkuIElmIGZpbGUgaXMgaW4gYSBmb2xkZXIgLSByZXR1cm4gaXRzIGZ1bGxQYXRoLCBlLmcuICcvc2ltcHNvbnMvaGkuanBlZycuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UmVsYXRpdmVQYXRoIChmaWxlRW50cnkpIHtcbiAgLy8gZmlsZUVudHJ5LmZ1bGxQYXRoIC0gXCIvc2ltcHNvbnMvaGkuanBlZ1wiIG9yIHVuZGVmaW5lZCAoZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBpdClcbiAgLy8gZmlsZUVudHJ5Lm5hbWUgLSBcImhpLmpwZWdcIlxuICBpZiAoIWZpbGVFbnRyeS5mdWxsUGF0aCB8fCBmaWxlRW50cnkuZnVsbFBhdGggPT09ICcvJyArIGZpbGVFbnRyeS5uYW1lKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmlsZUVudHJ5LmZ1bGxQYXRoXG4gIH1cbn1cbiIsImNvbnN0IHRvQXJyYXkgPSByZXF1aXJlKCcuLi8uLi8uLi90b0FycmF5JylcbmNvbnN0IGdldFJlbGF0aXZlUGF0aCA9IHJlcXVpcmUoJy4vZ2V0UmVsYXRpdmVQYXRoJylcbmNvbnN0IGdldEZpbGVzQW5kRGlyZWN0b3JpZXNGcm9tRGlyZWN0b3J5ID0gcmVxdWlyZSgnLi9nZXRGaWxlc0FuZERpcmVjdG9yaWVzRnJvbURpcmVjdG9yeScpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2Via2l0R2V0QXNFbnRyeUFwaSAoZGF0YVRyYW5zZmVyLCBsb2dEcm9wRXJyb3IpIHtcbiAgY29uc3QgZmlsZXMgPSBbXVxuXG4gIGNvbnN0IHJvb3RQcm9taXNlcyA9IFtdXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByZXNvbHZlZCBwcm9taXNlLCB3aGVuIDpmaWxlcyBhcnJheSBpcyBlbmhhbmNlZFxuICAgKlxuICAgKiBAcGFyYW0geyhGaWxlU3lzdGVtRmlsZUVudHJ5fEZpbGVTeXN0ZW1EaXJlY3RvcnlFbnRyeSl9IGVudHJ5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSAtIGVtcHR5IHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIDpmaWxlcyBpcyBlbmhhbmNlZCB3aXRoIGEgZmlsZVxuICAgKi9cbiAgY29uc3QgY3JlYXRlUHJvbWlzZVRvQWRkRmlsZU9yUGFyc2VEaXJlY3RvcnkgPSAoZW50cnkpID0+XG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIC8vIFRoaXMgaXMgYSBiYXNlIGNhbGxcbiAgICAgIGlmIChlbnRyeS5pc0ZpbGUpIHtcbiAgICAgICAgLy8gQ3JlYXRlcyBhIG5ldyBGaWxlIG9iamVjdCB3aGljaCBjYW4gYmUgdXNlZCB0byByZWFkIHRoZSBmaWxlLlxuICAgICAgICBlbnRyeS5maWxlKFxuICAgICAgICAgIChmaWxlKSA9PiB7XG4gICAgICAgICAgICBmaWxlLnJlbGF0aXZlUGF0aCA9IGdldFJlbGF0aXZlUGF0aChlbnRyeSlcbiAgICAgICAgICAgIGZpbGVzLnB1c2goZmlsZSlcbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHJlc29sdmUgb24gZXJyb3IgYW55d2F5LCBpdCdzIGZpbmUgaWYgb25seSBvbmUgZmlsZSBjb3VsZG4ndCBiZSByZWFkIVxuICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgbG9nRHJvcEVycm9yKGVycm9yKVxuICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICAvLyBUaGlzIGlzIGEgcmVjdXJzaXZlIGNhbGxcbiAgICAgIH0gZWxzZSBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgY29uc3QgZGlyZWN0b3J5UmVhZGVyID0gZW50cnkuY3JlYXRlUmVhZGVyKClcbiAgICAgICAgZ2V0RmlsZXNBbmREaXJlY3Rvcmllc0Zyb21EaXJlY3RvcnkoZGlyZWN0b3J5UmVhZGVyLCBbXSwgbG9nRHJvcEVycm9yLCB7XG4gICAgICAgICAgb25TdWNjZXNzOiAoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBlbnRyaWVzLm1hcCgoZW50cnkpID0+IGNyZWF0ZVByb21pc2VUb0FkZEZpbGVPclBhcnNlRGlyZWN0b3J5KGVudHJ5KSlcbiAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHJlc29sdmUoKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcblxuICAvLyBGb3IgZWFjaCBkcm9wcGVkIGl0ZW0sIC0gbWFrZSBzdXJlIGl0J3MgYSBmaWxlL2RpcmVjdG9yeSwgYW5kIHN0YXJ0IGRlZXBlbmluZyBpbiFcbiAgdG9BcnJheShkYXRhVHJhbnNmZXIuaXRlbXMpXG4gICAgLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gaXRlbS53ZWJraXRHZXRBc0VudHJ5KClcbiAgICAgIC8vIDplbnRyeSBjYW4gYmUgbnVsbCB3aGVuIHdlIGRyb3AgdGhlIHVybCBlLmcuXG4gICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgcm9vdFByb21pc2VzLnB1c2goY3JlYXRlUHJvbWlzZVRvQWRkRmlsZU9yUGFyc2VEaXJlY3RvcnkoZW50cnkpKVxuICAgICAgfVxuICAgIH0pXG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKHJvb3RQcm9taXNlcylcbiAgICAudGhlbigoKSA9PiBmaWxlcylcbn1cbiIsIi8qKlxuICogVGFrZXMgYSBmdWxsIGZpbGVuYW1lIHN0cmluZyBhbmQgcmV0dXJucyBhbiBvYmplY3Qge25hbWUsIGV4dGVuc2lvbn1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZnVsbEZpbGVOYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fSB7bmFtZSwgZXh0ZW5zaW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEZpbGVOYW1lQW5kRXh0ZW5zaW9uIChmdWxsRmlsZU5hbWUpIHtcbiAgY29uc3QgbGFzdERvdCA9IGZ1bGxGaWxlTmFtZS5sYXN0SW5kZXhPZignLicpXG4gIC8vIHRoZXNlIGNvdW50IGFzIG5vIGV4dGVuc2lvbjogXCJuby1kb3RcIiwgXCJ0cmFpbGluZy1kb3QuXCJcbiAgaWYgKGxhc3REb3QgPT09IC0xIHx8IGxhc3REb3QgPT09IGZ1bGxGaWxlTmFtZS5sZW5ndGggLSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IGZ1bGxGaWxlTmFtZSxcbiAgICAgIGV4dGVuc2lvbjogdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBmdWxsRmlsZU5hbWUuc2xpY2UoMCwgbGFzdERvdCksXG4gICAgICBleHRlbnNpb246IGZ1bGxGaWxlTmFtZS5zbGljZShsYXN0RG90ICsgMSlcbiAgICB9XG4gIH1cbn1cbiIsImNvbnN0IGdldEZpbGVOYW1lQW5kRXh0ZW5zaW9uID0gcmVxdWlyZSgnLi9nZXRGaWxlTmFtZUFuZEV4dGVuc2lvbicpXG5jb25zdCBtaW1lVHlwZXMgPSByZXF1aXJlKCcuL21pbWVUeXBlcycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RmlsZVR5cGUgKGZpbGUpIHtcbiAgbGV0IGZpbGVFeHRlbnNpb24gPSBmaWxlLm5hbWUgPyBnZXRGaWxlTmFtZUFuZEV4dGVuc2lvbihmaWxlLm5hbWUpLmV4dGVuc2lvbiA6IG51bGxcbiAgZmlsZUV4dGVuc2lvbiA9IGZpbGVFeHRlbnNpb24gPyBmaWxlRXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCkgOiBudWxsXG5cbiAgaWYgKGZpbGUudHlwZSkge1xuICAgIC8vIGlmIG1pbWUgdHlwZSBpcyBzZXQgaW4gdGhlIGZpbGUgb2JqZWN0IGFscmVhZHksIHVzZSB0aGF0XG4gICAgcmV0dXJuIGZpbGUudHlwZVxuICB9IGVsc2UgaWYgKGZpbGVFeHRlbnNpb24gJiYgbWltZVR5cGVzW2ZpbGVFeHRlbnNpb25dKSB7XG4gICAgLy8gZWxzZSwgc2VlIGlmIHdlIGNhbiBtYXAgZXh0ZW5zaW9uIHRvIGEgbWltZSB0eXBlXG4gICAgcmV0dXJuIG1pbWVUeXBlc1tmaWxlRXh0ZW5zaW9uXVxuICB9IGVsc2Uge1xuICAgIC8vIGlmIGFsbCBmYWlscywgZmFsbCBiYWNrIHRvIGEgZ2VuZXJpYyBieXRlIHN0cmVhbSB0eXBlXG4gICAgcmV0dXJuICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG4gIH1cbn1cbiIsIi8vIFRPRE8gQ2hlY2sgd2hpY2ggdHlwZXMgYXJlIGFjdHVhbGx5IHN1cHBvcnRlZCBpbiBicm93c2Vycy4gQ2hyb21lIGxpa2VzIHdlYm1cbi8vIGZyb20gbXkgdGVzdGluZywgYnV0IHdlIG1heSBuZWVkIG1vcmUuXG4vLyBXZSBjb3VsZCB1c2UgYSBsaWJyYXJ5IGJ1dCB0aGV5IHRlbmQgdG8gY29udGFpbiBkb3plbnMgb2YgS0JzIG9mIG1hcHBpbmdzLFxuLy8gbW9zdCBvZiB3aGljaCB3aWxsIGdvIHVudXNlZCwgc28gbm90IHN1cmUgaWYgdGhhdCdzIHdvcnRoIGl0LlxuY29uc3QgbWltZVRvRXh0ZW5zaW9ucyA9IHtcbiAgJ3ZpZGVvL29nZyc6ICdvZ3YnLFxuICAnYXVkaW8vb2dnJzogJ29nZycsXG4gICd2aWRlby93ZWJtJzogJ3dlYm0nLFxuICAnYXVkaW8vd2VibSc6ICd3ZWJtJyxcbiAgJ3ZpZGVvL3gtbWF0cm9za2EnOiAnbWt2JyxcbiAgJ3ZpZGVvL21wNCc6ICdtcDQnLFxuICAnYXVkaW8vbXAzJzogJ21wMydcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRGaWxlVHlwZUV4dGVuc2lvbiAobWltZVR5cGUpIHtcbiAgLy8gUmVtb3ZlIHRoZSA7IGJpdCBpbiAndmlkZW8veC1tYXRyb3NrYTtjb2RlY3M9YXZjMSdcbiAgbWltZVR5cGUgPSBtaW1lVHlwZS5yZXBsYWNlKC87LiokLywgJycpXG4gIHJldHVybiBtaW1lVG9FeHRlbnNpb25zW21pbWVUeXBlXSB8fCBudWxsXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNvY2tldEhvc3QgKHVybCkge1xuICAvLyBnZXQgdGhlIGhvc3QgZG9tYWluXG4gIHZhciByZWdleCA9IC9eKD86aHR0cHM/OlxcL1xcL3xcXC9cXC8pPyg/OlteQFxcbl0rQCk/KD86d3d3XFwuKT8oW15cXG5dKykvaVxuICB2YXIgaG9zdCA9IHJlZ2V4LmV4ZWModXJsKVsxXVxuICB2YXIgc29ja2V0UHJvdG9jb2wgPSAvXmh0dHA6XFwvXFwvL2kudGVzdCh1cmwpID8gJ3dzJyA6ICd3c3MnXG5cbiAgcmV0dXJuIGAke3NvY2tldFByb3RvY29sfTovLyR7aG9zdH1gXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNwZWVkIChmaWxlUHJvZ3Jlc3MpIHtcbiAgaWYgKCFmaWxlUHJvZ3Jlc3MuYnl0ZXNVcGxvYWRlZCkgcmV0dXJuIDBcblxuICBjb25zdCB0aW1lRWxhcHNlZCA9IChuZXcgRGF0ZSgpKSAtIGZpbGVQcm9ncmVzcy51cGxvYWRTdGFydGVkXG4gIGNvbnN0IHVwbG9hZFNwZWVkID0gZmlsZVByb2dyZXNzLmJ5dGVzVXBsb2FkZWQgLyAodGltZUVsYXBzZWQgLyAxMDAwKVxuICByZXR1cm4gdXBsb2FkU3BlZWRcbn1cbiIsIi8qKlxuICogUmV0dXJucyBhIHRpbWVzdGFtcCBpbiB0aGUgZm9ybWF0IG9mIGBob3VyczptaW51dGVzOnNlY29uZHNgXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0VGltZVN0YW1wICgpIHtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpXG4gIHZhciBob3VycyA9IHBhZChkYXRlLmdldEhvdXJzKCkudG9TdHJpbmcoKSlcbiAgdmFyIG1pbnV0ZXMgPSBwYWQoZGF0ZS5nZXRNaW51dGVzKCkudG9TdHJpbmcoKSlcbiAgdmFyIHNlY29uZHMgPSBwYWQoZGF0ZS5nZXRTZWNvbmRzKCkudG9TdHJpbmcoKSlcbiAgcmV0dXJuIGhvdXJzICsgJzonICsgbWludXRlcyArICc6JyArIHNlY29uZHNcbn1cblxuLyoqXG4gKiBBZGRzIHplcm8gdG8gc3RyaW5ncyBzaG9ydGVyIHRoYW4gdHdvIGNoYXJhY3RlcnNcbiAqL1xuZnVuY3Rpb24gcGFkIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5sZW5ndGggIT09IDIgPyAwICsgc3RyIDogc3RyXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhcyAob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSlcbn1cbiIsIi8qKlxuICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGEgRE9NIGVsZW1lbnQuIER1Y2stdHlwaW5nIGJhc2VkIG9uIGBub2RlVHlwZWAuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0RPTUVsZW1lbnQgKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iai5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREVcbn1cbiIsIi8qKlxuICogQ2hlY2sgaWYgYSBVUkwgc3RyaW5nIGlzIGFuIG9iamVjdCBVUkwgZnJvbSBgVVJMLmNyZWF0ZU9iamVjdFVSTGAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNPYmplY3RVUkwgKHVybCkge1xuICByZXR1cm4gdXJsLmluZGV4T2YoJ2Jsb2I6JykgPT09IDBcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQcmV2aWV3U3VwcG9ydGVkIChmaWxlVHlwZSkge1xuICBpZiAoIWZpbGVUeXBlKSByZXR1cm4gZmFsc2VcbiAgY29uc3QgZmlsZVR5cGVTcGVjaWZpYyA9IGZpbGVUeXBlLnNwbGl0KCcvJylbMV1cbiAgLy8gbGlzdCBvZiBpbWFnZXMgdGhhdCBicm93c2VycyBjYW4gcHJldmlld1xuICBpZiAoL14oanBlP2d8Z2lmfHBuZ3xzdmd8c3ZnXFwreG1sfGJtcHx3ZWJwKSQvLnRlc3QoZmlsZVR5cGVTcGVjaWZpYykpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1RvdWNoRGV2aWNlICgpIHtcbiAgLy8gd29ya3Mgb24gbW9zdCBicm93c2Vyc1xuICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIHdvcmtzIG9uIElFMTAvMTEgYW5kIFN1cmZhY2VcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgcmV0dXJuICEhbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzXG59XG4iLCIvLyBfX19XaHkgbm90IGFkZCB0aGUgbWltZS10eXBlcyBwYWNrYWdlP1xuLy8gICAgSXQncyAxOS43a0IgZ3ppcHBlZCwgYW5kIHdlIG9ubHkgbmVlZCBtaW1lIHR5cGVzIGZvciB3ZWxsLWtub3duIGV4dGVuc2lvbnMgKGZvciBmaWxlIHByZXZpZXdzKS5cbi8vIF9fX1doZXJlIHRvIHRha2UgbmV3IGV4dGVuc2lvbnMgZnJvbT9cbi8vICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9qc2h0dHAvbWltZS1kYi9ibG9iL21hc3Rlci9kYi5qc29uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtZDogJ3RleHQvbWFya2Rvd24nLFxuICBtYXJrZG93bjogJ3RleHQvbWFya2Rvd24nLFxuICBtcDQ6ICd2aWRlby9tcDQnLFxuICBtcDM6ICdhdWRpby9tcDMnLFxuICBzdmc6ICdpbWFnZS9zdmcreG1sJyxcbiAganBnOiAnaW1hZ2UvanBlZycsXG4gIHBuZzogJ2ltYWdlL3BuZycsXG4gIGdpZjogJ2ltYWdlL2dpZicsXG4gIGhlaWM6ICdpbWFnZS9oZWljJyxcbiAgaGVpZjogJ2ltYWdlL2hlaWYnLFxuICB5YW1sOiAndGV4dC95YW1sJyxcbiAgeW1sOiAndGV4dC95YW1sJyxcbiAgY3N2OiAndGV4dC9jc3YnLFxuICBhdmk6ICd2aWRlby94LW1zdmlkZW8nLFxuICBta3M6ICd2aWRlby94LW1hdHJvc2thJyxcbiAgbWt2OiAndmlkZW8veC1tYXRyb3NrYScsXG4gIG1vdjogJ3ZpZGVvL3F1aWNrdGltZScsXG4gIGRvYzogJ2FwcGxpY2F0aW9uL21zd29yZCcsXG4gIGRvY206ICdhcHBsaWNhdGlvbi92bmQubXMtd29yZC5kb2N1bWVudC5tYWNyb2VuYWJsZWQuMTInLFxuICBkb2N4OiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnLFxuICBkb3Q6ICdhcHBsaWNhdGlvbi9tc3dvcmQnLFxuICBkb3RtOiAnYXBwbGljYXRpb24vdm5kLm1zLXdvcmQudGVtcGxhdGUubWFjcm9lbmFibGVkLjEyJyxcbiAgZG90eDogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLnRlbXBsYXRlJyxcbiAgeGxhOiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJyxcbiAgeGxhbTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5hZGRpbi5tYWNyb2VuYWJsZWQuMTInLFxuICB4bGM6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICB4bGY6ICdhcHBsaWNhdGlvbi94LXhsaWZmK3htbCcsXG4gIHhsbTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCcsXG4gIHhsczogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCcsXG4gIHhsc2I6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwuc2hlZXQuYmluYXJ5Lm1hY3JvZW5hYmxlZC4xMicsXG4gIHhsc206ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwuc2hlZXQubWFjcm9lbmFibGVkLjEyJyxcbiAgeGxzeDogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0JyxcbiAgeGx0OiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJyxcbiAgeGx0bTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC50ZW1wbGF0ZS5tYWNyb2VuYWJsZWQuMTInLFxuICB4bHR4OiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwudGVtcGxhdGUnLFxuICB4bHc6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICB0eHQ6ICd0ZXh0L3BsYWluJyxcbiAgdGV4dDogJ3RleHQvcGxhaW4nLFxuICBjb25mOiAndGV4dC9wbGFpbicsXG4gIGxvZzogJ3RleHQvcGxhaW4nLFxuICBwZGY6ICdhcHBsaWNhdGlvbi9wZGYnXG59XG4iLCIvLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0ZsZXQvcHJldHRpZXItYnl0ZXMvXG4vLyBDaGFuZ2luZyAxMDAwIGJ5dGVzIHRvIDEwMjQsIHNvIHdlIGNhbiBrZWVwIHVwcGVyY2FzZSBLQiB2cyBrQlxuLy8gSVNDIExpY2Vuc2UgKGMpIERhbiBGbGV0dHJlIGh0dHBzOi8vZ2l0aHViLmNvbS9GbGV0L3ByZXR0aWVyLWJ5dGVzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcblxubW9kdWxlLmV4cG9ydHMgPSBwcmV0dGllckJ5dGVzXG5cbmZ1bmN0aW9uIHByZXR0aWVyQnl0ZXMgKG51bSkge1xuICBpZiAodHlwZW9mIG51bSAhPT0gJ251bWJlcicgfHwgaXNOYU4obnVtKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgbnVtYmVyLCBnb3QgJyArIHR5cGVvZiBudW0pXG4gIH1cblxuICB2YXIgbmVnID0gbnVtIDwgMFxuICB2YXIgdW5pdHMgPSBbJ0InLCAnS0InLCAnTUInLCAnR0InLCAnVEInLCAnUEInLCAnRUInLCAnWkInLCAnWUInXVxuXG4gIGlmIChuZWcpIHtcbiAgICBudW0gPSAtbnVtXG4gIH1cblxuICBpZiAobnVtIDwgMSkge1xuICAgIHJldHVybiAobmVnID8gJy0nIDogJycpICsgbnVtICsgJyBCJ1xuICB9XG5cbiAgdmFyIGV4cG9uZW50ID0gTWF0aC5taW4oTWF0aC5mbG9vcihNYXRoLmxvZyhudW0pIC8gTWF0aC5sb2coMTAyNCkpLCB1bml0cy5sZW5ndGggLSAxKVxuICBudW0gPSBOdW1iZXIobnVtIC8gTWF0aC5wb3coMTAyNCwgZXhwb25lbnQpKVxuICB2YXIgdW5pdCA9IHVuaXRzW2V4cG9uZW50XVxuXG4gIGlmIChudW0gPj0gMTAgfHwgbnVtICUgMSA9PT0gMCkge1xuICAgIC8vIERvIG5vdCBzaG93IGRlY2ltYWxzIHdoZW4gdGhlIG51bWJlciBpcyB0d28tZGlnaXQsIG9yIGlmIHRoZSBudW1iZXIgaGFzIG5vXG4gICAgLy8gZGVjaW1hbCBjb21wb25lbnQuXG4gICAgcmV0dXJuIChuZWcgPyAnLScgOiAnJykgKyBudW0udG9GaXhlZCgwKSArICcgJyArIHVuaXRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKG5lZyA/ICctJyA6ICcnKSArIG51bS50b0ZpeGVkKDEpICsgJyAnICsgdW5pdFxuICB9XG59XG4iLCJjb25zdCBzZWNvbmRzVG9UaW1lID0gcmVxdWlyZSgnLi9zZWNvbmRzVG9UaW1lJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcmV0dHlFVEEgKHNlY29uZHMpIHtcbiAgY29uc3QgdGltZSA9IHNlY29uZHNUb1RpbWUoc2Vjb25kcylcblxuICAvLyBPbmx5IGRpc3BsYXkgaG91cnMgYW5kIG1pbnV0ZXMgaWYgdGhleSBhcmUgZ3JlYXRlciB0aGFuIDAgYnV0IGFsd2F5c1xuICAvLyBkaXNwbGF5IG1pbnV0ZXMgaWYgaG91cnMgaXMgYmVpbmcgZGlzcGxheWVkXG4gIC8vIERpc3BsYXkgYSBsZWFkaW5nIHplcm8gaWYgdGhlIHRoZXJlIGlzIGEgcHJlY2VkaW5nIHVuaXQ6IDFtIDA1cywgYnV0IDVzXG4gIGNvbnN0IGhvdXJzU3RyID0gdGltZS5ob3VycyA/IHRpbWUuaG91cnMgKyAnaCAnIDogJydcbiAgY29uc3QgbWludXRlc1ZhbCA9IHRpbWUuaG91cnMgPyAoJzAnICsgdGltZS5taW51dGVzKS5zdWJzdHIoLTIpIDogdGltZS5taW51dGVzXG4gIGNvbnN0IG1pbnV0ZXNTdHIgPSBtaW51dGVzVmFsID8gbWludXRlc1ZhbCArICdtJyA6ICcnXG4gIGNvbnN0IHNlY29uZHNWYWwgPSBtaW51dGVzVmFsID8gKCcwJyArIHRpbWUuc2Vjb25kcykuc3Vic3RyKC0yKSA6IHRpbWUuc2Vjb25kc1xuICBjb25zdCBzZWNvbmRzU3RyID0gdGltZS5ob3VycyA/ICcnIDogKG1pbnV0ZXNWYWwgPyAnICcgKyBzZWNvbmRzVmFsICsgJ3MnIDogc2Vjb25kc1ZhbCArICdzJylcblxuICByZXR1cm4gYCR7aG91cnNTdHJ9JHttaW51dGVzU3RyfSR7c2Vjb25kc1N0cn1gXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNlY29uZHNUb1RpbWUgKHJhd1NlY29uZHMpIHtcbiAgY29uc3QgaG91cnMgPSBNYXRoLmZsb29yKHJhd1NlY29uZHMgLyAzNjAwKSAlIDI0XG4gIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKHJhd1NlY29uZHMgLyA2MCkgJSA2MFxuICBjb25zdCBzZWNvbmRzID0gTWF0aC5mbG9vcihyYXdTZWNvbmRzICUgNjApXG5cbiAgcmV0dXJuIHsgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUgKHByb21pc2VzKSB7XG4gIGNvbnN0IHJlc29sdXRpb25zID0gW11cbiAgY29uc3QgcmVqZWN0aW9ucyA9IFtdXG4gIGZ1bmN0aW9uIHJlc29sdmVkICh2YWx1ZSkge1xuICAgIHJlc29sdXRpb25zLnB1c2godmFsdWUpXG4gIH1cbiAgZnVuY3Rpb24gcmVqZWN0ZWQgKGVycm9yKSB7XG4gICAgcmVqZWN0aW9ucy5wdXNoKGVycm9yKVxuICB9XG5cbiAgY29uc3Qgd2FpdCA9IFByb21pc2UuYWxsKFxuICAgIHByb21pc2VzLm1hcCgocHJvbWlzZSkgPT4gcHJvbWlzZS50aGVuKHJlc29sdmVkLCByZWplY3RlZCkpXG4gIClcblxuICByZXR1cm4gd2FpdC50aGVuKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2Vzc2Z1bDogcmVzb2x1dGlvbnMsXG4gICAgICBmYWlsZWQ6IHJlamVjdGlvbnNcbiAgICB9XG4gIH0pXG59XG4iLCIvKipcbiAqIENvbnZlcnRzIGxpc3QgaW50byBhcnJheVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QgfHwgW10sIDApXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcIkB1cHB5L3dlYmNhbVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVXBweSBwbHVnaW4gdGhhdCB0YWtlcyBwaG90b3Mgb3IgcmVjb3JkcyB2aWRlb3MgdXNpbmcgdGhlIGRldmljZSdzIGNhbWVyYS5cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS41LjFcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcInN0eWxlXCI6IFwiZGlzdC9zdHlsZS5taW4uY3NzXCIsXG4gIFwidHlwZXNcIjogXCJ0eXBlcy9pbmRleC5kLnRzXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiZmlsZSB1cGxvYWRlclwiLFxuICAgIFwidXBweVwiLFxuICAgIFwidXBweS1wbHVnaW5cIixcbiAgICBcIndlYmNhbVwiLFxuICAgIFwicGljdHVyZVwiLFxuICAgIFwicGhvdG9cIixcbiAgICBcInZpZGVvXCIsXG4gICAgXCJyZWNvcmRcIixcbiAgICBcIm1lZGlhcmVjb3JkZXJcIlxuICBdLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly91cHB5LmlvXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdHJhbnNsb2FkaXQvdXBweS9pc3N1ZXNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS90cmFuc2xvYWRpdC91cHB5LmdpdFwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB1cHB5L3V0aWxzXCI6IFwiZmlsZTouLi91dGlsc1wiLFxuICAgIFwicHJlYWN0XCI6IFwiOC4yLjlcIlxuICB9LFxuICBcInBlZXJEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQHVwcHkvY29yZVwiOiBcIl4xLjAuMFwiXG4gIH1cbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgZmlsbD1cIiMwMDk3RENcIiB3aWR0aD1cIjY2XCIgaGVpZ2h0PVwiNTVcIiB2aWV3Qm94PVwiMCAwIDY2IDU1XCI+XG4gICAgICA8cGF0aCBkPVwiTTU3LjMgOC40MzNjNC41OSAwIDguMSAzLjUxIDguMSA4LjF2MjkuN2MwIDQuNTktMy41MSA4LjEtOC4xIDguMUg4LjdjLTQuNTkgMC04LjEtMy41MS04LjEtOC4xdi0yOS43YzAtNC41OSAzLjUxLTguMSA4LjEtOC4xaDkuNDVsNC41OS03LjAyYy41NC0uNTQgMS4zNS0xLjA4IDIuMTYtMS4wOGgxNi4yYy44MSAwIDEuNjIuNTQgMi4xNiAxLjA4bDQuNTkgNy4wMmg5LjQ1ek0zMyAxNC42NGMtOC42MiAwLTE1LjM5MyA2Ljc3My0xNS4zOTMgMTUuMzkzIDAgOC42MiA2Ljc3MyAxNS4zOTMgMTUuMzkzIDE1LjM5MyA4LjYyIDAgMTUuMzkzLTYuNzczIDE1LjM5My0xNS4zOTMgMC04LjYyLTYuNzczLTE1LjM5My0xNS4zOTMtMTUuMzkzek0zMyA0MGMtNS42NDggMC05Ljk2Ni00LjMxOS05Ljk2Ni05Ljk2NyAwLTUuNjQ3IDQuMzE4LTkuOTY2IDkuOTY2LTkuOTY2czkuOTY2IDQuMzE5IDkuOTY2IDkuOTY2QzQyLjk2NiAzNS42ODEgMzguNjQ4IDQwIDMzIDQwelwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIiAvPlxuICAgIDwvc3ZnPlxuICApXG59XG4iLCJjb25zdCB7IGgsIENvbXBvbmVudCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IFNuYXBzaG90QnV0dG9uID0gcmVxdWlyZSgnLi9TbmFwc2hvdEJ1dHRvbicpXG5jb25zdCBSZWNvcmRCdXR0b24gPSByZXF1aXJlKCcuL1JlY29yZEJ1dHRvbicpXG5jb25zdCBSZWNvcmRpbmdMZW5ndGggPSByZXF1aXJlKCcuL1JlY29yZGluZ0xlbmd0aCcpXG5cbmZ1bmN0aW9uIGlzTW9kZUF2YWlsYWJsZSAobW9kZXMsIG1vZGUpIHtcbiAgcmV0dXJuIG1vZGVzLmluZGV4T2YobW9kZSkgIT09IC0xXG59XG5cbmNsYXNzIENhbWVyYVNjcmVlbiBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICB0aGlzLnByb3BzLm9uRm9jdXMoKVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQgKCkge1xuICAgIHRoaXMucHJvcHMub25TdG9wKClcbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3Qgc2hvdWxkU2hvd1JlY29yZEJ1dHRvbiA9IHRoaXMucHJvcHMuc3VwcG9ydHNSZWNvcmRpbmcgJiYgKFxuICAgICAgaXNNb2RlQXZhaWxhYmxlKHRoaXMucHJvcHMubW9kZXMsICd2aWRlby1vbmx5JykgfHxcbiAgICAgIGlzTW9kZUF2YWlsYWJsZSh0aGlzLnByb3BzLm1vZGVzLCAnYXVkaW8tb25seScpIHx8XG4gICAgICBpc01vZGVBdmFpbGFibGUodGhpcy5wcm9wcy5tb2RlcywgJ3ZpZGVvLWF1ZGlvJylcbiAgICApXG4gICAgY29uc3Qgc2hvdWxkU2hvd1NuYXBzaG90QnV0dG9uID0gaXNNb2RlQXZhaWxhYmxlKHRoaXMucHJvcHMubW9kZXMsICdwaWN0dXJlJylcbiAgICBjb25zdCBzaG91bGRTaG93UmVjb3JkaW5nTGVuZ3RoID0gdGhpcy5wcm9wcy5zdXBwb3J0c1JlY29yZGluZyAmJiB0aGlzLnByb3BzLnNob3dSZWNvcmRpbmdMZW5ndGhcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzPVwidXBweSB1cHB5LVdlYmNhbS1jb250YWluZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVwcHktV2ViY2FtLXZpZGVvQ29udGFpbmVyXCI+XG4gICAgICAgICAgPHZpZGVvIGNsYXNzPXtgdXBweS1XZWJjYW0tdmlkZW8gICR7dGhpcy5wcm9wcy5taXJyb3IgPyAndXBweS1XZWJjYW0tdmlkZW8tLW1pcnJvcmVkJyA6ICcnfWB9IGF1dG9wbGF5IG11dGVkIHBsYXlzaW5saW5lIHNyY09iamVjdD17dGhpcy5wcm9wcy5zcmMgfHwgJyd9IC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwidXBweS1XZWJjYW0tYnV0dG9uQ29udGFpbmVyXCI+XG4gICAgICAgICAge3Nob3VsZFNob3dSZWNvcmRpbmdMZW5ndGggPyBSZWNvcmRpbmdMZW5ndGgodGhpcy5wcm9wcykgOiBudWxsfVxuICAgICAgICAgIHsnICd9XG4gICAgICAgICAge3Nob3VsZFNob3dTbmFwc2hvdEJ1dHRvbiA/IFNuYXBzaG90QnV0dG9uKHRoaXMucHJvcHMpIDogbnVsbH1cbiAgICAgICAgICB7JyAnfVxuICAgICAgICAgIHtzaG91bGRTaG93UmVjb3JkQnV0dG9uID8gUmVjb3JkQnV0dG9uKHRoaXMucHJvcHMpIDogbnVsbH1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYW1lcmFTY3JlZW5cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzPVwidXBweS1XZWJjYW0tcGVybWlzc29uc1wiPlxuICAgICAgPGRpdiBjbGFzcz1cInVwcHktV2ViY2FtLXBlcm1pc3NvbnNJY29uXCI+e3Byb3BzLmljb24oKX08L2Rpdj5cbiAgICAgIDxoMSBjbGFzcz1cInVwcHktV2ViY2FtLXRpdGxlXCI+e3Byb3BzLmkxOG4oJ2FsbG93QWNjZXNzVGl0bGUnKX08L2gxPlxuICAgICAgPHA+e3Byb3BzLmkxOG4oJ2FsbG93QWNjZXNzRGVzY3JpcHRpb24nKX08L3A+XG4gICAgPC9kaXY+XG4gIClcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBSZWNvcmRCdXR0b24gKHsgcmVjb3JkaW5nLCBvblN0YXJ0UmVjb3JkaW5nLCBvblN0b3BSZWNvcmRpbmcsIGkxOG4gfSkge1xuICBpZiAocmVjb3JkaW5nKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxidXR0b25cbiAgICAgICAgY2xhc3M9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LVdlYmNhbS1idXR0b24gdXBweS1XZWJjYW0tYnV0dG9uLS12aWRlb1wiXG4gICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICB0aXRsZT17aTE4bignc3RvcFJlY29yZGluZycpfVxuICAgICAgICBhcmlhLWxhYmVsPXtpMThuKCdzdG9wUmVjb3JkaW5nJyl9XG4gICAgICAgIG9uY2xpY2s9e29uU3RvcFJlY29yZGluZ31cbiAgICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgICAgPlxuICAgICAgICA8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvY3VzYWJsZT1cImZhbHNlXCIgY2xhc3M9XCJVcHB5SWNvblwiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgdmlld0JveD1cIjAgMCAxMDAgMTAwXCI+XG4gICAgICAgICAgPHJlY3QgeD1cIjE1XCIgeT1cIjE1XCIgd2lkdGg9XCI3MFwiIGhlaWdodD1cIjcwXCIgLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2J1dHRvbj5cbiAgICApXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIGNsYXNzPVwidXBweS11LXJlc2V0IHVwcHktYy1idG4gdXBweS1XZWJjYW0tYnV0dG9uIHVwcHktV2ViY2FtLWJ1dHRvbi0tdmlkZW9cIlxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICB0aXRsZT17aTE4bignc3RhcnRSZWNvcmRpbmcnKX1cbiAgICAgIGFyaWEtbGFiZWw9e2kxOG4oJ3N0YXJ0UmVjb3JkaW5nJyl9XG4gICAgICBvbmNsaWNrPXtvblN0YXJ0UmVjb3JkaW5nfVxuICAgICAgZGF0YS11cHB5LXN1cGVyLWZvY3VzYWJsZVxuICAgID5cbiAgICAgIDxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgZm9jdXNhYmxlPVwiZmFsc2VcIiBjbGFzcz1cIlVwcHlJY29uXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiB2aWV3Qm94PVwiMCAwIDEwMCAxMDBcIj5cbiAgICAgICAgPGNpcmNsZSBjeD1cIjUwXCIgY3k9XCI1MFwiIHI9XCI0MFwiIC8+XG4gICAgICA8L3N2Zz5cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgZm9ybWF0U2Vjb25kcyA9IHJlcXVpcmUoJy4vZm9ybWF0U2Vjb25kcycpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gUmVjb3JkaW5nTGVuZ3RoICh7IHJlY29yZGluZ0xlbmd0aFNlY29uZHMsIGkxOG4gfSkge1xuICBjb25zdCBmb3JtYXR0ZWRSZWNvcmRpbmdMZW5ndGhTZWNvbmRzID0gZm9ybWF0U2Vjb25kcyhyZWNvcmRpbmdMZW5ndGhTZWNvbmRzKVxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzcz1cInVwcHktV2ViY2FtLXJlY29yZGluZ0xlbmd0aFwiIGFyaWEtbGFiZWw9e2kxOG4oJ3JlY29yZGluZ0xlbmd0aCcsIHsgcmVjb3JkaW5nX2xlbmd0aDogZm9ybWF0dGVkUmVjb3JkaW5nTGVuZ3RoU2Vjb25kcyB9KX0+XG4gICAgICB7Zm9ybWF0dGVkUmVjb3JkaW5nTGVuZ3RoU2Vjb25kc31cbiAgICA8L2Rpdj5cbiAgKVxufVxuIiwiY29uc3QgeyBoIH0gPSByZXF1aXJlKCdwcmVhY3QnKVxuY29uc3QgQ2FtZXJhSWNvbiA9IHJlcXVpcmUoJy4vQ2FtZXJhSWNvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gKHsgb25TbmFwc2hvdCwgaTE4biB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgY2xhc3M9XCJ1cHB5LXUtcmVzZXQgdXBweS1jLWJ0biB1cHB5LVdlYmNhbS1idXR0b24gdXBweS1XZWJjYW0tYnV0dG9uLS1waWN0dXJlXCJcbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgdGl0bGU9e2kxOG4oJ3Rha2VQaWN0dXJlJyl9XG4gICAgICBhcmlhLWxhYmVsPXtpMThuKCd0YWtlUGljdHVyZScpfVxuICAgICAgb25jbGljaz17b25TbmFwc2hvdH1cbiAgICAgIGRhdGEtdXBweS1zdXBlci1mb2N1c2FibGVcbiAgICA+XG4gICAgICB7Q2FtZXJhSWNvbigpfVxuICAgIDwvYnV0dG9uPlxuICApXG59XG4iLCIvKipcbiAqIFRha2VzIGFuIEludGVnZXIgdmFsdWUgb2Ygc2Vjb25kcyAoZS5nLiA4MykgYW5kIGNvbnZlcnRzIGl0IGludG8gYSBodW1hbi1yZWFkYWJsZSBmb3JtYXR0ZWQgc3RyaW5nIChlLmcuICcxOjIzJykuXG4gKlxuICogQHBhcmFtIHtJbnRlZ2VyfSBzZWNvbmRzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZm9ybWF0dGVkIHNlY29uZHMgKGUuZy4gJzE6MjMnIGZvciAxIG1pbnV0ZSBhbmQgMjMgc2Vjb25kcylcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9ybWF0U2Vjb25kcyAoc2Vjb25kcykge1xuICByZXR1cm4gYCR7TWF0aC5mbG9vcihcbiAgICAgICAgc2Vjb25kcyAvIDYwXG4gICAgICApfToke1N0cmluZyhzZWNvbmRzICUgNjApLnBhZFN0YXJ0KDIsIDApfWBcbn1cbiIsImNvbnN0IHsgaCB9ID0gcmVxdWlyZSgncHJlYWN0JylcbmNvbnN0IHsgUGx1Z2luIH0gPSByZXF1aXJlKCdAdXBweS9jb3JlJylcbmNvbnN0IFRyYW5zbGF0b3IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvVHJhbnNsYXRvcicpXG5jb25zdCBnZXRGaWxlVHlwZUV4dGVuc2lvbiA9IHJlcXVpcmUoJ0B1cHB5L3V0aWxzL2xpYi9nZXRGaWxlVHlwZUV4dGVuc2lvbicpXG5jb25zdCBjYW52YXNUb0Jsb2IgPSByZXF1aXJlKCdAdXBweS91dGlscy9saWIvY2FudmFzVG9CbG9iJylcbmNvbnN0IHN1cHBvcnRzTWVkaWFSZWNvcmRlciA9IHJlcXVpcmUoJy4vc3VwcG9ydHNNZWRpYVJlY29yZGVyJylcbmNvbnN0IENhbWVyYUljb24gPSByZXF1aXJlKCcuL0NhbWVyYUljb24nKVxuY29uc3QgQ2FtZXJhU2NyZWVuID0gcmVxdWlyZSgnLi9DYW1lcmFTY3JlZW4nKVxuY29uc3QgUGVybWlzc2lvbnNTY3JlZW4gPSByZXF1aXJlKCcuL1Blcm1pc3Npb25zU2NyZWVuJylcblxuLy8gU2V0dXAgZ2V0VXNlck1lZGlhLCB3aXRoIHBvbHlmaWxsIGZvciBvbGRlciBicm93c2Vyc1xuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFEZXZpY2VzL2dldFVzZXJNZWRpYVxuZnVuY3Rpb24gZ2V0TWVkaWFEZXZpY2VzICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcbiAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzXG4gIH1cblxuICBjb25zdCBnZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWFcbiAgaWYgKCFnZXRVc2VyTWVkaWEpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXRVc2VyTWVkaWEgKG9wdHMpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGdldFVzZXJNZWRpYS5jYWxsKG5hdmlnYXRvciwgb3B0cywgcmVzb2x2ZSwgcmVqZWN0KVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBXZWJjYW1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBXZWJjYW0gZXh0ZW5kcyBQbHVnaW4ge1xuICBzdGF0aWMgVkVSU0lPTiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuICBjb25zdHJ1Y3RvciAodXBweSwgb3B0cykge1xuICAgIHN1cGVyKHVwcHksIG9wdHMpXG4gICAgdGhpcy5tZWRpYURldmljZXMgPSBnZXRNZWRpYURldmljZXMoKVxuICAgIHRoaXMuc3VwcG9ydHNVc2VyTWVkaWEgPSAhIXRoaXMubWVkaWFEZXZpY2VzXG4gICAgdGhpcy5wcm90b2NvbCA9IGxvY2F0aW9uLnByb3RvY29sLm1hdGNoKC9odHRwcy9pKSA/ICdodHRwcycgOiAnaHR0cCdcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRzLmlkIHx8ICdXZWJjYW0nXG4gICAgdGhpcy50aXRsZSA9IHRoaXMub3B0cy50aXRsZSB8fCAnQ2FtZXJhJ1xuICAgIHRoaXMudHlwZSA9ICdhY3F1aXJlcidcbiAgICB0aGlzLmljb24gPSBDYW1lcmFJY29uXG5cbiAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSB7XG4gICAgICBzdHJpbmdzOiB7XG4gICAgICAgIHNtaWxlOiAnU21pbGUhJyxcbiAgICAgICAgdGFrZVBpY3R1cmU6ICdUYWtlIGEgcGljdHVyZScsXG4gICAgICAgIHN0YXJ0UmVjb3JkaW5nOiAnQmVnaW4gdmlkZW8gcmVjb3JkaW5nJyxcbiAgICAgICAgc3RvcFJlY29yZGluZzogJ1N0b3AgdmlkZW8gcmVjb3JkaW5nJyxcbiAgICAgICAgYWxsb3dBY2Nlc3NUaXRsZTogJ1BsZWFzZSBhbGxvdyBhY2Nlc3MgdG8geW91ciBjYW1lcmEnLFxuICAgICAgICBhbGxvd0FjY2Vzc0Rlc2NyaXB0aW9uOiAnSW4gb3JkZXIgdG8gdGFrZSBwaWN0dXJlcyBvciByZWNvcmQgdmlkZW8gd2l0aCB5b3VyIGNhbWVyYSwgcGxlYXNlIGFsbG93IGNhbWVyYSBhY2Nlc3MgZm9yIHRoaXMgc2l0ZS4nLFxuICAgICAgICByZWNvcmRpbmdMZW5ndGg6ICdSZWNvcmRpbmcgbGVuZ3RoICV7cmVjb3JkaW5nX2xlbmd0aH0nXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgb25CZWZvcmVTbmFwc2hvdDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCksXG4gICAgICBjb3VudGRvd246IGZhbHNlLFxuICAgICAgbW9kZXM6IFtcbiAgICAgICAgJ3ZpZGVvLWF1ZGlvJyxcbiAgICAgICAgJ3ZpZGVvLW9ubHknLFxuICAgICAgICAnYXVkaW8tb25seScsXG4gICAgICAgICdwaWN0dXJlJ1xuICAgICAgXSxcbiAgICAgIG1pcnJvcjogdHJ1ZSxcbiAgICAgIGZhY2luZ01vZGU6ICd1c2VyJyxcbiAgICAgIHByZWZlcnJlZFZpZGVvTWltZVR5cGU6IG51bGwsXG4gICAgICBzaG93UmVjb3JkaW5nTGVuZ3RoOiBmYWxzZVxuICAgIH1cblxuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdHMgfVxuXG4gICAgdGhpcy5pMThuSW5pdCgpXG5cbiAgICB0aGlzLmluc3RhbGwgPSB0aGlzLmluc3RhbGwuYmluZCh0aGlzKVxuICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUgPSB0aGlzLnNldFBsdWdpblN0YXRlLmJpbmQodGhpcylcblxuICAgIHRoaXMucmVuZGVyID0gdGhpcy5yZW5kZXIuYmluZCh0aGlzKVxuXG4gICAgLy8gQ2FtZXJhIGNvbnRyb2xzXG4gICAgdGhpcy5zdGFydCA9IHRoaXMuc3RhcnQuYmluZCh0aGlzKVxuICAgIHRoaXMuc3RvcCA9IHRoaXMuc3RvcC5iaW5kKHRoaXMpXG4gICAgdGhpcy50YWtlU25hcHNob3QgPSB0aGlzLnRha2VTbmFwc2hvdC5iaW5kKHRoaXMpXG4gICAgdGhpcy5zdGFydFJlY29yZGluZyA9IHRoaXMuc3RhcnRSZWNvcmRpbmcuYmluZCh0aGlzKVxuICAgIHRoaXMuc3RvcFJlY29yZGluZyA9IHRoaXMuc3RvcFJlY29yZGluZy5iaW5kKHRoaXMpXG4gICAgdGhpcy5vbmVUd29UaHJlZVNtaWxlID0gdGhpcy5vbmVUd29UaHJlZVNtaWxlLmJpbmQodGhpcylcbiAgICB0aGlzLmZvY3VzID0gdGhpcy5mb2N1cy5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLndlYmNhbUFjdGl2ZSA9IGZhbHNlXG5cbiAgICBpZiAodGhpcy5vcHRzLmNvdW50ZG93bikge1xuICAgICAgdGhpcy5vcHRzLm9uQmVmb3JlU25hcHNob3QgPSB0aGlzLm9uZVR3b1RocmVlU21pbGVcbiAgICB9XG4gIH1cblxuICBzZXRPcHRpb25zIChuZXdPcHRzKSB7XG4gICAgc3VwZXIuc2V0T3B0aW9ucyhuZXdPcHRzKVxuICAgIHRoaXMuaTE4bkluaXQoKVxuICB9XG5cbiAgaTE4bkluaXQgKCkge1xuICAgIHRoaXMudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKFt0aGlzLmRlZmF1bHRMb2NhbGUsIHRoaXMudXBweS5sb2NhbGUsIHRoaXMub3B0cy5sb2NhbGVdKVxuICAgIHRoaXMuaTE4biA9IHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgdGhpcy5pMThuQXJyYXkgPSB0aGlzLnRyYW5zbGF0b3IudHJhbnNsYXRlQXJyYXkuYmluZCh0aGlzLnRyYW5zbGF0b3IpXG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSgpIC8vIHNvIHRoYXQgVUkgcmUtcmVuZGVycyBhbmQgd2Ugc2VlIHRoZSB1cGRhdGVkIGxvY2FsZVxuICB9XG5cbiAgaXNTdXBwb3J0ZWQgKCkge1xuICAgIHJldHVybiAhIXRoaXMubWVkaWFEZXZpY2VzXG4gIH1cblxuICBnZXRDb25zdHJhaW50cyAoKSB7XG4gICAgY29uc3QgYWNjZXB0c0F1ZGlvID0gdGhpcy5vcHRzLm1vZGVzLmluZGV4T2YoJ3ZpZGVvLWF1ZGlvJykgIT09IC0xIHx8XG4gICAgICB0aGlzLm9wdHMubW9kZXMuaW5kZXhPZignYXVkaW8tb25seScpICE9PSAtMVxuICAgIGNvbnN0IGFjY2VwdHNWaWRlbyA9IHRoaXMub3B0cy5tb2Rlcy5pbmRleE9mKCd2aWRlby1hdWRpbycpICE9PSAtMSB8fFxuICAgICAgdGhpcy5vcHRzLm1vZGVzLmluZGV4T2YoJ3ZpZGVvLW9ubHknKSAhPT0gLTEgfHxcbiAgICAgIHRoaXMub3B0cy5tb2Rlcy5pbmRleE9mKCdwaWN0dXJlJykgIT09IC0xXG5cbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW86IGFjY2VwdHNBdWRpbyxcbiAgICAgIHZpZGVvOiBhY2NlcHRzVmlkZW8gPyB7IGZhY2luZ01vZGU6IHRoaXMub3B0cy5mYWNpbmdNb2RlIH0gOiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHN0YXJ0ICgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignV2ViY2FtIGFjY2VzcyBub3Qgc3VwcG9ydGVkJykpXG4gICAgfVxuXG4gICAgdGhpcy53ZWJjYW1BY3RpdmUgPSB0cnVlXG5cbiAgICBjb25zdCBjb25zdHJhaW50cyA9IHRoaXMuZ2V0Q29uc3RyYWludHMoKVxuXG4gICAgLy8gYXNrIHVzZXIgZm9yIGFjY2VzcyB0byB0aGVpciBjYW1lcmFcbiAgICByZXR1cm4gdGhpcy5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKVxuICAgICAgLnRoZW4oKHN0cmVhbSkgPT4ge1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbVxuICAgICAgICAvLyB0aGlzLnN0cmVhbVNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwodGhpcy5zdHJlYW0pXG4gICAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICAgIGNhbWVyYVJlYWR5OiB0cnVlXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICAgICAgY2FtZXJhRXJyb3I6IGVyclxuICAgICAgICB9KVxuICAgICAgfSlcbiAgfVxuXG4gIHN0YXJ0UmVjb3JkaW5nICgpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge31cbiAgICBjb25zdCBwcmVmZXJyZWRWaWRlb01pbWVUeXBlID0gdGhpcy5vcHRzLnByZWZlcnJlZFZpZGVvTWltZVR5cGVcblxuICAgIC8vIEF0dGVtcHQgdG8gdXNlIHRoZSBwYXNzZWQgcHJlZmVycmVkVmlkZW9NaW1lVHlwZSAoaWYgYW55KSBkdXJpbmcgcmVjb3JkaW5nLlxuICAgIC8vIElmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBpdCwgd2UnbGwgZmFsbCBiYWNrIHRvIHRoZSBicm93c2VyIGRlZmF1bHQgaW5zdGVhZFxuICAgIGlmIChwcmVmZXJyZWRWaWRlb01pbWVUeXBlICYmIE1lZGlhUmVjb3JkZXIuaXNUeXBlU3VwcG9ydGVkKHByZWZlcnJlZFZpZGVvTWltZVR5cGUpICYmIGdldEZpbGVUeXBlRXh0ZW5zaW9uKHByZWZlcnJlZFZpZGVvTWltZVR5cGUpKSB7XG4gICAgICBvcHRpb25zLm1pbWVUeXBlID0gcHJlZmVycmVkVmlkZW9NaW1lVHlwZVxuICAgIH1cblxuICAgIHRoaXMucmVjb3JkZXIgPSBuZXcgTWVkaWFSZWNvcmRlcih0aGlzLnN0cmVhbSwgb3B0aW9ucylcbiAgICB0aGlzLnJlY29yZGluZ0NodW5rcyA9IFtdXG4gICAgdGhpcy5yZWNvcmRlci5hZGRFdmVudExpc3RlbmVyKCdkYXRhYXZhaWxhYmxlJywgKGV2ZW50KSA9PiB7XG4gICAgICB0aGlzLnJlY29yZGluZ0NodW5rcy5wdXNoKGV2ZW50LmRhdGEpXG4gICAgfSlcbiAgICB0aGlzLnJlY29yZGVyLnN0YXJ0KClcblxuICAgIGlmICh0aGlzLm9wdHMuc2hvd1JlY29yZGluZ0xlbmd0aCkge1xuICAgICAgLy8gU3RhcnQgdGhlIHJlY29yZGluZ0xlbmd0aFRpbWVyIGlmIHdlIGFyZSBzaG93aW5nIHRoZSByZWNvcmRpbmcgbGVuZ3RoLlxuICAgICAgdGhpcy5yZWNvcmRpbmdMZW5ndGhUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFJlY29yZGluZ0xlbmd0aCA9IHRoaXMuZ2V0UGx1Z2luU3RhdGUoKS5yZWNvcmRpbmdMZW5ndGhTZWNvbmRzXG4gICAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoeyByZWNvcmRpbmdMZW5ndGhTZWNvbmRzOiBjdXJyZW50UmVjb3JkaW5nTGVuZ3RoICsgMSB9KVxuICAgICAgfSwgMTAwMClcbiAgICB9XG5cbiAgICB0aGlzLnNldFBsdWdpblN0YXRlKHtcbiAgICAgIGlzUmVjb3JkaW5nOiB0cnVlXG4gICAgfSlcbiAgfVxuXG4gIHN0b3BSZWNvcmRpbmcgKCkge1xuICAgIGNvbnN0IHN0b3BwZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlY29yZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3N0b3AnLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSlcbiAgICAgIHRoaXMucmVjb3JkZXIuc3RvcCgpXG5cbiAgICAgIGlmICh0aGlzLm9wdHMuc2hvd1JlY29yZGluZ0xlbmd0aCkge1xuICAgICAgICAvLyBTdG9wIHRoZSByZWNvcmRpbmdMZW5ndGhUaW1lciBpZiB3ZSBhcmUgc2hvd2luZyB0aGUgcmVjb3JkaW5nIGxlbmd0aC5cbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnJlY29yZGluZ0xlbmd0aFRpbWVyKVxuICAgICAgICB0aGlzLnNldFBsdWdpblN0YXRlKHsgcmVjb3JkaW5nTGVuZ3RoU2Vjb25kczogMCB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gc3RvcHBlZC50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0UGx1Z2luU3RhdGUoe1xuICAgICAgICBpc1JlY29yZGluZzogZmFsc2VcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdGhpcy5nZXRWaWRlbygpXG4gICAgfSkudGhlbigoZmlsZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy51cHB5LmFkZEZpbGUoZmlsZSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBMb2dnaW5nIHRoZSBlcnJvciwgZXhlcHQgcmVzdHJpY3Rpb25zLCB3aGljaCBpcyBoYW5kbGVkIGluIENvcmVcbiAgICAgICAgaWYgKCFlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLnJlY29yZGluZ0NodW5rcyA9IG51bGxcbiAgICAgIHRoaXMucmVjb3JkZXIgPSBudWxsXG5cbiAgICAgIC8vIENsb3NlIHRoZSBEYXNoYm9hcmQgcGFuZWwgaWYgcGx1Z2luIGlzIGluc3RhbGxlZFxuICAgICAgLy8gaW50byBEYXNoYm9hcmQgKGNvdWxkIGJlIG90aGVyIHBhcmVudCBVSSBwbHVnaW4pXG4gICAgICAvLyBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaGlkZUFsbFBhbmVscykge1xuICAgICAgLy8gICB0aGlzLnBhcmVudC5oaWRlQWxsUGFuZWxzKClcbiAgICAgIC8vIH1cbiAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgIHRoaXMucmVjb3JkaW5nQ2h1bmtzID0gbnVsbFxuICAgICAgdGhpcy5yZWNvcmRlciA9IG51bGxcbiAgICAgIHRocm93IGVycm9yXG4gICAgfSlcbiAgfVxuXG4gIHN0b3AgKCkge1xuICAgIHRoaXMuc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuZm9yRWFjaCgodHJhY2spID0+IHtcbiAgICAgIHRyYWNrLnN0b3AoKVxuICAgIH0pXG4gICAgdGhpcy5zdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xuICAgICAgdHJhY2suc3RvcCgpXG4gICAgfSlcbiAgICB0aGlzLndlYmNhbUFjdGl2ZSA9IGZhbHNlXG4gICAgdGhpcy5zdHJlYW0gPSBudWxsXG4gIH1cblxuICBnZXRWaWRlb0VsZW1lbnQgKCkge1xuICAgIHJldHVybiB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy51cHB5LVdlYmNhbS12aWRlbycpXG4gIH1cblxuICBvbmVUd29UaHJlZVNtaWxlICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IGNvdW50ID0gdGhpcy5vcHRzLmNvdW50ZG93blxuXG4gICAgICBjb25zdCBjb3VudERvd24gPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy53ZWJjYW1BY3RpdmUpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGNvdW50RG93bilcbiAgICAgICAgICB0aGlzLmNhcHR1cmVJblByb2dyZXNzID0gZmFsc2VcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignV2ViY2FtIGlzIG5vdCBhY3RpdmUnKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICB0aGlzLnVwcHkuaW5mbyhgJHtjb3VudH0uLi5gLCAnd2FybmluZycsIDgwMClcbiAgICAgICAgICBjb3VudC0tXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChjb3VudERvd24pXG4gICAgICAgICAgdGhpcy51cHB5LmluZm8odGhpcy5pMThuKCdzbWlsZScpLCAnc3VjY2VzcycsIDE1MDApXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKCksIDE1MDApXG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDApXG4gICAgfSlcbiAgfVxuXG4gIHRha2VTbmFwc2hvdCAoKSB7XG4gICAgaWYgKHRoaXMuY2FwdHVyZUluUHJvZ3Jlc3MpIHJldHVyblxuICAgIHRoaXMuY2FwdHVyZUluUHJvZ3Jlc3MgPSB0cnVlXG5cbiAgICB0aGlzLm9wdHMub25CZWZvcmVTbmFwc2hvdCgpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0eXBlb2YgZXJyID09PSAnb2JqZWN0JyA/IGVyci5tZXNzYWdlIDogZXJyXG4gICAgICB0aGlzLnVwcHkuaW5mbyhtZXNzYWdlLCAnZXJyb3InLCA1MDAwKVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgb25CZWZvcmVTbmFwc2hvdDogJHttZXNzYWdlfWApKVxuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW1hZ2UoKVxuICAgIH0pLnRoZW4oKHRhZ0ZpbGUpID0+IHtcbiAgICAgIHRoaXMuY2FwdHVyZUluUHJvZ3Jlc3MgPSBmYWxzZVxuICAgICAgLy8gQ2xvc2UgdGhlIERhc2hib2FyZCBwYW5lbCBpZiBwbHVnaW4gaXMgaW5zdGFsbGVkXG4gICAgICAvLyBpbnRvIERhc2hib2FyZCAoY291bGQgYmUgb3RoZXIgcGFyZW50IFVJIHBsdWdpbilcbiAgICAgIC8vIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5oaWRlQWxsUGFuZWxzKSB7XG4gICAgICAvLyAgIHRoaXMucGFyZW50LmhpZGVBbGxQYW5lbHMoKVxuICAgICAgLy8gfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy51cHB5LmFkZEZpbGUodGFnRmlsZSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBMb2dnaW5nIHRoZSBlcnJvciwgZXhlcHQgcmVzdHJpY3Rpb25zLCB3aGljaCBpcyBoYW5kbGVkIGluIENvcmVcbiAgICAgICAgaWYgKCFlcnIuaXNSZXN0cmljdGlvbikge1xuICAgICAgICAgIHRoaXMudXBweS5sb2coZXJyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLmNhcHR1cmVJblByb2dyZXNzID0gZmFsc2VcbiAgICAgIHRocm93IGVycm9yXG4gICAgfSlcbiAgfVxuXG4gIGdldEltYWdlICgpIHtcbiAgICBjb25zdCB2aWRlbyA9IHRoaXMuZ2V0VmlkZW9FbGVtZW50KClcbiAgICBpZiAoIXZpZGVvKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdObyB2aWRlbyBlbGVtZW50IGZvdW5kLCBsaWtlbHkgZHVlIHRvIHRoZSBXZWJjYW0gdGFiIGJlaW5nIGNsb3NlZC4nKSlcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0gYGNhbS0ke0RhdGUubm93KCl9LmpwZ2BcbiAgICBjb25zdCBtaW1lVHlwZSA9ICdpbWFnZS9qcGVnJ1xuXG4gICAgY29uc3Qgd2lkdGggPSB2aWRlby52aWRlb1dpZHRoXG4gICAgY29uc3QgaGVpZ2h0ID0gdmlkZW8udmlkZW9IZWlnaHRcblxuICAgIC8vIGNvbnN0IHNjYWxlSCA9IHRoaXMub3B0cy5taXJyb3IgPyAtMSA6IDEgLy8gU2V0IGhvcml6b250YWwgc2NhbGUgdG8gLTEgaWYgZmxpcCBob3Jpem9udGFsXG4gICAgLy8gY29uc3Qgc2NhbGVWID0gMVxuICAgIC8vIGNvbnN0IHBvc1ggPSB0aGlzLm9wdHMubWlycm9yID8gd2lkdGggKiAtMSA6IDAgLy8gU2V0IHggcG9zaXRpb24gdG8gLTEwMCUgaWYgZmxpcCBob3Jpem9udGFsXG4gICAgLy8gY29uc3QgcG9zWSA9IDBcblxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgY2FudmFzLndpZHRoID0gd2lkdGhcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICBjdHguZHJhd0ltYWdlKHZpZGVvLCAwLCAwKVxuICAgIC8vIGN0eC5zYXZlKCkgLy8gU2F2ZSB0aGUgY3VycmVudCBzdGF0ZVxuICAgIC8vIGN0eC5zY2FsZShzY2FsZUgsIHNjYWxlVikgLy8gU2V0IHNjYWxlIHRvIGZsaXAgdGhlIGltYWdlXG4gICAgLy8gY3R4LmRyYXdJbWFnZSh2aWRlbywgcG9zWCwgcG9zWSwgd2lkdGgsIGhlaWdodCkgLy8gZHJhdyB0aGUgaW1hZ2VcbiAgICAvLyBjdHgucmVzdG9yZSgpIC8vIFJlc3RvcmUgdGhlIGxhc3Qgc2F2ZWQgc3RhdGVcblxuICAgIHJldHVybiBjYW52YXNUb0Jsb2IoY2FudmFzLCBtaW1lVHlwZSkudGhlbigoYmxvYikgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiB0aGlzLmlkLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBkYXRhOiBuZXcgQmxvYihbYmxvYl0sIHsgdHlwZTogbWltZVR5cGUgfSksXG4gICAgICAgIHR5cGU6IG1pbWVUeXBlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGdldFZpZGVvICgpIHtcbiAgICBjb25zdCBtaW1lVHlwZSA9IHRoaXMucmVjb3JkaW5nQ2h1bmtzWzBdLnR5cGVcbiAgICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gZ2V0RmlsZVR5cGVFeHRlbnNpb24obWltZVR5cGUpXG5cbiAgICBpZiAoIWZpbGVFeHRlbnNpb24pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYENvdWxkIG5vdCByZXRyaWV2ZSByZWNvcmRpbmc6IFVuc3VwcG9ydGVkIG1lZGlhIHR5cGUgXCIke21pbWVUeXBlfVwiYCkpXG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IGB3ZWJjYW0tJHtEYXRlLm5vdygpfS4ke2ZpbGVFeHRlbnNpb259YFxuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYih0aGlzLnJlY29yZGluZ0NodW5rcywgeyB0eXBlOiBtaW1lVHlwZSB9KVxuICAgIGNvbnN0IGZpbGUgPSB7XG4gICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZGF0YTogbmV3IEJsb2IoW2Jsb2JdLCB7IHR5cGU6IG1pbWVUeXBlIH0pLFxuICAgICAgdHlwZTogbWltZVR5cGVcbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZpbGUpXG4gIH1cblxuICBmb2N1cyAoKSB7XG4gICAgaWYgKCF0aGlzLm9wdHMuY291bnRkb3duKSByZXR1cm5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudXBweS5pbmZvKHRoaXMuaTE4bignc21pbGUnKSwgJ3N1Y2Nlc3MnLCAxNTAwKVxuICAgIH0sIDEwMDApXG4gIH1cblxuICByZW5kZXIgKHN0YXRlKSB7XG4gICAgaWYgKCF0aGlzLndlYmNhbUFjdGl2ZSkge1xuICAgICAgdGhpcy5zdGFydCgpXG4gICAgfVxuXG4gICAgY29uc3Qgd2ViY2FtU3RhdGUgPSB0aGlzLmdldFBsdWdpblN0YXRlKClcblxuICAgIGlmICghd2ViY2FtU3RhdGUuY2FtZXJhUmVhZHkpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxQZXJtaXNzaW9uc1NjcmVlbiBpY29uPXtDYW1lcmFJY29ufSBpMThuPXt0aGlzLmkxOG59IC8+XG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxDYW1lcmFTY3JlZW5cbiAgICAgICAgey4uLndlYmNhbVN0YXRlfVxuICAgICAgICBvblNuYXBzaG90PXt0aGlzLnRha2VTbmFwc2hvdH1cbiAgICAgICAgb25TdGFydFJlY29yZGluZz17dGhpcy5zdGFydFJlY29yZGluZ31cbiAgICAgICAgb25TdG9wUmVjb3JkaW5nPXt0aGlzLnN0b3BSZWNvcmRpbmd9XG4gICAgICAgIG9uRm9jdXM9e3RoaXMuZm9jdXN9XG4gICAgICAgIG9uU3RvcD17dGhpcy5zdG9wfVxuICAgICAgICBpMThuPXt0aGlzLmkxOG59XG4gICAgICAgIG1vZGVzPXt0aGlzLm9wdHMubW9kZXN9XG4gICAgICAgIHNob3dSZWNvcmRpbmdMZW5ndGg9e3RoaXMub3B0cy5zaG93UmVjb3JkaW5nTGVuZ3RofVxuICAgICAgICBzdXBwb3J0c1JlY29yZGluZz17c3VwcG9ydHNNZWRpYVJlY29yZGVyKCl9XG4gICAgICAgIHJlY29yZGluZz17d2ViY2FtU3RhdGUuaXNSZWNvcmRpbmd9XG4gICAgICAgIG1pcnJvcj17dGhpcy5vcHRzLm1pcnJvcn1cbiAgICAgICAgc3JjPXt0aGlzLnN0cmVhbX1cbiAgICAgIC8+XG4gICAgKVxuICB9XG5cbiAgaW5zdGFsbCAoKSB7XG4gICAgdGhpcy5zZXRQbHVnaW5TdGF0ZSh7XG4gICAgICBjYW1lcmFSZWFkeTogZmFsc2UsXG4gICAgICByZWNvcmRpbmdMZW5ndGhTZWNvbmRzOiAwXG4gICAgfSlcblxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0cy50YXJnZXRcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLm1vdW50KHRhcmdldCwgdGhpcylcbiAgICB9XG4gIH1cblxuICB1bmluc3RhbGwgKCkge1xuICAgIGlmICh0aGlzLnN0cmVhbSkge1xuICAgICAgdGhpcy5zdG9wKClcbiAgICB9XG5cbiAgICB0aGlzLnVubW91bnQoKVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN1cHBvcnRzTWVkaWFSZWNvcmRlciAoKSB7XG4gIHJldHVybiB0eXBlb2YgTWVkaWFSZWNvcmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiAhIU1lZGlhUmVjb3JkZXIucHJvdG90eXBlICYmXG4gICAgdHlwZW9mIE1lZGlhUmVjb3JkZXIucHJvdG90eXBlLnN0YXJ0ID09PSAnZnVuY3Rpb24nXG59XG4iLCJyZXF1aXJlKCdlczYtcHJvbWlzZS9hdXRvJylcbnJlcXVpcmUoJ3doYXR3Zy1mZXRjaCcpXG5jb25zdCBVcHB5ID0gcmVxdWlyZSgnQHVwcHkvY29yZScpXG5jb25zdCBEYXNoYm9hcmQgPSByZXF1aXJlKCdAdXBweS9kYXNoYm9hcmQnKVxuY29uc3QgR29vZ2xlRHJpdmUgPSByZXF1aXJlKCdAdXBweS9nb29nbGUtZHJpdmUnKVxuY29uc3QgRHJvcGJveCA9IHJlcXVpcmUoJ0B1cHB5L2Ryb3Bib3gnKVxuY29uc3QgSW5zdGFncmFtID0gcmVxdWlyZSgnQHVwcHkvaW5zdGFncmFtJylcbmNvbnN0IEZhY2Vib29rID0gcmVxdWlyZSgnQHVwcHkvZmFjZWJvb2snKVxuY29uc3QgT25lRHJpdmUgPSByZXF1aXJlKCdAdXBweS9vbmVkcml2ZScpXG5jb25zdCBVcmwgPSByZXF1aXJlKCdAdXBweS91cmwnKVxuY29uc3QgV2ViY2FtID0gcmVxdWlyZSgnQHVwcHkvd2ViY2FtJylcbmNvbnN0IFR1cyA9IHJlcXVpcmUoJ0B1cHB5L3R1cycpXG5jb25zdCBsb2NhbGVMaXN0ID0gcmVxdWlyZSgnLi4vbG9jYWxlX2xpc3QuanNvbicpXG5cbmNvbnN0IENPTVBBTklPTiA9IHJlcXVpcmUoJy4uL2VudicpXG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LlVwcHkgPT09ICd1bmRlZmluZWQnKSB7XG4gIHdpbmRvdy5VcHB5ID0ge1xuICAgIGxvY2FsZXM6IHt9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBweUluaXQgKCkge1xuICBpZiAod2luZG93LnVwcHkpIHtcbiAgICB3aW5kb3cudXBweS5jbG9zZSgpXG4gIH1cblxuICBjb25zdCBvcHRzID0gd2luZG93LnVwcHlPcHRpb25zXG5cbiAgY29uc3QgdXBweSA9IFVwcHkoe1xuICAgIGxvZ2dlcjogVXBweS5kZWJ1Z0xvZ2dlclxuICB9KVxuXG4gIHVwcHkudXNlKFR1cywgeyBlbmRwb2ludDogJ2h0dHBzOi8vbWFzdGVyLnR1cy5pby9maWxlcy8nLCByZXN1bWU6IHRydWUgfSlcblxuICB1cHB5Lm9uKCdjb21wbGV0ZScsIHJlc3VsdCA9PiB7XG4gICAgY29uc29sZS5sb2coJ3N1Y2Nlc3NmdWwgZmlsZXM6JylcbiAgICBjb25zb2xlLmxvZyhyZXN1bHQuc3VjY2Vzc2Z1bClcbiAgICBjb25zb2xlLmxvZygnZmFpbGVkIGZpbGVzOicpXG4gICAgY29uc29sZS5sb2cocmVzdWx0LmZhaWxlZClcbiAgfSlcblxuICB1cHB5LnVzZShEYXNoYm9hcmQsIHtcbiAgICB0cmlnZ2VyOiAnLlVwcHlNb2RhbE9wZW5lckJ0bicsXG4gICAgdGFyZ2V0OiBvcHRzLkRhc2hib2FyZElubGluZSA/ICcuRGFzaGJvYXJkQ29udGFpbmVyJyA6ICdib2R5JyxcbiAgICBpbmxpbmU6IG9wdHMuRGFzaGJvYXJkSW5saW5lLFxuICAgIHJlcGxhY2VUYXJnZXRDb250ZW50OiBvcHRzLkRhc2hib2FyZElubGluZSxcbiAgICBoZWlnaHQ6IDQ3MCxcbiAgICBzaG93UHJvZ3Jlc3NEZXRhaWxzOiB0cnVlLFxuICAgIG1ldGFGaWVsZHM6IFtcbiAgICAgIHsgaWQ6ICduYW1lJywgbmFtZTogJ05hbWUnLCBwbGFjZWhvbGRlcjogJ2ZpbGUgbmFtZScgfSxcbiAgICAgIHsgaWQ6ICdjYXB0aW9uJywgbmFtZTogJ0NhcHRpb24nLCBwbGFjZWhvbGRlcjogJ2FkZCBkZXNjcmlwdGlvbicgfVxuICAgIF1cbiAgfSlcblxuICB3aW5kb3cudXBweSA9IHVwcHlcbn1cblxuZnVuY3Rpb24gdXBweVNldE9wdGlvbnMgKCkge1xuICBjb25zdCBvcHRzID0gd2luZG93LnVwcHlPcHRpb25zXG5cbiAgY29uc3QgZGVmYXVsdE51bGxSZXN0cmljdGlvbnMgPSB7XG4gICAgbWF4RmlsZVNpemU6IG51bGwsXG4gICAgbWF4TnVtYmVyT2ZGaWxlczogbnVsbCxcbiAgICBtaW5OdW1iZXJPZkZpbGVzOiBudWxsLFxuICAgIGFsbG93ZWRGaWxlVHlwZXM6IG51bGxcbiAgfVxuXG4gIGNvbnN0IHJlc3RyaWN0aW9ucyA9IHtcbiAgICBtYXhGaWxlU2l6ZTogMTAwMDAwMCxcbiAgICBtYXhOdW1iZXJPZkZpbGVzOiAzLFxuICAgIG1pbk51bWJlck9mRmlsZXM6IDIsXG4gICAgYWxsb3dlZEZpbGVUeXBlczogWydpbWFnZS8qJywgJ3ZpZGVvLyonXVxuICB9XG5cbiAgd2luZG93LnVwcHkuc2V0T3B0aW9ucyh7XG4gICAgYXV0b1Byb2NlZWQ6IG9wdHMuYXV0b1Byb2NlZWQsXG4gICAgcmVzdHJpY3Rpb25zOiBvcHRzLnJlc3RyaWN0aW9ucyA/IHJlc3RyaWN0aW9ucyA6IGRlZmF1bHROdWxsUmVzdHJpY3Rpb25zXG4gIH0pXG5cbiAgd2luZG93LnVwcHkuZ2V0UGx1Z2luKCdEYXNoYm9hcmQnKS5zZXRPcHRpb25zKHtcbiAgICBub3RlOiBvcHRzLnJlc3RyaWN0aW9ucyA/ICdJbWFnZXMgYW5kIHZpZGVvIG9ubHksIDLigJMzIGZpbGVzLCB1cCB0byAxIE1CJyA6ICcnLFxuICAgIGJyb3dzZXJCYWNrQnV0dG9uQ2xvc2U6IG9wdHMuYnJvd3NlckJhY2tCdXR0b25DbG9zZVxuICB9KVxuXG4gIGNvbnN0IEdvb2dsZURyaXZlSW5zdGFuY2UgPSB3aW5kb3cudXBweS5nZXRQbHVnaW4oJ0dvb2dsZURyaXZlJylcbiAgaWYgKG9wdHMuR29vZ2xlRHJpdmUgJiYgIUdvb2dsZURyaXZlSW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS51c2UoR29vZ2xlRHJpdmUsIHsgdGFyZ2V0OiBEYXNoYm9hcmQsIGNvbXBhbmlvblVybDogQ09NUEFOSU9OIH0pXG4gIH1cbiAgaWYgKCFvcHRzLkdvb2dsZURyaXZlICYmIEdvb2dsZURyaXZlSW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS5yZW1vdmVQbHVnaW4oR29vZ2xlRHJpdmVJbnN0YW5jZSlcbiAgfVxuXG4gIGNvbnN0IERyb3Bib3hJbnN0YW5jZSA9IHdpbmRvdy51cHB5LmdldFBsdWdpbignRHJvcGJveCcpXG4gIGlmIChvcHRzLkRyb3Bib3ggJiYgIURyb3Bib3hJbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnVzZShEcm9wYm94LCB7IHRhcmdldDogRGFzaGJvYXJkLCBjb21wYW5pb25Vcmw6IENPTVBBTklPTiB9KVxuICB9XG4gIGlmICghb3B0cy5Ecm9wYm94ICYmIERyb3Bib3hJbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnJlbW92ZVBsdWdpbihEcm9wYm94SW5zdGFuY2UpXG4gIH1cblxuICBjb25zdCBJbnN0YWdyYW1JbnN0YW5jZSA9IHdpbmRvdy51cHB5LmdldFBsdWdpbignSW5zdGFncmFtJylcbiAgaWYgKG9wdHMuSW5zdGFncmFtICYmICFJbnN0YWdyYW1JbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnVzZShJbnN0YWdyYW0sIHsgdGFyZ2V0OiBEYXNoYm9hcmQsIGNvbXBhbmlvblVybDogQ09NUEFOSU9OIH0pXG4gIH1cbiAgaWYgKCFvcHRzLkluc3RhZ3JhbSAmJiBJbnN0YWdyYW1JbnN0YW5jZSkge1xuICAgIHdpbmRvdy51cHB5LnJlbW92ZVBsdWdpbihJbnN0YWdyYW1JbnN0YW5jZSlcbiAgfVxuXG4gIGNvbnN0IFVybEluc3RhbmNlID0gd2luZG93LnVwcHkuZ2V0UGx1Z2luKCdVcmwnKVxuICBpZiAob3B0cy5VcmwgJiYgIVVybEluc3RhbmNlKSB7XG4gICAgd2luZG93LnVwcHkudXNlKFVybCwgeyB0YXJnZXQ6IERhc2hib2FyZCwgY29tcGFuaW9uVXJsOiBDT01QQU5JT04gfSlcbiAgfVxuICBpZiAoIW9wdHMuVXJsICYmIFVybEluc3RhbmNlKSB7XG4gICAgd2luZG93LnVwcHkucmVtb3ZlUGx1Z2luKFVybEluc3RhbmNlKVxuICB9XG5cbiAgY29uc3QgRmFjZWJvb2tJbnN0YW5jZSA9IHdpbmRvdy51cHB5LmdldFBsdWdpbignRmFjZWJvb2snKVxuICBpZiAob3B0cy5GYWNlYm9vayAmJiAhRmFjZWJvb2tJbnN0YW5jZSkge1xuICAgIHVwcHkudXNlKEZhY2Vib29rLCB7IHRhcmdldDogRGFzaGJvYXJkLCBjb21wYW5pb25Vcmw6IENPTVBBTklPTiB9KVxuICB9XG4gIGlmICghb3B0cy5GYWNlYm9vayAmJiBGYWNlYm9va0luc3RhbmNlKSB7XG4gICAgd2luZG93LnVwcHkucmVtb3ZlUGx1Z2luKEZhY2Vib29rSW5zdGFuY2UpXG4gIH1cblxuICBjb25zdCBPbmVEcml2ZUluc3RhbmNlID0gd2luZG93LnVwcHkuZ2V0UGx1Z2luKCdPbmVEcml2ZScpXG4gIGlmIChvcHRzLk9uZURyaXZlICYmICFPbmVEcml2ZUluc3RhbmNlKSB7XG4gICAgdXBweS51c2UoT25lRHJpdmUsIHsgdGFyZ2V0OiBEYXNoYm9hcmQsIGNvbXBhbmlvblVybDogQ09NUEFOSU9OIH0pXG4gIH1cbiAgaWYgKCFvcHRzLk9uZURyaXZlICYmIE9uZURyaXZlSW5zdGFuY2UpIHtcbiAgICB3aW5kb3cudXBweS5yZW1vdmVQbHVnaW4oT25lRHJpdmVJbnN0YW5jZSlcbiAgfVxuXG4gIGNvbnN0IFdlYmNhbUluc3RhbmNlID0gd2luZG93LnVwcHkuZ2V0UGx1Z2luKCdXZWJjYW0nKVxuICBpZiAob3B0cy5XZWJjYW0gJiYgIVdlYmNhbUluc3RhbmNlKSB7XG4gICAgd2luZG93LnVwcHkudXNlKFdlYmNhbSwgeyB0YXJnZXQ6IERhc2hib2FyZCwgY29tcGFuaW9uVXJsOiBDT01QQU5JT04gfSlcbiAgfVxuICBpZiAoIW9wdHMuV2ViY2FtICYmIFdlYmNhbUluc3RhbmNlKSB7XG4gICAgd2luZG93LnVwcHkucmVtb3ZlUGx1Z2luKFdlYmNhbUluc3RhbmNlKVxuICB9XG59XG5cbmZ1bmN0aW9uIHdoZW5Mb2NhbGVBdmFpbGFibGUgKGxvY2FsZU5hbWUsIGNhbGxiYWNrKSB7XG4gIHZhciBpbnRlcnZhbCA9IDEwMCAvLyBtc1xuICB2YXIgbG9vcCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAod2luZG93LlVwcHkgJiYgd2luZG93LlVwcHkubG9jYWxlcyAmJiB3aW5kb3cuVXBweS5sb2NhbGVzW2xvY2FsZU5hbWVdKSB7XG4gICAgICBjbGVhckludGVydmFsKGxvb3ApXG4gICAgICBjYWxsYmFjayh3aW5kb3cuVXBweS5sb2NhbGVzW2xvY2FsZU5hbWVdKVxuICAgIH1cbiAgfSwgaW50ZXJ2YWwpXG59XG5cbmZ1bmN0aW9uIGxvYWRMb2NhbGVGcm9tQ0ROIChsb2NhbGVOYW1lKSB7XG4gIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXVxuICB2YXIganMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuICBqcy50eXBlID0gJ3RleHQvamF2YXNjcmlwdCdcbiAganMuc3JjID0gYGh0dHBzOi8vdHJhbnNsb2FkaXQuZWRnbHkubmV0L3JlbGVhc2VzL3VwcHkvbG9jYWxlcy92MS4xMS4wLyR7bG9jYWxlTmFtZX0ubWluLmpzYFxuXG4gIGhlYWQuYXBwZW5kQ2hpbGQoanMpXG59XG5cbmZ1bmN0aW9uIHNldExvY2FsZSAobG9jYWxlTmFtZSkge1xuICBpZiAodHlwZW9mIHdpbmRvdy5VcHB5LmxvY2FsZXNbbG9jYWxlTmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbG9hZExvY2FsZUZyb21DRE4obG9jYWxlTmFtZSlcbiAgfVxuICB3aGVuTG9jYWxlQXZhaWxhYmxlKGxvY2FsZU5hbWUsIChsb2NhbGVPYmopID0+IHtcbiAgICB3aW5kb3cudXBweS5zZXRPcHRpb25zKHtcbiAgICAgIGxvY2FsZTogbG9jYWxlT2JqXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gcG9wdWxhdGVMb2NhbGVTZWxlY3QgKCkge1xuICBjb25zdCBsb2NhbGVTZWxlY3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9jYWxlTGlzdCcpXG5cbiAgT2JqZWN0LmtleXMobG9jYWxlTGlzdCkuZm9yRWFjaChsb2NhbGVOYW1lID0+IHtcbiAgICBpZiAobG9jYWxlTmFtZSA9PT0gJ2VuX1VTJykgcmV0dXJuXG4gICAgbG9jYWxlU2VsZWN0LmlubmVySFRNTCArPSBgPG9wdGlvbiB2YWx1ZT1cIiR7bG9jYWxlTmFtZX1cIj4ke2xvY2FsZUxpc3RbbG9jYWxlTmFtZV19IOKAlCAoJHtsb2NhbGVOYW1lfSk8L29wdGlvbj5gXG4gIH0pXG5cbiAgbG9jYWxlU2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChldmVudCkgPT4ge1xuICAgIGNvbnN0IGxvY2FsZU5hbWUgPSBldmVudC50YXJnZXQudmFsdWVcbiAgICBzZXRMb2NhbGUobG9jYWxlTmFtZSlcbiAgfSlcbn1cblxud2luZG93LnVwcHlTZXRPcHRpb25zID0gdXBweVNldE9wdGlvbnNcbndpbmRvdy51cHB5SW5pdCA9IHVwcHlJbml0XG53aW5kb3cudXBweVNldExvY2FsZSA9IHNldExvY2FsZVxuXG5wb3B1bGF0ZUxvY2FsZVNlbGVjdCgpXG51cHB5SW5pdCgpXG51cHB5U2V0T3B0aW9ucygpXG4iLCJsZXQgY29tcGFuaW9uRW5kcG9pbnQgPSAnaHR0cDovL2xvY2FsaG9zdDozMDIwJ1xuXG5pZiAobG9jYXRpb24uaG9zdG5hbWUgPT09ICd1cHB5LmlvJykge1xuICBjb21wYW5pb25FbmRwb2ludCA9ICcvL2NvbXBhbmlvbi51cHB5LmlvJ1xufVxuXG5jb25zdCBDT01QQU5JT04gPSBjb21wYW5pb25FbmRwb2ludFxubW9kdWxlLmV4cG9ydHMgPSBDT01QQU5JT05cbiIsIm1vZHVsZS5leHBvcnRzPXtcImFyX1NBXCI6XCJBcmFiaWMgKFNhdWRpIEFyYWJpYSlcIixcImNzX0NaXCI6XCJDemVjaCAoQ3plY2ggUmVwdWJsaWMpXCIsXCJkYV9ES1wiOlwiRGFuaXNoIChEZW5tYXJrKVwiLFwiZGVfREVcIjpcIkdlcm1hbiAoR2VybWFueSlcIixcImVsX0dSXCI6XCJHcmVlayAoR3JlZWNlKVwiLFwiZW5fVVNcIjpcIkVuZ2xpc2ggKFVuaXRlZCBTdGF0ZXMpXCIsXCJlc19FU1wiOlwiU3BhbmlzaCAoU3BhaW4pXCIsXCJmYV9JUlwiOlwiUGVyc2lhbiAoSXJhbiwgSXNsYW1pYyBSZXB1YmxpYyBvZilcIixcImZpX0ZJXCI6XCJGaW5uaXNoIChGaW5sYW5kKVwiLFwiZnJfRlJcIjpcIkZyZW5jaCAoRnJhbmNlKVwiLFwiZ2xfRVNcIjpcIkdhbGljaWFuIChTcGFpbilcIixcImhlX0lMXCI6XCJIZWJyZXcgKElzcmFlbClcIixcImh1X0hVXCI6XCJIdW5nYXJpYW4gKEh1bmdhcnkpXCIsXCJpZF9JRFwiOlwiSW5kb25lc2lhbiAoSW5kb25lc2lhKVwiLFwiaXNfSVNcIjpcIkljZWxhbmRpYyAoSWNlbGFuZClcIixcIml0X0lUXCI6XCJJdGFsaWFuIChJdGFseSlcIixcImphX0pQXCI6XCJKYXBhbmVzZSAoSmFwYW4pXCIsXCJrb19LUlwiOlwiS29yZWFuIChLb3JlYSwgUmVwdWJsaWMgb2YpXCIsXCJubF9OTFwiOlwiRHV0Y2ggKE5ldGhlcmxhbmRzKVwiLFwicHRfQlJcIjpcIlBvcnR1Z3Vlc2UgKEJyYXppbClcIixcInJ1X1JVXCI6XCJSdXNzaWFuIChSdXNzaWFuIEZlZGVyYXRpb24pXCIsXCJzcl9SU19DeXJpbGxpY1wiOlwiU2VyYmlhbiAoU2VyYmlhIEN5cmlsbGljKVwiLFwic3JfUlNfTGF0aW5cIjpcIlNlcmJpYW4gKFNlcmJpYSBMYXRpbilcIixcInN2X1NFXCI6XCJTd2VkaXNoIChTd2VkZW4pXCIsXCJ0aF9USFwiOlwiVGhhaSAoVGhhaWxhbmQpXCIsXCJ0cl9UUlwiOlwiVHVya2lzaCAoVHVya2V5KVwiLFwidmlfVk5cIjpcIlZpZXRuYW1lc2UgKFZpZXQgTmFtKVwiLFwiemhfQ05cIjpcIkNoaW5lc2UgKENoaW5hKVwiLFwiemhfVFdcIjpcIkNoaW5lc2UgKFRhaXdhbiwgUHJvdmluY2Ugb2YgQ2hpbmEpXCJ9Il19
